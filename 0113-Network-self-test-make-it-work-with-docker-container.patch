From 0c3dbbefd281377d7eb100aa88e20866d9268be1 Mon Sep 17 00:00:00 2001
From: Timur Pocheptsov <timur.pocheptsov@qt.io>
Date: Mon, 2 Nov 2020 14:37:46 +0100
Subject: [PATCH 113/171] Network self-test: make it work with
 docker/containers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Also, removed the part that was testing the deprecated
(and later deleted in Qt 6) API.

Fixes: QTBUG-87740
Change-Id: Idfe73708784774188afd40048f81406aa720a554
Reviewed-by: MÃ¥rten Nordheim <marten.nordheim@qt.io>
(cherry picked from commit 4f6c5d83d09881a8432873487eab44b88eabec9e)
---
 tests/auto/network-settings.h                 |  38 +-
 .../other/networkselftest/networkselftest.pro |   3 +
 .../networkselftest/tst_networkselftest.cpp   | 236 +++--
 tests/testserver/apache2/testdata/main.conf   |   4 +
 .../testdata/www/htdocs/protected/rfc3252.txt | 899 ++++++++++++++++++
 .../htdocs/qxmlquery/completelyEmptyQuery.xq  |   0
 .../www/htdocs/qxmlquery/notWellformed.xml    |   1 +
 .../qxmlquery/notWellformedViaHttps.xml       |   1 +
 .../testdata/www/htdocs/qxmlquery/viaHttp.xq  |   1 +
 .../www/htdocs/qxmlquery/wellFormed.xml       |   2 +
 .../htdocs/qxmlquery/wellFormedViaHttps.xml   |   2 +
 .../vsftpd/testdata/ftp/pub/qxmlquery/README  |   1 +
 .../ftp/pub/qxmlquery/completelyEmptyQuery.xq |   0
 .../ftp/pub/qxmlquery/notWellFormed.xml       |   1 +
 .../testdata/ftp/pub/qxmlquery/viaFtp.xq      |   1 +
 .../testdata/ftp/pub/qxmlquery/wellFormed.xml |   2 +
 16 files changed, 1094 insertions(+), 98 deletions(-)
 create mode 100644 tests/testserver/apache2/testdata/www/htdocs/protected/rfc3252.txt
 create mode 100644 tests/testserver/apache2/testdata/www/htdocs/qxmlquery/completelyEmptyQuery.xq
 create mode 100644 tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformed.xml
 create mode 100644 tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformedViaHttps.xml
 create mode 100644 tests/testserver/apache2/testdata/www/htdocs/qxmlquery/viaHttp.xq
 create mode 100644 tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormed.xml
 create mode 100644 tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormedViaHttps.xml
 create mode 100644 tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/README
 create mode 100644 tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/completelyEmptyQuery.xq
 create mode 100644 tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/notWellFormed.xml
 create mode 100644 tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/viaFtp.xq
 create mode 100644 tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/wellFormed.xml

diff --git a/tests/auto/network-settings.h b/tests/auto/network-settings.h
index 4dd6ce897b..fc7b1d090e 100644
--- a/tests/auto/network-settings.h
+++ b/tests/auto/network-settings.h
@@ -262,6 +262,41 @@ public:
 #endif
     }
 
+    static QString hostWithServiceOnPort(int port)
+    {
+#if !defined(QT_TEST_SERVER)
+        Q_UNUSED(port);
+        return serverName();
+#else
+        switch (port) {
+        case 13:
+        case 22:
+        case 139:
+            return serverName(); // No such things in docker (yet?)
+        case 7:
+            return echoServerName();
+        case 21:
+            return ftpServerName();
+        case 80:
+        case 443:
+            return httpServerName();
+        case 143:
+            return imapServerName();
+        case 3128:
+        case 3129:
+        case 3130:
+            return httpProxyServerName();
+        case 1080:
+        case 1081:
+            return socksProxyServerName();
+        case 2121:
+            return ftpProxyServerName();
+        default:
+            return serverName();
+        }
+#endif // QT_TEST_SERVER
+    }
+
 #ifdef QT_NETWORK_LIB
     static QHostAddress imapServerIp()
     {
@@ -297,5 +332,6 @@ public:
     {
         return getServerIpImpl(firewallServerName());
     }
-#endif
+
+#endif // QT_NETWORK_LIB
 };
diff --git a/tests/auto/other/networkselftest/networkselftest.pro b/tests/auto/other/networkselftest/networkselftest.pro
index 7c307a097b..ea81b10f8c 100644
--- a/tests/auto/other/networkselftest/networkselftest.pro
+++ b/tests/auto/other/networkselftest/networkselftest.pro
@@ -3,3 +3,6 @@ TARGET = tst_networkselftest
 
 SOURCES += tst_networkselftest.cpp
 QT = core core-private network testlib
+
+CONFIG += unsupported/testserver
+QT_TEST_SERVER_LIST = cyrus vsftpd apache2 ftp-proxy danted squid echo
diff --git a/tests/auto/other/networkselftest/tst_networkselftest.cpp b/tests/auto/other/networkselftest/tst_networkselftest.cpp
index 396e23da0c..b875c7c5cf 100644
--- a/tests/auto/other/networkselftest/tst_networkselftest.cpp
+++ b/tests/auto/other/networkselftest/tst_networkselftest.cpp
@@ -35,18 +35,16 @@
 #include <QtCore/QStandardPaths>
 #include <QtCore/private/qiodevice_p.h>
 
-#ifndef QT_NO_BEARERMANAGEMENT
-#include <QtNetwork/qnetworkconfigmanager.h>
-#include <QtNetwork/qnetworkconfiguration.h>
-#include <QtNetwork/qnetworksession.h>
-#endif
-
 #include "../../network-settings.h"
 
 class tst_NetworkSelfTest: public QObject
 {
     Q_OBJECT
+    // This is either old server's address, or the new http
+    // server's address (different from ftp, for example):
     QHostAddress cachedIpAddress;
+    // This is only for the new docker test server:
+    QHostAddress ftpServerIpAddress;
 public:
     tst_NetworkSelfTest();
     virtual ~tst_NetworkSelfTest();
@@ -83,12 +81,6 @@ private slots:
 
     // ssl supported test
     void supportsSsl();
-private:
-#ifndef QT_NO_BEARERMANAGEMENT
-    QNetworkConfigurationManager *netConfMan;
-    QNetworkConfiguration networkConfiguration;
-    QScopedPointer<QNetworkSession> networkSession;
-#endif
 };
 
 class Chat
@@ -223,8 +215,8 @@ static void netChat(int port, const QList<Chat> &chat)
 #else
     QTcpSocket socket;
 #endif
-
-    socket.connectToHost(QtNetworkSettings::serverName(), port);
+    const auto serverName = QtNetworkSettings::hostWithServiceOnPort(port);
+    socket.connectToHost(serverName, port);
     qDebug() << 0 << "Connecting to server on port" << port;
     QVERIFY2(socket.waitForConnected(10000),
              QString("Failed to connect to server in step 0: %1").arg(socket.errorString()).toLocal8Bit());
@@ -236,7 +228,7 @@ static void netChat(int port, const QList<Chat> &chat)
             case Chat::Expect: {
                     qDebug() << i << "Expecting" << prettyByteArray(it->data);
                     if (!doSocketRead(&socket, it->data.length(), 3 * defaultReadTimeoutMS))
-                        QFAIL(msgDoSocketReadFailed(QtNetworkSettings::serverName(), port, i, it->data.length()));
+                        QFAIL(msgDoSocketReadFailed(serverName, port, i, it->data.length()));
 
                     // pop that many bytes off the socket
                     QByteArray received = socket.read(it->data.length());
@@ -254,7 +246,7 @@ static void netChat(int port, const QList<Chat> &chat)
                 while (true) {
                     // scan the buffer until we have our string
                     if (!doSocketRead(&socket, it->data.length()))
-                        QFAIL(msgDoSocketReadFailed(QtNetworkSettings::serverName(), port, i, it->data.length()));
+                        QFAIL(msgDoSocketReadFailed(serverName, port, i, it->data.length()));
 
                     QByteArray buffer;
                     buffer.resize(socket.bytesAvailable());
@@ -275,7 +267,7 @@ static void netChat(int port, const QList<Chat> &chat)
             case Chat::SkipBytes: {
                     qDebug() << i << "Skipping" << it->value << "bytes";
                     if (!doSocketRead(&socket, it->value))
-                        QFAIL(msgDoSocketReadFailed(QtNetworkSettings::serverName(), port, i, it->value));
+                        QFAIL(msgDoSocketReadFailed(serverName, port, i, it->value));
 
                     // now discard the bytes
                     QByteArray buffer = socket.read(it->value);
@@ -324,7 +316,7 @@ static void netChat(int port, const QList<Chat> &chat)
 
             case Chat::Reconnect:
                 qDebug() << i << "Reconnecting to server on port" << port;
-                socket.connectToHost(QtNetworkSettings::serverName(), port);
+                socket.connectToHost(serverName, port);
                 QVERIFY2(socket.waitForConnected(10000),
                          QString("Failed to reconnect to server in step %1: %2").arg(i).arg(socket.errorString()).toLocal8Bit());
                 break;
@@ -357,7 +349,7 @@ QHostAddress tst_NetworkSelfTest::serverIpAddress()
 {
     if (cachedIpAddress.protocol() == QAbstractSocket::UnknownNetworkLayerProtocol) {
         // need resolving
-        QHostInfo resolved = QHostInfo::fromName(QtNetworkSettings::serverName());
+        QHostInfo resolved = QHostInfo::fromName(QtNetworkSettings::httpServerName());
         if(resolved.error() != QHostInfo::NoError ||
             resolved.addresses().isEmpty()) {
             qWarning("QHostInfo::fromName failed (%d).", resolved.error());
@@ -370,16 +362,27 @@ QHostAddress tst_NetworkSelfTest::serverIpAddress()
 
 void tst_NetworkSelfTest::initTestCase()
 {
+#if defined(QT_TEST_SERVER)
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::echoServerName(), 7));
+    // TODO: 'daytime' , port 13.
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::ftpServerName(), 21));
+    const QHostInfo resolved = QHostInfo::fromName(QtNetworkSettings::ftpServerName());
+    if (resolved.error() == QHostInfo::NoError && !resolved.addresses().isEmpty())
+        ftpServerIpAddress = resolved.addresses().first();
+    // TODO: 'ssh', port 22.
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::ftpProxyServerName(), 2121));
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::httpServerName(), 80));
+    // TODO: 'smb', port 139.
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::imapServerName(), 143));
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::httpServerName(), 443));
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::httpProxyServerName(), 3128));
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::httpProxyServerName(), 3129));
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::httpProxyServerName(), 3130));
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::socksProxyServerName(), 1080));
+    QVERIFY(QtNetworkSettings::verifyConnection(QtNetworkSettings::socksProxyServerName(), 1081));
+#else
     if (!QtNetworkSettings::verifyTestNetworkSettings())
         QSKIP("No network test server available");
-#ifndef QT_NO_BEARERMANAGEMENT
-    netConfMan = new QNetworkConfigurationManager(this);
-    networkConfiguration = netConfMan->defaultConfiguration();
-    networkSession.reset(new QNetworkSession(networkConfiguration));
-    if (!networkSession->isOpen()) {
-        networkSession->open();
-        QVERIFY(networkSession->waitForOpened(30000));
-    }
 #endif
 }
 
@@ -402,7 +405,7 @@ void tst_NetworkSelfTest::dnsResolution_data()
 {
     QTest::addColumn<QString>("hostName");
     QTest::newRow("local-name") << QtNetworkSettings::serverLocalName();
-    QTest::newRow("fqdn") << QtNetworkSettings::serverName();
+    QTest::newRow("fqdn") << QtNetworkSettings::httpServerName();
 }
 
 void tst_NetworkSelfTest::dnsResolution()
@@ -420,7 +423,7 @@ void tst_NetworkSelfTest::serverReachability()
 {
     // check that we get a proper error connecting to port 12346
     QTcpSocket socket;
-    socket.connectToHost(QtNetworkSettings::serverName(), 12346);
+    socket.connectToHost(QtNetworkSettings::httpServerName(), 12346);
 
     QElapsedTimer timer;
     timer.start();
@@ -434,7 +437,11 @@ void tst_NetworkSelfTest::serverReachability()
 
 void tst_NetworkSelfTest::remotePortsOpen_data()
 {
+#if defined(QT_TEST_SERVER)
+    QSKIP("Skipping, for the docker test server already tested by initTestCase()");
+#endif
     QTest::addColumn<int>("portNumber");
+
     QTest::newRow("echo") << 7;
     QTest::newRow("daytime") << 13;
     QTest::newRow("ftp") << 21;
@@ -453,9 +460,10 @@ void tst_NetworkSelfTest::remotePortsOpen_data()
 
 void tst_NetworkSelfTest::remotePortsOpen()
 {
-    QFETCH(int, portNumber);
+    QFETCH(const int, portNumber);
+
     QTcpSocket socket;
-    socket.connectToHost(QtNetworkSettings::serverName(), portNumber);
+    socket.connectToHost(QtNetworkSettings::hostWithServiceOnPort(portNumber), quint16(portNumber));
 
     if (!socket.waitForConnected(10000)) {
         if (socket.error() == QAbstractSocket::SocketTimeoutError)
@@ -470,43 +478,43 @@ static QList<Chat> ftpChat(const QByteArray &userSuffix = QByteArray())
 {
     QList<Chat> rv;
     rv << Chat::expect("220")
-            << Chat::discardUntil("\r\n")
-            << Chat::send("USER anonymous" + userSuffix + "\r\n")
-            << Chat::expect("331")
-            << Chat::discardUntil("\r\n")
-            << Chat::send("PASS user@hostname\r\n")
-            << Chat::expect("230")
-            << Chat::discardUntil("\r\n")
-
-            << Chat::send("CWD pub\r\n")
-            << Chat::expect("250")
-            << Chat::discardUntil("\r\n")
-            << Chat::send("CWD dir-not-readable\r\n")
-            << Chat::expect("550")
-            << Chat::discardUntil("\r\n")
-            << Chat::send("PWD\r\n")
-            << Chat::expect("257 \"/pub\"\r\n")
-            << Chat::send("SIZE file-not-readable.txt\r\n")
-            << Chat::expect("213 41\r\n")
-            << Chat::send("CWD qxmlquery\r\n")
-            << Chat::expect("250")
-            << Chat::discardUntil("\r\n")
-
-            << Chat::send("CWD /qtest\r\n")
-            << Chat::expect("250")
-            << Chat::discardUntil("\r\n")
-            << Chat::send("SIZE bigfile\r\n")
-            << Chat::expect("213 519240\r\n")
-            << Chat::send("SIZE rfc3252\r\n")
-            << Chat::expect("213 25962\r\n")
-            << Chat::send("SIZE rfc3252.txt\r\n")
-            << Chat::expect("213 25962\r\n")
-//            << Chat::send("SIZE nonASCII/german_\344\366\374\304\326\334\337\r\n")
-//            << Chat::expect("213 40\r\n")
-
-            << Chat::send("QUIT\r\n");
-        rv  << Chat::expect("221")
-            << Chat::discardUntil("\r\n");
+       << Chat::discardUntil("\r\n")
+       << Chat::send("USER anonymous" + userSuffix + "\r\n")
+       << Chat::expect("331")
+       << Chat::discardUntil("\r\n")
+       << Chat::send("PASS user@hostname\r\n")
+       << Chat::expect("230")
+       << Chat::discardUntil("\r\n")
+       << Chat::send("CWD pub\r\n")
+       << Chat::expect("250")
+       << Chat::discardUntil("\r\n")
+       << Chat::send("CWD dir-not-readable\r\n")
+       << Chat::expect("550")
+       << Chat::discardUntil("\r\n")
+       << Chat::send("PWD\r\n")
+#if defined(QT_TEST_SERVER)
+       << Chat::expect("257 \"/pub\" is the current directory\r\n")
+#else
+       << Chat::expect("257 \"/pub\"\r\n")
+#endif
+       << Chat::send("SIZE file-not-readable.txt\r\n")
+       << Chat::expect("213 41\r\n")
+       << Chat::send("CWD qxmlquery\r\n")
+       << Chat::expect("250")
+       << Chat::discardUntil("\r\n")
+       << Chat::send("CWD /qtest\r\n")
+       << Chat::expect("250")
+       << Chat::discardUntil("\r\n")
+       << Chat::send("SIZE bigfile\r\n")
+       << Chat::expect("213 519240\r\n")
+       << Chat::send("SIZE rfc3252\r\n")
+       << Chat::expect("213 25962\r\n")
+       << Chat::send("SIZE rfc3252.txt\r\n")
+       << Chat::expect("213 25962\r\n")
+       << Chat::send("QUIT\r\n");
+
+    rv << Chat::expect("221")
+       << Chat::discardUntil("\r\n");
 
     rv << Chat::RemoteDisconnect;
     return rv;
@@ -519,7 +527,7 @@ void tst_NetworkSelfTest::ftpServer()
 
 void tst_NetworkSelfTest::ftpProxyServer()
 {
-    netChat(2121, ftpChat("@" + QtNetworkSettings::serverName().toLatin1()));
+    netChat(2121, ftpChat("@" + QtNetworkSettings::ftpServerName().toLatin1()));
 }
 
 void tst_NetworkSelfTest::imapServer()
@@ -551,7 +559,7 @@ void tst_NetworkSelfTest::httpServer()
             // HTTP/1.0 chat:
             << Chat::Reconnect
             << Chat::send("GET / HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -563,7 +571,7 @@ void tst_NetworkSelfTest::httpServer()
             << Chat::Reconnect
             << Chat::send("POST / HTTP/1.0\r\n"
                           "Content-Length: 5\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n"
                           "Hello")
@@ -575,7 +583,7 @@ void tst_NetworkSelfTest::httpServer()
             // HTTP protected area
             << Chat::Reconnect
             << Chat::send("GET /qtest/protected/rfc3252.txt HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -585,7 +593,7 @@ void tst_NetworkSelfTest::httpServer()
 
             << Chat::Reconnect
             << Chat::send("HEAD /qtest/protected/rfc3252.txt HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "Authorization: Basic cXNvY2tzdGVzdDpwYXNzd29yZA==\r\n"
                           "\r\n")
@@ -597,7 +605,7 @@ void tst_NetworkSelfTest::httpServer()
             // DAV area
             << Chat::Reconnect
             << Chat::send("HEAD /dav/ HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -609,7 +617,7 @@ void tst_NetworkSelfTest::httpServer()
             << Chat::Reconnect
             << Chat::send("PUT /dav/networkselftest-" + uniqueExtension + ".txt HTTP/1.0\r\n"
                           "Content-Length: 5\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n"
                           "Hello")
@@ -621,7 +629,7 @@ void tst_NetworkSelfTest::httpServer()
             // check that the file did get uploaded
             << Chat::Reconnect
             << Chat::send("HEAD /dav/networkselftest-" + uniqueExtension + ".txt HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -633,7 +641,7 @@ void tst_NetworkSelfTest::httpServer()
             // HTTP/1.0 DELETE
             << Chat::Reconnect
             << Chat::send("DELETE /dav/networkselftest-" + uniqueExtension + ".txt HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -668,7 +676,7 @@ void tst_NetworkSelfTest::httpServerFiles()
 
     QList<Chat> chat;
     chat << Chat::send("HEAD " + url.toEncoded() + " HTTP/1.0\r\n"
-                       "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                       "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                        "Connection: close\r\n"
                        "Authorization: Basic cXNvY2tzdGVzdDpwYXNzd29yZA==\r\n"
                        "\r\n")
@@ -757,7 +765,7 @@ void tst_NetworkSelfTest::httpsServer()
     netChat(443, QList<Chat>()
             << Chat::StartEncryption
             << Chat::send("GET / HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -772,7 +780,7 @@ void tst_NetworkSelfTest::httpProxy()
     netChat(3128, QList<Chat>()
             // proxy GET by IP
             << Chat::send("GET http://" + serverIpAddress().toString().toLatin1() + "/ HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Proxy-connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -782,8 +790,8 @@ void tst_NetworkSelfTest::httpProxy()
 
             // proxy GET by hostname
             << Chat::Reconnect
-            << Chat::send("GET http://" + QtNetworkSettings::serverName().toLatin1() + "/ HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+            << Chat::send("GET http://" + QtNetworkSettings::httpServerName().toLatin1() + "/ HTTP/1.0\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Proxy-connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -793,8 +801,13 @@ void tst_NetworkSelfTest::httpProxy()
 
             // proxy CONNECT by IP
             << Chat::Reconnect
+#if !defined(QT_TEST_SERVER)
             << Chat::send("CONNECT " + serverIpAddress().toString().toLatin1() + ":21 HTTP/1.0\r\n"
                           "\r\n")
+#else
+            << Chat::send("CONNECT " + ftpServerIpAddress.toString().toLatin1() + ":21 HTTP/1.0\r\n"
+                          "\r\n")
+#endif
             << Chat::expect("HTTP/1.")
             << Chat::discardUntil(" ")
             << Chat::expect("200 ")
@@ -803,7 +816,7 @@ void tst_NetworkSelfTest::httpProxy()
 
             // proxy CONNECT by hostname
             << Chat::Reconnect
-            << Chat::send("CONNECT " + QtNetworkSettings::serverName().toLatin1() + ":21 HTTP/1.0\r\n"
+            << Chat::send("CONNECT " + QtNetworkSettings::ftpServerName().toLatin1() + ":21 HTTP/1.0\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
             << Chat::discardUntil(" ")
@@ -817,8 +830,8 @@ void tst_NetworkSelfTest::httpProxyBasicAuth()
 {
     netChat(3129, QList<Chat>()
             // test auth required response
-            << Chat::send("GET http://" + QtNetworkSettings::serverName().toLatin1() + "/ HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+            << Chat::send("GET http://" + QtNetworkSettings::httpServerName().toLatin1() + "/ HTTP/1.0\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Proxy-connection: close\r\n"
                           "\r\n")
             << Chat::expect("HTTP/1.")
@@ -829,8 +842,8 @@ void tst_NetworkSelfTest::httpProxyBasicAuth()
 
             // now try sending our credentials
             << Chat::Reconnect
-            << Chat::send("GET http://" + QtNetworkSettings::serverName().toLatin1() + "/ HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+            << Chat::send("GET http://" + QtNetworkSettings::httpServerName().toLatin1() + "/ HTTP/1.0\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
                           "Proxy-connection: close\r\n"
                           "Proxy-Authorization: Basic cXNvY2tzdGVzdDpwYXNzd29yZA==\r\n"
                           "\r\n")
@@ -844,9 +857,13 @@ void tst_NetworkSelfTest::httpProxyNtlmAuth()
 {
     netChat(3130, QList<Chat>()
             // test auth required response
-            << Chat::send("GET http://" + QtNetworkSettings::serverName().toLatin1() + "/ HTTP/1.0\r\n"
-                          "Host: " + QtNetworkSettings::serverName().toLatin1() + "\r\n"
+            << Chat::send("GET http://" + QtNetworkSettings::httpServerName().toLatin1() + "/ HTTP/1.0\r\n"
+                          "Host: " + QtNetworkSettings::httpServerName().toLatin1() + "\r\n"
+#if !defined(QT_TEST_SERVER)
                           "Proxy-connection: keep-alive\r\n" // NTLM auth will disconnect
+#else
+                          "Proxy-connection: close\r\n" // Well, what do you know? It keeps it alive!
+#endif
                           "\r\n")
             << Chat::expect("HTTP/1.")
             << Chat::discardUntil(" ")
@@ -877,8 +894,12 @@ void tst_NetworkSelfTest::socks5Proxy()
         char buf[4];
         quint32 data;
     } ip4Address;
-    ip4Address.data = qToBigEndian(serverIpAddress().toIPv4Address());
-
+    ip4Address.data =
+#if !defined(QT_TEST_SERVER)
+    qToBigEndian(serverIpAddress().toIPv4Address());
+#else
+    qToBigEndian(ftpServerIpAddress.toIPv4Address());
+#endif
     const QByteArray handshakeNoAuthData = QByteArray(handshakeNoAuth, int(sizeof handshakeNoAuth) - 1);
     const QByteArray handshakeOkNoAuthData = QByteArray(handshakeOkNoAuth, int(sizeof handshakeOkNoAuth) - 1);
     const QByteArray connect1Data = QByteArray(connect1, int(sizeof connect1) - 1);
@@ -887,6 +908,10 @@ void tst_NetworkSelfTest::socks5Proxy()
 
     netChat(1080, QList<Chat>()
             // IP address connection
+#if !defined(QT_TEST_SERVER)
+            // This test relies on the proxy and ftp servers
+            // running on the same machine, which is not the
+            // case for the docker test server.
             << Chat::send(handshakeNoAuthData)
             << Chat::expect(handshakeOkNoAuthData)
             << Chat::send(connect1Data)
@@ -897,6 +922,7 @@ void tst_NetworkSelfTest::socks5Proxy()
 
             // connect by IP
             << Chat::Reconnect
+#endif
             << Chat::send(handshakeNoAuthData)
             << Chat::expect(handshakeOkNoAuthData)
             << Chat::send(QBA(connect1a) + QByteArray::fromRawData(ip4Address.buf, 4) + QBA(connect1b))
@@ -904,8 +930,9 @@ void tst_NetworkSelfTest::socks5Proxy()
             << Chat::expect("\1") // IPv4 address following
             << Chat::skipBytes(6) // the server's local address and port
             << ftpChat()
-
-            // connect to "localhost" by hostname
+#if !defined(QT_TEST_SERVER)
+            // connect to "localhost" by hostname, the same as above:
+            // makes no sense with the docker test server.
             << Chat::Reconnect
             << Chat::send(handshakeNoAuthData)
             << Chat::expect(handshakeOkNoAuthData)
@@ -914,12 +941,12 @@ void tst_NetworkSelfTest::socks5Proxy()
             << Chat::expect("\1") // IPv4 address following
             << Chat::skipBytes(6) // the server's local address and port
             << ftpChat()
-
+#endif
             // connect to server by its official name
             << Chat::Reconnect
             << Chat::send(handshakeNoAuthData)
             << Chat::expect(handshakeOkNoAuthData)
-            << Chat::send(QBA(connect2a) + char(QtNetworkSettings::serverName().size()) + QtNetworkSettings::serverName().toLatin1() + QBA(connect1b))
+            << Chat::send(QBA(connect2a) + char(QtNetworkSettings::ftpServerName().size()) + QtNetworkSettings::ftpServerName().toLatin1() + QBA(connect1b))
             << Chat::expect(connectedData)
             << Chat::expect("\1") // IPv4 address following
             << Chat::skipBytes(6) // the server's local address and port
@@ -941,8 +968,10 @@ void tst_NetworkSelfTest::socks5ProxyAuth()
             << Chat::send(handshakeNoAuthData)
             << Chat::expect(handshakeAuthNotOkData)
             << Chat::RemoteDisconnect
-
-            // now try to connect with authentication
+#if !defined(QT_TEST_SERVER)
+            // now try to connect with authentication,
+            // danted is just that, socks 5 proxy and
+            // does not have ftp running, skip!
             << Chat::Reconnect
             << Chat::send(handshakeAuthPasswordData)
             << Chat::expect(handshakeOkPasswdAuthData)
@@ -951,6 +980,16 @@ void tst_NetworkSelfTest::socks5ProxyAuth()
             << Chat::expect("\1") // IPv4 address following
             << Chat::skipBytes(6) // the server's local address and port
             << ftpChat()
+#else
+            << Chat::Reconnect
+            << Chat::send(handshakeAuthPasswordData)
+            << Chat::expect(handshakeOkPasswdAuthData)
+            << Chat::send(QBA(connect2a) + char(QtNetworkSettings::ftpServerName().size()) + QtNetworkSettings::ftpServerName().toLatin1() + QBA(connect1b))
+            << Chat::expect(connectedData)
+            << Chat::expect("\1") // IPv4 address following
+            << Chat::skipBytes(6) // the server's local address and port
+            << ftpChat()
+#endif
             );
 }
 
@@ -984,6 +1023,9 @@ static void ensureTermination(QProcess &process)
 
 void tst_NetworkSelfTest::smbServer()
 {
+#if defined(QT_TEST_SERVER)
+    QSKIP("Not supported by the docker test server");
+#endif // QT_TEST_SERVER
     static const char contents[] = "This is 34 bytes. Do not change...";
 #ifdef Q_OS_WIN
     // use Windows's native UNC support to try and open a file on the server
diff --git a/tests/testserver/apache2/testdata/main.conf b/tests/testserver/apache2/testdata/main.conf
index f3b13bb571..ed9aae3fbd 100644
--- a/tests/testserver/apache2/testdata/main.conf
+++ b/tests/testserver/apache2/testdata/main.conf
@@ -54,3 +54,7 @@ Alias /qtest "/home/qt-test-server/www/htdocs/"
 <Directory "/home/qt-test-server/www/htdocs/protected/">
     AllowOverride AuthConfig Options
 </Directory>
+
+<Directory /home/writeables/dav>
+    Options Indexes
+</Directory>
diff --git a/tests/testserver/apache2/testdata/www/htdocs/protected/rfc3252.txt b/tests/testserver/apache2/testdata/www/htdocs/protected/rfc3252.txt
new file mode 100644
index 0000000000..b80c61bf0a
--- /dev/null
+++ b/tests/testserver/apache2/testdata/www/htdocs/protected/rfc3252.txt
@@ -0,0 +1,899 @@
+
+
+
+
+
+
+Network Working Group                                         H. Kennedy
+Request for Comments: 3252                                      Mimezine
+Category: Informational                                     1 April 2002
+
+
+                 Binary Lexical Octet Ad-hoc Transport
+
+Status of this Memo
+
+   This memo provides information for the Internet community.  It does
+   not specify an Internet standard of any kind.  Distribution of this
+   memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2002).  All Rights Reserved.
+
+Abstract
+
+   This document defines a reformulation of IP and two transport layer
+   protocols (TCP and UDP) as XML applications.
+
+1.   Introduction
+
+1.1. Overview
+
+   This document describes the Binary Lexical Octet Ad-hoc Transport
+   (BLOAT): a reformulation of a widely-deployed network-layer protocol
+   (IP [RFC791]), and two associated transport layer protocols (TCP
+   [RFC793] and UDP [RFC768]) as XML [XML] applications.  It also
+   describes methods for transporting BLOAT over Ethernet and IEEE 802
+   networks as well as encapsulating BLOAT in IP for gatewaying BLOAT
+   across the public Internet.
+
+1.2. Motivation
+
+   The wild popularity of XML as a basis for application-level protocols
+   such as the Blocks Extensible Exchange Protocol [RFC3080], the Simple
+   Object Access Protocol [SOAP], and Jabber [JABBER] prompted
+   investigation into the possibility of extending the use of XML in the
+   protocol stack.  Using XML at both the transport and network layer in
+   addition to the application layer would provide for an amazing amount
+   of power and flexibility while removing dependencies on proprietary
+   and hard-to-understand binary protocols.  This protocol unification
+   would also allow applications to use a single XML parser for all
+   aspects of their operation, eliminating developer time spent figuring
+   out the intricacies of each new protocol, and moving the hard work of
+
+
+
+
+Kennedy                      Informational                      [Page 1]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   parsing to the XML toolset.  The use of XML also mitigates concerns
+   over "network vs. host" byte ordering which is at the root of many
+   network application bugs.
+
+1.3. Relation to Existing Protocols
+
+   The reformulations specified in this RFC follow as closely as
+   possible the spirit of the RFCs on which they are based, and so MAY
+   contain elements or attributes that would not be needed in a pure
+   reworking (e.g. length attributes, which are implicit in XML.)
+
+   The layering of network and transport protocols are maintained in
+   this RFC despite the optimizations that could be made if the line
+   were somewhat blurred (i.e. merging TCP and IP into a single, larger
+   element in the DTD) in order to foster future use of this protocol as
+   a basis for reformulating other protocols (such as ICMP.)
+
+   Other than the encoding, the behavioral aspects of each of the
+   existing protocols remain unchanged.  Routing, address spaces, TCP
+   congestion control, etc. behave as specified in the extant standards.
+   Adapting to new standards and experimental algorithm heuristics for
+   improving performance will become much easier once the move to BLOAT
+   has been completed.
+
+1.4. Requirement Levels
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in BCP 14, RFC 2119
+   [RFC2119].
+
+2.   IPoXML
+
+   This protocol MUST be implemented to be compliant with this RFC.
+   IPoXML is the root protocol REQUIRED for effective use of TCPoXML
+   (section 3.) and higher-level application protocols.
+
+   The DTD for this document type can be found in section 7.1.
+
+   The routing of IPoXML can be easily implemented on hosts with an XML
+   parser, as the regular structure lends itself handily to parsing and
+   validation of the document/datagram and then processing the
+   destination address, TTL, and checksum before sending it on to its
+   next-hop.
+
+   The reformulation of IPv4 was chosen over IPv6 [RFC2460] due to the
+   wider deployment of IPv4 and the fact that implementing IPv6 as XML
+   would have exceeded the 1500 byte Ethernet MTU.
+
+
+
+Kennedy                      Informational                      [Page 2]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   All BLOAT implementations MUST use - and specify - the UTF-8 encoding
+   of RFC 2279 [RFC2279].  All BLOAT document/datagrams MUST be well-
+   formed and include the XMLDecl.
+
+2.1. IP Description
+
+   A number of items have changed (for the better) from the original IP
+   specification.  Bit-masks, where present have been converted into
+   human-readable values.  IP addresses are listed in their dotted-
+   decimal notation [RFC1123].  Length and checksum values are present
+   as decimal integers.
+
+   To calculate the length and checksum fields of the IP element, a
+   canonicalized form of the element MUST be used.  The canonical form
+   SHALL have no whitespace (including newline characters) between
+   elements and only one space character between attributes.  There
+   SHALL NOT be a space following the last attribute in an element.
+
+   An iterative method SHOULD be used to calculate checksums, as the
+   length field will vary based on the size of the checksum.
+
+   The payload element bears special attention.  Due to the character
+   set restrictions of XML, the payload of IP datagrams (which MAY
+   contain arbitrary data) MUST be encoded for transport. This RFC
+   REQUIRES the contents of the payload to be encoded in the base-64
+   encoding of RFC 2045 [RFC2045], but removes the requirement that the
+   encoded output MUST be wrapped on 76-character lines.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Kennedy                      Informational                      [Page 3]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+2.2. Example Datagram
+
+   The following is an example IPoXML datagram with an empty payload:
+
+   <?xml version="1.0" encoding="UTF-8"?>
+   <!DOCTYPE ip PUBLIC "-//IETF//DTD BLOAT 1.0 IP//EN" "bloat.dtd">
+   <ip>
+   <header length="474">
+   <version value="4"/>
+   <tos precedence="Routine" delay="Normal" throughput="Normal"
+        relibility="Normal" reserved="0"/>
+   <total.length value="461"/>
+   <id value="1"/>
+   <flags reserved="0" df="dont" mf="last"/>
+   <offset value="0"/>
+   <ttl value="255"/>
+   <protocol value="6"/>
+   <checksum value="8707"/>
+   <source address="10.0.0.22"/>
+   <destination address="10.0.0.1"/>
+   <options>
+   <end copied="0" class="0" number="0"/>
+   </options>
+   <padding pad="0"/>
+   </header>
+   <payload>
+   </payload>
+   </ip>
+
+3.   TCPoXML
+
+   This protocol MUST be implemented to be compliant with this RFC.  The
+   DTD for this document type can be found in section 7.2.
+
+3.1. TCP Description
+
+   A number of items have changed from the original TCP specification.
+   Bit-masks, where present have been converted into human-readable
+   values.  Length and checksum and port values are present as decimal
+   integers.
+
+   To calculate the length and checksum fields of the TCP element, a
+   canonicalized form of the element MUST be used as in section 2.1.
+
+   An iterative method SHOULD be used to calculate checksums as in
+   section 2.1.
+
+   The payload element MUST be encoded as in section 2.1.
+
+
+
+Kennedy                      Informational                      [Page 4]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   The TCP offset element was expanded to a maximum of 255 from 16 to
+   allow for the increased size of the header in XML.
+
+   TCPoXML datagrams encapsulated by IPoXML MAY omit the <?xml?> header
+   as well as the <!DOCTYPE> declaration.
+
+3.2. Example Datagram
+
+   The following is an example TCPoXML datagram with an empty payload:
+
+   <?xml version="1.0" encoding="UTF-8"?>
+   <!DOCTYPE tcp PUBLIC "-//IETF//DTD BLOAT 1.0 TCP//EN" "bloat.dtd">
+   <tcp>
+   <tcp.header>
+   <src port="31415"/>
+   <dest port="42424"/>
+   <sequence number="322622954"/>
+   <acknowledgement number="689715995"/>
+   <offset number=""/>
+   <reserved value="0"/>
+   <control syn="1" ack="1"/>
+   <window size="1"/>
+   <urgent pointer="0"/>
+   <checksum value="2988"/>
+   <tcp.options>
+   <tcp.end kind="0"/>
+   </tcp.options>
+   <padding pad="0"/>
+   </tcp.header>
+   <payload>
+   </payload>
+   </tcp>
+
+4.   UDPoXML
+
+   This protocol MUST be implemented to be compliant with this RFC.  The
+   DTD for this document type can be found in section 7.3.
+
+4.1. UDP Description
+
+   A number of items have changed from the original UDP specification.
+   Bit-masks, where present have been converted into human-readable
+   values.  Length and checksum and port values are present as decimal
+   integers.
+
+
+
+
+
+
+
+Kennedy                      Informational                      [Page 5]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   To calculate the length and checksum fields of the UDP element, a
+   canonicalized form of the element MUST be used as in section 2.1.  An
+   iterative method SHOULD be used to calculate checksums as in section
+   2.1.
+
+   The payload element MUST be encoded as in section 2.1.
+
+   UDPoXML datagrams encapsulated by IPoXML MAY omit the <?xml?> header
+   as well as the <!DOCTYPE> declaration.
+
+4.2. Example Datagram
+
+   The following is an example UDPoXML datagram with an empty payload:
+
+   <?xml version="1.0" encoding="UTF-8"?>
+   <!DOCTYPE udp PUBLIC "-//IETF//DTD BLOAT 1.0 UDP//EN" "bloat.dtd">
+   <udp>
+   <udp.header>
+   <src port="31415"/>
+   <dest port="42424"/>
+   <udp.length value="143"/>
+   <checksum value="2988"/>
+   </udp.header>
+   <payload>
+   </payload>
+   </udp>
+
+5.   Network Transport
+
+   This document provides for the transmission of BLOAT datagrams over
+   two common families of physical layer transport.  Future RFCs will
+   address additional transports as routing vendors catch up to the
+   specification, and we begin to see BLOAT routed across the Internet
+   backbone.
+
+5.1. Ethernet
+
+   BLOAT is encapsulated in Ethernet datagrams as in [RFC894] with the
+   exception that the type field of the Ethernet frame MUST contain the
+   value 0xBEEF.  The first 5 octets of the Ethernet frame payload will
+   be 0x3c 3f 78 6d 6c ("<?xml".)
+
+5.2. IEEE 802
+
+   BLOAT is encapsulated in IEEE 802 Networks as in [RFC1042] except
+   that the protocol type code for IPoXML is 0xBEEF.
+
+
+
+
+
+Kennedy                      Informational                      [Page 6]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+6. Gatewaying over IP
+
+   In order to facilitate the gradual introduction of BLOAT into the
+   public Internet, BLOAT MAY be encapsulated in IP as in [RFC2003] to
+   gateway between networks that run BLOAT natively on their LANs.
+
+7. DTDs
+
+   The Transport DTDs (7.2. and 7.3.) build on the definitions in the
+   Network DTD (7.1.)
+
+   The DTDs are referenced by their PubidLiteral and SystemLiteral (from
+   [XML]) although it is understood that most IPoXML implementations
+   will not need to pull down the DTD, as it will normally be embedded
+   in the implementation, and presents something of a catch-22 if you
+   need to load part of your network protocol over the network.
+
+7.1.  IPoXML DTD
+
+   <!--
+    DTD for IP over XML.
+    Refer to this DTD as:
+
+    <!DOCTYPE ip PUBLIC "-//IETF//DTD BLOAT 1.0 IP//EN" "bloat.dtd">
+   -->
+   <!--
+    DTD data types:
+
+      Digits      [0..9]+
+
+      Precedence  "NetworkControl | InternetworkControl |
+                   CRITIC | FlashOverride | Flash | Immediate |
+                   Priority | Routine"
+
+      IP4Addr     "dotted-decimal" notation of [RFC1123]
+
+      Class       [0..3]
+
+      Sec          "Unclassified | Confidential | EFTO | MMMM | PROG |
+                    Restricted | Secret | Top Secret | Reserved"
+
+      Compartments [0..65535]
+
+      Handling     [0..65535]
+
+      TCC          [0..16777216]
+
+   -->
+
+
+
+Kennedy                      Informational                      [Page 7]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   <!ENTITY % Digits "CDATA">
+   <!ENTITY % Precedence "CDATA">
+   <!ENTITY % IP4Addr "CDATA">
+   <!ENTITY % Class "CDATA">
+   <!ENTITY % Sec "CDATA">
+   <!ENTITY % Compartments "CDATA">
+   <!ENTITY % Handling "CDATA">
+   <!ENTITY % TCC "CDATA">
+
+   <!ELEMENT ip (header, payload)>
+
+   <!ELEMENT header (version, tos, total.length, id, flags, offset, ttl,
+                    protocol, checksum, source, destination, options,
+                    padding)>
+   <!-- length of header in 32-bit words -->
+   <!ATTLIST header
+             length %Digits; #REQUIRED>
+
+   <!ELEMENT version EMPTY>
+   <!-- ip version. SHOULD be "4" -->
+   <!ATTLIST version
+             value   %Digits;  #REQUIRED>
+
+   <!ELEMENT tos EMPTY>
+   <!ATTLIST tos
+             precedence   %Precedence;    #REQUIRED
+             delay    (normal | low)  #REQUIRED
+             throughput   (normal | high) #REQUIRED
+             relibility   (normal | high) #REQUIRED
+             reserved     CDATA #FIXED "0">
+
+   <!ELEMENT total.length EMPTY>
+   <!--
+    total length of datagram (header and payload) in octets, MUST be
+    less than 65,535 (and SHOULD be less than 1024 for IPoXML on local
+    ethernets).
+   -->
+   <!ATTLIST total.length
+             value %Digits; #REQUIRED>
+
+   <!ELEMENT id EMPTY>
+   <!-- 0 <= id <= 65,535  -->
+   <!ATTLIST id
+             value %Digits; #REQUIRED>
+
+   <!ELEMENT flags EMPTY>
+   <!-- df = don't fragment, mf = more fragments  -->
+   <!ATTLIST flags
+
+
+
+Kennedy                      Informational                      [Page 8]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+          reserved CDATA  #FIXED "0"
+          df (may|dont)   #REQUIRED
+          mf (last|more)  #REQUIRED>
+
+   <!ELEMENT offset EMPTY>
+   <!-- 0 <= offset <= 8192 measured in 8 octet (64-bit) chunks -->
+   <!ATTLIST offset
+             value %Digits; #REQUIRED>
+
+   <!ELEMENT ttl EMPTY>
+   <!-- 0 <= ttl <= 255 -->
+   <!ATTLIST ttl
+             value %Digits; #REQUIRED>
+
+   <!ELEMENT protocol EMPTY>
+   <!-- 0 <= protocol <= 255 (per IANA) -->
+   <!ATTLIST protocol
+             value %Digits; #REQUIRED>
+
+   <!ELEMENT checksum EMPTY>
+   <!-- 0 <= checksum <= 65535 (over header only) -->
+   <!ATTLIST checksum
+             value %Digits; #REQUIRED>
+
+   <!ELEMENT source EMPTY>
+   <!ATTLIST source
+             address %IP4Addr; #REQUIRED>
+
+   <!ELEMENT destination EMPTY>
+   <!ATTLIST destination
+             address %IP4Addr; #REQUIRED>
+
+   <!ELEMENT options ( end | noop | security | loose | strict | record
+                     | stream | timestamp )*>
+
+   <!ELEMENT end EMPTY>
+   <!ATTLIST end
+             copied (0|1) #REQUIRED
+             class  CDATA #FIXED "0"
+             number CDATA #FIXED "0">
+
+   <!ELEMENT noop EMPTY>
+   <!ATTLIST noop
+             copied (0|1) #REQUIRED
+             class  CDATA #FIXED "0"
+             number CDATA #FIXED "1">
+
+   <!ELEMENT security EMPTY>
+
+
+
+Kennedy                      Informational                      [Page 9]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   <!ATTLIST security
+             copied CDATA #FIXED "1"
+             class  CDATA #FIXED "0"
+             number CDATA #FIXED "2"
+             length CDATA #FIXED "11"
+             security %Sec; #REQUIRED
+             compartments %Compartments; #REQUIRED
+             handling %Handling; #REQUIRED
+             tcc %TCC; #REQUIRED>
+   <!ELEMENT loose (hop)+>
+   <!ATTLIST loose
+             copied CDATA #FIXED "1"
+             class  CDATA #FIXED "0"
+             number CDATA #FIXED "3"
+             length %Digits; #REQUIRED
+             pointer %Digits; #REQUIRED>
+
+   <!ELEMENT hop EMPTY>
+   <!ATTLIST hop
+             address %IP4Addr; #REQUIRED>
+
+   <!ELEMENT strict (hop)+>
+   <!ATTLIST strict
+             copied CDATA #FIXED "1"
+             class  CDATA #FIXED "0"
+             number CDATA #FIXED "9"
+             length %Digits; #REQUIRED
+             pointer %Digits; #REQUIRED>
+
+   <!ELEMENT record (hop)+>
+   <!ATTLIST record
+             copied CDATA #FIXED "0"
+             class  CDATA #FIXED "0"
+             number CDATA #FIXED "7"
+             length %Digits; #REQUIRED
+             pointer %Digits; #REQUIRED>
+
+   <!ELEMENT stream EMPTY>
+   <!-- 0 <= id <= 65,535 -->
+   <!ATTLIST stream
+             copied CDATA #FIXED "1"
+             class  CDATA #FIXED "0"
+             number CDATA #FIXED "8"
+             length CDATA #FIXED "4"
+             id %Digits; #REQUIRED>
+
+   <!ELEMENT timestamp (tstamp)+>
+   <!-- 0 <= oflw <=15 -->
+
+
+
+Kennedy                      Informational                     [Page 10]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   <!ATTLIST timestamp
+             copied CDATA #FIXED "0"
+             class  CDATA #FIXED "2"
+             number CDATA #FIXED "4"
+             length %Digits;  #REQUIRED
+             pointer %Digits; #REQUIRED
+             oflw %Digits;    #REQUIRED
+             flag (0 | 1 | 3)  #REQUIRED>
+
+   <!ELEMENT tstamp EMPTY>
+   <!ATTLIST tstamp
+             time %Digits;   #REQUIRED
+             address %IP4Addr; #IMPLIED>
+   <!--
+       padding to bring header to 32-bit boundary.
+       pad MUST be "0"*
+    -->
+   <!ELEMENT padding EMPTY>
+   <!ATTLIST padding
+             pad CDATA #REQUIRED>
+
+   <!-- payload MUST be encoded as base-64 [RFC2045], as modified
+        by section 2.1 of this RFC -->
+   <!ELEMENT payload (CDATA)>
+
+7.2.  TCPoXML DTD
+
+   <!--
+      DTD for TCP over XML.
+      Refer to this DTD as:
+
+      <!DOCTYPE tcp PUBLIC "-//IETF//DTD BLOAT 1.0 TCP//EN" "bloat.dtd">
+   -->
+
+   <!-- the pseudoheader is only included for checksum calculations -->
+   <!ELEMENT tcp (tcp.pseudoheader?, tcp.header, payload)>
+
+   <!ELEMENT tcp.header (src, dest, sequence, acknowledgement, offset,
+                         reserved, control, window, checksum, urgent,
+                         tcp.options, padding)>
+
+   <!ELEMENT src EMPTY>
+   <!-- 0 <= port <= 65,535 -->
+   <!ATTLIST src
+             port %Digits; #REQUIRED>
+
+   <!ELEMENT dest EMPTY>
+   <!-- 0 <= port <= 65,535 -->
+
+
+
+Kennedy                      Informational                     [Page 11]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   <!ATTLIST dest
+             port %Digits; #REQUIRED>
+
+   <!ELEMENT sequence EMPTY>
+   <!-- 0 <= number <= 4294967295 -->
+   <!ATTLIST sequence
+             number %Digits; #REQUIRED>
+
+   <!ELEMENT acknowledgement EMPTY>
+   <!-- 0 <= number <= 4294967295 -->
+   <!ATTLIST acknowledgement
+             number %Digits; #REQUIRED>
+
+   <!ELEMENT offset EMPTY>
+   <!-- 0 <= number <= 255 -->
+   <!ATTLIST offset
+             number %Digits; #REQUIRED>
+
+   <!ELEMENT reserved EMPTY>
+   <!ATTLIST reserved
+             value CDATA #FIXED "0">
+
+   <!ELEMENT control EMPTY>
+   <!ATTLIST control
+             urg (0|1) #IMPLIED
+             ack (0|1) #IMPLIED
+             psh (0|1) #IMPLIED
+             rst (0|1) #IMPLIED
+             syn (0|1) #IMPLIED
+             fin (0|1) #IMPLIED>
+
+   <!ELEMENT window EMPTY>
+   <!-- 0 <= size <= 65,535 -->
+   <!ATTLIST window
+             size %Digits; #REQUIRED>
+
+   <!--
+      checksum as in ip, but with
+      the following pseudo-header added into the tcp element:
+     -->
+   <!ELEMENT tcp.pseudoheader (source, destination, protocol,
+                               tcp.length)>
+
+   <!--
+      tcp header + data length in octets. does not include the size of
+
+      the pseudoheader.
+    -->
+
+
+
+Kennedy                      Informational                     [Page 12]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   <!ELEMENT tcp.length EMPTY>
+   <!ATTLIST tcp.length
+             value %Digits; #REQUIRED>
+
+   <!ELEMENT urgent EMPTY>
+   <!-- 0 <= pointer <= 65,535 -->
+   <!ATTLIST urgent
+             pointer %Digits; #REQUIRED>
+
+   <!ELEMENT tcp.options (tcp.end | tcp.noop | tcp.mss)+>
+
+   <!ELEMENT tcp.end EMPTY>
+   <!ATTLIST tcp.end
+             kind CDATA #FIXED "0">
+
+   <!ELEMENT tcp.noop EMPTY>
+   <!ATTLIST tcp.noop
+             kind CDATA #FIXED "1">
+
+   <!ELEMENT tcp.mss EMPTY>
+   <!ATTLIST tcp.mss
+             kind CDATA #FIXED "2"
+             length CDATA #FIXED "4"
+             size %Digits; #REQUIRED>
+
+7.3.  UDPoXML DTD
+
+   <!--
+      DTD for UDP over XML.
+      Refer to this DTD as:
+
+      <!DOCTYPE udp PUBLIC "-//IETF//DTD BLOAT 1.0 UDP//EN" "bloat.dtd">
+   -->
+
+   <!ELEMENT udp (udp.pseudoheader?, udp.header, payload)>
+
+   <!ELEMENT udp.header (src, dest, udp.length, checksum)>
+
+   <!ELEMENT udp.pseudoheader (source, destination, protocol,
+                               udp.length)>
+
+   <!--
+      udp header + data length in octets. does not include the size of
+      the pseudoheader.
+    -->
+   <!ELEMENT udp.length EMPTY>
+   <!ATTLIST udp.length
+             value %Digits; #REQUIRED>
+
+
+
+Kennedy                      Informational                     [Page 13]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+8. Security Considerations
+
+   XML, as a subset of SGML, has the same security considerations as
+   specified in SGML Media Types [RFC1874].  Security considerations
+   that apply to IP, TCP and UDP also likely apply to BLOAT as it does
+   not attempt to correct for issues not related to message format.
+
+9.   References
+
+   [JABBER]    Miller, J., "Jabber", draft-miller-jabber-00.txt,
+               February 2002. (Work in Progress)
+
+   [RFC768]    Postel, J., "User Datagram Protocol", STD 6, RFC 768,
+               August 1980.
+
+   [RFC791]    Postel, J., "Internet Protocol", STD 5, RFC 791,
+               September 1981.
+
+   [RFC793]    Postel, J., "Transmission Control Protocol", STD 7, RFC
+               793, September 1981.
+
+   [RFC894]    Hornig, C., "Standard for the Transmission of IP
+               Datagrams over Ethernet Networks.", RFC 894, April 1984.
+
+   [RFC1042]   Postel, J. and J. Reynolds, "Standard for the
+               Transmission of IP Datagrams Over IEEE 802 Networks", STD
+               43, RFC 1042, February 1988.
+
+   [RFC1123]   Braden, R., "Requirements for Internet Hosts -
+               Application and Support", RFC 1123, October 1989.
+
+   [RFC1874]   Levinson, E., "SGML Media Types", RFC 1874, December
+               1995.
+
+   [RFC2003]   Perkins, C., "IP Encapsulation within IP", RFC 2003,
+               October 1996.
+
+   [RFC2045]   Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+               Extensions (MIME) Part One: Format of Internet Message
+               Bodies", RFC 2045, November 1996.
+
+   [RFC2119]   Bradner, S., "Key words for use in RFCs to Indicate
+               Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2279]   Yergeau, F., "UTF-8, a transformation format of ISO
+               10646", RFC 2279, January 1998.
+
+
+
+
+
+Kennedy                      Informational                     [Page 14]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+   [RFC2460]   Deering, S. and R. Hinden, "Internet Protocol, Version 6
+               (IPv6) Specification", RFC 2460, December 1998.
+
+   [RFC3080]   Rose, M., "The Blocks Extensible Exchange Protocol Core",
+               RFC 3080, March 2001.
+
+   [SOAP]      Box, D., Ehnebuske, D., Kakivaya, G., Layman, A.,
+               Mendelsohn, N., Nielsen, H. F., Thatte, S. Winer, D.,
+               "Simple Object Access Protocol (SOAP) 1.1" World Wide Web
+               Consortium Note, May 2000 http://www.w3.org/TR/SOAP/
+
+   [XML]       Bray, T., Paoli, J., Sperberg-McQueen, C. M., "Extensible
+               Markup Language (XML)" World Wide Web Consortium
+               Recommendation REC- xml-19980210.
+               http://www.w3.org/TR/1998/REC-xml-19980210
+
+10.  Author's Address
+
+   Hugh Kennedy
+   Mimezine
+   1060 West Addison
+   Chicago, IL 60613
+   USA
+
+   EMail: kennedyh@engin.umich.edu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Kennedy                      Informational                     [Page 15]
+
+RFC 3252         Binary Lexical Octet Ad-hoc Transport      1 April 2002
+
+
+11.  Full Copyright Statement
+
+   Copyright (C) The Internet Society (2002).  All Rights Reserved.
+
+   This document and translations of it may be copied and furnished to
+   others, and derivative works that comment on or otherwise explain it
+   or assist in its implementation may be prepared, copied, published
+   and distributed, in whole or in part, without restriction of any
+   kind, provided that the above copyright notice and this paragraph are
+   included on all such copies and derivative works.  However, this
+   document itself may not be modified in any way, such as by removing
+   the copyright notice or references to the Internet Society or other
+   Internet organizations, except as needed for the purpose of
+   developing Internet standards in which case the procedures for
+   copyrights defined in the Internet Standards process must be
+   followed, or as required to translate it into languages other than
+   English.
+
+   The limited permissions granted above are perpetual and will not be
+   revoked by the Internet Society or its successors or assigns.
+
+   This document and the information contained herein is provided on an
+   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Kennedy                      Informational                     [Page 16]
+
diff --git a/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/completelyEmptyQuery.xq b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/completelyEmptyQuery.xq
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformed.xml b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformed.xml
new file mode 100644
index 0000000000..cf49e65bab
--- /dev/null
+++ b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformed.xml
@@ -0,0 +1 @@
+<e/
diff --git a/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformedViaHttps.xml b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformedViaHttps.xml
new file mode 100644
index 0000000000..cf49e65bab
--- /dev/null
+++ b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/notWellformedViaHttps.xml
@@ -0,0 +1 @@
+<e/
diff --git a/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/viaHttp.xq b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/viaHttp.xq
new file mode 100644
index 0000000000..106072a44c
--- /dev/null
+++ b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/viaHttp.xq
@@ -0,0 +1 @@
+concat("This was ", "received via HTTP.")
diff --git a/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormed.xml b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormed.xml
new file mode 100644
index 0000000000..714922e727
--- /dev/null
+++ b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormed.xml
@@ -0,0 +1,2 @@
+<!-- a comment -->
+<e from="http">Some Text</e>
diff --git a/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormedViaHttps.xml b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormedViaHttps.xml
new file mode 100644
index 0000000000..555d29e1d7
--- /dev/null
+++ b/tests/testserver/apache2/testdata/www/htdocs/qxmlquery/wellFormedViaHttps.xml
@@ -0,0 +1,2 @@
+<!-- a comment -->
+<e from="https">Some Text</e>
diff --git a/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/README b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/README
new file mode 100644
index 0000000000..0f4a679502
--- /dev/null
+++ b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/README
@@ -0,0 +1 @@
+This directory contains data for the auto test for QXmlQuery, found in the Qt module QtXmlPatterns.
diff --git a/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/completelyEmptyQuery.xq b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/completelyEmptyQuery.xq
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/notWellFormed.xml b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/notWellFormed.xml
new file mode 100644
index 0000000000..f967989a0b
--- /dev/null
+++ b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/notWellFormed.xml
@@ -0,0 +1 @@
+<ftp/
diff --git a/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/viaFtp.xq b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/viaFtp.xq
new file mode 100644
index 0000000000..0dacd63cc0
--- /dev/null
+++ b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/viaFtp.xq
@@ -0,0 +1 @@
+concat("This was ", "received via FTP")
diff --git a/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/wellFormed.xml b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/wellFormed.xml
new file mode 100644
index 0000000000..2ee6884b09
--- /dev/null
+++ b/tests/testserver/vsftpd/testdata/ftp/pub/qxmlquery/wellFormed.xml
@@ -0,0 +1,2 @@
+<!-- a comment -->
+<e from="ftp">Some Text</e>
-- 
2.31.1

