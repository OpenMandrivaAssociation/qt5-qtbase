From d3e694b5015be4a6ff711a808be138d29a5049ae Mon Sep 17 00:00:00 2001
From: "Richard J. Moore" <rich@kde.org>
Date: Mon, 25 Jul 2016 22:02:03 +0100
Subject: [PATCH 15/23] Remove more compatibility cruft

Change-Id: I339817de1b9c3fd8780b407249f9daf4c997bf4a
---
 src/network/ssl/qsslcontext_openssl.cpp | 79 +++++++++++++++------------------
 1 file changed, 36 insertions(+), 43 deletions(-)

diff --git a/src/network/ssl/qsslcontext_openssl.cpp b/src/network/ssl/qsslcontext_openssl.cpp
index 391fd08..43363d5 100644
--- a/src/network/ssl/qsslcontext_openssl.cpp
+++ b/src/network/ssl/qsslcontext_openssl.cpp
@@ -125,12 +125,9 @@ init_context:
     long options = QSslSocketBackendPrivate::setupOpenSslOptions(configuration.protocol(), configuration.d->sslOptions);
     q_SSL_CTX_set_options(sslContext->ctx, options);
 
-#if OPENSSL_VERSION_NUMBER >= 0x10000000L
     // Tell OpenSSL to release memory early
     // http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html
-    if (q_SSLeay() >= 0x10000000L)
-        q_SSL_CTX_set_mode(sslContext->ctx, SSL_MODE_RELEASE_BUFFERS);
-#endif
+    q_SSL_CTX_set_mode(sslContext->ctx, SSL_MODE_RELEASE_BUFFERS);
 
     // Initialize ciphers
     QByteArray cipherString;
@@ -274,31 +271,29 @@ init_context:
         q_DH_free(dh);
     }
 
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L && !defined(OPENSSL_NO_PSK)
+#if !defined(OPENSSL_NO_PSK)
     if (!client)
         q_SSL_CTX_use_psk_identity_hint(sslContext->ctx, sslContext->sslConfiguration.preSharedKeyIdentityHint().constData());
-#endif // OPENSSL_VERSION_NUMBER >= 0x10001000L && !defined(OPENSSL_NO_PSK)
+#endif // !defined(OPENSSL_NO_PSK)
 
     const QVector<QSslEllipticCurve> qcurves = sslContext->sslConfiguration.ellipticCurves();
     if (!qcurves.isEmpty()) {
-#if OPENSSL_VERSION_NUMBER >= 0x10002000L && !defined(OPENSSL_NO_EC)
+#if !defined(OPENSSL_NO_EC)
         // Set the curves to be used
-        if (q_SSLeay() >= 0x10002000L) {
-            // SSL_CTX_ctrl wants a non-const pointer as last argument,
-            // but let's avoid a copy into a temporary array
-            if (!q_SSL_CTX_ctrl(sslContext->ctx,
-                                SSL_CTRL_SET_CURVES,
-                                qcurves.size(),
-                                const_cast<int *>(reinterpret_cast<const int *>(qcurves.data())))) {
-                sslContext->errorStr = msgErrorSettingEllipticCurves(QSslSocketBackendPrivate::getErrorsFromOpenSsl());
-                sslContext->errorCode = QSslError::UnspecifiedError;
-            }
-        } else
-#endif // OPENSSL_VERSION_NUMBER >= 0x10002000L && !defined(OPENSSL_NO_EC)
+      // SSL_CTX_ctrl wants a non-const pointer as last argument,
+      // but let's avoid a copy into a temporary array
+      if (!q_SSL_CTX_ctrl(sslContext->ctx,
+                          SSL_CTRL_SET_CURVES,
+                          qcurves.size(),
+                          const_cast<int *>(reinterpret_cast<const int *>(qcurves.data())))) {
+        sslContext->errorStr = msgErrorSettingEllipticCurves(QSslSocketBackendPrivate::getErrorsFromOpenSsl());
+        sslContext->errorCode = QSslError::UnspecifiedError;
+      } else
+#endif // !defined(OPENSSL_NO_EC)
         {
-            // specific curves requested, but not possible to set -> error
-            sslContext->errorStr = msgErrorSettingEllipticCurves(QSslSocket::tr("OpenSSL version too old, need at least v1.0.2"));
-            sslContext->errorCode = QSslError::UnspecifiedError;
+          // specific curves requested, but not possible to set -> error
+          sslContext->errorStr = msgErrorSettingEllipticCurves(QSslSocket::tr("OpenSSL version too old, need at least v1.0.2"));
+          sslContext->errorCode = QSslError::UnspecifiedError;
         }
     }
 }
@@ -317,7 +312,7 @@ QSharedPointer<QSslContext> QSslContext::sharedFromConfiguration(QSslSocket::Ssl
     return sslContext;
 }
 
-#if OPENSSL_VERSION_NUMBER >= 0x1000100fL && !defined(OPENSSL_NO_NEXTPROTONEG)
+#if !defined(OPENSSL_NO_NEXTPROTONEG)
 
 static int next_proto_cb(SSL *, unsigned char **out, unsigned char *outlen,
                          const unsigned char *in, unsigned int inlen, void *arg)
@@ -354,7 +349,7 @@ QSslContext::NPNContext QSslContext::npnContext() const
 {
     return m_npnContext;
 }
-#endif // OPENSSL_VERSION_NUMBER >= 0x1000100fL ...
+#endif // !defined(OPENSSL_NO_NEXTPROTONEG)
 
 // Needs to be deleted by caller
 SSL* QSslContext::createSsl()
@@ -377,7 +372,7 @@ SSL* QSslContext::createSsl()
         }
     }
 
-#if OPENSSL_VERSION_NUMBER >= 0x1000100fL && !defined(OPENSSL_NO_NEXTPROTONEG)
+#if !defined(OPENSSL_NO_NEXTPROTONEG)
     QList<QByteArray> protocols = sslConfiguration.d->nextAllowedProtocols;
     if (!protocols.isEmpty()) {
         m_supportedNPNVersions.clear();
@@ -392,26 +387,24 @@ SSL* QSslContext::createSsl()
         m_npnContext.data = reinterpret_cast<unsigned char *>(m_supportedNPNVersions.data());
         m_npnContext.len = m_supportedNPNVersions.count();
         m_npnContext.status = QSslConfiguration::NextProtocolNegotiationNone;
-#if OPENSSL_VERSION_NUMBER >= 0x10002000L
-        if (q_SSLeay() >= 0x10002000L) {
-            // Callback's type has a parameter 'const unsigned char ** out'
-            // since it was introduced in 1.0.2. Internally, OpenSSL's own code
-            // (tests/examples) cast it to unsigned char * (since it's 'out').
-            // We just re-use our NPN callback and cast here:
-            typedef int (*alpn_callback_t) (SSL *, const unsigned char **, unsigned char *,
-                                            const unsigned char *, unsigned int, void *);
-            // With ALPN callback is for a server side only, for a client m_npnContext.status
-            // will stay in NextProtocolNegotiationNone.
-            q_SSL_CTX_set_alpn_select_cb(ctx, alpn_callback_t(next_proto_cb), &m_npnContext);
-            // Client:
-            q_SSL_set_alpn_protos(ssl, m_npnContext.data, m_npnContext.len);
-        }
-#endif // OPENSSL_VERSION_NUMBER >= 0x10002000L ...
 
-        // And in case our peer does not support ALPN, but supports NPN:
-        q_SSL_CTX_set_next_proto_select_cb(ctx, next_proto_cb, &m_npnContext);
+        // Callback's type has a parameter 'const unsigned char ** out'
+        // since it was introduced in 1.0.2. Internally, OpenSSL's own code
+        // (tests/examples) cast it to unsigned char * (since it's 'out').
+        // We just re-use our NPN callback and cast here:
+        typedef int (*alpn_callback_t) (SSL *, const unsigned char **, unsigned char *,
+                                        const unsigned char *, unsigned int, void *);
+        
+        // With ALPN callback is for a server side only, for a client m_npnContext.status
+        // will stay in NextProtocolNegotiationNone.
+        q_SSL_CTX_set_alpn_select_cb(ctx, alpn_callback_t(next_proto_cb), &m_npnContext);
+        // Client:
+        q_SSL_set_alpn_protos(ssl, m_npnContext.data, m_npnContext.len);
     }
-#endif // OPENSSL_VERSION_NUMBER >= 0x1000100fL ...
+
+    // And in case our peer does not support ALPN, but supports NPN:
+    q_SSL_CTX_set_next_proto_select_cb(ctx, next_proto_cb, &m_npnContext);
+#endif // !defined(OPENSSL_NO_NEXTPROTONEG)
 
     return ssl;
 }
-- 
2.10.0

