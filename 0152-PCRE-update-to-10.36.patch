From cf797c611d0e021e6ddae95f8ec24fb1638d04e4 Mon Sep 17 00:00:00 2001
From: Giuseppe D'Angelo <giuseppe.dangelo@kdab.com>
Date: Fri, 4 Dec 2020 16:45:55 +0100
Subject: [PATCH 152/171] PCRE: update to 10.36

Dropped the RTEMS patch (upstream now uses posix_madvise).
Drop support for the TILE architecture (dropped by upstream).

[ChangeLog][Third-Party Code] PCRE2 has been updated to version
10.36.

Change-Id: Idb4467bef0ff520605b8b5d9188b9d67d8e4d0f2
Reviewed-by: Lars Knoll <lars.knoll@qt.io>
(cherry picked from commit 509c25752112583e6bc997e8c9442f6b69136816)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/3rdparty/pcre2/AUTHORS                    |     4 +-
 src/3rdparty/pcre2/LICENCE                    |     4 +-
 .../pcre2/import_from_pcre2_tarball.sh        |     5 +-
 ...001-fix-rtems-build-undefine-madvise.patch |    28 -
 src/3rdparty/pcre2/qt_attribution.json        |    11 +-
 src/3rdparty/pcre2/src/pcre2.h                |     4 +-
 src/3rdparty/pcre2/src/pcre2_compile.c        |     3 +-
 src/3rdparty/pcre2/src/pcre2_jit_compile.c    |   220 +-
 src/3rdparty/pcre2/src/pcre2_jit_misc.c       |     2 +-
 src/3rdparty/pcre2/src/pcre2_jit_neon_inc.h   |     4 +
 src/3rdparty/pcre2/src/pcre2_match.c          |    10 +-
 src/3rdparty/pcre2/src/sljit/sljitConfig.h    |    46 +-
 .../pcre2/src/sljit/sljitConfigInternal.h     |   145 +-
 .../pcre2/src/sljit/sljitExecAllocator.c      |    59 +-
 src/3rdparty/pcre2/src/sljit/sljitLir.c       |    59 +-
 src/3rdparty/pcre2/src/sljit/sljitLir.h       |    42 +-
 .../pcre2/src/sljit/sljitNativeARM_32.c       |    80 +-
 .../pcre2/src/sljit/sljitNativeARM_64.c       |    32 +-
 .../pcre2/src/sljit/sljitNativeARM_T2_32.c    |    23 +-
 .../pcre2/src/sljit/sljitNativeMIPS_32.c      |    11 +-
 .../pcre2/src/sljit/sljitNativeMIPS_64.c      |    12 +-
 .../pcre2/src/sljit/sljitNativeMIPS_common.c  |    15 +-
 .../pcre2/src/sljit/sljitNativePPC_32.c       |    11 +-
 .../pcre2/src/sljit/sljitNativePPC_64.c       |    12 +-
 .../pcre2/src/sljit/sljitNativePPC_common.c   |     3 +-
 .../pcre2/src/sljit/sljitNativeS390X.c        |  2812 +++++
 .../pcre2/src/sljit/sljitNativeSPARC_32.c     |    11 +-
 .../pcre2/src/sljit/sljitNativeSPARC_common.c |     3 +-
 .../src/sljit/sljitNativeTILEGX-encoder.c     | 10159 ----------------
 .../pcre2/src/sljit/sljitNativeTILEGX_64.c    |  2563 ----
 .../pcre2/src/sljit/sljitNativeX86_common.c   |    55 +-
 .../pcre2/src/sljit/sljitProtExecAllocator.c  |   474 +
 src/3rdparty/pcre2/src/sljit/sljitUtils.c     |   261 +-
 .../pcre2/src/sljit/sljitWXExecAllocator.c    |   225 +
 34 files changed, 4166 insertions(+), 13242 deletions(-)
 delete mode 100644 src/3rdparty/pcre2/patches/0001-fix-rtems-build-undefine-madvise.patch
 create mode 100644 src/3rdparty/pcre2/src/sljit/sljitNativeS390X.c
 delete mode 100644 src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX-encoder.c
 delete mode 100644 src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX_64.c
 create mode 100644 src/3rdparty/pcre2/src/sljit/sljitProtExecAllocator.c
 create mode 100644 src/3rdparty/pcre2/src/sljit/sljitWXExecAllocator.c

diff --git a/src/3rdparty/pcre2/AUTHORS b/src/3rdparty/pcre2/AUTHORS
index 645c0657b3..f001cb770e 100644
--- a/src/3rdparty/pcre2/AUTHORS
+++ b/src/3rdparty/pcre2/AUTHORS
@@ -2,8 +2,8 @@ THE MAIN PCRE2 LIBRARY CODE
 ---------------------------
 
 Written by:       Philip Hazel
-Email local part: ph10
-Email domain:     cam.ac.uk
+Email local part: Philip.Hazel
+Email domain:     gmail.com
 
 University of Cambridge Computing Service,
 Cambridge, England.
diff --git a/src/3rdparty/pcre2/LICENCE b/src/3rdparty/pcre2/LICENCE
index 1568be3a17..155d073127 100644
--- a/src/3rdparty/pcre2/LICENCE
+++ b/src/3rdparty/pcre2/LICENCE
@@ -20,8 +20,8 @@ THE BASIC LIBRARY FUNCTIONS
 ---------------------------
 
 Written by:       Philip Hazel
-Email local part: ph10
-Email domain:     cam.ac.uk
+Email local part: Philip.Hazel
+Email domain:     gmail.com
 
 University of Cambridge Computing Service,
 Cambridge, England.
diff --git a/src/3rdparty/pcre2/import_from_pcre2_tarball.sh b/src/3rdparty/pcre2/import_from_pcre2_tarball.sh
index 0a308d8104..c7abb7d297 100755
--- a/src/3rdparty/pcre2/import_from_pcre2_tarball.sh
+++ b/src/3rdparty/pcre2/import_from_pcre2_tarball.sh
@@ -128,14 +128,15 @@ FILES="
     src/sljit/sljitNativePPC_32.c
     src/sljit/sljitNativePPC_64.c
     src/sljit/sljitNativePPC_common.c
+    src/sljit/sljitNativeS390X.c
     src/sljit/sljitNativeSPARC_32.c
     src/sljit/sljitNativeSPARC_common.c
-    src/sljit/sljitNativeTILEGX_64.c
-    src/sljit/sljitNativeTILEGX-encoder.c
     src/sljit/sljitNativeX86_32.c
     src/sljit/sljitNativeX86_64.c
     src/sljit/sljitNativeX86_common.c
+    src/sljit/sljitProtExecAllocator.c
     src/sljit/sljitUtils.c
+    src/sljit/sljitWXExecAllocator.c
 "
 
 for i in $FILES; do
diff --git a/src/3rdparty/pcre2/patches/0001-fix-rtems-build-undefine-madvise.patch b/src/3rdparty/pcre2/patches/0001-fix-rtems-build-undefine-madvise.patch
deleted file mode 100644
index 074b39df85..0000000000
--- a/src/3rdparty/pcre2/patches/0001-fix-rtems-build-undefine-madvise.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From ac10063196685fe6124055feb1275e13a78f562e Mon Sep 17 00:00:00 2001
-From: Mikhail Svetkin <mikhail.svetkin@qt.io>
-Date: Tue, 20 Mar 2018 14:03:54 +0100
-Subject: [PATCH] rtems: Fix pcre2 build (madvise undefined)
-
-RTEMS does not have madvise. We can use only posix_madvise
-
-Change-Id: Ia18b7cd2d7f9db84331f7e2350d060b9e85b30c8
----
- src/3rdparty/pcre2/src/sljit/sljitUtils.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/src/3rdparty/pcre2/src/sljit/sljitUtils.c b/src/3rdparty/pcre2/src/sljit/sljitUtils.c
-index 5c2a838932..2ead044b1b 100644
---- a/src/3rdparty/pcre2/src/sljit/sljitUtils.c
-+++ b/src/3rdparty/pcre2/src/sljit/sljitUtils.c
-@@ -315,7 +315,7 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_u8 *SLJIT_FUNC sljit_stack_resize(struct sljit_st
- 		aligned_new_start = (sljit_uw)new_start & ~sljit_page_align;
- 		aligned_old_start = ((sljit_uw)stack->start) & ~sljit_page_align;
- 		/* If madvise is available, we release the unnecessary space. */
--#if defined(MADV_DONTNEED)
-+#if defined(MADV_DONTNEED) && !defined(__rtems__)
- 		if (aligned_new_start > aligned_old_start)
- 			madvise((void*)aligned_old_start, aligned_new_start - aligned_old_start, MADV_DONTNEED);
- #elif defined(POSIX_MADV_DONTNEED)
--- 
-2.21.0
-
diff --git a/src/3rdparty/pcre2/qt_attribution.json b/src/3rdparty/pcre2/qt_attribution.json
index df70d42d65..e7abb56762 100644
--- a/src/3rdparty/pcre2/qt_attribution.json
+++ b/src/3rdparty/pcre2/qt_attribution.json
@@ -7,8 +7,8 @@
 
     "Description": "The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.",
     "Homepage": "http://www.pcre.org/",
-    "Version": "10.35",
-    "DownloadLocation": "https://ftp.pcre.org/pub/pcre/pcre2-10.35.tar.bz2",
+    "Version": "10.36",
+    "DownloadLocation": "https://ftp.pcre.org/pub/pcre/pcre2-10.36.tar.bz2",
     "License": "BSD 3-clause \"New\" or \"Revised\" License",
     "LicenseId": "BSD-3-Clause",
     "LicenseFile": "LICENCE",
@@ -24,12 +24,11 @@ Copyright (c) 2010-2020 Zoltan Herczeg"
     "Path": "src/sljit",
     "Description": "The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.",
     "Homepage": "http://www.pcre.org/",
-    "Version": "10.35",
-    "DownloadLocation": "https://ftp.pcre.org/pub/pcre/pcre2-10.35.tar.bz2",
+    "Version": "10.36",
+    "DownloadLocation": "https://ftp.pcre.org/pub/pcre/pcre2-10.36.tar.bz2",
     "License": "BSD 2-clause \"Simplified\" License",
     "LicenseId": "BSD-2-Clause",
     "LicenseFile": "LICENCE-SLJIT",
-    "Copyright": "Copyright (c) 2009-2020 Zoltan Herczeg
-Copyright 2013-2013 Tilera Corporation(jiwang@tilera.com)"
+    "Copyright": "Copyright (c) 2009-2020 Zoltan Herczeg"
 }
 ]
diff --git a/src/3rdparty/pcre2/src/pcre2.h b/src/3rdparty/pcre2/src/pcre2.h
index 4a42a7975a..f204ec8180 100644
--- a/src/3rdparty/pcre2/src/pcre2.h
+++ b/src/3rdparty/pcre2/src/pcre2.h
@@ -42,9 +42,9 @@ POSSIBILITY OF SUCH DAMAGE.
 /* The current PCRE version information. */
 
 #define PCRE2_MAJOR           10
-#define PCRE2_MINOR           35
+#define PCRE2_MINOR           36
 #define PCRE2_PRERELEASE      
-#define PCRE2_DATE            2020-05-09
+#define PCRE2_DATE            2020-12-04
 
 /* When an application links to a PCRE DLL in Windows, the symbols that are
 imported have to be identified as such. When building PCRE2, the appropriate
diff --git a/src/3rdparty/pcre2/src/pcre2_compile.c b/src/3rdparty/pcre2/src/pcre2_compile.c
index 62393bea74..e811f12f02 100644
--- a/src/3rdparty/pcre2/src/pcre2_compile.c
+++ b/src/3rdparty/pcre2/src/pcre2_compile.c
@@ -2344,7 +2344,7 @@ if (ptr > *nameptr + MAX_NAME_SIZE)
   *errorcodeptr = ERR48;
   goto FAILED;
   }
-*namelenptr = ptr - *nameptr;
+*namelenptr = (uint32_t)(ptr - *nameptr);
 
 /* Subpattern names must not be empty, and their terminator is checked here.
 (What follows a verb or alpha assertion name is checked separately.) */
@@ -4331,6 +4331,7 @@ while (ptr < ptrend)
           {
           if (++ptr >= ptrend || !IS_DIGIT(*ptr)) goto BAD_VERSION_CONDITION;
           minor = (*ptr++ - CHAR_0) * 10;
+          if (ptr >= ptrend) goto BAD_VERSION_CONDITION;
           if (IS_DIGIT(*ptr)) minor += *ptr++ - CHAR_0;
           if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)
             goto BAD_VERSION_CONDITION;
diff --git a/src/3rdparty/pcre2/src/pcre2_jit_compile.c b/src/3rdparty/pcre2/src/pcre2_jit_compile.c
index 33ad7e6553..1977d28aa5 100644
--- a/src/3rdparty/pcre2/src/pcre2_jit_compile.c
+++ b/src/3rdparty/pcre2/src/pcre2_jit_compile.c
@@ -1466,9 +1466,9 @@ do
         default:
         accelerated_start = NULL;
         fast_forward_allowed = FALSE;
-        break;
+        continue;
         }
-      continue;
+      break;
 
       case OP_ONCE:
       case OP_BRA:
@@ -1834,57 +1834,57 @@ while (cc < ccend)
     case OP_BRAZERO:
     case OP_BRAMINZERO:
     case OP_BRAPOSZERO:
-    repeat_check = FALSE;
     size = 1;
+    repeat_check = FALSE;
     break;
 
     CASE_ITERATOR_PRIVATE_DATA_1
-    space = 1;
     size = -2;
+    space = 1;
     break;
 
     CASE_ITERATOR_PRIVATE_DATA_2A
-    space = 2;
     size = -2;
+    space = 2;
     break;
 
     CASE_ITERATOR_PRIVATE_DATA_2B
-    space = 2;
     size = -(2 + IMM2_SIZE);
+    space = 2;
     break;
 
     CASE_ITERATOR_TYPE_PRIVATE_DATA_1
-    space = 1;
     size = 1;
+    space = 1;
     break;
 
     CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
+    size = 1;
     if (cc[1] != OP_ANYNL && cc[1] != OP_EXTUNI)
       space = 2;
-    size = 1;
     break;
 
     case OP_TYPEUPTO:
+    size = 1 + IMM2_SIZE;
     if (cc[1 + IMM2_SIZE] != OP_ANYNL && cc[1 + IMM2_SIZE] != OP_EXTUNI)
       space = 2;
-    size = 1 + IMM2_SIZE;
     break;
 
     case OP_TYPEMINUPTO:
-    space = 2;
     size = 1 + IMM2_SIZE;
+    space = 2;
     break;
 
     case OP_CLASS:
     case OP_NCLASS:
-    space = get_class_iterator_size(cc + size);
     size = 1 + 32 / sizeof(PCRE2_UCHAR);
+    space = get_class_iterator_size(cc + size);
     break;
 
 #if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8
     case OP_XCLASS:
-    space = get_class_iterator_size(cc + size);
     size = GET(cc, 1);
+    space = get_class_iterator_size(cc + size);
     break;
 #endif
 
@@ -4578,7 +4578,14 @@ if (common->nltype != NLTYPE_ANY)
   /* All newlines are ascii, just skip intermediate octets. */
   jump[0] = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
   loop = LABEL();
-  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));
+  if (sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_SUPP | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1)) == SLJIT_SUCCESS)
+    sljit_emit_mem(compiler, MOV_UCHAR | SLJIT_MEM_POST, TMP2, SLJIT_MEM1(STR_PTR), IN_UCHARS(1));
+  else
+    {
+    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(0));
+    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
+    }
+
   OP2(SLJIT_AND, TMP2, 0, TMP2, 0, SLJIT_IMM, 0xc0);
   CMPTO(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, 0x80, loop);
   OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
@@ -6161,9 +6168,9 @@ static SLJIT_INLINE void fast_forward_newline(compiler_common *common)
 {
 DEFINE_COMPILER;
 struct sljit_label *loop;
-struct sljit_jump *lastchar;
+struct sljit_jump *lastchar = NULL;
 struct sljit_jump *firstchar;
-struct sljit_jump *quit;
+struct sljit_jump *quit = NULL;
 struct sljit_jump *foundcr = NULL;
 struct sljit_jump *notfoundnl;
 jump_list *newline = NULL;
@@ -6176,39 +6183,71 @@ if (common->match_end_ptr != 0)
 
 if (common->nltype == NLTYPE_FIXED && common->newline > 255)
   {
-  lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
-  if (HAS_VIRTUAL_REGISTERS)
+#ifdef JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD
+  if (JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD && common->mode == PCRE2_JIT_COMPLETE)
     {
-    OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);
-    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));
-    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));
+    if (HAS_VIRTUAL_REGISTERS)
+      {
+      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);
+      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));
+      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));
+      }
+    else
+      {
+      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));
+      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));
+      }
+    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);
+
+    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
+    OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, STR_PTR, 0, TMP1, 0);
+    OP_FLAGS(SLJIT_MOV, TMP1, 0, SLJIT_NOT_EQUAL);
+#if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32
+    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, UCHAR_SHIFT);
+#endif
+    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP1, 0);
+
+    fast_forward_char_pair_simd(common, 1, common->newline & 0xff, common->newline & 0xff, 0, (common->newline >> 8) & 0xff, (common->newline >> 8) & 0xff);
+    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(2));
     }
   else
+#endif /* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */
     {
-    OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));
-    OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));
-    }
-  firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);
+    lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
+    if (HAS_VIRTUAL_REGISTERS)
+      {
+      OP1(SLJIT_MOV, TMP1, 0, ARGUMENTS, 0);
+      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, str));
+      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(TMP1), SLJIT_OFFSETOF(jit_arguments, begin));
+      }
+    else
+      {
+      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, str));
+      OP1(SLJIT_MOV, TMP1, 0, SLJIT_MEM1(ARGUMENTS), SLJIT_OFFSETOF(jit_arguments, begin));
+      }
+    firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);
 
-  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(2));
-  OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, STR_PTR, 0, TMP1, 0);
-  OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER_EQUAL);
+    OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, IN_UCHARS(2));
+    OP2(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, SLJIT_UNUSED, 0, STR_PTR, 0, TMP1, 0);
+    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER_EQUAL);
 #if PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32
-  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);
+    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCHAR_SHIFT);
 #endif
-  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);
+    OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, TMP2, 0);
 
-  loop = LABEL();
-  OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
-  quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
-  OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));
-  OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));
-  CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, loop);
-  CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, loop);
+    loop = LABEL();
+    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
+    quit = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
+    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-2));
+    OP1(MOV_UCHAR, TMP2, 0, SLJIT_MEM1(STR_PTR), IN_UCHARS(-1));
+    CMPTO(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, (common->newline >> 8) & 0xff, loop);
+    CMPTO(SLJIT_NOT_EQUAL, TMP2, 0, SLJIT_IMM, common->newline & 0xff, loop);
+
+    JUMPHERE(quit);
+    JUMPHERE(lastchar);
+    }
 
-  JUMPHERE(quit);
   JUMPHERE(firstchar);
-  JUMPHERE(lastchar);
 
   if (common->match_end_ptr != 0)
     OP1(SLJIT_MOV, STR_END, 0, TMP3, 0);
@@ -6225,22 +6264,59 @@ else
 
 /* Example: match /^/ to \r\n from offset 1. */
 firstchar = CMP(SLJIT_LESS_EQUAL, STR_PTR, 0, TMP2, 0);
-move_back(common, NULL, FALSE);
+
+if (common->nltype == NLTYPE_ANY)
+  move_back(common, NULL, FALSE);
+else
+  OP2(SLJIT_SUB, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
 
 loop = LABEL();
 common->ff_newline_shortcut = loop;
 
-read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);
-lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
-if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)
-  foundcr = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);
-check_newlinechar(common, common->nltype, &newline, FALSE);
-set_jumps(newline, loop);
+#ifdef JIT_HAS_FAST_FORWARD_CHAR_SIMD
+if (JIT_HAS_FAST_FORWARD_CHAR_SIMD && (common->nltype == NLTYPE_FIXED || common->nltype == NLTYPE_ANYCRLF))
+  {
+  if (common->nltype == NLTYPE_ANYCRLF)
+    {
+    fast_forward_char_simd(common, CHAR_CR, CHAR_LF, 0);
+    if (common->mode != PCRE2_JIT_COMPLETE)
+      lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
+
+    OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);
+    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
+    quit = CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);
+    }
+   else
+    {
+    fast_forward_char_simd(common, common->newline, common->newline, 0);
+
+    OP2(SLJIT_ADD, STR_PTR, 0, STR_PTR, 0, SLJIT_IMM, IN_UCHARS(1));
+    if (common->mode != PCRE2_JIT_COMPLETE)
+      {
+      OP2(SLJIT_SUB | SLJIT_SET_GREATER, SLJIT_UNUSED, 0, STR_PTR, 0, STR_END, 0);
+      CMOV(SLJIT_GREATER, STR_PTR, STR_END, 0);
+      }
+    }
+  }
+else
+#endif /* JIT_HAS_FAST_FORWARD_CHAR_SIMD */
+  {
+  read_char(common, common->nlmin, common->nlmax, NULL, READ_CHAR_NEWLINE);
+  lastchar = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
+  if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)
+    foundcr = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);
+  check_newlinechar(common, common->nltype, &newline, FALSE);
+  set_jumps(newline, loop);
+  }
 
 if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)
   {
-  quit = JUMP(SLJIT_JUMP);
-  JUMPHERE(foundcr);
+  if (quit == NULL)
+    {
+    quit = JUMP(SLJIT_JUMP);
+    JUMPHERE(foundcr);
+    }
+
   notfoundnl = CMP(SLJIT_GREATER_EQUAL, STR_PTR, 0, STR_END, 0);
   OP1(MOV_UCHAR, TMP1, 0, SLJIT_MEM1(STR_PTR), 0);
   OP2(SLJIT_SUB | SLJIT_SET_Z, SLJIT_UNUSED, 0, TMP1, 0, SLJIT_IMM, CHAR_NL);
@@ -6252,7 +6328,9 @@ if (common->nltype == NLTYPE_ANY || common->nltype == NLTYPE_ANYCRLF)
   JUMPHERE(notfoundnl);
   JUMPHERE(quit);
   }
-JUMPHERE(lastchar);
+
+if (lastchar)
+  JUMPHERE(lastchar);
 JUMPHERE(firstchar);
 
 if (common->match_end_ptr != 0)
@@ -6493,9 +6571,11 @@ if (common->invalid_utf)
 
   if (common->mode != PCRE2_JIT_COMPLETE)
     {
+    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);
     OP1(SLJIT_MOV, TMP2, 0, STR_PTR, 0);
     move_back(common, NULL, TRUE);
     check_start_used_ptr(common);
+    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
     OP1(SLJIT_MOV, STR_PTR, 0, TMP2, 0);
     }
   }
@@ -7594,25 +7674,43 @@ if (needstype || needsscript)
       }
 
     cc = ccbegin;
-    }
 
-  if (needschar)
-    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
+    if (needstype)
+      {
+      /* TMP2 has already been shifted by 2 */
+      if (!needschar)
+        {
+        OP2(SLJIT_ADD, TMP1, 0, TMP2, 0, TMP2, 0);
+        OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);
 
-  if (needstype)
+        OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));
+        }
+      else
+        {
+        OP2(SLJIT_ADD, TMP1, 0, TMP2, 0, TMP2, 0);
+        OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);
+
+        OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
+        OP1(SLJIT_MOV_U8, RETURN_ADDR, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));
+        typereg = RETURN_ADDR;
+        }
+      }
+    else if (needschar)
+      OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
+    }
+  else if (needstype)
     {
+    OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);
+    OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);
+
     if (!needschar)
       {
-      OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);
-      OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);
       OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);
 
       OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));
       }
     else
       {
-      OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 2);
-      OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 3);
       OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);
 
       OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
@@ -7620,6 +7718,8 @@ if (needstype || needsscript)
       typereg = RETURN_ADDR;
       }
     }
+  else if (needschar)
+    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
   }
 #endif /* SUPPORT_UNICODE */
 
@@ -13581,7 +13681,7 @@ if (common->has_then)
   set_then_offsets(common, common->start, NULL);
   }
 
-compiler = sljit_create_compiler(allocator_data);
+compiler = sljit_create_compiler(allocator_data, NULL);
 if (!compiler)
   {
   SLJIT_FREE(common->optimized_cbracket, allocator_data);
@@ -13983,7 +14083,7 @@ else
     {
     /* This case is highly unlikely since we just recently
     freed a lot of memory. Not impossible though. */
-    sljit_free_code(executable_func);
+    sljit_free_code(executable_func, NULL);
     PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);
     return PCRE2_ERROR_NOMEMORY;
     }
@@ -14097,13 +14197,13 @@ if (executable_allocator_is_working == 0)
   /* Checks whether the executable allocator is working. This check
      might run multiple times in multi-threaded environments, but the
      result should not be affected by it. */
-  void *ptr = SLJIT_MALLOC_EXEC(32);
+  void *ptr = SLJIT_MALLOC_EXEC(32, NULL);
 
   executable_allocator_is_working = -1;
 
   if (ptr != NULL)
     {
-    SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr));
+    SLJIT_FREE_EXEC(((sljit_u8*)(ptr)) + SLJIT_EXEC_OFFSET(ptr), NULL);
     executable_allocator_is_working = 1;
     }
   }
diff --git a/src/3rdparty/pcre2/src/pcre2_jit_misc.c b/src/3rdparty/pcre2/src/pcre2_jit_misc.c
index 36abdbaf9c..ec924e0f9b 100644
--- a/src/3rdparty/pcre2/src/pcre2_jit_misc.c
+++ b/src/3rdparty/pcre2/src/pcre2_jit_misc.c
@@ -89,7 +89,7 @@ int i;
 for (i = 0; i < JIT_NUMBER_OF_COMPILE_MODES; i++)
   {
   if (functions->executable_funcs[i] != NULL)
-    sljit_free_code(functions->executable_funcs[i]);
+    sljit_free_code(functions->executable_funcs[i], NULL);
   PRIV(jit_free_rodata)(functions->read_only_data_heads[i], allocator_data);
   }
 
diff --git a/src/3rdparty/pcre2/src/pcre2_jit_neon_inc.h b/src/3rdparty/pcre2/src/pcre2_jit_neon_inc.h
index 66373b6cb0..150da29eba 100644
--- a/src/3rdparty/pcre2/src/pcre2_jit_neon_inc.h
+++ b/src/3rdparty/pcre2/src/pcre2_jit_neon_inc.h
@@ -87,6 +87,10 @@ static sljit_u8* SLJIT_FUNC FF_FUN(sljit_u8 *str_end, sljit_u8 *str_ptr, sljit_u
 {
 quad_word qw;
 int_char ic;
+
+SLJIT_UNUSED_ARG(offs1);
+SLJIT_UNUSED_ARG(offs2);
+
 ic.x = chars;
 
 #if defined(FFCS)
diff --git a/src/3rdparty/pcre2/src/pcre2_match.c b/src/3rdparty/pcre2/src/pcre2_match.c
index 11289d575d..e3f78c2ca3 100644
--- a/src/3rdparty/pcre2/src/pcre2_match.c
+++ b/src/3rdparty/pcre2/src/pcre2_match.c
@@ -6115,8 +6115,8 @@ BOOL has_req_cu = FALSE;
 BOOL startline;
 
 #if PCRE2_CODE_UNIT_WIDTH == 8
-BOOL memchr_not_found_first_cu = FALSE;
-BOOL memchr_not_found_first_cu2 = FALSE;
+BOOL memchr_not_found_first_cu;
+BOOL memchr_not_found_first_cu2;
 #endif
 
 PCRE2_UCHAR first_cu = 0;
@@ -6709,6 +6709,11 @@ FRAGMENT_RESTART:
 start_partial = match_partial = NULL;
 mb->hitend = FALSE;
 
+#if PCRE2_CODE_UNIT_WIDTH == 8
+memchr_not_found_first_cu = FALSE;
+memchr_not_found_first_cu2 = FALSE;
+#endif
+
 for(;;)
   {
   PCRE2_SPTR new_start_match;
@@ -7187,6 +7192,7 @@ if (utf && end_subject != true_end_subject &&
     starting code units in 8-bit and 16-bit modes. */
 
     start_match = end_subject + 1;
+
 #if PCRE2_CODE_UNIT_WIDTH != 32
     while (start_match < true_end_subject && NOT_FIRSTCU(*start_match))
       start_match++;
diff --git a/src/3rdparty/pcre2/src/sljit/sljitConfig.h b/src/3rdparty/pcre2/src/sljit/sljitConfig.h
index 4560450c1c..1c821d287d 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitConfig.h
+++ b/src/3rdparty/pcre2/src/sljit/sljitConfig.h
@@ -24,19 +24,19 @@
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef _SLJIT_CONFIG_H_
-#define _SLJIT_CONFIG_H_
+#ifndef SLJIT_CONFIG_H_
+#define SLJIT_CONFIG_H_
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-/* --------------------------------------------------------------------- */
-/*  Custom defines                                                       */
-/* --------------------------------------------------------------------- */
-
-/* Put your custom defines here. This empty section will never change
-   which helps maintaining patches (with diff / patch utilities). */
+/*
+  This file contains the basic configuration options for the SLJIT compiler
+  and their default values. These options can be overridden in the
+  sljitConfigPre.h header file when SLJIT_HAVE_CONFIG_PRE is set to a
+  non-zero value.
+*/
 
 /* --------------------------------------------------------------------- */
 /*  Architecture                                                         */
@@ -54,7 +54,7 @@ extern "C" {
 /* #define SLJIT_CONFIG_MIPS_32 1 */
 /* #define SLJIT_CONFIG_MIPS_64 1 */
 /* #define SLJIT_CONFIG_SPARC_32 1 */
-/* #define SLJIT_CONFIG_TILEGX 1 */
+/* #define SLJIT_CONFIG_S390X 1 */
 
 /* #define SLJIT_CONFIG_AUTO 1 */
 /* #define SLJIT_CONFIG_UNSUPPORTED 1 */
@@ -63,12 +63,6 @@ extern "C" {
 /*  Utilities                                                            */
 /* --------------------------------------------------------------------- */
 
-/* Useful for thread-safe compiling of global functions. */
-#ifndef SLJIT_UTIL_GLOBAL_LOCK
-/* Enabled by default */
-#define SLJIT_UTIL_GLOBAL_LOCK 1
-#endif
-
 /* Implements a stack like data structure (by using mmap / VirtualAlloc  */
 /* or a custom allocator). */
 #ifndef SLJIT_UTIL_STACK
@@ -108,15 +102,31 @@ extern "C" {
 
 /* When SLJIT_PROT_EXECUTABLE_ALLOCATOR is enabled SLJIT uses
    an allocator which does not set writable and executable
-   permission flags at the same time. The trade-of is increased
-   memory consumption and disabled dynamic code modifications. */
+   permission flags at the same time.
+   Instead, it creates a shared memory segment (usually backed by a file)
+   and maps it twice, with different permissions, depending on the use
+   case.
+   The trade-off is increased use of virtual memory, incompatibility with
+   fork(), and some possible additional security risks by the use of
+   publicly accessible files for the generated code. */
 #ifndef SLJIT_PROT_EXECUTABLE_ALLOCATOR
 /* Disabled by default. */
 #define SLJIT_PROT_EXECUTABLE_ALLOCATOR 0
 #endif
 
+/* When SLJIT_WX_EXECUTABLE_ALLOCATOR is enabled SLJIT uses an
+   allocator which does not set writable and executable permission
+   flags at the same time.
+   Instead, it creates a new independent map on each invocation and
+   switches permissions at the underlying pages as needed.
+   The trade-off is increased memory use and degraded performance. */
+#ifndef SLJIT_WX_EXECUTABLE_ALLOCATOR
+/* Disabled by default. */
+#define SLJIT_WX_EXECUTABLE_ALLOCATOR 0
 #endif
 
+#endif /* !SLJIT_EXECUTABLE_ALLOCATOR */
+
 /* Force cdecl calling convention even if a better calling
    convention (e.g. fastcall) is supported by the C compiler.
    If this option is disabled (this is the default), functions
@@ -159,4 +169,4 @@ extern "C" {
 } /* extern "C" */
 #endif
 
-#endif
+#endif /* SLJIT_CONFIG_H_ */
diff --git a/src/3rdparty/pcre2/src/sljit/sljitConfigInternal.h b/src/3rdparty/pcre2/src/sljit/sljitConfigInternal.h
index 049ed2fe91..eb1132db30 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitConfigInternal.h
+++ b/src/3rdparty/pcre2/src/sljit/sljitConfigInternal.h
@@ -24,8 +24,8 @@
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef _SLJIT_CONFIG_INTERNAL_H_
-#define _SLJIT_CONFIG_INTERNAL_H_
+#ifndef SLJIT_CONFIG_INTERNAL_H_
+#define SLJIT_CONFIG_INTERNAL_H_
 
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
 	|| (defined SLJIT_DEBUG && SLJIT_DEBUG && (!defined(SLJIT_ASSERT) || !defined(SLJIT_UNREACHABLE)))
@@ -81,30 +81,13 @@ extern "C" {
 
    Other macros:
      SLJIT_FUNC : calling convention attribute for both calling JIT from C and C calling back from JIT
-     SLJIT_W(number) : defining 64 bit constants on 64 bit architectures (compiler independent helper)
+     SLJIT_W(number) : defining 64 bit constants on 64 bit architectures (platform independent helper)
 */
 
 /*****************/
 /* Sanity check. */
 /*****************/
 
-#if !((defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32) \
-	|| (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64) \
-	|| (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5) \
-	|| (defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7) \
-	|| (defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2) \
-	|| (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
-	|| (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
-	|| (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
-	|| (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32) \
-	|| (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64) \
-	|| (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
-	|| (defined SLJIT_CONFIG_TILEGX && SLJIT_CONFIG_TILEGX) \
-	|| (defined SLJIT_CONFIG_AUTO && SLJIT_CONFIG_AUTO) \
-	|| (defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED))
-#error "An architecture must be selected"
-#endif
-
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32) \
 	+ (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64) \
 	+ (defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5) \
@@ -113,15 +96,36 @@ extern "C" {
 	+ (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
 	+ (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
 	+ (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
-	+ (defined SLJIT_CONFIG_TILEGX && SLJIT_CONFIG_TILEGX) \
 	+ (defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32) \
 	+ (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64) \
 	+ (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
+	+ (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X) \
 	+ (defined SLJIT_CONFIG_AUTO && SLJIT_CONFIG_AUTO) \
 	+ (defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED) >= 2
 #error "Multiple architectures are selected"
 #endif
 
+#if !(defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32) \
+	&& !(defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64) \
+	&& !(defined SLJIT_CONFIG_ARM_V5 && SLJIT_CONFIG_ARM_V5) \
+	&& !(defined SLJIT_CONFIG_ARM_V7 && SLJIT_CONFIG_ARM_V7) \
+	&& !(defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2) \
+	&& !(defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
+	&& !(defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
+	&& !(defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
+	&& !(defined SLJIT_CONFIG_MIPS_32 && SLJIT_CONFIG_MIPS_32) \
+	&& !(defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64) \
+	&& !(defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
+	&& !(defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X) \
+	&& !(defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED) \
+	&& !(defined SLJIT_CONFIG_AUTO && SLJIT_CONFIG_AUTO)
+#if defined SLJIT_CONFIG_AUTO && !SLJIT_CONFIG_AUTO
+#error "An architecture must be selected"
+#else /* SLJIT_CONFIG_AUTO */
+#define SLJIT_CONFIG_AUTO 1
+#endif /* !SLJIT_CONFIG_AUTO */
+#endif /* !SLJIT_CONFIG */
+
 /********************************************************/
 /* Automatic CPU detection (requires compiler support). */
 /********************************************************/
@@ -154,8 +158,6 @@ extern "C" {
 #define SLJIT_CONFIG_MIPS_64 1
 #elif defined(__sparc__) || defined(__sparc)
 #define SLJIT_CONFIG_SPARC_32 1
-#elif defined(__tilegx__)
-#define SLJIT_CONFIG_TILEGX 1
 #else
 /* Unsupported architecture */
 #define SLJIT_CONFIG_UNSUPPORTED 1
@@ -210,18 +212,16 @@ extern "C" {
 /***********************************************************/
 
 #ifdef SLJIT_CONFIG_X86
-#if defined(__CET__)
+
+#if defined(__CET__) && !(defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET)
 #define SLJIT_CONFIG_X86_CET 1
 #endif
-#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET)
-#if defined(__GNUC__)
-#if !defined (__SHSTK__)
-#error "-mshstk is needed to compile with -fcf-protection"
-#endif
+
+#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET) && defined(__GNUC__)
 #include <x86intrin.h>
 #endif
-#endif
-#endif
+
+#endif /* SLJIT_CONFIG_X86 */
 
 /**********************************/
 /* External function definitions. */
@@ -411,7 +411,7 @@ typedef long int sljit_sw;
 	&& !(defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
 	&& !(defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
 	&& !(defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64) \
-	&& !(defined SLJIT_CONFIG_TILEGX && SLJIT_CONFIG_TILEGX)
+	&& !(defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 #define SLJIT_32BIT_ARCHITECTURE 1
 #define SLJIT_WORD_SHIFT 2
 typedef unsigned int sljit_uw;
@@ -453,10 +453,14 @@ typedef double sljit_f64;
 #if (defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED)
 #define SLJIT_W(w)	(w##l)
 #elif (defined SLJIT_64BIT_ARCHITECTURE && SLJIT_64BIT_ARCHITECTURE)
+#ifdef _WIN64
 #define SLJIT_W(w)	(w##ll)
-#else
+#else /* !windows */
+#define SLJIT_W(w)	(w##l)
+#endif /* windows */
+#else /* 32 bit */
 #define SLJIT_W(w)	(w)
-#endif
+#endif /* unknown */
 
 #endif /* !SLJIT_W */
 
@@ -504,7 +508,8 @@ typedef double sljit_f64;
 
 #endif /* !SLJIT_MIPS_REV */
 
-#elif (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
+#elif (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
+	|| (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 
 #define SLJIT_BIG_ENDIAN 1
 
@@ -531,7 +536,8 @@ typedef double sljit_f64;
 	|| (defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2) \
 	|| (defined SLJIT_CONFIG_ARM_64 && SLJIT_CONFIG_ARM_64) \
 	|| (defined SLJIT_CONFIG_PPC_32 && SLJIT_CONFIG_PPC_32) \
-	|| (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64)
+	|| (defined SLJIT_CONFIG_PPC_64 && SLJIT_CONFIG_PPC_64) \
+	|| (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 #define SLJIT_UNALIGNED 1
 #endif
 
@@ -549,17 +555,19 @@ typedef double sljit_f64;
 
 #ifndef SLJIT_FUNC
 
-#if (defined SLJIT_USE_CDECL_CALLING_CONVENTION && SLJIT_USE_CDECL_CALLING_CONVENTION)
+#if (defined SLJIT_USE_CDECL_CALLING_CONVENTION && SLJIT_USE_CDECL_CALLING_CONVENTION) \
+	|| !(defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 
-/* Force cdecl. */
 #define SLJIT_FUNC
 
-#elif (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
-
-#if defined(__GNUC__) && !defined(__APPLE__)
+#elif defined(__GNUC__) && !defined(__APPLE__)
 
+#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
 #define SLJIT_FUNC __attribute__ ((fastcall))
 #define SLJIT_X86_32_FASTCALL 1
+#else
+#define SLJIT_FUNC
+#endif /* gcc >= 3.4 */
 
 #elif defined(_MSC_VER)
 
@@ -573,16 +581,10 @@ typedef double sljit_f64;
 
 #else /* Unknown compiler. */
 
-/* The cdecl attribute is the default. */
-#define SLJIT_FUNC
-
-#endif
-
-#else /* Non x86-32 architectures. */
-
+/* The cdecl calling convention is usually the x86 default. */
 #define SLJIT_FUNC
 
-#endif /* SLJIT_CONFIG_X86_32 */
+#endif /* SLJIT_USE_CDECL_CALLING_CONVENTION */
 
 #endif /* !SLJIT_FUNC */
 
@@ -613,8 +615,16 @@ determine the next executed instruction after return. */
 SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size);
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_exec(void* ptr);
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_unused_memory_exec(void);
-#define SLJIT_MALLOC_EXEC(size) sljit_malloc_exec(size)
-#define SLJIT_FREE_EXEC(ptr) sljit_free_exec(ptr)
+#define SLJIT_BUILTIN_MALLOC_EXEC(size, exec_allocator_data) sljit_malloc_exec(size)
+#define SLJIT_BUILTIN_FREE_EXEC(ptr, exec_allocator_data) sljit_free_exec(ptr)
+
+#ifndef SLJIT_MALLOC_EXEC
+#define SLJIT_MALLOC_EXEC(size, exec_allocator_data) SLJIT_BUILTIN_MALLOC_EXEC((size), (exec_allocator_data))
+#endif /* SLJIT_MALLOC_EXEC */
+
+#ifndef SLJIT_FREE_EXEC
+#define SLJIT_FREE_EXEC(ptr, exec_allocator_data) SLJIT_BUILTIN_FREE_EXEC((ptr), (exec_allocator_data))
+#endif /* SLJIT_FREE_EXEC */
 
 #if (defined SLJIT_PROT_EXECUTABLE_ALLOCATOR && SLJIT_PROT_EXECUTABLE_ALLOCATOR)
 SLJIT_API_FUNC_ATTRIBUTE sljit_sw sljit_exec_offset(void* ptr);
@@ -623,7 +633,7 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_sw sljit_exec_offset(void* ptr);
 #define SLJIT_EXEC_OFFSET(ptr) 0
 #endif
 
-#endif
+#endif /* SLJIT_EXECUTABLE_ALLOCATOR */
 
 /**********************************************/
 /* Registers and locals offset determination. */
@@ -699,11 +709,32 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_sw sljit_exec_offset(void* ptr);
 #define SLJIT_LOCALS_OFFSET_BASE ((16 + 1 + 6 + 2 + 1) * sizeof(sljit_sw))
 #endif
 
-#elif (defined SLJIT_CONFIG_TILEGX && SLJIT_CONFIG_TILEGX)
+#elif (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 
-#define SLJIT_NUMBER_OF_REGISTERS 10
-#define SLJIT_NUMBER_OF_SAVED_REGISTERS 5
-#define SLJIT_LOCALS_OFFSET_BASE 0
+/*
+ * https://refspecs.linuxbase.org/ELF/zSeries/lzsabi0_zSeries.html#STACKFRAME
+ *
+ * 160
+ *  .. FR6
+ *  .. FR4
+ *  .. FR2
+ * 128 FR0
+ * 120 R15 (used for SP)
+ * 112 R14
+ * 104 R13
+ *  96 R12
+ *  ..
+ *  48 R6
+ *  ..
+ *  16 R2
+ *   8 RESERVED
+ *   0 SP
+ */
+#define SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE 160
+
+#define SLJIT_NUMBER_OF_REGISTERS 12
+#define SLJIT_NUMBER_OF_SAVED_REGISTERS 8
+#define SLJIT_LOCALS_OFFSET_BASE SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE
 
 #elif (defined SLJIT_CONFIG_UNSUPPORTED && SLJIT_CONFIG_UNSUPPORTED)
 
@@ -791,4 +822,4 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_sw sljit_exec_offset(void* ptr);
 } /* extern "C" */
 #endif
 
-#endif
+#endif /* SLJIT_CONFIG_INTERNAL_H_ */
diff --git a/src/3rdparty/pcre2/src/sljit/sljitExecAllocator.c b/src/3rdparty/pcre2/src/sljit/sljitExecAllocator.c
index 76539072fe..61a32f23e9 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitExecAllocator.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitExecAllocator.c
@@ -72,9 +72,8 @@
    alloc_chunk / free_chunk :
      * allocate executable system memory chunks
      * the size is always divisible by CHUNK_SIZE
-   allocator_grab_lock / allocator_release_lock :
-     * make the allocator thread safe
-     * can be empty if the OS (or the application) does not support threading
+   SLJIT_ALLOCATOR_LOCK / SLJIT_ALLOCATOR_UNLOCK :
+     * provided as part of sljitUtils
      * only the allocator requires this lock, sljit is fully thread safe
        as it only uses local variables
 */
@@ -95,6 +94,7 @@ static SLJIT_INLINE void free_chunk(void *chunk, sljit_uw size)
 #else
 
 #ifdef __APPLE__
+#ifdef MAP_ANON
 /* Configures TARGET_OS_OSX when appropriate */
 #include <TargetConditionals.h>
 
@@ -104,17 +104,23 @@ static SLJIT_INLINE void free_chunk(void *chunk, sljit_uw size)
 
 #ifdef MAP_JIT
 
+/*
+   On macOS systems, returns MAP_JIT if it is defined _and_ we're running on a
+   version where it's OK to have more than one JIT block.
+   On non-macOS systems, returns MAP_JIT if it is defined.
+*/
 static SLJIT_INLINE int get_map_jit_flag()
 {
-/* On macOS systems, returns MAP_JIT if it is defined _and_ we're running on a version
-   of macOS where it's OK to have more than one JIT block.
-   On non-macOS systems, returns MAP_JIT if it is defined. */
 #if TARGET_OS_OSX
+	sljit_sw page_size = get_page_alignment() + 1;
+	void *ptr;
 	static int map_jit_flag = -1;
 
-	/* The following code is thread safe because multiple initialization
-	   sets map_jit_flag to the same value and the code has no side-effects.
-	   Changing the kernel version witout system restart is (very) unlikely. */
+	/*
+	  The following code is thread safe because multiple initialization
+	  sets map_jit_flag to the same value and the code has no side-effects.
+	  Changing the kernel version witout system restart is (very) unlikely.
+	*/
 	if (map_jit_flag == -1) {
 		struct utsname name;
 
@@ -123,15 +129,9 @@ static SLJIT_INLINE int get_map_jit_flag()
 
 		/* Kernel version for 10.14.0 (Mojave) */
 		if (atoi(name.release) >= 18) {
-			/* Only use MAP_JIT if a hardened runtime is used, because MAP_JIT is incompatible with fork(). */
+			/* Only use MAP_JIT if a hardened runtime is used */
 
-			/* mirroring page size detection from sljit_allocate_stack */
-			long page_size = sysconf(_SC_PAGESIZE);
-			/* Should never happen */
-			if (page_size < 0)
-				page_size = 4096;
-
-			void *ptr = mmap(NULL, page_size, PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);
+			ptr = mmap(NULL, page_size, PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);
 
 			if (ptr == MAP_FAILED) {
 				map_jit_flag = MAP_JIT;
@@ -148,7 +148,7 @@ static SLJIT_INLINE int get_map_jit_flag()
 }
 
 #endif /* MAP_JIT */
-
+#endif /* MAP_ANON */
 #endif /* __APPLE__ */
 
 static SLJIT_INLINE void* alloc_chunk(sljit_uw size)
@@ -166,10 +166,9 @@ static SLJIT_INLINE void* alloc_chunk(sljit_uw size)
 
 	retval = mmap(NULL, size, prot, flags, -1, 0);
 #else /* !MAP_ANON */
-	if (dev_zero < 0) {
-		if (open_dev_zero())
-			return NULL;
-	}
+	if (SLJIT_UNLIKELY((dev_zero < 0) && open_dev_zero()))
+		return NULL;
+
 	retval = mmap(NULL, size, prot, MAP_PRIVATE, dev_zero, 0);
 #endif /* MAP_ANON */
 
@@ -253,7 +252,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
 	struct free_block *free_block;
 	sljit_uw chunk_size;
 
-	allocator_grab_lock();
+	SLJIT_ALLOCATOR_LOCK();
 	if (size < (64 - sizeof(struct block_header)))
 		size = (64 - sizeof(struct block_header));
 	size = ALIGN_SIZE(size);
@@ -277,7 +276,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
 			}
 			allocated_size += size;
 			header->size = size;
-			allocator_release_lock();
+			SLJIT_ALLOCATOR_UNLOCK();
 			return MEM_START(header);
 		}
 		free_block = free_block->next;
@@ -286,7 +285,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
 	chunk_size = (size + sizeof(struct block_header) + CHUNK_SIZE - 1) & CHUNK_MASK;
 	header = (struct block_header*)alloc_chunk(chunk_size);
 	if (!header) {
-		allocator_release_lock();
+		SLJIT_ALLOCATOR_UNLOCK();
 		return NULL;
 	}
 
@@ -313,7 +312,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
 	}
 	next_header->size = 1;
 	next_header->prev_size = chunk_size;
-	allocator_release_lock();
+	SLJIT_ALLOCATOR_UNLOCK();
 	return MEM_START(header);
 }
 
@@ -322,7 +321,7 @@ SLJIT_API_FUNC_ATTRIBUTE void sljit_free_exec(void* ptr)
 	struct block_header *header;
 	struct free_block* free_block;
 
-	allocator_grab_lock();
+	SLJIT_ALLOCATOR_LOCK();
 	header = AS_BLOCK_HEADER(ptr, -(sljit_sw)sizeof(struct block_header));
 	allocated_size -= header->size;
 
@@ -359,7 +358,7 @@ SLJIT_API_FUNC_ATTRIBUTE void sljit_free_exec(void* ptr)
 		}
 	}
 
-	allocator_release_lock();
+	SLJIT_ALLOCATOR_UNLOCK();
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_unused_memory_exec(void)
@@ -367,7 +366,7 @@ SLJIT_API_FUNC_ATTRIBUTE void sljit_free_unused_memory_exec(void)
 	struct free_block* free_block;
 	struct free_block* next_free_block;
 
-	allocator_grab_lock();
+	SLJIT_ALLOCATOR_LOCK();
 
 	free_block = free_blocks;
 	while (free_block) {
@@ -382,5 +381,5 @@ SLJIT_API_FUNC_ATTRIBUTE void sljit_free_unused_memory_exec(void)
 	}
 
 	SLJIT_ASSERT((total_size && free_blocks) || (!total_size && !free_blocks));
-	allocator_release_lock();
+	SLJIT_ALLOCATOR_UNLOCK();
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitLir.c b/src/3rdparty/pcre2/src/sljit/sljitLir.c
index 86772cc1a5..d817c90b3a 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitLir.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitLir.c
@@ -28,7 +28,6 @@
 
 #ifdef _WIN32
 
-/* For SLJIT_CACHE_FLUSH, which can expand to FlushInstructionCache. */
 #include <windows.h>
 
 #endif /* _WIN32 */
@@ -223,14 +222,6 @@
 #	define FCSR_FCC		33
 #endif
 
-#if (defined SLJIT_CONFIG_TILEGX && SLJIT_CONFIG_TILEGX)
-#	define IS_JAL		0x04
-#	define IS_COND		0x08
-
-#	define PATCH_B		0x10
-#	define PATCH_J		0x20
-#endif
-
 #if (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32)
 #	define IS_MOVABLE	0x04
 #	define IS_COND		0x08
@@ -274,6 +265,8 @@
 
 #if (defined SLJIT_PROT_EXECUTABLE_ALLOCATOR && SLJIT_PROT_EXECUTABLE_ALLOCATOR)
 #include "sljitProtExecAllocator.c"
+#elif (defined SLJIT_WX_EXECUTABLE_ALLOCATOR && SLJIT_WX_EXECUTABLE_ALLOCATOR)
+#include "sljitWXExecAllocator.c"
 #else
 #include "sljitExecAllocator.c"
 #endif
@@ -286,6 +279,10 @@
 #define SLJIT_ADD_EXEC_OFFSET(ptr, exec_offset) ((sljit_u8 *)(ptr))
 #endif
 
+#ifndef SLJIT_UPDATE_WX_FLAGS
+#define SLJIT_UPDATE_WX_FLAGS(from, to, enable_exec)
+#endif
+
 /* Argument checking features. */
 
 #if (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
@@ -366,7 +363,7 @@ static sljit_s32 compiler_initialized = 0;
 static void init_compiler(void);
 #endif
 
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allocator_data)
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allocator_data, void *exec_allocator_data)
 {
 	struct sljit_compiler *compiler = (struct sljit_compiler*)SLJIT_MALLOC(sizeof(struct sljit_compiler), allocator_data);
 	if (!compiler)
@@ -393,6 +390,7 @@ SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allo
 	compiler->error = SLJIT_SUCCESS;
 
 	compiler->allocator_data = allocator_data;
+	compiler->exec_allocator_data = exec_allocator_data;
 	compiler->buf = (struct sljit_memory_fragment*)SLJIT_MALLOC(BUF_SIZE, allocator_data);
 	compiler->abuf = (struct sljit_memory_fragment*)SLJIT_MALLOC(ABUF_SIZE, allocator_data);
 
@@ -485,22 +483,28 @@ SLJIT_API_FUNC_ATTRIBUTE void sljit_set_compiler_memory_error(struct sljit_compi
 }
 
 #if (defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2)
-SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code)
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code, void *exec_allocator_data)
 {
+	SLJIT_UNUSED_ARG(exec_allocator_data);
+
 	/* Remove thumb mode flag. */
-	SLJIT_FREE_EXEC((void*)((sljit_uw)code & ~0x1));
+	SLJIT_FREE_EXEC((void*)((sljit_uw)code & ~0x1), exec_allocator_data);
 }
 #elif (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
-SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code)
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code, void *exec_allocator_data)
 {
+	SLJIT_UNUSED_ARG(exec_allocator_data);
+
 	/* Resolve indirection. */
 	code = (void*)(*(sljit_uw*)code);
-	SLJIT_FREE_EXEC(code);
+	SLJIT_FREE_EXEC(code, exec_allocator_data);
 }
 #else
-SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code)
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code, void *exec_allocator_data)
 {
-	SLJIT_FREE_EXEC(code);
+	SLJIT_UNUSED_ARG(exec_allocator_data);
+
+	SLJIT_FREE_EXEC(code, exec_allocator_data);
 }
 #endif
 
@@ -627,7 +631,10 @@ static SLJIT_INLINE sljit_s32 get_arg_count(sljit_s32 arg_types)
 	return arg_count;
 }
 
-#if !(defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86)
+
+/* Only used in RISC architectures where the instruction size is constant */
+#if !(defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) \
+	&& !(defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
 
 static SLJIT_INLINE sljit_uw compute_next_addr(struct sljit_label *label, struct sljit_jump *jump,
 	struct sljit_const *const_, struct sljit_put_label *put_label)
@@ -649,7 +656,7 @@ static SLJIT_INLINE sljit_uw compute_next_addr(struct sljit_label *label, struct
 	return result;
 }
 
-#endif /* !SLJIT_CONFIG_X86 */
+#endif /* !SLJIT_CONFIG_X86 && !SLJIT_CONFIG_S390X */
 
 static SLJIT_INLINE void set_emit_enter(struct sljit_compiler *compiler,
 	sljit_s32 options, sljit_s32 args, sljit_s32 scratches, sljit_s32 saveds,
@@ -1378,6 +1385,8 @@ static SLJIT_INLINE CHECK_RETURN_TYPE check_sljit_emit_op_custom(struct sljit_co
 #elif (defined SLJIT_CONFIG_ARM_THUMB2 && SLJIT_CONFIG_ARM_THUMB2)
 	CHECK_ARGUMENT((size == 2 && (((sljit_sw)instruction) & 0x1) == 0)
 		|| (size == 4 && (((sljit_sw)instruction) & 0x3) == 0));
+#elif (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
+	CHECK_ARGUMENT(size == 2 || size == 4 || size == 6);
 #else
 	CHECK_ARGUMENT(size == 4 && (((sljit_sw)instruction) & 0x3) == 0);
 #endif
@@ -2034,7 +2043,7 @@ static SLJIT_INLINE sljit_s32 emit_mov_before_return(struct sljit_compiler *comp
 #if (defined SLJIT_CONFIG_X86 && SLJIT_CONFIG_X86) \
 		|| (defined SLJIT_CONFIG_PPC && SLJIT_CONFIG_PPC) \
 		|| (defined SLJIT_CONFIG_SPARC_32 && SLJIT_CONFIG_SPARC_32) \
-		|| ((defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) && !(defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1))
+		|| ((defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS) && !(defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6))
 
 static SLJIT_INLINE sljit_s32 sljit_emit_cmov_generic(struct sljit_compiler *compiler, sljit_s32 type,
 	sljit_s32 dst_reg,
@@ -2111,8 +2120,8 @@ static SLJIT_INLINE sljit_s32 sljit_emit_cmov_generic(struct sljit_compiler *com
 #	include "sljitNativeMIPS_common.c"
 #elif (defined SLJIT_CONFIG_SPARC && SLJIT_CONFIG_SPARC)
 #	include "sljitNativeSPARC_common.c"
-#elif (defined SLJIT_CONFIG_TILEGX && SLJIT_CONFIG_TILEGX)
-#	include "sljitNativeTILEGX_64.c"
+#elif (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
+#	include "sljitNativeS390X.c"
 #endif
 
 #if !(defined SLJIT_CONFIG_MIPS && SLJIT_CONFIG_MIPS)
@@ -2143,7 +2152,7 @@ SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_cmp(struct sljit_compiler
 #endif
 
 	if (SLJIT_UNLIKELY((src1 & SLJIT_IMM) && !(src2 & SLJIT_IMM))) {
-		/* Immediate is prefered as second argument by most architectures. */
+		/* Immediate is preferred as second argument by most architectures. */
 		switch (condition) {
 		case SLJIT_LESS:
 			condition = SLJIT_GREATER;
@@ -2292,9 +2301,10 @@ SLJIT_API_FUNC_ATTRIBUTE const char* sljit_get_platform_name(void)
 	return "unsupported";
 }
 
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allocator_data)
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allocator_data, void *exec_allocator_data)
 {
 	SLJIT_UNUSED_ARG(allocator_data);
+	SLJIT_UNUSED_ARG(exec_allocator_data);
 	SLJIT_UNREACHABLE();
 	return NULL;
 }
@@ -2342,9 +2352,10 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
 	return 0;
 }
 
-SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code)
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code, void *exec_allocator_data)
 {
 	SLJIT_UNUSED_ARG(code);
+	SLJIT_UNUSED_ARG(exec_allocator_data);
 	SLJIT_UNREACHABLE();
 }
 
diff --git a/src/3rdparty/pcre2/src/sljit/sljitLir.h b/src/3rdparty/pcre2/src/sljit/sljitLir.h
index 72595bb271..93d2804675 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitLir.h
+++ b/src/3rdparty/pcre2/src/sljit/sljitLir.h
@@ -24,8 +24,8 @@
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef _SLJIT_LIR_H_
-#define _SLJIT_LIR_H_
+#ifndef SLJIT_LIR_H_
+#define SLJIT_LIR_H_
 
 /*
    ------------------------------------------------------------------------
@@ -70,9 +70,11 @@
       - pass --smc-check=all argument to valgrind, since JIT is a "self-modifying code"
 */
 
-#if !(defined SLJIT_NO_DEFAULT_CONFIG && SLJIT_NO_DEFAULT_CONFIG)
+#if (defined SLJIT_HAVE_CONFIG_PRE && SLJIT_HAVE_CONFIG_PRE)
+#include "sljitConfigPre.h"
+#endif /* SLJIT_HAVE_CONFIG_PRE */
+
 #include "sljitConfig.h"
-#endif
 
 /* The following header file defines useful macros for fine tuning
 sljit based code generators. They are listed in the beginning
@@ -80,6 +82,10 @@ of sljitConfigInternal.h */
 
 #include "sljitConfigInternal.h"
 
+#if (defined SLJIT_HAVE_CONFIG_POST && SLJIT_HAVE_CONFIG_POST)
+#include "sljitConfigPost.h"
+#endif /* SLJIT_HAVE_CONFIG_POST */
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -385,6 +391,7 @@ struct sljit_compiler {
 	struct sljit_put_label *last_put_label;
 
 	void *allocator_data;
+	void *exec_allocator_data;
 	struct sljit_memory_fragment *buf;
 	struct sljit_memory_fragment *abuf;
 
@@ -451,9 +458,9 @@ struct sljit_compiler {
 	sljit_sw cache_argw;
 #endif
 
-#if (defined SLJIT_CONFIG_TILEGX && SLJIT_CONFIG_TILEGX)
-	sljit_s32 cache_arg;
-	sljit_sw cache_argw;
+#if (defined SLJIT_CONFIG_S390X && SLJIT_CONFIG_S390X)
+	/* Need to allocate register save area to make calls. */
+	sljit_s32 have_save_area;
 #endif
 
 #if (defined SLJIT_VERBOSE && SLJIT_VERBOSE)
@@ -485,10 +492,12 @@ struct sljit_compiler {
    custom memory managers. This pointer is passed to SLJIT_MALLOC
    and SLJIT_FREE macros. Most allocators (including the default
    one) ignores this value, and it is recommended to pass NULL
-   as a dummy value for allocator_data.
+   as a dummy value for allocator_data. The exec_allocator_data
+   has the same purpose but this one is passed to SLJIT_MALLOC_EXEC /
+   SLJIT_MALLOC_FREE functions.
 
    Returns NULL if failed. */
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allocator_data);
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_compiler* sljit_create_compiler(void *allocator_data, void *exec_allocator_data);
 
 /* Frees everything except the compiled machine code. */
 SLJIT_API_FUNC_ATTRIBUTE void sljit_free_compiler(struct sljit_compiler *compiler);
@@ -535,7 +544,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 
 /* Free executable code. */
 
-SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code);
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_code(void* code, void *exec_allocator_data);
 
 /*
    When the protected executable allocator is used the JIT code is mapped
@@ -699,7 +708,7 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *
 */
 
 /*
-   IMPORATNT NOTE: memory access MUST be naturally aligned except
+   IMPORTANT NOTE: memory access MUST be naturally aligned unless
                    SLJIT_UNALIGNED macro is defined and its value is 1.
 
      length | alignment
@@ -741,6 +750,9 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *
    mips:   [reg+imm], -65536 <= imm <= 65535
    sparc:  [reg+imm], -4096 <= imm <= 4095
            [reg+reg] is supported
+   s390x:  [reg+imm], -2^19 <= imm < 2^19
+           [reg+reg] is supported
+           Write-back is not supported
 */
 
 /* Macros for specifying operand types. */
@@ -1405,12 +1417,6 @@ SLJIT_API_FUNC_ATTRIBUTE const char* sljit_get_platform_name(void);
 /* Portable helper function to get an offset of a member. */
 #define SLJIT_OFFSETOF(base, member) ((sljit_sw)(&((base*)0x10)->member) - 0x10)
 
-#if (defined SLJIT_UTIL_GLOBAL_LOCK && SLJIT_UTIL_GLOBAL_LOCK)
-/* This global lock is useful to compile common functions. */
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_grab_lock(void);
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_release_lock(void);
-#endif
-
 #if (defined SLJIT_UTIL_STACK && SLJIT_UTIL_STACK)
 
 /* The sljit_stack structure and its manipulation functions provides
@@ -1538,4 +1544,4 @@ SLJIT_API_FUNC_ATTRIBUTE void sljit_set_current_flags(struct sljit_compiler *com
 } /* extern "C" */
 #endif
 
-#endif /* _SLJIT_LIR_H_ */
+#endif /* SLJIT_LIR_H_ */
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeARM_32.c b/src/3rdparty/pcre2/src/sljit/sljitNativeARM_32.c
index 5d180c2e2f..ae8479f031 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeARM_32.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeARM_32.c
@@ -467,18 +467,28 @@ static SLJIT_INLINE void inline_set_jump_addr(sljit_uw jump_ptr, sljit_sw execut
 	sljit_s32 bl = (mov_pc & 0x0000f000) != RD(TMP_PC);
 	sljit_sw diff = (sljit_sw)(((sljit_sw)new_addr - (sljit_sw)(inst + 2) - executable_offset) >> 2);
 
+	SLJIT_UNUSED_ARG(executable_offset);
+
 	if (diff <= 0x7fffff && diff >= -0x800000) {
 		/* Turn to branch. */
 		if (!bl) {
+			if (flush_cache) {
+				SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 0);
+			}
 			inst[0] = (mov_pc & COND_MASK) | (B - CONDITIONAL) | (diff & 0xffffff);
 			if (flush_cache) {
+				SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 1);
 				inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 				SLJIT_CACHE_FLUSH(inst, inst + 1);
 			}
 		} else {
+			if (flush_cache) {
+				SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 0);
+			}
 			inst[0] = (mov_pc & COND_MASK) | (BL - CONDITIONAL) | (diff & 0xffffff);
 			inst[1] = NOP;
 			if (flush_cache) {
+				SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 				inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 				SLJIT_CACHE_FLUSH(inst, inst + 2);
 			}
@@ -491,28 +501,52 @@ static SLJIT_INLINE void inline_set_jump_addr(sljit_uw jump_ptr, sljit_sw execut
 			ptr = inst + 1;
 
 		if (*inst != mov_pc) {
+			if (flush_cache) {
+				SLJIT_UPDATE_WX_FLAGS(inst, inst + (!bl ? 1 : 2), 0);
+			}
 			inst[0] = mov_pc;
 			if (!bl) {
 				if (flush_cache) {
+					SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 1);
 					inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 					SLJIT_CACHE_FLUSH(inst, inst + 1);
 				}
 			} else {
 				inst[1] = BLX | RM(TMP_REG1);
 				if (flush_cache) {
+					SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 					inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 					SLJIT_CACHE_FLUSH(inst, inst + 2);
 				}
 			}
 		}
+
+		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(ptr, ptr + 1, 0);
+		}
+
 		*ptr = new_addr;
+
+		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(ptr, ptr + 1, 1);
+		}
 	}
 #else
 	sljit_uw *inst = (sljit_uw*)jump_ptr;
+
+	SLJIT_UNUSED_ARG(executable_offset);
+
 	SLJIT_ASSERT((inst[0] & 0xfff00000) == MOVW && (inst[1] & 0xfff00000) == MOVT);
+
+	if (flush_cache) {
+		SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 0);
+	}
+
 	inst[0] = MOVW | (inst[0] & 0xf000) | ((new_addr << 4) & 0xf0000) | (new_addr & 0xfff);
 	inst[1] = MOVT | (inst[1] & 0xf000) | ((new_addr >> 12) & 0xf0000) | ((new_addr >> 16) & 0xfff);
+
 	if (flush_cache) {
+		SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 		inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 		SLJIT_CACHE_FLUSH(inst, inst + 2);
 	}
@@ -529,10 +563,18 @@ static SLJIT_INLINE void inline_set_const(sljit_uw addr, sljit_sw executable_off
 	sljit_uw ldr_literal = ptr[1];
 	sljit_uw src2;
 
+	SLJIT_UNUSED_ARG(executable_offset);
+
 	src2 = get_imm(new_constant);
 	if (src2) {
+		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 0);
+		}
+
 		*inst = 0xe3a00000 | (ldr_literal & 0xf000) | src2;
+
 		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 1);
 			inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 			SLJIT_CACHE_FLUSH(inst, inst + 1);
 		}
@@ -541,8 +583,14 @@ static SLJIT_INLINE void inline_set_const(sljit_uw addr, sljit_sw executable_off
 
 	src2 = get_imm(~new_constant);
 	if (src2) {
+		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 0);
+		}
+
 		*inst = 0xe3e00000 | (ldr_literal & 0xf000) | src2;
+
 		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 1);
 			inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 			SLJIT_CACHE_FLUSH(inst, inst + 1);
 		}
@@ -555,19 +603,44 @@ static SLJIT_INLINE void inline_set_const(sljit_uw addr, sljit_sw executable_off
 		ptr = inst + 1;
 
 	if (*inst != ldr_literal) {
+		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 0);
+		}
+
 		*inst = ldr_literal;
+
 		if (flush_cache) {
+			SLJIT_UPDATE_WX_FLAGS(inst, inst + 1, 1);
 			inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 			SLJIT_CACHE_FLUSH(inst, inst + 1);
 		}
 	}
+
+	if (flush_cache) {
+		SLJIT_UPDATE_WX_FLAGS(ptr, ptr + 1, 0);
+	}
+
 	*ptr = new_constant;
+
+	if (flush_cache) {
+		SLJIT_UPDATE_WX_FLAGS(ptr, ptr + 1, 1);
+	}
 #else
 	sljit_uw *inst = (sljit_uw*)addr;
+
+	SLJIT_UNUSED_ARG(executable_offset);
+
 	SLJIT_ASSERT((inst[0] & 0xfff00000) == MOVW && (inst[1] & 0xfff00000) == MOVT);
+
+	if (flush_cache) {
+		SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 0);
+	}
+
 	inst[0] = MOVW | (inst[0] & 0xf000) | ((new_constant << 4) & 0xf0000) | (new_constant & 0xfff);
 	inst[1] = MOVT | (inst[1] & 0xf000) | ((new_constant >> 12) & 0xf0000) | ((new_constant >> 16) & 0xfff);
+
 	if (flush_cache) {
+		SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 		inst = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 		SLJIT_CACHE_FLUSH(inst, inst + 2);
 	}
@@ -612,7 +685,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 #else
 	size = compiler->size;
 #endif
-	code = (sljit_uw*)SLJIT_MALLOC_EXEC(size * sizeof(sljit_uw));
+	code = (sljit_uw*)SLJIT_MALLOC_EXEC(size * sizeof(sljit_uw), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
@@ -653,7 +726,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 				}
 				else {
 					if (SLJIT_UNLIKELY(resolve_const_pool_index(compiler, &first_patch, cpool_current_index, cpool_start_address, buf_ptr))) {
-						SLJIT_FREE_EXEC(code);
+						SLJIT_FREE_EXEC(code, compiler->exec_allocator_data);
 						compiler->error = SLJIT_ERR_ALLOC_FAILED;
 						return NULL;
 					}
@@ -756,7 +829,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 		cpool_current_index = 0;
 		while (buf_ptr < buf_end) {
 			if (SLJIT_UNLIKELY(resolve_const_pool_index(compiler, &first_patch, cpool_current_index, cpool_start_address, buf_ptr))) {
-				SLJIT_FREE_EXEC(code);
+				SLJIT_FREE_EXEC(code, compiler->exec_allocator_data);
 				compiler->error = SLJIT_ERR_ALLOC_FAILED;
 				return NULL;
 			}
@@ -856,6 +929,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	code_ptr = (sljit_uw *)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 
 	SLJIT_CACHE_FLUSH(code, code_ptr);
+	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
 	return code;
 }
 
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeARM_64.c b/src/3rdparty/pcre2/src/sljit/sljitNativeARM_64.c
index eaca095a2b..52267e7df7 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeARM_64.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeARM_64.c
@@ -151,16 +151,6 @@ static SLJIT_INLINE sljit_s32 emit_imm64_const(struct sljit_compiler *compiler,
 	return push_inst(compiler, MOVK | RD(dst) | ((imm >> 48) << 5) | (3 << 21));
 }
 
-static SLJIT_INLINE void modify_imm64_const(sljit_ins* inst, sljit_uw new_imm)
-{
-	sljit_s32 dst = inst[0] & 0x1f;
-	SLJIT_ASSERT((inst[0] & 0xffe00000) == MOVZ && (inst[1] & 0xffe00000) == (MOVK | (1 << 21)));
-	inst[0] = MOVZ | dst | ((new_imm & 0xffff) << 5);
-	inst[1] = MOVK | dst | (((new_imm >> 16) & 0xffff) << 5) | (1 << 21);
-	inst[2] = MOVK | dst | (((new_imm >> 32) & 0xffff) << 5) | (2 << 21);
-	inst[3] = MOVK | dst | ((new_imm >> 48) << 5) | (3 << 21);
-}
-
 static SLJIT_INLINE sljit_sw detect_jump_type(struct sljit_jump *jump, sljit_ins *code_ptr, sljit_ins *code, sljit_sw executable_offset)
 {
 	sljit_sw diff;
@@ -253,7 +243,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	CHECK_PTR(check_sljit_generate_code(compiler));
 	reverse_buf(compiler);
 
-	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins));
+	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
@@ -380,6 +370,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	code_ptr = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 
 	SLJIT_CACHE_FLUSH(code, code_ptr);
+	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
 	return code;
 }
 
@@ -2034,15 +2025,24 @@ SLJIT_API_FUNC_ATTRIBUTE struct sljit_put_label* sljit_emit_put_label(struct slj
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_ins* inst = (sljit_ins*)addr;
-	modify_imm64_const(inst, new_target);
+	sljit_s32 dst;
+	SLJIT_UNUSED_ARG(executable_offset);
+
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 4, 0);
+
+	dst = inst[0] & 0x1f;
+	SLJIT_ASSERT((inst[0] & 0xffe00000) == MOVZ && (inst[1] & 0xffe00000) == (MOVK | (1 << 21)));
+	inst[0] = MOVZ | dst | ((new_target & 0xffff) << 5);
+	inst[1] = MOVK | dst | (((new_target >> 16) & 0xffff) << 5) | (1 << 21);
+	inst[2] = MOVK | dst | (((new_target >> 32) & 0xffff) << 5) | (2 << 21);
+	inst[3] = MOVK | dst | ((new_target >> 48) << 5) | (3 << 21);
+
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 4, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 4);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
-	sljit_ins* inst = (sljit_ins*)addr;
-	modify_imm64_const(inst, new_constant);
-	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 4);
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeARM_T2_32.c b/src/3rdparty/pcre2/src/sljit/sljitNativeARM_T2_32.c
index a81e008a8b..4624882f42 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeARM_T2_32.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeARM_T2_32.c
@@ -377,7 +377,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	CHECK_PTR(check_sljit_generate_code(compiler));
 	reverse_buf(compiler);
 
-	code = (sljit_u16*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_u16));
+	code = (sljit_u16*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_u16), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
@@ -463,6 +463,8 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	code_ptr = (sljit_u16 *)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 
 	SLJIT_CACHE_FLUSH(code, code_ptr);
+	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
+
 	/* Set thumb mode flag. */
 	return (void*)((sljit_uw)code | 0x1);
 }
@@ -608,7 +610,7 @@ static sljit_s32 emit_op_imm(struct sljit_compiler *compiler, sljit_s32 flags, s
 			   Although some clever things could be done here, "NOT IMM" does not worth the efforts. */
 			break;
 		case SLJIT_ADD:
-			nimm = -imm;
+			nimm = -(sljit_sw)imm;
 			if (IS_2_LO_REGS(reg, dst)) {
 				if (imm <= 0x7)
 					return push_inst16(compiler, ADDSI3 | IMM3(imm) | RD3(dst) | RN3(reg));
@@ -630,7 +632,7 @@ static sljit_s32 emit_op_imm(struct sljit_compiler *compiler, sljit_s32 flags, s
 			nimm = get_imm(imm);
 			if (nimm != INVALID_IMM)
 				return push_inst32(compiler, ADD_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
-			nimm = get_imm(-imm);
+			nimm = get_imm(-(sljit_sw)imm);
 			if (nimm != INVALID_IMM)
 				return push_inst32(compiler, SUB_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
 			break;
@@ -655,11 +657,11 @@ static sljit_s32 emit_op_imm(struct sljit_compiler *compiler, sljit_s32 flags, s
 				nimm = get_imm(imm);
 				if (nimm != INVALID_IMM)
 					return push_inst32(compiler, CMPI_W | RN4(reg) | nimm);
-				nimm = get_imm(-imm);
+				nimm = get_imm(-(sljit_sw)imm);
 				if (nimm != INVALID_IMM)
 					return push_inst32(compiler, CMNI_W | RN4(reg) | nimm);
 			}
-			nimm = -imm;
+			nimm = -(sljit_sw)imm;
 			if (IS_2_LO_REGS(reg, dst)) {
 				if (imm <= 0x7)
 					return push_inst16(compiler, SUBSI3 | IMM3(imm) | RD3(dst) | RN3(reg));
@@ -681,7 +683,7 @@ static sljit_s32 emit_op_imm(struct sljit_compiler *compiler, sljit_s32 flags, s
 			nimm = get_imm(imm);
 			if (nimm != INVALID_IMM)
 				return push_inst32(compiler, SUB_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
-			nimm = get_imm(-imm);
+			nimm = get_imm(-(sljit_sw)imm);
 			if (nimm != INVALID_IMM)
 				return push_inst32(compiler, ADD_WI | (flags & SET_FLAGS) | RD4(dst) | RN4(reg) | nimm);
 			break;
@@ -2366,15 +2368,16 @@ SLJIT_API_FUNC_ATTRIBUTE struct sljit_put_label* sljit_emit_put_label(struct slj
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_u16 *inst = (sljit_u16*)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
+
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 4, 0);
 	modify_imm32_const(inst, new_target);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 4, 1);
 	inst = (sljit_u16 *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 4);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
-	sljit_u16 *inst = (sljit_u16*)addr;
-	modify_imm32_const(inst, new_constant);
-	inst = (sljit_u16 *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 4);
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_32.c b/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_32.c
index 777627bb7f..f887ee1311 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_32.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_32.c
@@ -425,23 +425,20 @@ static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_ins *inst = (sljit_ins *)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
 
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 0);
 	SLJIT_ASSERT((inst[0] & 0xffe00000) == LUI && (inst[1] & 0xfc000000) == ORI);
 	inst[0] = (inst[0] & 0xffff0000) | ((new_target >> 16) & 0xffff);
 	inst[1] = (inst[1] & 0xffff0000) | (new_target & 0xffff);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 2);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
-	sljit_ins *inst = (sljit_ins *)addr;
-
-	SLJIT_ASSERT((inst[0] & 0xffe00000) == LUI && (inst[1] & 0xfc000000) == ORI);
-	inst[0] = (inst[0] & 0xffff0000) | ((new_constant >> 16) & 0xffff);
-	inst[1] = (inst[1] & 0xffff0000) | (new_constant & 0xffff);
-	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 2);
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
 }
 
 static sljit_s32 call_with_args(struct sljit_compiler *compiler, sljit_s32 arg_types, sljit_ins *ins_ptr)
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_64.c b/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_64.c
index 479244d707..5ab9b7d06b 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_64.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_64.c
@@ -525,25 +525,21 @@ static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_ins *inst = (sljit_ins *)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
 
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 6, 0);
 	inst[0] = (inst[0] & 0xffff0000) | ((new_target >> 48) & 0xffff);
 	inst[1] = (inst[1] & 0xffff0000) | ((new_target >> 32) & 0xffff);
 	inst[3] = (inst[3] & 0xffff0000) | ((new_target >> 16) & 0xffff);
 	inst[5] = (inst[5] & 0xffff0000) | (new_target & 0xffff);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 6, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 6);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
-	sljit_ins *inst = (sljit_ins *)addr;
-
-	inst[0] = (inst[0] & 0xffff0000) | ((new_constant >> 48) & 0xffff);
-	inst[1] = (inst[1] & 0xffff0000) | ((new_constant >> 32) & 0xffff);
-	inst[3] = (inst[3] & 0xffff0000) | ((new_constant >> 16) & 0xffff);
-	inst[5] = (inst[5] & 0xffff0000) | (new_constant & 0xffff);
-	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 6);
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
 }
 
 static sljit_s32 call_with_args(struct sljit_compiler *compiler, sljit_s32 arg_types, sljit_ins *ins_ptr)
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_common.c b/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_common.c
index 88df904e24..ecf4dac4c8 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_common.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeMIPS_common.c
@@ -290,9 +290,9 @@ static const sljit_u8 freg_map[SLJIT_NUMBER_OF_FLOAT_REGISTERS + 4] = {
    Useful for reordering instructions in the delay slot. */
 static sljit_s32 push_inst(struct sljit_compiler *compiler, sljit_ins ins, sljit_s32 delay_slot)
 {
+	sljit_ins *ptr = (sljit_ins*)ensure_buf(compiler, sizeof(sljit_ins));
 	SLJIT_ASSERT(delay_slot == MOVABLE_INS || delay_slot >= UNMOVABLE_INS
 		|| delay_slot == ((ins >> 11) & 0x1f) || delay_slot == ((ins >> 16) & 0x1f));
-	sljit_ins *ptr = (sljit_ins*)ensure_buf(compiler, sizeof(sljit_ins));
 	FAIL_IF(!ptr);
 	*ptr = ins;
 	compiler->size++;
@@ -520,7 +520,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	CHECK_PTR(check_sljit_generate_code(compiler));
 	reverse_buf(compiler);
 
-	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins));
+	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
@@ -667,6 +667,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	/* GCC workaround for invalid code generation with -O2. */
 	sljit_cache_flush(code, code_ptr);
 #endif
+	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
 	return code;
 }
 
@@ -679,7 +680,7 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
 #ifdef SLJIT_IS_FPU_AVAILABLE
 		return SLJIT_IS_FPU_AVAILABLE;
 #elif defined(__GNUC__)
-		asm ("cfc1 %0, $0" : "=r"(fir));
+		__asm__ ("cfc1 %0, $0" : "=r"(fir));
 		return (fir >> 22) & 0x1;
 #else
 #error "FIR check is not implemented for this architecture"
@@ -2185,14 +2186,14 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compil
 	sljit_s32 dst_reg,
 	sljit_s32 src, sljit_sw srcw)
 {
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1)
+#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6)
 	sljit_ins ins;
-#endif /* SLJIT_MIPS_REV >= 1 */
+#endif /* SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6 */
 
 	CHECK_ERROR();
 	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
 
-#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1)
+#if (defined SLJIT_MIPS_REV && SLJIT_MIPS_REV >= 1 && SLJIT_MIPS_REV < 6)
 
 	if (SLJIT_UNLIKELY(src & SLJIT_IMM)) {
 #if (defined SLJIT_CONFIG_MIPS_64 && SLJIT_CONFIG_MIPS_64)
@@ -2249,7 +2250,7 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compil
 
 	return push_inst(compiler, ins | S(src) | D(dst_reg), DR(dst_reg));
 
-#else /* SLJIT_MIPS_REV < 1 */
+#else /* SLJIT_MIPS_REV < 1 || SLJIT_MIPS_REV >= 6 */
 	return sljit_emit_cmov_generic(compiler, type, dst_reg, src, srcw);
 #endif /* SLJIT_MIPS_REV >= 1 */
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativePPC_32.c b/src/3rdparty/pcre2/src/sljit/sljitNativePPC_32.c
index 3ce741153f..7d9ec5338f 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativePPC_32.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativePPC_32.c
@@ -258,21 +258,18 @@ static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_ins *inst = (sljit_ins *)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
 
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 0);
 	SLJIT_ASSERT((inst[0] & 0xfc1f0000) == ADDIS && (inst[1] & 0xfc000000) == ORI);
 	inst[0] = (inst[0] & 0xffff0000) | ((new_target >> 16) & 0xffff);
 	inst[1] = (inst[1] & 0xffff0000) | (new_target & 0xffff);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 2);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
-	sljit_ins *inst = (sljit_ins *)addr;
-
-	SLJIT_ASSERT((inst[0] & 0xfc1f0000) == ADDIS && (inst[1] & 0xfc000000) == ORI);
-	inst[0] = (inst[0] & 0xffff0000) | ((new_constant >> 16) & 0xffff);
-	inst[1] = (inst[1] & 0xffff0000) | (new_constant & 0xffff);
-	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 2);
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativePPC_64.c b/src/3rdparty/pcre2/src/sljit/sljitNativePPC_64.c
index 3b73021cc8..92147d2a5d 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativePPC_64.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativePPC_64.c
@@ -477,23 +477,19 @@ static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_ins *inst = (sljit_ins*)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
 
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 5, 0);
 	inst[0] = (inst[0] & 0xffff0000) | ((new_target >> 48) & 0xffff);
 	inst[1] = (inst[1] & 0xffff0000) | ((new_target >> 32) & 0xffff);
 	inst[3] = (inst[3] & 0xffff0000) | ((new_target >> 16) & 0xffff);
 	inst[4] = (inst[4] & 0xffff0000) | (new_target & 0xffff);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 5, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 5);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
-	sljit_ins *inst = (sljit_ins*)addr;
-
-	inst[0] = (inst[0] & 0xffff0000) | ((new_constant >> 48) & 0xffff);
-	inst[1] = (inst[1] & 0xffff0000) | ((new_constant >> 32) & 0xffff);
-	inst[3] = (inst[3] & 0xffff0000) | ((new_constant >> 16) & 0xffff);
-	inst[4] = (inst[4] & 0xffff0000) | (new_constant & 0xffff);
-	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 5);
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativePPC_common.c b/src/3rdparty/pcre2/src/sljit/sljitNativePPC_common.c
index 590f91c258..d84562ce09 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativePPC_common.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativePPC_common.c
@@ -404,7 +404,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	compiler->size += (sizeof(struct sljit_function_context) / sizeof(sljit_ins));
 #endif
 #endif
-	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins));
+	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
@@ -607,6 +607,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	code_ptr = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 
 	SLJIT_CACHE_FLUSH(code, code_ptr);
+	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
 
 #if (defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL)
 	return code_ptr;
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeS390X.c b/src/3rdparty/pcre2/src/sljit/sljitNativeS390X.c
new file mode 100644
index 0000000000..a8b65112d4
--- /dev/null
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeS390X.c
@@ -0,0 +1,2812 @@
+/*
+ *    Stack-less Just-In-Time compiler
+ *
+ *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are
+ * permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this list of
+ *      conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *      of conditions and the following disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/auxv.h>
+
+#ifdef __ARCH__
+#define ENABLE_STATIC_FACILITY_DETECTION 1
+#else
+#define ENABLE_STATIC_FACILITY_DETECTION 0
+#endif
+#define ENABLE_DYNAMIC_FACILITY_DETECTION 1
+
+SLJIT_API_FUNC_ATTRIBUTE const char* sljit_get_platform_name(void)
+{
+	return "s390x" SLJIT_CPUINFO;
+}
+
+/* Instructions. */
+typedef sljit_uw sljit_ins;
+
+/* Instruction tags (most significant halfword). */
+const sljit_ins sljit_ins_const = (sljit_ins)1 << 48;
+
+static const sljit_u8 reg_map[SLJIT_NUMBER_OF_REGISTERS + 4] = {
+	14, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 0, 1
+};
+
+/* there are also a[2-15] available, but they are slower to access and
+ * their use is limited as mundaym explained:
+ *   https://github.com/zherczeg/sljit/pull/91#discussion_r486895689
+ */
+
+/* General Purpose Registers [0-15]. */
+typedef sljit_uw sljit_gpr;
+
+/*
+ * WARNING
+ * the following code is non standard and should be improved for
+ * consistency, but doesn't use SLJIT_NUMBER_OF_REGISTERS based
+ * registers because r0 and r1 are the ABI recommended volatiles.
+ * there is a gpr() function that maps sljit to physical register numbers
+ * that should be used instead of the usual index into reg_map[] and
+ * will be retired ASAP (TODO: carenas)
+ */
+
+const sljit_gpr r0 = 0;	/* reg_map[SLJIT_NUMBER_OF_REGISTERS + 2]: 0 in address calculations; reserved */
+const sljit_gpr r1 = 1;	/* reg_map[SLJIT_NUMBER_OF_REGISTERS + 3]: reserved */
+const sljit_gpr r2 = 2;	/* reg_map[1]: 1st argument */
+const sljit_gpr r3 = 3;	/* reg_map[2]: 2nd argument */
+const sljit_gpr r4 = 4;	/* reg_map[3]: 3rd argument */
+const sljit_gpr r5 = 5;	/* reg_map[4]: 4th argument */
+const sljit_gpr r6 = 6;	/* reg_map[5]: 5th argument; 1st saved register */
+const sljit_gpr r7 = 7;	/* reg_map[6] */
+const sljit_gpr r8 = 8;	/* reg_map[7] */
+const sljit_gpr r9 = 9;	/* reg_map[8] */
+const sljit_gpr r10 = 10;	/* reg_map[9] */
+const sljit_gpr r11 = 11;	/* reg_map[10] */
+const sljit_gpr r12 = 12;	/* reg_map[11]: GOT */
+const sljit_gpr r13 = 13;	/* reg_map[12]: Literal Pool pointer */
+const sljit_gpr r14 = 14;	/* reg_map[0]: return address and flag register */
+const sljit_gpr r15 = 15;	/* reg_map[SLJIT_NUMBER_OF_REGISTERS + 1]: stack pointer */
+
+/* WARNING: r12 and r13 shouldn't be used as per ABI recommendation */
+/* TODO(carenas): r12 might conflict in PIC code, reserve? */
+/* TODO(carenas): r13 is usually pointed to "pool" per ABI, using a tmp
+ *                like we do know might be faster though, reserve?
+ */
+
+/* TODO(carenas): should be named TMP_REG[1-2] for consistency */
+#define tmp0	r0
+#define tmp1	r1
+
+/* TODO(carenas): flags should move to a different register so that
+ *                link register doesn't need to change
+ */
+
+/* Link registers. The normal link register is r14, but since
+   we use that for flags we need to use r0 instead to do fast
+   calls so that flags are preserved. */
+const sljit_gpr link_r = 14;     /* r14 */
+const sljit_gpr fast_link_r = 0; /* r0 */
+
+/* Flag register layout:
+
+   0               32  33  34      36      64
+   +---------------+---+---+-------+-------+
+   |      ZERO     | 0 | 0 |  C C  |///////|
+   +---------------+---+---+-------+-------+
+*/
+const sljit_gpr flag_r = 14; /* r14 */
+
+struct sljit_s390x_const {
+	struct sljit_const const_; /* must be first */
+	sljit_sw init_value;       /* required to build literal pool */
+};
+
+/* Convert SLJIT register to hardware register. */
+static SLJIT_INLINE sljit_gpr gpr(sljit_s32 r)
+{
+	SLJIT_ASSERT(r != SLJIT_UNUSED);
+	SLJIT_ASSERT(r < (sljit_s32)(sizeof(reg_map) / sizeof(reg_map[0])));
+	return reg_map[r];
+}
+
+/* Size of instruction in bytes. Tags must already be cleared. */
+static SLJIT_INLINE sljit_uw sizeof_ins(sljit_ins ins)
+{
+	/* keep faulting instructions */
+	if (ins == 0)
+		 return 2;
+
+	if ((ins & 0x00000000ffffL) == ins)
+		 return 2;
+	if ((ins & 0x0000ffffffffL) == ins)
+		 return 4;
+	if ((ins & 0xffffffffffffL) == ins)
+		 return 6;
+
+	SLJIT_UNREACHABLE();
+	return (sljit_uw)-1;
+}
+
+static sljit_s32 push_inst(struct sljit_compiler *compiler, sljit_ins ins)
+{
+	sljit_ins *ibuf = (sljit_ins *)ensure_buf(compiler, sizeof(sljit_ins));
+	FAIL_IF(!ibuf);
+	*ibuf = ins;
+	compiler->size++;
+	return SLJIT_SUCCESS;
+}
+
+static sljit_s32 encode_inst(void **ptr, sljit_ins ins)
+{
+	sljit_u16 *ibuf = (sljit_u16 *)*ptr;
+	sljit_uw size = sizeof_ins(ins);
+
+	SLJIT_ASSERT((size & 6) == size);
+	switch (size) {
+	case 6:
+		*ibuf++ = (sljit_u16)(ins >> 32);
+		/* fallthrough */
+	case 4:
+		*ibuf++ = (sljit_u16)(ins >> 16);
+		/* fallthrough */
+	case 2:
+		*ibuf++ = (sljit_u16)(ins);
+	}
+	*ptr = (void*)ibuf;
+	return SLJIT_SUCCESS;
+}
+
+/* Map the given type to a 4-bit condition code mask. */
+static SLJIT_INLINE sljit_u8 get_cc(sljit_s32 type) {
+	const sljit_u8 eq = 1 << 3; /* equal {,to zero} */
+	const sljit_u8 lt = 1 << 2; /* less than {,zero} */
+	const sljit_u8 gt = 1 << 1; /* greater than {,zero} */
+	const sljit_u8 ov = 1 << 0; /* {overflow,NaN} */
+
+	switch (type) {
+	case SLJIT_EQUAL:
+	case SLJIT_EQUAL_F64:
+		return eq;
+
+	case SLJIT_NOT_EQUAL:
+	case SLJIT_NOT_EQUAL_F64:
+		return ~eq;
+
+	case SLJIT_LESS:
+	case SLJIT_SIG_LESS:
+	case SLJIT_LESS_F64:
+		return lt;
+
+	case SLJIT_LESS_EQUAL:
+	case SLJIT_SIG_LESS_EQUAL:
+	case SLJIT_LESS_EQUAL_F64:
+		return (lt | eq);
+
+	case SLJIT_GREATER:
+	case SLJIT_SIG_GREATER:
+	case SLJIT_GREATER_F64:
+		return gt;
+
+	case SLJIT_GREATER_EQUAL:
+	case SLJIT_SIG_GREATER_EQUAL:
+	case SLJIT_GREATER_EQUAL_F64:
+		return (gt | eq);
+
+	case SLJIT_OVERFLOW:
+	case SLJIT_MUL_OVERFLOW:
+	case SLJIT_UNORDERED_F64:
+		return ov;
+
+	case SLJIT_NOT_OVERFLOW:
+	case SLJIT_MUL_NOT_OVERFLOW:
+	case SLJIT_ORDERED_F64:
+		return ~ov;
+	}
+
+	SLJIT_UNREACHABLE();
+	return (sljit_u8)-1;
+}
+
+/* Facility to bit index mappings.
+   Note: some facilities share the same bit index. */
+typedef sljit_uw facility_bit;
+#define STORE_FACILITY_LIST_EXTENDED_FACILITY 7
+#define FAST_LONG_DISPLACEMENT_FACILITY 19
+#define EXTENDED_IMMEDIATE_FACILITY 21
+#define GENERAL_INSTRUCTION_EXTENSION_FACILITY 34
+#define DISTINCT_OPERAND_FACILITY 45
+#define HIGH_WORD_FACILITY 45
+#define POPULATION_COUNT_FACILITY 45
+#define LOAD_STORE_ON_CONDITION_1_FACILITY 45
+#define MISCELLANEOUS_INSTRUCTION_EXTENSIONS_1_FACILITY 49
+#define LOAD_STORE_ON_CONDITION_2_FACILITY 53
+#define MISCELLANEOUS_INSTRUCTION_EXTENSIONS_2_FACILITY 58
+#define VECTOR_FACILITY 129
+#define VECTOR_ENHANCEMENTS_1_FACILITY 135
+
+/* Report whether a facility is known to be present due to the compiler
+   settings. This function should always be compiled to a constant
+   value given a constant argument. */
+static SLJIT_INLINE int have_facility_static(facility_bit x)
+{
+#if ENABLE_STATIC_FACILITY_DETECTION
+	switch (x) {
+	case FAST_LONG_DISPLACEMENT_FACILITY:
+		return (__ARCH__ >=  6 /* z990 */);
+	case EXTENDED_IMMEDIATE_FACILITY:
+	case STORE_FACILITY_LIST_EXTENDED_FACILITY:
+		return (__ARCH__ >=  7 /* z9-109 */);
+	case GENERAL_INSTRUCTION_EXTENSION_FACILITY:
+		return (__ARCH__ >=  8 /* z10 */);
+	case DISTINCT_OPERAND_FACILITY:
+		return (__ARCH__ >=  9 /* z196 */);
+	case MISCELLANEOUS_INSTRUCTION_EXTENSIONS_1_FACILITY:
+		return (__ARCH__ >= 10 /* zEC12 */);
+	case LOAD_STORE_ON_CONDITION_2_FACILITY:
+	case VECTOR_FACILITY:
+		return (__ARCH__ >= 11 /* z13 */);
+	case MISCELLANEOUS_INSTRUCTION_EXTENSIONS_2_FACILITY:
+	case VECTOR_ENHANCEMENTS_1_FACILITY:
+		return (__ARCH__ >= 12 /* z14 */);
+	default:
+		SLJIT_UNREACHABLE();
+	}
+#endif
+	return 0;
+}
+
+static SLJIT_INLINE unsigned long get_hwcap()
+{
+	static unsigned long hwcap = 0;
+	if (SLJIT_UNLIKELY(!hwcap)) {
+		hwcap = getauxval(AT_HWCAP);
+		SLJIT_ASSERT(hwcap != 0);
+	}
+	return hwcap;
+}
+
+static SLJIT_INLINE int have_stfle()
+{
+	if (have_facility_static(STORE_FACILITY_LIST_EXTENDED_FACILITY))
+		return 1;
+
+	return (get_hwcap() & HWCAP_S390_STFLE);
+}
+
+/* Report whether the given facility is available. This function always
+   performs a runtime check. */
+static int have_facility_dynamic(facility_bit x)
+{
+#if ENABLE_DYNAMIC_FACILITY_DETECTION
+	static struct {
+		sljit_uw bits[4];
+	} cpu_features;
+	size_t size = sizeof(cpu_features);
+	const sljit_uw word_index = x >> 6;
+	const sljit_uw bit_index = ((1UL << 63) >> (x & 63));
+
+	SLJIT_ASSERT(x < size * 8);
+	if (SLJIT_UNLIKELY(!have_stfle()))
+		return 0;
+
+	if (SLJIT_UNLIKELY(cpu_features.bits[0] == 0)) {
+		__asm__ __volatile__ (
+			"lgr   %%r0, %0;"
+			"stfle 0(%1);"
+			/* outputs  */:
+			/* inputs   */: "d" ((size / 8) - 1), "a" (&cpu_features)
+			/* clobbers */: "r0", "cc", "memory"
+		);
+		SLJIT_ASSERT(cpu_features.bits[0] != 0);
+	}
+	return (cpu_features.bits[word_index] & bit_index) != 0;
+#else
+	return 0;
+#endif
+}
+
+#define HAVE_FACILITY(name, bit) \
+static SLJIT_INLINE int name() \
+{ \
+	static int have = -1; \
+	/* Static check first. May allow the function to be optimized away. */ \
+	if (have_facility_static(bit)) \
+		have = 1; \
+	else if (SLJIT_UNLIKELY(have < 0)) \
+		have = have_facility_dynamic(bit) ? 1 : 0; \
+\
+	return have; \
+}
+
+HAVE_FACILITY(have_eimm,    EXTENDED_IMMEDIATE_FACILITY)
+HAVE_FACILITY(have_ldisp,   FAST_LONG_DISPLACEMENT_FACILITY)
+HAVE_FACILITY(have_genext,  GENERAL_INSTRUCTION_EXTENSION_FACILITY)
+HAVE_FACILITY(have_lscond1, LOAD_STORE_ON_CONDITION_1_FACILITY)
+HAVE_FACILITY(have_lscond2, LOAD_STORE_ON_CONDITION_2_FACILITY)
+HAVE_FACILITY(have_misc2,   MISCELLANEOUS_INSTRUCTION_EXTENSIONS_2_FACILITY)
+#undef HAVE_FACILITY
+
+#define is_u12(d)	(0 <= (d) && (d) <= 0x00000fffL)
+#define is_u32(d)	(0 <= (d) && (d) <= 0xffffffffL)
+
+#define CHECK_SIGNED(v, bitlen) \
+	((v) == (((v) << (sizeof(v) * 8 - bitlen)) >> (sizeof(v) * 8 - bitlen)))
+
+#define is_s16(d)	CHECK_SIGNED((d), 16)
+#define is_s20(d)	CHECK_SIGNED((d), 20)
+#define is_s32(d)	CHECK_SIGNED((d), 32)
+
+static SLJIT_INLINE sljit_uw disp_s20(sljit_s32 d)
+{
+	sljit_uw dh = (d >> 12) & 0xff;
+	sljit_uw dl = (d << 8) & 0xfff00;
+
+	SLJIT_ASSERT(is_s20(d));
+	return dh | dl;
+}
+
+/* TODO(carenas): variadic macro is not strictly needed */
+#define SLJIT_S390X_INSTRUCTION(op, ...) \
+static SLJIT_INLINE sljit_ins op(__VA_ARGS__)
+
+/* RR form instructions. */
+#define SLJIT_S390X_RR(name, pattern) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src) \
+{ \
+	return (pattern) | ((dst & 0xf) << 4) | (src & 0xf); \
+}
+
+/* ADD */
+SLJIT_S390X_RR(ar,   0x1a00)
+
+/* ADD LOGICAL */
+SLJIT_S390X_RR(alr,  0x1e00)
+
+/* AND */
+SLJIT_S390X_RR(nr,   0x1400)
+
+/* BRANCH AND SAVE */
+SLJIT_S390X_RR(basr, 0x0d00)
+
+/* BRANCH ON CONDITION */
+SLJIT_S390X_RR(bcr,  0x0700) /* TODO(mundaym): type for mask? */
+
+/* COMPARE */
+SLJIT_S390X_RR(cr,   0x1900)
+
+/* COMPARE LOGICAL */
+SLJIT_S390X_RR(clr,  0x1500)
+
+/* DIVIDE */
+SLJIT_S390X_RR(dr,   0x1d00)
+
+/* EXCLUSIVE OR */
+SLJIT_S390X_RR(xr,   0x1700)
+
+/* LOAD */
+SLJIT_S390X_RR(lr,   0x1800)
+
+/* LOAD COMPLEMENT */
+SLJIT_S390X_RR(lcr,  0x1300)
+
+/* OR */
+SLJIT_S390X_RR(or,   0x1600)
+
+/* SUBTRACT */
+SLJIT_S390X_RR(sr,   0x1b00)
+
+/* SUBTRACT LOGICAL */
+SLJIT_S390X_RR(slr,  0x1f00)
+
+#undef SLJIT_S390X_RR
+
+/* RRE form instructions */
+#define SLJIT_S390X_RRE(name, pattern) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src) \
+{ \
+	return (pattern) | ((dst & 0xf) << 4) | (src & 0xf); \
+}
+
+/* ADD */
+SLJIT_S390X_RRE(agr,   0xb9080000)
+
+/* ADD LOGICAL */
+SLJIT_S390X_RRE(algr,  0xb90a0000)
+
+/* ADD LOGICAL WITH CARRY */
+SLJIT_S390X_RRE(alcr,  0xb9980000)
+SLJIT_S390X_RRE(alcgr, 0xb9880000)
+
+/* AND */
+SLJIT_S390X_RRE(ngr,   0xb9800000)
+
+/* COMPARE */
+SLJIT_S390X_RRE(cgr,   0xb9200000)
+
+/* COMPARE LOGICAL */
+SLJIT_S390X_RRE(clgr,  0xb9210000)
+
+/* DIVIDE LOGICAL */
+SLJIT_S390X_RRE(dlr,   0xb9970000)
+SLJIT_S390X_RRE(dlgr,  0xb9870000)
+
+/* DIVIDE SINGLE */
+SLJIT_S390X_RRE(dsgr,  0xb90d0000)
+
+/* EXCLUSIVE OR */
+SLJIT_S390X_RRE(xgr,   0xb9820000)
+
+/* LOAD */
+SLJIT_S390X_RRE(lgr,   0xb9040000)
+SLJIT_S390X_RRE(lgfr,  0xb9140000)
+
+/* LOAD BYTE */
+SLJIT_S390X_RRE(lbr,   0xb9260000)
+SLJIT_S390X_RRE(lgbr,  0xb9060000)
+
+/* LOAD COMPLEMENT */
+SLJIT_S390X_RRE(lcgr,  0xb9030000)
+
+/* LOAD HALFWORD */
+SLJIT_S390X_RRE(lhr,   0xb9270000)
+SLJIT_S390X_RRE(lghr,  0xb9070000)
+
+/* LOAD LOGICAL */
+SLJIT_S390X_RRE(llgfr, 0xb9160000)
+
+/* LOAD LOGICAL CHARACTER */
+SLJIT_S390X_RRE(llcr,  0xb9940000)
+SLJIT_S390X_RRE(llgcr, 0xb9840000)
+
+/* LOAD LOGICAL HALFWORD */
+SLJIT_S390X_RRE(llhr,  0xb9950000)
+SLJIT_S390X_RRE(llghr, 0xb9850000)
+
+/* MULTIPLY LOGICAL */
+SLJIT_S390X_RRE(mlgr,  0xb9860000)
+
+/* MULTIPLY SINGLE */
+SLJIT_S390X_RRE(msr,   0xb2520000)
+SLJIT_S390X_RRE(msgr,  0xb90c0000)
+SLJIT_S390X_RRE(msgfr, 0xb91c0000)
+
+/* OR */
+SLJIT_S390X_RRE(ogr,   0xb9810000)
+
+/* SUBTRACT */
+SLJIT_S390X_RRE(sgr,   0xb9090000)
+
+/* SUBTRACT LOGICAL */
+SLJIT_S390X_RRE(slgr,  0xb90b0000)
+
+/* SUBTRACT LOGICAL WITH BORROW */
+SLJIT_S390X_RRE(slbr,  0xb9990000)
+SLJIT_S390X_RRE(slbgr, 0xb9890000)
+
+#undef SLJIT_S390X_RRE
+
+/* RI-a form instructions */
+#define SLJIT_S390X_RIA(name, pattern, imm_type) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, imm_type imm) \
+{ \
+	return (pattern) | ((reg & 0xf) << 20) | (imm & 0xffff); \
+}
+
+/* ADD HALFWORD IMMEDIATE */
+SLJIT_S390X_RIA(ahi,   0xa70a0000, sljit_s16)
+SLJIT_S390X_RIA(aghi,  0xa70b0000, sljit_s16)
+
+/* COMPARE HALFWORD IMMEDIATE */
+SLJIT_S390X_RIA(chi,   0xa70e0000, sljit_s16)
+SLJIT_S390X_RIA(cghi,  0xa70f0000, sljit_s16)
+
+/* LOAD HALFWORD IMMEDIATE */
+SLJIT_S390X_RIA(lhi,   0xa7080000, sljit_s16)
+SLJIT_S390X_RIA(lghi,  0xa7090000, sljit_s16)
+
+/* LOAD LOGICAL IMMEDIATE */
+SLJIT_S390X_RIA(llihh, 0xa50c0000, sljit_u16)
+SLJIT_S390X_RIA(llihl, 0xa50d0000, sljit_u16)
+SLJIT_S390X_RIA(llilh, 0xa50e0000, sljit_u16)
+SLJIT_S390X_RIA(llill, 0xa50f0000, sljit_u16)
+
+/* MULTIPLY HALFWORD IMMEDIATE */
+SLJIT_S390X_RIA(mhi,   0xa70c0000, sljit_s16)
+SLJIT_S390X_RIA(mghi,  0xa70d0000, sljit_s16)
+
+/* OR IMMEDIATE */
+SLJIT_S390X_RIA(oilh,  0xa50a0000, sljit_u16)
+
+/* TEST UNDER MASK */
+SLJIT_S390X_RIA(tmlh,  0xa7000000, sljit_u16)
+
+#undef SLJIT_S390X_RIA
+
+/* RIL-a form instructions (requires extended immediate facility) */
+#define SLJIT_S390X_RILA(name, pattern, imm_type) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, imm_type imm) \
+{ \
+	SLJIT_ASSERT(have_eimm()); \
+	return (pattern) | ((sljit_ins)(reg & 0xf) << 36) | (imm & 0xffffffff); \
+}
+
+/* ADD IMMEDIATE */
+SLJIT_S390X_RILA(afi,   0xc20900000000, sljit_s32)
+SLJIT_S390X_RILA(agfi,  0xc20800000000, sljit_s32)
+
+/* ADD IMMEDIATE HIGH */
+SLJIT_S390X_RILA(aih,   0xcc0800000000, sljit_s32) /* TODO(mundaym): high-word facility? */
+
+/* ADD LOGICAL IMMEDIATE */
+SLJIT_S390X_RILA(alfi,  0xc20b00000000, sljit_u32)
+SLJIT_S390X_RILA(algfi, 0xc20a00000000, sljit_u32)
+
+/* AND IMMEDIATE */
+SLJIT_S390X_RILA(nihf,  0xc00a00000000, sljit_u32)
+SLJIT_S390X_RILA(nilf,  0xc00b00000000, sljit_u32)
+
+/* COMPARE IMMEDIATE */
+SLJIT_S390X_RILA(cfi,   0xc20d00000000, sljit_s32)
+SLJIT_S390X_RILA(cgfi,  0xc20c00000000, sljit_s32)
+
+/* COMPARE IMMEDIATE HIGH */
+SLJIT_S390X_RILA(cih,   0xcc0d00000000, sljit_s32) /* TODO(mundaym): high-word facility? */
+
+/* COMPARE LOGICAL IMMEDIATE */
+SLJIT_S390X_RILA(clfi,  0xc20f00000000, sljit_u32)
+SLJIT_S390X_RILA(clgfi, 0xc20e00000000, sljit_u32)
+
+/* EXCLUSIVE OR IMMEDIATE */
+SLJIT_S390X_RILA(xilf,  0xc00700000000, sljit_u32)
+
+/* INSERT IMMEDIATE */
+SLJIT_S390X_RILA(iihf,  0xc00800000000, sljit_u32)
+SLJIT_S390X_RILA(iilf,  0xc00900000000, sljit_u32)
+
+/* LOAD IMMEDIATE */
+SLJIT_S390X_RILA(lgfi,  0xc00100000000, sljit_s32)
+
+/* LOAD LOGICAL IMMEDIATE */
+SLJIT_S390X_RILA(llihf, 0xc00e00000000, sljit_u32)
+SLJIT_S390X_RILA(llilf, 0xc00f00000000, sljit_u32)
+
+/* OR IMMEDIATE */
+SLJIT_S390X_RILA(oilf,  0xc00d00000000, sljit_u32)
+
+#undef SLJIT_S390X_RILA
+
+/* RX-a form instructions */
+#define SLJIT_S390X_RXA(name, pattern) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr r, sljit_u16 d, sljit_gpr x, sljit_gpr b) \
+{ \
+	sljit_ins ri, xi, bi, di; \
+\
+	SLJIT_ASSERT((d & 0xfff) == d); \
+	ri = (sljit_ins)(r & 0xf) << 20; \
+	xi = (sljit_ins)(x & 0xf) << 16; \
+	bi = (sljit_ins)(b & 0xf) << 12; \
+	di = (sljit_ins)(d & 0xfff); \
+\
+	return (pattern) | ri | xi | bi | di; \
+}
+
+/* ADD */
+SLJIT_S390X_RXA(a,   0x5a000000)
+
+/* ADD LOGICAL */
+SLJIT_S390X_RXA(al,  0x5e000000)
+
+/* AND */
+SLJIT_S390X_RXA(n,   0x54000000)
+
+/* EXCLUSIVE OR */
+SLJIT_S390X_RXA(x,   0x57000000)
+
+/* LOAD */
+SLJIT_S390X_RXA(l,   0x58000000)
+
+/* LOAD ADDRESS */
+SLJIT_S390X_RXA(la,  0x41000000)
+
+/* LOAD HALFWORD */
+SLJIT_S390X_RXA(lh,  0x48000000)
+
+/* MULTIPLY SINGLE */
+SLJIT_S390X_RXA(ms,  0x71000000)
+
+/* OR */
+SLJIT_S390X_RXA(o,   0x56000000)
+
+/* STORE */
+SLJIT_S390X_RXA(st,  0x50000000)
+
+/* STORE CHARACTER */
+SLJIT_S390X_RXA(stc, 0x42000000)
+
+/* STORE HALFWORD */
+SLJIT_S390X_RXA(sth, 0x40000000)
+
+/* SUBTRACT */
+SLJIT_S390X_RXA(s,   0x5b000000)
+
+/* SUBTRACT LOGICAL */
+SLJIT_S390X_RXA(sl,  0x5f000000)
+
+#undef SLJIT_S390X_RXA
+
+/* RXY-a instructions */
+#define SLJIT_S390X_RXYA(name, pattern, cond) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr r, sljit_s32 d, sljit_gpr x, sljit_gpr b) \
+{ \
+	sljit_ins ri, xi, bi, di; \
+\
+	SLJIT_ASSERT(cond); \
+	ri = (sljit_ins)(r & 0xf) << 36; \
+	xi = (sljit_ins)(x & 0xf) << 32; \
+	bi = (sljit_ins)(b & 0xf) << 28; \
+	di = (sljit_ins)disp_s20(d) << 8; \
+\
+	return (pattern) | ri | xi | bi | di; \
+}
+
+/* ADD */
+SLJIT_S390X_RXYA(ay,    0xe3000000005a, have_ldisp())
+SLJIT_S390X_RXYA(ag,    0xe30000000008, 1)
+
+/* ADD LOGICAL */
+SLJIT_S390X_RXYA(aly,   0xe3000000005e, have_ldisp())
+SLJIT_S390X_RXYA(alg,   0xe3000000000a, 1)
+
+/* ADD LOGICAL WITH CARRY */
+SLJIT_S390X_RXYA(alc,   0xe30000000098, 1)
+SLJIT_S390X_RXYA(alcg,  0xe30000000088, 1)
+
+/* AND */
+SLJIT_S390X_RXYA(ny,    0xe30000000054, have_ldisp())
+SLJIT_S390X_RXYA(ng,    0xe30000000080, 1)
+
+/* EXCLUSIVE OR */
+SLJIT_S390X_RXYA(xy,    0xe30000000057, have_ldisp())
+SLJIT_S390X_RXYA(xg,    0xe30000000082, 1)
+
+/* LOAD */
+SLJIT_S390X_RXYA(ly,    0xe30000000058, have_ldisp())
+SLJIT_S390X_RXYA(lg,    0xe30000000004, 1)
+SLJIT_S390X_RXYA(lgf,   0xe30000000014, 1)
+
+/* LOAD BYTE */
+SLJIT_S390X_RXYA(lb,    0xe30000000076, have_ldisp())
+SLJIT_S390X_RXYA(lgb,   0xe30000000077, have_ldisp())
+
+/* LOAD HALFWORD */
+SLJIT_S390X_RXYA(lhy,   0xe30000000078, have_ldisp())
+SLJIT_S390X_RXYA(lgh,   0xe30000000015, 1)
+
+/* LOAD LOGICAL */
+SLJIT_S390X_RXYA(llgf,  0xe30000000016, 1)
+
+/* LOAD LOGICAL CHARACTER */
+SLJIT_S390X_RXYA(llc,   0xe30000000094, have_eimm())
+SLJIT_S390X_RXYA(llgc,  0xe30000000090, 1)
+
+/* LOAD LOGICAL HALFWORD */
+SLJIT_S390X_RXYA(llh,   0xe30000000095, have_eimm())
+SLJIT_S390X_RXYA(llgh,  0xe30000000091, 1)
+
+/* MULTIPLY SINGLE */
+SLJIT_S390X_RXYA(msy,   0xe30000000051, have_ldisp())
+SLJIT_S390X_RXYA(msg,   0xe3000000000c, 1)
+
+/* OR */
+SLJIT_S390X_RXYA(oy,    0xe30000000056, have_ldisp())
+SLJIT_S390X_RXYA(og,    0xe30000000081, 1)
+
+/* STORE */
+SLJIT_S390X_RXYA(sty,   0xe30000000050, have_ldisp())
+SLJIT_S390X_RXYA(stg,   0xe30000000024, 1)
+
+/* STORE CHARACTER */
+SLJIT_S390X_RXYA(stcy,  0xe30000000072, have_ldisp())
+
+/* STORE HALFWORD */
+SLJIT_S390X_RXYA(sthy,  0xe30000000070, have_ldisp())
+
+/* SUBTRACT */
+SLJIT_S390X_RXYA(sy,    0xe3000000005b, have_ldisp())
+SLJIT_S390X_RXYA(sg,    0xe30000000009, 1)
+
+/* SUBTRACT LOGICAL */
+SLJIT_S390X_RXYA(sly,   0xe3000000005f, have_ldisp())
+SLJIT_S390X_RXYA(slg,   0xe3000000000b, 1)
+
+/* SUBTRACT LOGICAL WITH BORROW */
+SLJIT_S390X_RXYA(slb,   0xe30000000099, 1)
+SLJIT_S390X_RXYA(slbg,  0xe30000000089, 1)
+
+#undef SLJIT_S390X_RXYA
+
+/* RS-a instructions */
+#define SLJIT_S390X_RSA(name, pattern) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, sljit_sw d, sljit_gpr b) \
+{ \
+	sljit_ins r1 = (sljit_ins)(reg & 0xf) << 20; \
+	sljit_ins b2 = (sljit_ins)(b & 0xf) << 12; \
+	sljit_ins d2 = (sljit_ins)(d & 0xfff); \
+	return (pattern) | r1 | b2 | d2; \
+}
+
+/* SHIFT LEFT SINGLE LOGICAL */
+SLJIT_S390X_RSA(sll, 0x89000000)
+
+/* SHIFT RIGHT SINGLE */
+SLJIT_S390X_RSA(sra, 0x8a000000)
+
+/* SHIFT RIGHT SINGLE LOGICAL */
+SLJIT_S390X_RSA(srl, 0x88000000)
+
+#undef SLJIT_S390X_RSA
+
+/* RSY-a instructions */
+#define SLJIT_S390X_RSYA(name, pattern, cond) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src, sljit_sw d, sljit_gpr b) \
+{ \
+	sljit_ins r1, r3, b2, d2; \
+\
+	SLJIT_ASSERT(cond); \
+	r1 = (sljit_ins)(dst & 0xf) << 36; \
+	r3 = (sljit_ins)(src & 0xf) << 32; \
+	b2 = (sljit_ins)(b & 0xf) << 28; \
+	d2 = (sljit_ins)disp_s20(d) << 8; \
+\
+	return (pattern) | r1 | r3 | b2 | d2; \
+}
+
+/* LOAD MULTIPLE */
+SLJIT_S390X_RSYA(lmg,   0xeb0000000004, 1)
+
+/* SHIFT LEFT LOGICAL */
+SLJIT_S390X_RSYA(sllg,  0xeb000000000d, 1)
+
+/* SHIFT RIGHT SINGLE */
+SLJIT_S390X_RSYA(srag,  0xeb000000000a, 1)
+
+/* SHIFT RIGHT SINGLE LOGICAL */
+SLJIT_S390X_RSYA(srlg,  0xeb000000000c, 1)
+
+/* STORE MULTIPLE */
+SLJIT_S390X_RSYA(stmg,  0xeb0000000024, 1)
+
+#undef SLJIT_S390X_RSYA
+
+/* RIE-f instructions (require general-instructions-extension facility) */
+#define SLJIT_S390X_RIEF(name, pattern) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src, sljit_u8 start, sljit_u8 end, sljit_u8 rot) \
+{ \
+	sljit_ins r1, r2, i3, i4, i5; \
+\
+	SLJIT_ASSERT(have_genext()); \
+	r1 = (sljit_ins)(dst & 0xf) << 36; \
+	r2 = (sljit_ins)(src & 0xf) << 32; \
+	i3 = (sljit_ins)start << 24; \
+	i4 = (sljit_ins)end << 16; \
+	i5 = (sljit_ins)rot << 8; \
+\
+	return (pattern) | r1 | r2 | i3 | i4 | i5; \
+}
+
+/* ROTATE THEN AND SELECTED BITS */
+/* SLJIT_S390X_RIEF(rnsbg,  0xec0000000054) */
+
+/* ROTATE THEN EXCLUSIVE OR SELECTED BITS */
+/* SLJIT_S390X_RIEF(rxsbg,  0xec0000000057) */
+
+/* ROTATE THEN OR SELECTED BITS */
+SLJIT_S390X_RIEF(rosbg,  0xec0000000056)
+
+/* ROTATE THEN INSERT SELECTED BITS */
+/* SLJIT_S390X_RIEF(risbg,  0xec0000000055) */
+/* SLJIT_S390X_RIEF(risbgn, 0xec0000000059) */
+
+/* ROTATE THEN INSERT SELECTED BITS HIGH */
+SLJIT_S390X_RIEF(risbhg, 0xec000000005d)
+
+/* ROTATE THEN INSERT SELECTED BITS LOW */
+/* SLJIT_S390X_RIEF(risblg, 0xec0000000051) */
+
+#undef SLJIT_S390X_RIEF
+
+/* RRF-a instructions */
+#define SLJIT_S390X_RRFA(name, pattern, cond) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src1, sljit_gpr src2) \
+{ \
+	sljit_ins r1, r2, r3; \
+\
+	SLJIT_ASSERT(cond); \
+	r1 = (sljit_ins)(dst & 0xf) << 4; \
+	r2 = (sljit_ins)(src1 & 0xf); \
+	r3 = (sljit_ins)(src2 & 0xf) << 12; \
+\
+	return (pattern) | r3 | r1 | r2; \
+}
+
+/* MULTIPLY */
+SLJIT_S390X_RRFA(msrkc,  0xb9fd0000, have_misc2())
+SLJIT_S390X_RRFA(msgrkc, 0xb9ed0000, have_misc2())
+
+#undef SLJIT_S390X_RRFA
+
+/* RRF-c instructions (require load/store-on-condition 1 facility) */
+#define SLJIT_S390X_RRFC(name, pattern) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src, sljit_uw mask) \
+{ \
+	sljit_ins r1, r2, m3; \
+\
+	SLJIT_ASSERT(have_lscond1()); \
+	r1 = (sljit_ins)(dst & 0xf) << 4; \
+	r2 = (sljit_ins)(src & 0xf); \
+	m3 = (sljit_ins)(mask & 0xf) << 12; \
+\
+	return (pattern) | m3 | r1 | r2; \
+}
+
+/* LOAD HALFWORD IMMEDIATE ON CONDITION */
+SLJIT_S390X_RRFC(locr,  0xb9f20000)
+SLJIT_S390X_RRFC(locgr, 0xb9e20000)
+
+#undef SLJIT_S390X_RRFC
+
+/* RIE-g instructions (require load/store-on-condition 2 facility) */
+#define SLJIT_S390X_RIEG(name, pattern) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, sljit_sw imm, sljit_uw mask) \
+{ \
+	sljit_ins r1, m3, i2; \
+\
+	SLJIT_ASSERT(have_lscond2()); \
+	r1 = (sljit_ins)(reg & 0xf) << 36; \
+	m3 = (sljit_ins)(mask & 0xf) << 32; \
+	i2 = (sljit_ins)(imm & 0xffffL) << 16; \
+\
+	return (pattern) | r1 | m3 | i2; \
+}
+
+/* LOAD HALFWORD IMMEDIATE ON CONDITION */
+SLJIT_S390X_RIEG(lochi,  0xec0000000042)
+SLJIT_S390X_RIEG(locghi, 0xec0000000046)
+
+#undef SLJIT_S390X_RIEG
+
+#define SLJIT_S390X_RILB(name, pattern, cond) \
+SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, sljit_sw ri) \
+{ \
+	sljit_ins r1, ri2; \
+\
+	SLJIT_ASSERT(cond); \
+	r1 = (sljit_ins)(reg & 0xf) << 36; \
+	ri2 = (sljit_ins)(ri & 0xffffffff); \
+\
+	return (pattern) | r1 | ri2; \
+}
+
+/* BRANCH RELATIVE AND SAVE LONG */
+SLJIT_S390X_RILB(brasl, 0xc00500000000, 1)
+
+/* LOAD ADDRESS RELATIVE LONG */
+SLJIT_S390X_RILB(larl,  0xc00000000000, 1)
+
+/* LOAD RELATIVE LONG */
+SLJIT_S390X_RILB(lgrl,  0xc40800000000, have_genext())
+
+#undef SLJIT_S390X_RILB
+
+SLJIT_S390X_INSTRUCTION(br, sljit_gpr target)
+{
+	return 0x07f0 | target;
+}
+
+SLJIT_S390X_INSTRUCTION(brcl, sljit_uw mask, sljit_sw target)
+{
+	sljit_ins m1 = (sljit_ins)(mask & 0xf) << 36;
+	sljit_ins ri2 = (sljit_ins)target & 0xffffffff;
+	return 0xc00400000000L | m1 | ri2;
+}
+
+SLJIT_S390X_INSTRUCTION(flogr, sljit_gpr dst, sljit_gpr src)
+{
+	sljit_ins r1 = ((sljit_ins)dst & 0xf) << 8;
+	sljit_ins r2 = ((sljit_ins)src & 0xf);
+	SLJIT_ASSERT(have_eimm());
+	return 0xb9830000 | r1 | r2;
+}
+
+/* INSERT PROGRAM MASK */
+SLJIT_S390X_INSTRUCTION(ipm, sljit_gpr dst)
+{
+	return 0xb2220000 | ((sljit_ins)(dst & 0xf) << 4);
+}
+
+/* ROTATE THEN INSERT SELECTED BITS HIGH (ZERO) */
+SLJIT_S390X_INSTRUCTION(risbhgz, sljit_gpr dst, sljit_gpr src, sljit_u8 start, sljit_u8 end, sljit_u8 rot)
+{
+	return risbhg(dst, src, start, 0x8 | end, rot);
+}
+
+#undef SLJIT_S390X_INSTRUCTION
+
+/* load condition code as needed to match type */
+static sljit_s32 push_load_cc(struct sljit_compiler *compiler, sljit_s32 type)
+{
+	type &= ~SLJIT_I32_OP;
+	switch (type) {
+	case SLJIT_ZERO:
+	case SLJIT_NOT_ZERO:
+		return push_inst(compiler, cih(flag_r, 0));
+		break;
+	default:
+		return push_inst(compiler, tmlh(flag_r, 0x3000));
+		break;
+	}
+	return SLJIT_SUCCESS;
+}
+
+static sljit_s32 push_store_zero_flag(struct sljit_compiler *compiler, sljit_s32 op, sljit_gpr source)
+{
+	/* insert low 32-bits into high 32-bits of flag register */
+	FAIL_IF(push_inst(compiler, risbhgz(flag_r, source, 0, 31, 32)));
+	if (!(op & SLJIT_I32_OP)) {
+		/* OR high 32-bits with high 32-bits of flag register */
+		return push_inst(compiler, rosbg(flag_r, source, 0, 31, 0));
+	}
+	return SLJIT_SUCCESS;
+}
+
+/* load 64-bit immediate into register without clobbering flags */
+static sljit_s32 push_load_imm_inst(struct sljit_compiler *compiler, sljit_gpr target, sljit_sw v)
+{
+	/* 4 byte instructions */
+	if (is_s16(v))
+		return push_inst(compiler, lghi(target, (sljit_s16)v));
+
+	if ((sljit_uw)v == (v & 0x000000000000ffffU))
+		return push_inst(compiler, llill(target, (sljit_u16)v));
+
+	if ((sljit_uw)v == (v & 0x00000000ffff0000U))
+		return push_inst(compiler, llilh(target, (sljit_u16)(v >> 16)));
+
+	if ((sljit_uw)v == (v & 0x0000ffff00000000U))
+		return push_inst(compiler, llihl(target, (sljit_u16)(v >> 32)));
+
+	if ((sljit_uw)v == (v & 0xffff000000000000U))
+		return push_inst(compiler, llihh(target, (sljit_u16)(v >> 48)));
+
+	/* 6 byte instructions (requires extended immediate facility) */
+	if (have_eimm()) {
+		if (is_s32(v))
+			return push_inst(compiler, lgfi(target, (sljit_s32)v));
+
+		if ((sljit_uw)v == (v & 0x00000000ffffffffU))
+			return push_inst(compiler, llilf(target, (sljit_u32)v));
+
+		if ((sljit_uw)v == (v & 0xffffffff00000000U))
+			return push_inst(compiler, llihf(target, (sljit_u32)(v >> 32)));
+
+		FAIL_IF(push_inst(compiler, llilf(target, (sljit_u32)v)));
+		return push_inst(compiler, iihf(target, (sljit_u32)(v >> 32)));
+	}
+	/* TODO(mundaym): instruction sequences that don't use extended immediates */
+	abort();
+}
+
+struct addr {
+	sljit_gpr base;
+	sljit_gpr index;
+	sljit_sw  offset;
+};
+
+/* transform memory operand into D(X,B) form with a signed 20-bit offset */
+static sljit_s32 make_addr_bxy(struct sljit_compiler *compiler,
+	struct addr *addr, sljit_s32 mem, sljit_sw off,
+	sljit_gpr tmp /* clobbered, must not be r0 */)
+{
+	sljit_gpr base = r0;
+	sljit_gpr index = r0;
+
+	SLJIT_ASSERT(tmp != r0);
+	if (mem & REG_MASK)
+		base = gpr(mem & REG_MASK);
+
+	if (mem & OFFS_REG_MASK) {
+		index = gpr(OFFS_REG(mem));
+		if (off != 0) {
+			/* shift and put the result into tmp */
+			SLJIT_ASSERT(0 <= off && off < 64);
+			FAIL_IF(push_inst(compiler, sllg(tmp, index, off, 0)));
+			index = tmp;
+			off = 0; /* clear offset */
+		}
+	}
+	else if (!is_s20(off)) {
+		FAIL_IF(push_load_imm_inst(compiler, tmp, off));
+		index = tmp;
+		off = 0; /* clear offset */
+	}
+	addr->base = base;
+	addr->index = index;
+	addr->offset = off;
+	return SLJIT_SUCCESS;
+}
+
+/* transform memory operand into D(X,B) form with an unsigned 12-bit offset */
+static sljit_s32 make_addr_bx(struct sljit_compiler *compiler,
+	struct addr *addr, sljit_s32 mem, sljit_sw off,
+	sljit_gpr tmp /* clobbered, must not be r0 */)
+{
+	sljit_gpr base = r0;
+	sljit_gpr index = r0;
+
+	SLJIT_ASSERT(tmp != r0);
+	if (mem & REG_MASK)
+		base = gpr(mem & REG_MASK);
+
+	if (mem & OFFS_REG_MASK) {
+		index = gpr(OFFS_REG(mem));
+		if (off != 0) {
+			/* shift and put the result into tmp */
+			SLJIT_ASSERT(0 <= off && off < 64);
+			FAIL_IF(push_inst(compiler, sllg(tmp, index, off, 0)));
+			index = tmp;
+			off = 0; /* clear offset */
+		}
+	}
+	else if (!is_u12(off)) {
+		FAIL_IF(push_load_imm_inst(compiler, tmp, off));
+		index = tmp;
+		off = 0; /* clear offset */
+	}
+	addr->base = base;
+	addr->index = index;
+	addr->offset = off;
+	return SLJIT_SUCCESS;
+}
+
+#define EVAL(op, r, addr) op(r, addr.offset, addr.index, addr.base)
+#define WHEN(cond, r, i1, i2, addr) \
+	(cond) ? EVAL(i1, r, addr) : EVAL(i2, r, addr)
+
+static sljit_s32 load_word(struct sljit_compiler *compiler, sljit_gpr dst,
+		sljit_s32 src, sljit_sw srcw,
+		sljit_gpr tmp /* clobbered */, sljit_s32 is_32bit)
+{
+	struct addr addr;
+	sljit_ins ins;
+
+	SLJIT_ASSERT(src & SLJIT_MEM);
+	if (have_ldisp() || !is_32bit)
+		FAIL_IF(make_addr_bxy(compiler, &addr, src, srcw, tmp));
+	else
+		FAIL_IF(make_addr_bx(compiler, &addr, src, srcw, tmp));
+
+	if (is_32bit)
+		ins = WHEN(is_u12(addr.offset), dst, l, ly, addr);
+	else
+		ins = lg(dst, addr.offset, addr.index, addr.base);
+
+	return push_inst(compiler, ins);
+}
+
+static sljit_s32 store_word(struct sljit_compiler *compiler, sljit_gpr src,
+		sljit_s32 dst, sljit_sw dstw,
+		sljit_gpr tmp /* clobbered */, sljit_s32 is_32bit)
+{
+	struct addr addr;
+	sljit_ins ins;
+
+	SLJIT_ASSERT(dst & SLJIT_MEM);
+	if (have_ldisp() || !is_32bit)
+		FAIL_IF(make_addr_bxy(compiler, &addr, dst, dstw, tmp));
+	else
+		FAIL_IF(make_addr_bx(compiler, &addr, dst, dstw, tmp));
+
+	if (is_32bit)
+		ins = WHEN(is_u12(addr.offset), src, st, sty, addr);
+	else
+		ins = stg(src, addr.offset, addr.index, addr.base);
+
+	return push_inst(compiler, ins);
+}
+
+#undef WHEN
+
+SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compiler)
+{
+	struct sljit_label *label;
+	struct sljit_jump *jump;
+	struct sljit_s390x_const *const_;
+	struct sljit_put_label *put_label;
+	sljit_sw executable_offset;
+	sljit_uw ins_size = 0; /* instructions */
+	sljit_uw pool_size = 0; /* literal pool */
+	sljit_uw pad_size;
+	sljit_uw i, j = 0;
+	struct sljit_memory_fragment *buf;
+	void *code, *code_ptr;
+	sljit_uw *pool, *pool_ptr;
+
+	sljit_uw source;
+	sljit_sw offset; /* TODO(carenas): only need 32 bit */
+
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_generate_code(compiler));
+	reverse_buf(compiler);
+
+	/* branch handling */
+	label = compiler->labels;
+	jump = compiler->jumps;
+	put_label = compiler->put_labels;
+
+	/* TODO(carenas): compiler->executable_size could be calculated
+         *                before to avoid the following loop (except for
+         *                pool_size)
+         */
+	/* calculate the size of the code */
+	for (buf = compiler->buf; buf != NULL; buf = buf->next) {
+		sljit_uw len = buf->used_size / sizeof(sljit_ins);
+		sljit_ins *ibuf = (sljit_ins *)buf->memory;
+		for (i = 0; i < len; ++i, ++j) {
+			sljit_ins ins = ibuf[i];
+
+			/* TODO(carenas): instruction tag vs size/addr == j
+			 * using instruction tags for const is creative
+			 * but unlike all other architectures, and is not
+			 * done consistently for all other objects.
+			 * This might need reviewing later.
+			 */
+			if (ins & sljit_ins_const) {
+				pool_size += sizeof(*pool);
+				ins &= ~sljit_ins_const;
+			}
+			if (label && label->size == j) {
+				label->size = ins_size;
+				label = label->next;
+			}
+			if (jump && jump->addr == j) {
+				if ((jump->flags & SLJIT_REWRITABLE_JUMP) || (jump->flags & JUMP_ADDR)) {
+					/* encoded: */
+					/*   brasl %r14, <rel_addr> (or brcl <mask>, <rel_addr>) */
+					/* replace with: */
+					/*   lgrl %r1, <pool_addr> */
+					/*   bras %r14, %r1 (or bcr <mask>, %r1) */
+					pool_size += sizeof(*pool);
+					ins_size += 2;
+				}
+				jump = jump->next;
+			}
+			if (put_label && put_label->addr == j) {
+				pool_size += sizeof(*pool);
+				put_label = put_label->next;
+			}
+			ins_size += sizeof_ins(ins);
+		}
+	}
+
+	/* emit trailing label */
+	if (label && label->size == j) {
+		label->size = ins_size;
+		label = label->next;
+	}
+
+	SLJIT_ASSERT(!label);
+	SLJIT_ASSERT(!jump);
+	SLJIT_ASSERT(!put_label);
+
+	/* pad code size to 8 bytes so is accessible with half word offsets */
+	/* the literal pool needs to be doubleword aligned */
+	pad_size = ((ins_size + 7UL) & ~7UL) - ins_size;
+	SLJIT_ASSERT(pad_size < 8UL);
+
+	/* allocate target buffer */
+	code = SLJIT_MALLOC_EXEC(ins_size + pad_size + pool_size,
+					compiler->exec_allocator_data);
+	PTR_FAIL_WITH_EXEC_IF(code);
+	code_ptr = code;
+	executable_offset = SLJIT_EXEC_OFFSET(code);
+
+	/* TODO(carenas): pool is optional, and the ABI recommends it to
+         *                be created before the function code, instead of
+         *                globally; if generated code is too big could
+         *                need offsets bigger than 32bit words and asser()
+         */
+	pool = (sljit_uw *)((sljit_uw)code + ins_size + pad_size);
+	pool_ptr = pool;
+	const_ = (struct sljit_s390x_const *)compiler->consts;
+
+	/* update label addresses */
+	label = compiler->labels;
+	while (label) {
+		label->addr = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(
+			(sljit_uw)code_ptr + label->size, executable_offset);
+		label = label->next;
+	}
+
+	/* reset jumps */
+	jump = compiler->jumps;
+	put_label = compiler->put_labels;
+
+	/* emit the code */
+	j = 0;
+	for (buf = compiler->buf; buf != NULL; buf = buf->next) {
+		sljit_uw len = buf->used_size / sizeof(sljit_ins);
+		sljit_ins *ibuf = (sljit_ins *)buf->memory;
+		for (i = 0; i < len; ++i, ++j) {
+			sljit_ins ins = ibuf[i];
+			if (ins & sljit_ins_const) {
+				/* clear the const tag */
+				ins &= ~sljit_ins_const;
+
+				/* update instruction with relative address of constant */
+				source = (sljit_uw)code_ptr;
+				offset = (sljit_uw)pool_ptr - source;
+				SLJIT_ASSERT(!(offset & 1));
+				offset >>= 1; /* halfword (not byte) offset */
+				SLJIT_ASSERT(is_s32(offset));
+				ins |= (sljit_ins)offset & 0xffffffff;
+
+				/* update address */
+				const_->const_.addr = (sljit_uw)pool_ptr;
+
+				/* store initial value into pool and update pool address */
+				*(pool_ptr++) = const_->init_value;
+
+				/* move to next constant */
+				const_ = (struct sljit_s390x_const *)const_->const_.next;
+			}
+			if (jump && jump->addr == j) {
+				sljit_sw target = (jump->flags & JUMP_LABEL) ? jump->u.label->addr : jump->u.target;
+				if ((jump->flags & SLJIT_REWRITABLE_JUMP) || (jump->flags & JUMP_ADDR)) {
+					jump->addr = (sljit_uw)pool_ptr;
+
+					/* load address into tmp1 */
+					source = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
+					offset = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(pool_ptr, executable_offset) - source;
+					SLJIT_ASSERT(!(offset & 1));
+					offset >>= 1;
+					SLJIT_ASSERT(is_s32(offset));
+					encode_inst(&code_ptr,
+						lgrl(tmp1, offset & 0xffffffff));
+
+					/* store jump target into pool and update pool address */
+					*(pool_ptr++) = target;
+
+					/* branch to tmp1 */
+					sljit_ins op = (ins >> 32) & 0xf;
+					sljit_ins arg = (ins >> 36) & 0xf;
+					switch (op) {
+					case 4: /* brcl -> bcr */
+						ins = bcr(arg, tmp1);
+						break;
+					case 5: /* brasl -> basr */
+						ins = basr(arg, tmp1);
+						break;
+					default:
+						abort();
+					}
+				}
+				else {
+					jump->addr = (sljit_uw)code_ptr + 2;
+					source = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
+					offset = target - source;
+
+					/* offset must be halfword aligned */
+					SLJIT_ASSERT(!(offset & 1));
+					offset >>= 1;
+					SLJIT_ASSERT(is_s32(offset)); /* TODO(mundaym): handle arbitrary offsets */
+
+					/* patch jump target */
+					ins |= (sljit_ins)offset & 0xffffffff;
+				}
+				jump = jump->next;
+			}
+			if (put_label && put_label->addr == j) {
+				source = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
+
+				SLJIT_ASSERT(put_label->label);
+				put_label->addr = (sljit_uw)code_ptr;
+
+				/* store target into pool */
+				*pool_ptr = put_label->label->addr;
+				offset = (sljit_uw)SLJIT_ADD_EXEC_OFFSET(pool_ptr, executable_offset) - source;
+				pool_ptr++;
+
+				SLJIT_ASSERT(!(offset & 1));
+				offset >>= 1;
+				SLJIT_ASSERT(is_s32(offset));
+				ins |= (sljit_ins)offset & 0xffffffff;
+
+				put_label = put_label->next;
+			}
+			encode_inst(&code_ptr, ins);
+		}
+	}
+	SLJIT_ASSERT((sljit_u8 *)code + ins_size == code_ptr);
+	SLJIT_ASSERT((sljit_u8 *)pool + pool_size == (sljit_u8 *)pool_ptr);
+
+	compiler->error = SLJIT_ERR_COMPILED;
+	compiler->executable_offset = executable_offset;
+	compiler->executable_size = ins_size;
+	code = SLJIT_ADD_EXEC_OFFSET(code, executable_offset);
+	code_ptr = SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
+	SLJIT_CACHE_FLUSH(code, code_ptr);
+	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
+	return code;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
+{
+	/* TODO(mundaym): implement all */
+	switch (feature_type) {
+	case SLJIT_HAS_CLZ:
+		return have_eimm() ? 1 : 0; /* FLOGR instruction */
+	case SLJIT_HAS_CMOV:
+		return have_lscond1() ? 1 : 0;
+	case SLJIT_HAS_FPU:
+		return 0;
+	}
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/*  Entry, exit                                                          */
+/* --------------------------------------------------------------------- */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
+	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
+	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
+{
+	sljit_s32 args = get_arg_count(arg_types);
+	sljit_sw frame_size;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
+	set_emit_enter(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
+
+	/* saved registers go in callee allocated save area */
+	compiler->local_size = (local_size + 0xf) & ~0xf;
+	frame_size = compiler->local_size + SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE;
+
+	FAIL_IF(push_inst(compiler, stmg(r6, r15, r6 * sizeof(sljit_sw), r15))); /* save registers TODO(MGM): optimize */
+	if (frame_size != 0) {
+		if (is_s16(-frame_size))
+			FAIL_IF(push_inst(compiler, aghi(r15, -((sljit_s16)frame_size))));
+		else if (is_s32(-frame_size))
+			FAIL_IF(push_inst(compiler, agfi(r15, -((sljit_s32)frame_size))));
+		else {
+			FAIL_IF(push_load_imm_inst(compiler, tmp1, -frame_size));
+			FAIL_IF(push_inst(compiler, la(r15, 0, tmp1, r15)));
+		}
+	}
+
+	if (args >= 1)
+		FAIL_IF(push_inst(compiler, lgr(gpr(SLJIT_S0), gpr(SLJIT_R0))));
+	if (args >= 2)
+		FAIL_IF(push_inst(compiler, lgr(gpr(SLJIT_S1), gpr(SLJIT_R1))));
+	if (args >= 3)
+		FAIL_IF(push_inst(compiler, lgr(gpr(SLJIT_S2), gpr(SLJIT_R2))));
+	SLJIT_ASSERT(args < 4);
+
+	return SLJIT_SUCCESS;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_set_context(struct sljit_compiler *compiler,
+	sljit_s32 options, sljit_s32 arg_types, sljit_s32 scratches, sljit_s32 saveds,
+	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size));
+	set_set_context(compiler, options, arg_types, scratches, saveds, fscratches, fsaveds, local_size);
+
+	/* TODO(mundaym): stack space for saved floating point registers */
+	compiler->local_size = (local_size + 0xf) & ~0xf;
+	return SLJIT_SUCCESS;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+	sljit_sw size;
+	sljit_gpr end;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_return(compiler, op, src, srcw));
+
+	FAIL_IF(emit_mov_before_return(compiler, op, src, srcw));
+
+	size = compiler->local_size + SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE + (r6 * sizeof(sljit_sw));
+	if (!is_s20(size)) {
+		FAIL_IF(push_load_imm_inst(compiler, tmp1, compiler->local_size + SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE));
+		FAIL_IF(push_inst(compiler, la(r15, 0, tmp1, r15)));
+		size = r6 * sizeof(sljit_sw);
+		end = r14; /* r15 has been restored already */
+	}
+	else
+		end = r15;
+
+	FAIL_IF(push_inst(compiler, lmg(r6, end, size, r15))); /* restore registers TODO(MGM): optimize */
+	FAIL_IF(push_inst(compiler, br(r14))); /* return */
+
+	return SLJIT_SUCCESS;
+}
+
+/* --------------------------------------------------------------------- */
+/*  Operators                                                            */
+/* --------------------------------------------------------------------- */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op0(struct sljit_compiler *compiler, sljit_s32 op)
+{
+	sljit_gpr arg0 = gpr(SLJIT_R0);
+	sljit_gpr arg1 = gpr(SLJIT_R1);
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_op0(compiler, op));
+
+	op = GET_OPCODE(op) | (op & SLJIT_I32_OP);
+	switch (op) {
+	case SLJIT_BREAKPOINT:
+		/* TODO(mundaym): insert real breakpoint? */
+	case SLJIT_NOP:
+		return push_inst(compiler, 0x0700 /* 2-byte nop */);
+	case SLJIT_LMUL_UW:
+		FAIL_IF(push_inst(compiler, mlgr(arg0, arg0)));
+		break;
+	case SLJIT_LMUL_SW:
+		/* signed multiplication from: */
+		/* Hacker's Delight, Second Edition: Chapter 8-3. */
+		FAIL_IF(push_inst(compiler, srag(tmp0, arg0, 63, 0)));
+		FAIL_IF(push_inst(compiler, srag(tmp1, arg1, 63, 0)));
+		FAIL_IF(push_inst(compiler, ngr(tmp0, arg1)));
+		FAIL_IF(push_inst(compiler, ngr(tmp1, arg0)));
+
+		/* unsigned multiplication */
+		FAIL_IF(push_inst(compiler, mlgr(arg0, arg0)));
+
+		FAIL_IF(push_inst(compiler, sgr(arg0, tmp0)));
+		FAIL_IF(push_inst(compiler, sgr(arg0, tmp1)));
+		break;
+	case SLJIT_DIV_U32:
+	case SLJIT_DIVMOD_U32:
+		FAIL_IF(push_inst(compiler, lhi(tmp0, 0)));
+		FAIL_IF(push_inst(compiler, lr(tmp1, arg0)));
+		FAIL_IF(push_inst(compiler, dlr(tmp0, arg1)));
+		FAIL_IF(push_inst(compiler, lr(arg0, tmp1))); /* quotient */
+		if (op == SLJIT_DIVMOD_U32)
+			return push_inst(compiler, lr(arg1, tmp0)); /* remainder */
+
+		return SLJIT_SUCCESS;
+	case SLJIT_DIV_S32:
+	case SLJIT_DIVMOD_S32:
+		FAIL_IF(push_inst(compiler, lhi(tmp0, 0)));
+		FAIL_IF(push_inst(compiler, lr(tmp1, arg0)));
+		FAIL_IF(push_inst(compiler, dr(tmp0, arg1)));
+		FAIL_IF(push_inst(compiler, lr(arg0, tmp1))); /* quotient */
+		if (op == SLJIT_DIVMOD_S32)
+			return push_inst(compiler, lr(arg1, tmp0)); /* remainder */
+
+		return SLJIT_SUCCESS;
+	case SLJIT_DIV_UW:
+	case SLJIT_DIVMOD_UW:
+		FAIL_IF(push_inst(compiler, lghi(tmp0, 0)));
+		FAIL_IF(push_inst(compiler, lgr(tmp1, arg0)));
+		FAIL_IF(push_inst(compiler, dlgr(tmp0, arg1)));
+		FAIL_IF(push_inst(compiler, lgr(arg0, tmp1))); /* quotient */
+		if (op == SLJIT_DIVMOD_UW)
+			return push_inst(compiler, lgr(arg1, tmp0)); /* remainder */
+
+		return SLJIT_SUCCESS;
+	case SLJIT_DIV_SW:
+	case SLJIT_DIVMOD_SW:
+		FAIL_IF(push_inst(compiler, lgr(tmp1, arg0)));
+		FAIL_IF(push_inst(compiler, dsgr(tmp0, arg1)));
+		FAIL_IF(push_inst(compiler, lgr(arg0, tmp1))); /* quotient */
+		if (op == SLJIT_DIVMOD_SW)
+			return push_inst(compiler, lgr(arg1, tmp0)); /* remainder */
+
+		return SLJIT_SUCCESS;
+	case SLJIT_ENDBR:
+		return SLJIT_SUCCESS;
+	case SLJIT_SKIP_FRAMES_BEFORE_RETURN:
+		return SLJIT_SUCCESS;
+	default:
+		SLJIT_UNREACHABLE();
+	}
+	/* swap result registers */
+	FAIL_IF(push_inst(compiler, lgr(tmp0, arg0)));
+	FAIL_IF(push_inst(compiler, lgr(arg0, arg1)));
+	return push_inst(compiler, lgr(arg1, tmp0));
+}
+
+/* LEVAL will be defined later with different parameters as needed */
+#define WHEN2(cond, i1, i2) (cond) ? LEVAL(i1) : LEVAL(i2)
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op1(struct sljit_compiler *compiler, sljit_s32 op,
+        sljit_s32 dst, sljit_sw dstw,
+        sljit_s32 src, sljit_sw srcw)
+{
+	sljit_ins ins;
+	struct addr mem;
+	sljit_gpr dst_r;
+	sljit_gpr src_r;
+	sljit_s32 opcode = GET_OPCODE(op);
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_op1(compiler, op, dst, dstw, src, srcw));
+	ADJUST_LOCAL_OFFSET(dst, dstw);
+	ADJUST_LOCAL_OFFSET(src, srcw);
+
+	if ((dst == SLJIT_UNUSED) && !HAS_FLAGS(op)) {
+		/* TODO(carenas): implement prefetch? */
+		return SLJIT_SUCCESS;
+	}
+	if (opcode >= SLJIT_MOV && opcode <= SLJIT_MOV_P) {
+		/* LOAD REGISTER */
+		if (FAST_IS_REG(dst) && FAST_IS_REG(src)) {
+			dst_r = gpr(dst);
+			src_r = gpr(src);
+			switch (opcode | (op & SLJIT_I32_OP)) {
+			/* 32-bit */
+			case SLJIT_MOV32_U8:
+				ins = llcr(dst_r, src_r);
+				break;
+			case SLJIT_MOV32_S8:
+				ins = lbr(dst_r, src_r);
+				break;
+			case SLJIT_MOV32_U16:
+				ins = llhr(dst_r, src_r);
+				break;
+			case SLJIT_MOV32_S16:
+				ins = lhr(dst_r, src_r);
+				break;
+			case SLJIT_MOV32:
+				ins = lr(dst_r, src_r);
+				break;
+			/* 64-bit */
+			case SLJIT_MOV_U8:
+				ins = llgcr(dst_r, src_r);
+				break;
+			case SLJIT_MOV_S8:
+				ins = lgbr(dst_r, src_r);
+				break;
+			case SLJIT_MOV_U16:
+				ins = llghr(dst_r, src_r);
+				break;
+			case SLJIT_MOV_S16:
+				ins = lghr(dst_r, src_r);
+				break;
+			case SLJIT_MOV_U32:
+				ins = llgfr(dst_r, src_r);
+				break;
+			case SLJIT_MOV_S32:
+				ins = lgfr(dst_r, src_r);
+				break;
+			case SLJIT_MOV:
+			case SLJIT_MOV_P:
+				ins = lgr(dst_r, src_r);
+				break;
+			default:
+				ins = 0;
+				SLJIT_UNREACHABLE();
+			}
+			FAIL_IF(push_inst(compiler, ins));
+			if (HAS_FLAGS(op)) {
+				/* only handle zero flag */
+				SLJIT_ASSERT(!(op & VARIABLE_FLAG_MASK));
+				return push_store_zero_flag(compiler, op, dst_r);
+			}
+			return SLJIT_SUCCESS;
+		}
+		/* LOAD IMMEDIATE */
+		if (FAST_IS_REG(dst) && (src & SLJIT_IMM)) {
+			switch (opcode) {
+			case SLJIT_MOV_U8:
+				srcw = (sljit_sw)((sljit_u8)(srcw));
+				break;
+			case SLJIT_MOV_S8:
+				srcw = (sljit_sw)((sljit_s8)(srcw));
+				break;
+			case SLJIT_MOV_U16:
+				srcw = (sljit_sw)((sljit_u16)(srcw));
+				break;
+			case SLJIT_MOV_S16:
+				srcw = (sljit_sw)((sljit_s16)(srcw));
+				break;
+			case SLJIT_MOV_U32:
+				srcw = (sljit_sw)((sljit_u32)(srcw));
+				break;
+			case SLJIT_MOV_S32:
+				srcw = (sljit_sw)((sljit_s32)(srcw));
+				break;
+			}
+			return push_load_imm_inst(compiler, gpr(dst), srcw);
+		}
+		/* LOAD */
+		/* TODO(carenas): avoid reg being defined later */
+		#define LEVAL(i) EVAL(i, reg, mem)
+		if (FAST_IS_REG(dst) && (src & SLJIT_MEM)) {
+			sljit_gpr reg = gpr(dst);
+
+			FAIL_IF(make_addr_bxy(compiler, &mem, src, srcw, tmp1));
+			/* TODO(carenas): convert all calls below to LEVAL */
+			switch (opcode | (op & SLJIT_I32_OP)) {
+			case SLJIT_MOV32_U8:
+				ins = llc(reg, mem.offset, mem.index, mem.base);
+				break;
+			case SLJIT_MOV32_S8:
+				ins = lb(reg, mem.offset, mem.index, mem.base);
+				break;
+			case SLJIT_MOV32_U16:
+				ins = llh(reg, mem.offset, mem.index, mem.base);
+				break;
+			case SLJIT_MOV32_S16:
+				ins = WHEN2(is_u12(mem.offset), lh, lhy);
+				break;
+			case SLJIT_MOV32:
+				ins = WHEN2(is_u12(mem.offset), l, ly);
+				break;
+			case SLJIT_MOV_U8:
+				ins = LEVAL(llgc);
+				break;
+			case SLJIT_MOV_S8:
+				ins = lgb(reg, mem.offset, mem.index, mem.base);
+				break;
+			case SLJIT_MOV_U16:
+				ins = LEVAL(llgh);
+				break;
+			case SLJIT_MOV_S16:
+				ins = lgh(reg, mem.offset, mem.index, mem.base);
+				break;
+			case SLJIT_MOV_U32:
+				ins = LEVAL(llgf);
+				break;
+			case SLJIT_MOV_S32:
+				ins = lgf(reg, mem.offset, mem.index, mem.base);
+				break;
+			case SLJIT_MOV_P:
+			case SLJIT_MOV:
+				ins = lg(reg, mem.offset, mem.index, mem.base);
+				break;
+			default:
+				SLJIT_UNREACHABLE();
+			}
+			FAIL_IF(push_inst(compiler, ins));
+			if (HAS_FLAGS(op)) {
+				/* only handle zero flag */
+				SLJIT_ASSERT(!(op & VARIABLE_FLAG_MASK));
+				return push_store_zero_flag(compiler, op, reg);
+			}
+			return SLJIT_SUCCESS;
+		}
+		/* STORE and STORE IMMEDIATE */
+		if ((dst & SLJIT_MEM)
+			&& (FAST_IS_REG(src) || (src & SLJIT_IMM))) {
+			sljit_gpr reg = FAST_IS_REG(src) ? gpr(src) : tmp0;
+			if (src & SLJIT_IMM) {
+				/* TODO(mundaym): MOVE IMMEDIATE? */
+				FAIL_IF(push_load_imm_inst(compiler, reg, srcw));
+			}
+			struct addr mem;
+			FAIL_IF(make_addr_bxy(compiler, &mem, dst, dstw, tmp1));
+			switch (opcode) {
+			case SLJIT_MOV_U8:
+			case SLJIT_MOV_S8:
+				return push_inst(compiler,
+					WHEN2(is_u12(mem.offset), stc, stcy));
+			case SLJIT_MOV_U16:
+			case SLJIT_MOV_S16:
+				return push_inst(compiler,
+					WHEN2(is_u12(mem.offset), sth, sthy));
+			case SLJIT_MOV_U32:
+			case SLJIT_MOV_S32:
+				return push_inst(compiler,
+					WHEN2(is_u12(mem.offset), st, sty));
+			case SLJIT_MOV_P:
+			case SLJIT_MOV:
+				FAIL_IF(push_inst(compiler, LEVAL(stg)));
+				if (HAS_FLAGS(op)) {
+					/* only handle zero flag */
+					SLJIT_ASSERT(!(op & VARIABLE_FLAG_MASK));
+					return push_store_zero_flag(compiler, op, reg);
+				}
+				return SLJIT_SUCCESS;
+			default:
+				SLJIT_UNREACHABLE();
+			}
+		}
+		#undef LEVAL
+		/* MOVE CHARACTERS */
+		if ((dst & SLJIT_MEM) && (src & SLJIT_MEM)) {
+			struct addr mem;
+			FAIL_IF(make_addr_bxy(compiler, &mem, src, srcw, tmp1));
+			switch (opcode) {
+			case SLJIT_MOV_U8:
+			case SLJIT_MOV_S8:
+				FAIL_IF(push_inst(compiler,
+					EVAL(llgc, tmp0, mem)));
+				FAIL_IF(make_addr_bxy(compiler, &mem, dst, dstw, tmp1));
+				return push_inst(compiler,
+					EVAL(stcy, tmp0, mem));
+			case SLJIT_MOV_U16:
+			case SLJIT_MOV_S16:
+				FAIL_IF(push_inst(compiler,
+					EVAL(llgh, tmp0, mem)));
+				FAIL_IF(make_addr_bxy(compiler, &mem, dst, dstw, tmp1));
+				return push_inst(compiler,
+					EVAL(sthy, tmp0, mem));
+			case SLJIT_MOV_U32:
+			case SLJIT_MOV_S32:
+				FAIL_IF(push_inst(compiler,
+					EVAL(ly, tmp0, mem)));
+				FAIL_IF(make_addr_bxy(compiler, &mem, dst, dstw, tmp1));
+				return push_inst(compiler,
+					EVAL(sty, tmp0, mem));
+			case SLJIT_MOV_P:
+			case SLJIT_MOV:
+				FAIL_IF(push_inst(compiler,
+					EVAL(lg, tmp0, mem)));
+				FAIL_IF(make_addr_bxy(compiler, &mem, dst, dstw, tmp1));
+				FAIL_IF(push_inst(compiler,
+					EVAL(stg, tmp0, mem)));
+				if (HAS_FLAGS(op)) {
+					/* only handle zero flag */
+					SLJIT_ASSERT(!(op & VARIABLE_FLAG_MASK));
+					return push_store_zero_flag(compiler, op, tmp0);
+				}
+				return SLJIT_SUCCESS;
+			default:
+				SLJIT_UNREACHABLE();
+			}
+		}
+		SLJIT_UNREACHABLE();
+	}
+
+	SLJIT_ASSERT((src & SLJIT_IMM) == 0); /* no immediates */
+
+	dst_r = SLOW_IS_REG(dst) ? gpr(REG_MASK & dst) : tmp0;
+	src_r = FAST_IS_REG(src) ? gpr(REG_MASK & src) : tmp0;
+	if (src & SLJIT_MEM)
+		FAIL_IF(load_word(compiler, src_r, src, srcw, tmp1, src & SLJIT_I32_OP));
+
+	/* TODO(mundaym): optimize loads and stores */
+	switch (opcode | (op & SLJIT_I32_OP)) {
+	case SLJIT_NOT:
+		/* emulate ~x with x^-1 */
+		FAIL_IF(push_load_imm_inst(compiler, tmp1, -1));
+		if (src_r != dst_r)
+			FAIL_IF(push_inst(compiler, lgr(dst_r, src_r)));
+
+		FAIL_IF(push_inst(compiler, xgr(dst_r, tmp1)));
+		break;
+	case SLJIT_NOT32:
+		/* emulate ~x with x^-1 */
+		if (have_eimm())
+			FAIL_IF(push_inst(compiler, xilf(dst_r, -1)));
+		else {
+			FAIL_IF(push_load_imm_inst(compiler, tmp1, -1));
+			if (src_r != dst_r)
+				FAIL_IF(push_inst(compiler, lr(dst_r, src_r)));
+
+			FAIL_IF(push_inst(compiler, xr(dst_r, tmp1)));
+		}
+		break;
+	case SLJIT_NEG:
+		FAIL_IF(push_inst(compiler, lcgr(dst_r, src_r)));
+		break;
+	case SLJIT_NEG32:
+		FAIL_IF(push_inst(compiler, lcr(dst_r, src_r)));
+		break;
+	case SLJIT_CLZ:
+		if (have_eimm()) {
+			FAIL_IF(push_inst(compiler, flogr(tmp0, src_r))); /* clobbers tmp1 */
+			if (dst_r != tmp0)
+				FAIL_IF(push_inst(compiler, lgr(dst_r, tmp0)));
+		} else {
+			abort(); /* TODO(mundaym): no eimm (?) */
+		}
+		break;
+	case SLJIT_CLZ32:
+		if (have_eimm()) {
+			FAIL_IF(push_inst(compiler, sllg(tmp1, src_r, 32, 0)));
+			FAIL_IF(push_inst(compiler, iilf(tmp1, 0xffffffff)));
+			FAIL_IF(push_inst(compiler, flogr(tmp0, tmp1))); /* clobbers tmp1 */
+			if (dst_r != tmp0)
+				FAIL_IF(push_inst(compiler, lr(dst_r, tmp0)));
+		} else {
+			abort(); /* TODO(mundaym): no eimm (?) */
+		}
+		break;
+	default:
+		SLJIT_UNREACHABLE();
+	}
+
+	/* write condition code to emulated flag register */
+	if (op & VARIABLE_FLAG_MASK)
+		FAIL_IF(push_inst(compiler, ipm(flag_r)));
+
+	/* write zero flag to emulated flag register */
+	if (op & SLJIT_SET_Z)
+		FAIL_IF(push_store_zero_flag(compiler, op, dst_r));
+
+	/* TODO(carenas): doesn't need FAIL_IF */
+	if ((dst != SLJIT_UNUSED) && (dst & SLJIT_MEM))
+		FAIL_IF(store_word(compiler, dst_r, dst, dstw, tmp1, op & SLJIT_I32_OP));
+
+	return SLJIT_SUCCESS;
+}
+
+static SLJIT_INLINE int is_commutative(sljit_s32 op)
+{
+	switch (GET_OPCODE(op)) {
+	case SLJIT_ADD:
+	case SLJIT_ADDC:
+	case SLJIT_MUL:
+	case SLJIT_AND:
+	case SLJIT_OR:
+	case SLJIT_XOR:
+		return 1;
+	}
+	return 0;
+}
+
+static SLJIT_INLINE int is_shift(sljit_s32 op) {
+	sljit_s32 v = GET_OPCODE(op);
+	return (v == SLJIT_SHL || v == SLJIT_ASHR || v == SLJIT_LSHR) ? 1 : 0;
+}
+
+static SLJIT_INLINE int sets_signed_flag(sljit_s32 op)
+{
+	switch (GET_FLAG_TYPE(op)) {
+	case SLJIT_OVERFLOW:
+	case SLJIT_NOT_OVERFLOW:
+	case SLJIT_SIG_LESS:
+	case SLJIT_SIG_LESS_EQUAL:
+	case SLJIT_SIG_GREATER:
+	case SLJIT_SIG_GREATER_EQUAL:
+		return 1;
+	}
+	return 0;
+}
+
+/* Report whether we have an instruction for:
+     op dst src imm
+   where dst and src are separate registers. */
+static int have_op_3_imm(sljit_s32 op, sljit_sw imm) {
+	return 0; /* TODO(mundaym): implement */
+}
+
+/* Report whether we have an instruction for:
+     op reg imm
+  where reg is both a source and the destination. */
+static int have_op_2_imm(sljit_s32 op, sljit_sw imm) {
+	switch (GET_OPCODE(op) | (op & SLJIT_I32_OP)) {
+	case SLJIT_ADD32:
+	case SLJIT_ADD:
+		if (!HAS_FLAGS(op) || sets_signed_flag(op))
+			return have_eimm() ? is_s32(imm) : is_s16(imm);
+
+		return have_eimm() && is_u32(imm);
+	case SLJIT_MUL32:
+	case SLJIT_MUL:
+		/* TODO(mundaym): general extension check */
+		/* for ms{,g}fi */
+		if (op & VARIABLE_FLAG_MASK)
+			return 0;
+
+		return have_genext() && is_s16(imm);
+	case SLJIT_OR32:
+	case SLJIT_XOR32:
+	case SLJIT_AND32:
+		/* only use if have extended immediate facility */
+		/* this ensures flags are set correctly */
+		return have_eimm();
+	case SLJIT_AND:
+	case SLJIT_OR:
+	case SLJIT_XOR:
+		/* TODO(mundaym): make this more flexible */
+		/* avoid using immediate variations, flags */
+		/* won't be set correctly */
+		return 0;
+	case SLJIT_ADDC32:
+	case SLJIT_ADDC:
+		/* no ADD LOGICAL WITH CARRY IMMEDIATE */
+		return 0;
+	case SLJIT_SUB:
+	case SLJIT_SUB32:
+	case SLJIT_SUBC:
+	case SLJIT_SUBC32:
+		/* no SUBTRACT IMMEDIATE */
+		/* TODO(mundaym): SUBTRACT LOGICAL IMMEDIATE */
+		return 0;
+	}
+	return 0;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 dst, sljit_sw dstw,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_op2(compiler, op, dst, dstw, src1, src1w, src2, src2w));
+	ADJUST_LOCAL_OFFSET(dst, dstw);
+	ADJUST_LOCAL_OFFSET(src1, src1w);
+	ADJUST_LOCAL_OFFSET(src2, src2w);
+
+	if (dst == SLJIT_UNUSED && !HAS_FLAGS(op))
+		return SLJIT_SUCCESS;
+
+	sljit_gpr dst_r = SLOW_IS_REG(dst) ? gpr(dst & REG_MASK) : tmp0;
+
+	if (is_commutative(op)) {
+		#define SWAP_ARGS \
+		do {                         \
+			sljit_s32 t = src1;  \
+			sljit_sw tw = src1w; \
+			src1 = src2;         \
+			src1w = src2w;       \
+			src2 = t;            \
+			src2w = tw;          \
+		} while(0);
+
+		/* prefer immediate in src2 */
+		if (src1 & SLJIT_IMM) {
+			SWAP_ARGS
+		}
+
+		/* prefer to have src1 use same register as dst */
+		if (FAST_IS_REG(src2) && gpr(src2 & REG_MASK) == dst_r) {
+			SWAP_ARGS
+		}
+
+		/* prefer memory argument in src2 */
+		if (FAST_IS_REG(src2) && (src1 & SLJIT_MEM)) {
+			SWAP_ARGS
+		}
+		#undef SWAP_ARGS
+	}
+
+	/* src1 must be in a register */
+	sljit_gpr src1_r = FAST_IS_REG(src1) ? gpr(src1 & REG_MASK) : tmp0;
+	if (src1 & SLJIT_IMM)
+		FAIL_IF(push_load_imm_inst(compiler, src1_r, src1w));
+
+	if (src1 & SLJIT_MEM)
+		FAIL_IF(load_word(compiler, src1_r, src1, src1w, tmp1, op & SLJIT_I32_OP));
+
+	/* emit comparison before subtract */
+	if (GET_OPCODE(op) == SLJIT_SUB && (op & VARIABLE_FLAG_MASK)) {
+		sljit_sw cmp = 0;
+		switch (GET_FLAG_TYPE(op)) {
+		case SLJIT_LESS:
+		case SLJIT_LESS_EQUAL:
+		case SLJIT_GREATER:
+		case SLJIT_GREATER_EQUAL:
+			cmp = 1; /* unsigned */
+			break;
+		case SLJIT_EQUAL:
+		case SLJIT_SIG_LESS:
+		case SLJIT_SIG_LESS_EQUAL:
+		case SLJIT_SIG_GREATER:
+		case SLJIT_SIG_GREATER_EQUAL:
+			cmp = -1; /* signed */
+			break;
+		}
+		if (cmp) {
+			/* clear flags - no need to generate now */
+			op &= ~VARIABLE_FLAG_MASK;
+			sljit_gpr src2_r = FAST_IS_REG(src2) ? gpr(src2 & REG_MASK) : tmp1;
+			if (src2 & SLJIT_IMM) {
+				#define LEVAL(i) i(src1_r, src2w)
+				if (cmp > 0 && is_u32(src2w)) {
+					/* unsigned */
+					FAIL_IF(push_inst(compiler,
+					WHEN2(op & SLJIT_I32_OP, clfi, clgfi)));
+				}
+				else if (cmp < 0 && is_s16(src2w)) {
+					/* signed */
+					FAIL_IF(push_inst(compiler,
+					WHEN2(op & SLJIT_I32_OP, chi, cghi)));
+				}
+				else if (cmp < 0 && is_s32(src2w)) {
+					/* signed */
+					FAIL_IF(push_inst(compiler,
+					WHEN2(op & SLJIT_I32_OP, cfi, cgfi)));
+				}
+				#undef LEVAL
+				#define LEVAL(i) i(src1_r, src2_r)
+				else {
+					FAIL_IF(push_load_imm_inst(compiler, src2_r, src2w));
+					if (cmp > 0) {
+						/* unsigned */
+						FAIL_IF(push_inst(compiler,
+						WHEN2(op & SLJIT_I32_OP, clr, clgr)));
+					}
+					if (cmp < 0) {
+						/* signed */
+						FAIL_IF(push_inst(compiler,
+						WHEN2(op & SLJIT_I32_OP, cr, cgr)));
+					}
+				}
+			}
+			else {
+				if (src2 & SLJIT_MEM) {
+					/* TODO(mundaym): comparisons with memory */
+					/* load src2 into register */
+					FAIL_IF(load_word(compiler, src2_r, src2, src2w, tmp1, op & SLJIT_I32_OP));
+				}
+				if (cmp > 0) {
+					/* unsigned */
+					FAIL_IF(push_inst(compiler,
+						WHEN2(op & SLJIT_I32_OP, clr, clgr)));
+				}
+				if (cmp < 0) {
+					/* signed */
+					FAIL_IF(push_inst(compiler,
+						WHEN2(op & SLJIT_I32_OP, cr, cgr)));
+				}
+				#undef LEVAL
+			}
+			FAIL_IF(push_inst(compiler, ipm(flag_r)));
+		}
+	}
+
+	if (!HAS_FLAGS(op) && dst == SLJIT_UNUSED)
+		return SLJIT_SUCCESS;
+
+	/* need to specify signed or logical operation */
+	int signed_flags = sets_signed_flag(op);
+
+	if (is_shift(op)) {
+		/* handle shifts first, they have more constraints than other operations */
+		sljit_sw d = 0;
+		sljit_gpr b = FAST_IS_REG(src2) ? gpr(src2 & REG_MASK) : r0;
+		if (src2 & SLJIT_IMM)
+			d = src2w & ((op & SLJIT_I32_OP) ? 31 : 63);
+
+		if (src2 & SLJIT_MEM) {
+			/* shift amount (b) cannot be in r0 (i.e. tmp0) */
+			FAIL_IF(load_word(compiler, tmp1, src2, src2w, tmp1, op & SLJIT_I32_OP));
+			b = tmp1;
+		}
+		/* src1 and dst share the same register in the base 32-bit ISA */
+		/* TODO(mundaym): not needed when distinct-operand facility is available */
+		int workaround_alias = op & SLJIT_I32_OP && src1_r != dst_r;
+		if (workaround_alias) {
+			/* put src1 into tmp0 so we can overwrite it */
+			FAIL_IF(push_inst(compiler, lr(tmp0, src1_r)));
+			src1_r = tmp0;
+		}
+		switch (GET_OPCODE(op) | (op & SLJIT_I32_OP)) {
+		case SLJIT_SHL:
+			FAIL_IF(push_inst(compiler, sllg(dst_r, src1_r, d, b)));
+			break;
+		case SLJIT_SHL32:
+			FAIL_IF(push_inst(compiler, sll(src1_r, d, b)));
+			break;
+		case SLJIT_LSHR:
+			FAIL_IF(push_inst(compiler, srlg(dst_r, src1_r, d, b)));
+			break;
+		case SLJIT_LSHR32:
+			FAIL_IF(push_inst(compiler, srl(src1_r, d, b)));
+			break;
+		case SLJIT_ASHR:
+			FAIL_IF(push_inst(compiler, srag(dst_r, src1_r, d, b)));
+			break;
+		case SLJIT_ASHR32:
+			FAIL_IF(push_inst(compiler, sra(src1_r, d, b)));
+			break;
+		default:
+			SLJIT_UNREACHABLE();
+		}
+		if (workaround_alias && dst_r != src1_r)
+			FAIL_IF(push_inst(compiler, lr(dst_r, src1_r)));
+
+	}
+	else if ((GET_OPCODE(op) == SLJIT_MUL) && HAS_FLAGS(op)) {
+		/* multiply instructions do not generally set flags so we need to manually */
+		/* detect overflow conditions */
+		/* TODO(mundaym): 64-bit overflow */
+		SLJIT_ASSERT(GET_FLAG_TYPE(op) == SLJIT_MUL_OVERFLOW ||
+		             GET_FLAG_TYPE(op) == SLJIT_MUL_NOT_OVERFLOW);
+		sljit_gpr src2_r = FAST_IS_REG(src2) ? gpr(src2 & REG_MASK) : tmp1;
+		if (src2 & SLJIT_IMM) {
+			/* load src2 into register */
+			FAIL_IF(push_load_imm_inst(compiler, src2_r, src2w));
+		}
+		if (src2 & SLJIT_MEM) {
+			/* load src2 into register */
+			FAIL_IF(load_word(compiler, src2_r, src2, src2w, tmp1, op & SLJIT_I32_OP));
+		}
+		if (have_misc2()) {
+			#define LEVAL(i) i(dst_r, src1_r, src2_r)
+			FAIL_IF(push_inst(compiler,
+				WHEN2(op & SLJIT_I32_OP, msrkc, msgrkc)));
+			#undef LEVAL
+		}
+		else if (op & SLJIT_I32_OP) {
+			op &= ~VARIABLE_FLAG_MASK;
+			FAIL_IF(push_inst(compiler, lgfr(tmp0, src1_r)));
+			FAIL_IF(push_inst(compiler, msgfr(tmp0, src2_r)));
+			if (dst_r != tmp0) {
+				FAIL_IF(push_inst(compiler, lr(dst_r, tmp0)));
+			}
+			FAIL_IF(push_inst(compiler, aih(tmp0, 1)));
+			FAIL_IF(push_inst(compiler, nihf(tmp0, ~1U)));
+			FAIL_IF(push_inst(compiler, ipm(flag_r)));
+			FAIL_IF(push_inst(compiler, oilh(flag_r, 0x2000)));
+		}
+		else
+			return SLJIT_ERR_UNSUPPORTED;
+
+	}
+	else if ((GET_OPCODE(op) == SLJIT_SUB) && (op & SLJIT_SET_Z) && !signed_flags) {
+		/* subtract logical instructions do not set the right flags unfortunately */
+		/* instead, negate src2 and issue an add logical */
+		/* TODO(mundaym): distinct operand facility where needed */
+		if (src1_r != dst_r && src1_r != tmp0) {
+			#define LEVAL(i) i(tmp0, src1_r)
+			FAIL_IF(push_inst(compiler,
+				WHEN2(op & SLJIT_I32_OP, lr, lgr)));
+			src1_r = tmp0;
+			#undef LEVAL
+		}
+		sljit_gpr src2_r = FAST_IS_REG(src2) ? gpr(src2 & REG_MASK) : tmp1;
+		if (src2 & SLJIT_IMM) {
+			/* load src2 into register */
+			FAIL_IF(push_load_imm_inst(compiler, src2_r, src2w));
+		}
+		if (src2 & SLJIT_MEM) {
+			/* load src2 into register */
+			FAIL_IF(load_word(compiler, src2_r, src2, src2w, tmp1, op & SLJIT_I32_OP));
+		}
+		if (op & SLJIT_I32_OP) {
+			FAIL_IF(push_inst(compiler, lcr(tmp1, src2_r)));
+			FAIL_IF(push_inst(compiler, alr(src1_r, tmp1)));
+			if (src1_r != dst_r)
+				FAIL_IF(push_inst(compiler, lr(dst_r, src1_r)));
+		}
+		else {
+			FAIL_IF(push_inst(compiler, lcgr(tmp1, src2_r)));
+			FAIL_IF(push_inst(compiler, algr(src1_r, tmp1)));
+			if (src1_r != dst_r)
+				FAIL_IF(push_inst(compiler, lgr(dst_r, src1_r)));
+		}
+	}
+	else if ((src2 & SLJIT_IMM) && (src1_r == dst_r) && have_op_2_imm(op, src2w)) {
+		switch (GET_OPCODE(op) | (op & SLJIT_I32_OP)) {
+		#define LEVAL(i) i(dst_r, src2w)
+		case SLJIT_ADD:
+			if (!HAS_FLAGS(op) || signed_flags) {
+				FAIL_IF(push_inst(compiler,
+					WHEN2(is_s16(src2w), aghi, agfi)));
+			}
+			else
+				FAIL_IF(push_inst(compiler, LEVAL(algfi)));
+
+			break;
+		case SLJIT_ADD32:
+			if (!HAS_FLAGS(op) || signed_flags)
+				FAIL_IF(push_inst(compiler,
+					WHEN2(is_s16(src2w), ahi, afi)));
+			else
+				FAIL_IF(push_inst(compiler, LEVAL(alfi)));
+
+			break;
+		#undef LEVAL /* TODO(carenas): move down and refactor? */
+		case SLJIT_MUL:
+			FAIL_IF(push_inst(compiler, mhi(dst_r, src2w)));
+			break;
+		case SLJIT_MUL32:
+			FAIL_IF(push_inst(compiler, mghi(dst_r, src2w)));
+			break;
+		case SLJIT_OR32:
+			FAIL_IF(push_inst(compiler, oilf(dst_r, src2w)));
+			break;
+		case SLJIT_XOR32:
+			FAIL_IF(push_inst(compiler, xilf(dst_r, src2w)));
+			break;
+		case SLJIT_AND32:
+			FAIL_IF(push_inst(compiler, nilf(dst_r, src2w)));
+			break;
+		default:
+			SLJIT_UNREACHABLE();
+		}
+	}
+	else if ((src2 & SLJIT_IMM) && have_op_3_imm(op, src2w)) {
+		abort(); /* TODO(mundaym): implement */
+	}
+	else if ((src2 & SLJIT_MEM) && (dst_r == src1_r)) {
+		/* most 32-bit instructions can only handle 12-bit immediate offsets */
+		int need_u12 = !have_ldisp() &&
+			(op & SLJIT_I32_OP) &&
+			(GET_OPCODE(op) != SLJIT_ADDC) &&
+			(GET_OPCODE(op) != SLJIT_SUBC);
+		struct addr mem;
+		if (need_u12)
+			FAIL_IF(make_addr_bx(compiler, &mem, src2, src2w, tmp1));
+		else
+			FAIL_IF(make_addr_bxy(compiler, &mem, src2, src2w, tmp1));
+
+		int can_u12 = is_u12(mem.offset) ? 1 : 0;
+		sljit_ins ins = 0;
+		switch (GET_OPCODE(op) | (op & SLJIT_I32_OP)) {
+		/* 64-bit ops */
+		#define LEVAL(i) EVAL(i, dst_r, mem)
+		case SLJIT_ADD:
+			ins = WHEN2(signed_flags, ag, alg);
+			break;
+		case SLJIT_SUB:
+			ins = WHEN2(signed_flags, sg, slg);
+			break;
+		case SLJIT_ADDC:
+			ins = LEVAL(alcg);
+			break;
+		case SLJIT_SUBC:
+			ins = LEVAL(slbg);
+			break;
+		case SLJIT_MUL:
+			ins = LEVAL(msg);
+			break;
+		case SLJIT_OR:
+			ins = LEVAL(og);
+			break;
+		case SLJIT_XOR:
+			ins = LEVAL(xg);
+			break;
+		case SLJIT_AND:
+			ins = LEVAL(ng);
+			break;
+		/* 32-bit ops */
+		case SLJIT_ADD32:
+			if (signed_flags)
+				ins = WHEN2(can_u12, a, ay);
+			else
+				ins = WHEN2(can_u12, al, aly);
+			break;
+		case SLJIT_SUB32:
+			if (signed_flags)
+				ins = WHEN2(can_u12, s, sy);
+			else
+				ins = WHEN2(can_u12, sl, sly);
+			break;
+		case SLJIT_ADDC32:
+			ins = LEVAL(alc);
+			break;
+		case SLJIT_SUBC32:
+			ins = LEVAL(slb);
+			break;
+		case SLJIT_MUL32:
+			ins = WHEN2(can_u12, ms, msy);
+			break;
+		case SLJIT_OR32:
+			ins = WHEN2(can_u12, o, oy);
+			break;
+		case SLJIT_XOR32:
+			ins = WHEN2(can_u12, x, xy);
+			break;
+		case SLJIT_AND32:
+			ins = WHEN2(can_u12, n, ny);
+			break;
+		#undef LEVAL
+		default:
+			SLJIT_UNREACHABLE();
+		}
+		FAIL_IF(push_inst(compiler, ins));
+	}
+	else {
+		sljit_gpr src2_r = FAST_IS_REG(src2) ? gpr(src2 & REG_MASK) : tmp1;
+		if (src2 & SLJIT_IMM) {
+			/* load src2 into register */
+			FAIL_IF(push_load_imm_inst(compiler, src2_r, src2w));
+		}
+		if (src2 & SLJIT_MEM) {
+			/* load src2 into register */
+			FAIL_IF(load_word(compiler, src2_r, src2, src2w, tmp1, op & SLJIT_I32_OP));
+		}
+		/* TODO(mundaym): distinct operand facility where needed */
+		#define LEVAL(i) i(tmp0, src1_r)
+		if (src1_r != dst_r && src1_r != tmp0) {
+			FAIL_IF(push_inst(compiler,
+				WHEN2(op & SLJIT_I32_OP, lr, lgr)));
+			src1_r = tmp0;
+		}
+		#undef LEVAL
+		sljit_ins ins = 0;
+		switch (GET_OPCODE(op) | (op & SLJIT_I32_OP)) {
+		#define LEVAL(i) i(src1_r, src2_r)
+		/* 64-bit ops */
+		case SLJIT_ADD:
+			ins = WHEN2(signed_flags, agr, algr);
+			break;
+		case SLJIT_SUB:
+			ins = WHEN2(signed_flags, sgr, slgr);
+			break;
+		case SLJIT_ADDC:
+			ins = LEVAL(alcgr);
+			break;
+		case SLJIT_SUBC:
+			ins = LEVAL(slbgr);
+			break;
+		case SLJIT_MUL:
+			ins = LEVAL(msgr);
+			break;
+		case SLJIT_AND:
+			ins = LEVAL(ngr);
+			break;
+		case SLJIT_OR:
+			ins = LEVAL(ogr);
+			break;
+		case SLJIT_XOR:
+			ins = LEVAL(xgr);
+			break;
+		/* 32-bit ops */
+		case SLJIT_ADD32:
+			ins = WHEN2(signed_flags, ar, alr);
+			break;
+		case SLJIT_SUB32:
+			ins = WHEN2(signed_flags, sr, slr);
+			break;
+		case SLJIT_ADDC32:
+			ins = LEVAL(alcr);
+			break;
+		case SLJIT_SUBC32:
+			ins = LEVAL(slbr);
+			break;
+		case SLJIT_MUL32:
+			ins = LEVAL(msr);
+			break;
+		case SLJIT_AND32:
+			ins = LEVAL(nr);
+			break;
+		case SLJIT_OR32:
+			ins = LEVAL(or);
+			break;
+		case SLJIT_XOR32:
+			ins = LEVAL(xr);
+			break;
+		#undef LEVAL
+		default:
+			SLJIT_UNREACHABLE();
+		}
+		FAIL_IF(push_inst(compiler, ins));
+		#define LEVAL(i) i(dst_r, src1_r)
+		if (src1_r != dst_r)
+			FAIL_IF(push_inst(compiler,
+				WHEN2(op & SLJIT_I32_OP, lr, lgr)));
+		#undef LEVAL
+	}
+
+	/* write condition code to emulated flag register */
+	if (op & VARIABLE_FLAG_MASK)
+		FAIL_IF(push_inst(compiler, ipm(flag_r)));
+
+	/* write zero flag to emulated flag register */
+	if (op & SLJIT_SET_Z)
+		FAIL_IF(push_store_zero_flag(compiler, op, dst_r));
+
+	/* finally write the result to memory if required */
+	if (dst & SLJIT_MEM) {
+		SLJIT_ASSERT(dst_r != tmp1);
+		/* TODO(carenas): s/FAIL_IF/ return */
+		FAIL_IF(store_word(compiler, dst_r, dst, dstw, tmp1, op & SLJIT_I32_OP));
+	}
+
+	return SLJIT_SUCCESS;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(
+	struct sljit_compiler *compiler,
+	sljit_s32 op, sljit_s32 src, sljit_sw srcw)
+{
+	sljit_gpr src_r;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
+	ADJUST_LOCAL_OFFSET(src, srcw);
+
+	switch (op) {
+	case SLJIT_FAST_RETURN:
+		src_r = FAST_IS_REG(src) ? gpr(src) : tmp1;
+		if (src & SLJIT_MEM)
+			FAIL_IF(load_word(compiler, tmp1, src, srcw, tmp1, 0));
+
+		return push_inst(compiler, br(src_r));
+	case SLJIT_SKIP_FRAMES_BEFORE_FAST_RETURN:
+		/* TODO(carenas): implement? */
+		return SLJIT_SUCCESS;
+	case SLJIT_PREFETCH_L1:
+	case SLJIT_PREFETCH_L2:
+	case SLJIT_PREFETCH_L3:
+	case SLJIT_PREFETCH_ONCE:
+		/* TODO(carenas): implement */
+		return SLJIT_SUCCESS;
+	default:
+                /* TODO(carenas): probably should not success by default */
+		return SLJIT_SUCCESS;
+	}
+
+	return SLJIT_SUCCESS;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_register_index(sljit_s32 reg)
+{
+	CHECK_REG_INDEX(check_sljit_get_register_index(reg));
+	return gpr(reg);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_float_register_index(sljit_s32 reg)
+{
+	CHECK_REG_INDEX(check_sljit_get_float_register_index(reg));
+	abort();
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_custom(struct sljit_compiler *compiler,
+	void *instruction, sljit_s32 size)
+{
+	sljit_ins ins = 0;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_op_custom(compiler, instruction, size));
+
+	memcpy((sljit_u8 *)&ins + sizeof(ins) - size, instruction, size);
+	return push_inst(compiler, ins);
+}
+
+/* --------------------------------------------------------------------- */
+/*  Floating point operators                                             */
+/* --------------------------------------------------------------------- */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop1(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 dst, sljit_sw dstw,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	abort();
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop2(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 dst, sljit_sw dstw,
+	sljit_s32 src1, sljit_sw src1w,
+	sljit_s32 src2, sljit_sw src2w)
+{
+	CHECK_ERROR();
+	abort();
+}
+
+/* --------------------------------------------------------------------- */
+/*  Other instructions                                                   */
+/* --------------------------------------------------------------------- */
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_fast_enter(compiler, dst, dstw));
+	ADJUST_LOCAL_OFFSET(dst, dstw);
+
+	if (FAST_IS_REG(dst))
+		return push_inst(compiler, lgr(gpr(dst), fast_link_r));
+
+	/* memory */
+	return store_word(compiler, fast_link_r, dst, dstw, tmp1, 0);
+}
+
+/* --------------------------------------------------------------------- */
+/*  Conditional instructions                                             */
+/* --------------------------------------------------------------------- */
+
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_label* sljit_emit_label(struct sljit_compiler *compiler)
+{
+	struct sljit_label *label;
+
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_label(compiler));
+
+	if (compiler->last_label && compiler->last_label->size == compiler->size)
+		return compiler->last_label;
+
+	label = (struct sljit_label*)ensure_abuf(compiler, sizeof(struct sljit_label));
+	PTR_FAIL_IF(!label);
+	set_label(label, compiler);
+	return label;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type)
+{
+	sljit_u8 mask = ((type & 0xff) < SLJIT_JUMP) ? get_cc(type & 0xff) : 0xf;
+
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_jump(compiler, type));
+
+	/* reload condition code */
+	if (mask != 0xf)
+		PTR_FAIL_IF(push_load_cc(compiler, type & 0xff));
+
+	/* record jump */
+	struct sljit_jump *jump = (struct sljit_jump *)
+		ensure_abuf(compiler, sizeof(struct sljit_jump));
+	PTR_FAIL_IF(!jump);
+	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
+	jump->addr = compiler->size;
+
+	/* emit jump instruction */
+	type &= 0xff;
+	if (type >= SLJIT_FAST_CALL)
+		PTR_FAIL_IF(push_inst(compiler, brasl(type == SLJIT_FAST_CALL ? fast_link_r : link_r, 0)));
+	else
+		PTR_FAIL_IF(push_inst(compiler, brcl(mask, 0)));
+
+	return jump;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 arg_types)
+{
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
+
+#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
+		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
+	compiler->skip_checks = 1;
+#endif
+
+	return sljit_emit_jump(compiler, type);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
+{
+	sljit_gpr src_r = FAST_IS_REG(src) ? gpr(src) : tmp1;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_ijump(compiler, type, src, srcw));
+	ADJUST_LOCAL_OFFSET(src, srcw);
+
+	if (src & SLJIT_IMM) {
+		SLJIT_ASSERT(!(srcw & 1)); /* target address must be even */
+		FAIL_IF(push_load_imm_inst(compiler, src_r, srcw));
+	}
+	else if (src & SLJIT_MEM)
+		FAIL_IF(load_word(compiler, src_r, src, srcw, tmp1, 0 /* 64-bit */));
+
+	/* emit jump instruction */
+	if (type >= SLJIT_FAST_CALL)
+		return push_inst(compiler, basr(type == SLJIT_FAST_CALL ? fast_link_r : link_r, src_r));
+
+	return push_inst(compiler, br(src_r));
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_icall(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 arg_types,
+	sljit_s32 src, sljit_sw srcw)
+{
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_icall(compiler, type, arg_types, src, srcw));
+
+#if (defined SLJIT_VERBOSE && SLJIT_VERBOSE) \
+		|| (defined SLJIT_ARGUMENT_CHECKS && SLJIT_ARGUMENT_CHECKS)
+	compiler->skip_checks = 1;
+#endif
+
+	return sljit_emit_ijump(compiler, type, src, srcw);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op,
+	sljit_s32 dst, sljit_sw dstw,
+	sljit_s32 type)
+{
+	sljit_u8 mask = get_cc(type & 0xff);
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, type));
+
+	sljit_gpr dst_r = FAST_IS_REG(dst) ? gpr(dst & REG_MASK) : tmp0;
+	sljit_gpr loc_r = tmp1;
+	switch (GET_OPCODE(op)) {
+	case SLJIT_AND:
+	case SLJIT_OR:
+	case SLJIT_XOR:
+		/* dst is also source operand */
+		if (dst & SLJIT_MEM)
+			FAIL_IF(load_word(compiler, dst_r, dst, dstw, tmp1, op & SLJIT_I32_OP));
+
+		break;
+	case SLJIT_MOV:
+	case (SLJIT_MOV32 & ~SLJIT_I32_OP):
+		/* can write straight into destination */
+		loc_r = dst_r;
+		break;
+	default:
+		SLJIT_UNREACHABLE();
+	}
+
+	if (mask != 0xf)
+		FAIL_IF(push_load_cc(compiler, type & 0xff));
+
+	/* TODO(mundaym): fold into cmov helper function? */
+	#define LEVAL(i) i(loc_r, 1, mask)
+	if (have_lscond2()) {
+		FAIL_IF(push_load_imm_inst(compiler, loc_r, 0));
+		FAIL_IF(push_inst(compiler,
+			WHEN2(op & SLJIT_I32_OP, lochi, locghi)));
+	} else {
+		/* TODO(mundaym): no load/store-on-condition 2 facility (ipm? branch-and-set?) */
+		abort();
+	}
+	#undef LEVAL
+
+	/* apply bitwise op and set condition codes */
+	switch (GET_OPCODE(op)) {
+	#define LEVAL(i) i(dst_r, loc_r)
+	case SLJIT_AND:
+		FAIL_IF(push_inst(compiler,
+			WHEN2(op & SLJIT_I32_OP, nr, ngr)));
+		break;
+	case SLJIT_OR:
+		FAIL_IF(push_inst(compiler,
+			WHEN2(op & SLJIT_I32_OP, or, ogr)));
+		break;
+	case SLJIT_XOR:
+		FAIL_IF(push_inst(compiler,
+			WHEN2(op & SLJIT_I32_OP, xr, xgr)));
+		break;
+	#undef LEVAL
+	}
+
+	/* set zero flag if needed */
+	if (op & SLJIT_SET_Z)
+		FAIL_IF(push_store_zero_flag(compiler, op, dst_r));
+
+	/* store result to memory if required */
+	/* TODO(carenas): s/FAIL_IF/ return */
+	if (dst & SLJIT_MEM)
+		FAIL_IF(store_word(compiler, dst_r, dst, dstw, tmp1, op & SLJIT_I32_OP));
+
+	return SLJIT_SUCCESS;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_cmov(struct sljit_compiler *compiler, sljit_s32 type,
+	sljit_s32 dst_reg,
+	sljit_s32 src, sljit_sw srcw)
+{
+	sljit_u8 mask = get_cc(type & 0xff);
+	sljit_gpr dst_r = gpr(dst_reg & ~SLJIT_I32_OP);
+	sljit_gpr src_r = FAST_IS_REG(src) ? gpr(src) : tmp0;
+
+	CHECK_ERROR();
+	CHECK(check_sljit_emit_cmov(compiler, type, dst_reg, src, srcw));
+
+	if (mask != 0xf)
+		FAIL_IF(push_load_cc(compiler, type & 0xff));
+
+	if (src & SLJIT_IMM) {
+		/* TODO(mundaym): fast path with lscond2 */
+		FAIL_IF(push_load_imm_inst(compiler, src_r, srcw));
+	}
+
+	#define LEVAL(i) i(dst_r, src_r, mask)
+	if (have_lscond1())
+		return push_inst(compiler,
+			WHEN2(dst_reg & SLJIT_I32_OP, locr, locgr));
+
+	#undef LEVAL
+
+	/* TODO(mundaym): implement */
+	return SLJIT_ERR_UNSUPPORTED;
+}
+
+/* --------------------------------------------------------------------- */
+/*  Other instructions                                                   */
+/* --------------------------------------------------------------------- */
+
+/* On s390x we build a literal pool to hold constants. This has two main
+   advantages:
+
+     1. we only need one instruction in the instruction stream (LGRL)
+     2. we can store 64 bit addresses and use 32 bit offsets
+
+   To retrofit the extra information needed to build the literal pool we
+   add a new sljit_s390x_const struct that contains the initial value but
+   can still be cast to a sljit_const. */
+
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_const* sljit_emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw init_value)
+{
+	struct sljit_s390x_const *const_;
+	sljit_gpr dst_r;
+
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_const(compiler, dst, dstw, init_value));
+
+	const_ = (struct sljit_s390x_const*)ensure_abuf(compiler,
+					sizeof(struct sljit_s390x_const));
+	PTR_FAIL_IF(!const_);
+	set_const((struct sljit_const*)const_, compiler);
+	const_->init_value = init_value;
+
+	dst_r = FAST_IS_REG(dst) ? gpr(dst & REG_MASK) : tmp0;
+	if (have_genext())
+		PTR_FAIL_IF(push_inst(compiler, sljit_ins_const | lgrl(dst_r, 0)));
+	else {
+		PTR_FAIL_IF(push_inst(compiler, sljit_ins_const | larl(tmp1, 0)));
+		PTR_FAIL_IF(push_inst(compiler, lg(dst_r, 0, r0, tmp1)));
+	}
+
+	if (dst & SLJIT_MEM)
+		PTR_FAIL_IF(store_word(compiler, dst_r, dst, dstw, tmp1, 0 /* always 64-bit */));
+
+	return (struct sljit_const*)const_;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
+{
+	/* Update the constant pool. */
+	sljit_uw *ptr = (sljit_uw *)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
+
+	SLJIT_UPDATE_WX_FLAGS(ptr, ptr + 1, 0);
+	*ptr = new_target;
+	SLJIT_UPDATE_WX_FLAGS(ptr, ptr + 1, 1);
+	SLJIT_CACHE_FLUSH(ptr, ptr + 1);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
+{
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE struct sljit_put_label *sljit_emit_put_label(
+	struct sljit_compiler *compiler,
+	sljit_s32 dst, sljit_sw dstw)
+{
+	struct sljit_put_label *put_label;
+	sljit_gpr dst_r;
+
+	CHECK_ERROR_PTR();
+	CHECK_PTR(check_sljit_emit_put_label(compiler, dst, dstw));
+	ADJUST_LOCAL_OFFSET(dst, dstw);
+
+	put_label = (struct sljit_put_label*)ensure_abuf(compiler, sizeof(struct sljit_put_label));
+	PTR_FAIL_IF(!put_label);
+	set_put_label(put_label, compiler, 0);
+
+	dst_r = FAST_IS_REG(dst) ? gpr(dst & REG_MASK) : tmp0;
+
+	if (have_genext())
+		PTR_FAIL_IF(push_inst(compiler, lgrl(dst_r, 0)));
+	else {
+		PTR_FAIL_IF(push_inst(compiler, larl(tmp1, 0)));
+		PTR_FAIL_IF(push_inst(compiler, lg(dst_r, 0, r0, tmp1)));
+	}
+
+	if (dst & SLJIT_MEM)
+		PTR_FAIL_IF(store_word(compiler, dst_r, dst, dstw, tmp1, 0));
+
+	return put_label;
+}
+
+/* TODO(carenas): EVAL probably should move up or be refactored */
+#undef WHEN2
+#undef EVAL
+
+#undef tmp1
+#undef tmp0
+
+/* TODO(carenas): undef other macros that spill like is_u12? */
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_32.c b/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_32.c
index 8079fad8df..e5167f02ba 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_32.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_32.c
@@ -266,21 +266,18 @@ static SLJIT_INLINE sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	sljit_ins *inst = (sljit_ins *)addr;
+	SLJIT_UNUSED_ARG(executable_offset);
 
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 0);
 	SLJIT_ASSERT(((inst[0] & 0xc1c00000) == 0x01000000) && ((inst[1] & 0xc1f82000) == 0x80102000));
 	inst[0] = (inst[0] & 0xffc00000) | ((new_target >> 10) & 0x3fffff);
 	inst[1] = (inst[1] & 0xfffffc00) | (new_target & 0x3ff);
+	SLJIT_UPDATE_WX_FLAGS(inst, inst + 2, 1);
 	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
 	SLJIT_CACHE_FLUSH(inst, inst + 2);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
-	sljit_ins *inst = (sljit_ins *)addr;
-
-	SLJIT_ASSERT(((inst[0] & 0xc1c00000) == 0x01000000) && ((inst[1] & 0xc1f82000) == 0x80102000));
-	inst[0] = (inst[0] & 0xffc00000) | ((new_constant >> 10) & 0x3fffff);
-	inst[1] = (inst[1] & 0xfffffc00) | (new_constant & 0x3ff);
-	inst = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(inst, executable_offset);
-	SLJIT_CACHE_FLUSH(inst, inst + 2);
+	sljit_set_jump_addr(addr, new_constant, executable_offset);
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_common.c b/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_common.c
index 7d6be6ca3c..544d80d028 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_common.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeSPARC_common.c
@@ -311,7 +311,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	CHECK_PTR(check_sljit_generate_code(compiler));
 	reverse_buf(compiler);
 
-	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins));
+	code = (sljit_ins*)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins), compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
@@ -437,6 +437,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	code_ptr = (sljit_ins *)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset);
 
 	SLJIT_CACHE_FLUSH(code, code_ptr);
+	SLJIT_UPDATE_WX_FLAGS(code, code_ptr, 1);
 	return code;
 }
 
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX-encoder.c b/src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX-encoder.c
deleted file mode 100644
index dd82ebae6a..0000000000
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX-encoder.c
+++ /dev/null
@@ -1,10159 +0,0 @@
-/*
- *    Stack-less Just-In-Time compiler
- *
- *    Copyright 2013-2013 Tilera Corporation(jiwang@tilera.com). All rights reserved.
- *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are
- * permitted provided that the following conditions are met:
- *
- *   1. Redistributions of source code must retain the above copyright notice, this list of
- *      conditions and the following disclaimer.
- *
- *   2. Redistributions in binary form must reproduce the above copyright notice, this list
- *      of conditions and the following disclaimer in the documentation and/or other materials
- *      provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
- * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* This code is owned by Tilera Corporation, and distributed as part
-   of multiple projects. In sljit, the code is under BSD licence.  */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#define BFD_RELOC(x) R_##x
-
-/* Special registers. */
-#define TREG_LR 55
-#define TREG_SN 56
-#define TREG_ZERO 63
-
-/* Canonical name of each register. */
-const char *const tilegx_register_names[] =
-{
-  "r0",   "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
-  "r8",   "r9",  "r10", "r11", "r12", "r13", "r14", "r15",
-  "r16",  "r17", "r18", "r19", "r20", "r21", "r22", "r23",
-  "r24",  "r25", "r26", "r27", "r28", "r29", "r30", "r31",
-  "r32",  "r33", "r34", "r35", "r36", "r37", "r38", "r39",
-  "r40",  "r41", "r42", "r43", "r44", "r45", "r46", "r47",
-  "r48",  "r49", "r50", "r51", "r52", "tp",  "sp",  "lr",
-  "sn",  "idn0", "idn1", "udn0", "udn1", "udn2", "udn3", "zero"
-};
-
-enum
-{
-  R_NONE = 0,
-  R_TILEGX_NONE = 0,
-  R_TILEGX_64 = 1,
-  R_TILEGX_32 = 2,
-  R_TILEGX_16 = 3,
-  R_TILEGX_8 = 4,
-  R_TILEGX_64_PCREL = 5,
-  R_TILEGX_32_PCREL = 6,
-  R_TILEGX_16_PCREL = 7,
-  R_TILEGX_8_PCREL = 8,
-  R_TILEGX_HW0 = 9,
-  R_TILEGX_HW1 = 10,
-  R_TILEGX_HW2 = 11,
-  R_TILEGX_HW3 = 12,
-  R_TILEGX_HW0_LAST = 13,
-  R_TILEGX_HW1_LAST = 14,
-  R_TILEGX_HW2_LAST = 15,
-  R_TILEGX_COPY = 16,
-  R_TILEGX_GLOB_DAT = 17,
-  R_TILEGX_JMP_SLOT = 18,
-  R_TILEGX_RELATIVE = 19,
-  R_TILEGX_BROFF_X1 = 20,
-  R_TILEGX_JUMPOFF_X1 = 21,
-  R_TILEGX_JUMPOFF_X1_PLT = 22,
-  R_TILEGX_IMM8_X0 = 23,
-  R_TILEGX_IMM8_Y0 = 24,
-  R_TILEGX_IMM8_X1 = 25,
-  R_TILEGX_IMM8_Y1 = 26,
-  R_TILEGX_DEST_IMM8_X1 = 27,
-  R_TILEGX_MT_IMM14_X1 = 28,
-  R_TILEGX_MF_IMM14_X1 = 29,
-  R_TILEGX_MMSTART_X0 = 30,
-  R_TILEGX_MMEND_X0 = 31,
-  R_TILEGX_SHAMT_X0 = 32,
-  R_TILEGX_SHAMT_X1 = 33,
-  R_TILEGX_SHAMT_Y0 = 34,
-  R_TILEGX_SHAMT_Y1 = 35,
-  R_TILEGX_IMM16_X0_HW0 = 36,
-  R_TILEGX_IMM16_X1_HW0 = 37,
-  R_TILEGX_IMM16_X0_HW1 = 38,
-  R_TILEGX_IMM16_X1_HW1 = 39,
-  R_TILEGX_IMM16_X0_HW2 = 40,
-  R_TILEGX_IMM16_X1_HW2 = 41,
-  R_TILEGX_IMM16_X0_HW3 = 42,
-  R_TILEGX_IMM16_X1_HW3 = 43,
-  R_TILEGX_IMM16_X0_HW0_LAST = 44,
-  R_TILEGX_IMM16_X1_HW0_LAST = 45,
-  R_TILEGX_IMM16_X0_HW1_LAST = 46,
-  R_TILEGX_IMM16_X1_HW1_LAST = 47,
-  R_TILEGX_IMM16_X0_HW2_LAST = 48,
-  R_TILEGX_IMM16_X1_HW2_LAST = 49,
-  R_TILEGX_IMM16_X0_HW0_PCREL = 50,
-  R_TILEGX_IMM16_X1_HW0_PCREL = 51,
-  R_TILEGX_IMM16_X0_HW1_PCREL = 52,
-  R_TILEGX_IMM16_X1_HW1_PCREL = 53,
-  R_TILEGX_IMM16_X0_HW2_PCREL = 54,
-  R_TILEGX_IMM16_X1_HW2_PCREL = 55,
-  R_TILEGX_IMM16_X0_HW3_PCREL = 56,
-  R_TILEGX_IMM16_X1_HW3_PCREL = 57,
-  R_TILEGX_IMM16_X0_HW0_LAST_PCREL = 58,
-  R_TILEGX_IMM16_X1_HW0_LAST_PCREL = 59,
-  R_TILEGX_IMM16_X0_HW1_LAST_PCREL = 60,
-  R_TILEGX_IMM16_X1_HW1_LAST_PCREL = 61,
-  R_TILEGX_IMM16_X0_HW2_LAST_PCREL = 62,
-  R_TILEGX_IMM16_X1_HW2_LAST_PCREL = 63,
-  R_TILEGX_IMM16_X0_HW0_GOT = 64,
-  R_TILEGX_IMM16_X1_HW0_GOT = 65,
-
-  R_TILEGX_IMM16_X0_HW0_PLT_PCREL = 66,
-  R_TILEGX_IMM16_X1_HW0_PLT_PCREL = 67,
-  R_TILEGX_IMM16_X0_HW1_PLT_PCREL = 68,
-  R_TILEGX_IMM16_X1_HW1_PLT_PCREL = 69,
-  R_TILEGX_IMM16_X0_HW2_PLT_PCREL = 70,
-  R_TILEGX_IMM16_X1_HW2_PLT_PCREL = 71,
-
-  R_TILEGX_IMM16_X0_HW0_LAST_GOT = 72,
-  R_TILEGX_IMM16_X1_HW0_LAST_GOT = 73,
-  R_TILEGX_IMM16_X0_HW1_LAST_GOT = 74,
-  R_TILEGX_IMM16_X1_HW1_LAST_GOT = 75,
-  R_TILEGX_IMM16_X0_HW0_TLS_GD = 78,
-  R_TILEGX_IMM16_X1_HW0_TLS_GD = 79,
-  R_TILEGX_IMM16_X0_HW0_TLS_LE = 80,
-  R_TILEGX_IMM16_X1_HW0_TLS_LE = 81,
-  R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE = 82,
-  R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE = 83,
-  R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE = 84,
-  R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE = 85,
-  R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD = 86,
-  R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD = 87,
-  R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD = 88,
-  R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD = 89,
-  R_TILEGX_IMM16_X0_HW0_TLS_IE = 92,
-  R_TILEGX_IMM16_X1_HW0_TLS_IE = 93,
-
-  R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL = 94,
-  R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL = 95,
-  R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL = 96,
-  R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL = 97,
-  R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL = 98,
-  R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL = 99,
-
-  R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE = 100,
-  R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE = 101,
-  R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE = 102,
-  R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE = 103,
-  R_TILEGX_TLS_DTPMOD64 = 106,
-  R_TILEGX_TLS_DTPOFF64 = 107,
-  R_TILEGX_TLS_TPOFF64 = 108,
-  R_TILEGX_TLS_DTPMOD32 = 109,
-  R_TILEGX_TLS_DTPOFF32 = 110,
-  R_TILEGX_TLS_TPOFF32 = 111,
-  R_TILEGX_TLS_GD_CALL = 112,
-  R_TILEGX_IMM8_X0_TLS_GD_ADD = 113,
-  R_TILEGX_IMM8_X1_TLS_GD_ADD = 114,
-  R_TILEGX_IMM8_Y0_TLS_GD_ADD = 115,
-  R_TILEGX_IMM8_Y1_TLS_GD_ADD = 116,
-  R_TILEGX_TLS_IE_LOAD = 117,
-  R_TILEGX_IMM8_X0_TLS_ADD = 118,
-  R_TILEGX_IMM8_X1_TLS_ADD = 119,
-  R_TILEGX_IMM8_Y0_TLS_ADD = 120,
-  R_TILEGX_IMM8_Y1_TLS_ADD = 121,
-  R_TILEGX_GNU_VTINHERIT = 128,
-  R_TILEGX_GNU_VTENTRY = 129,
-  R_TILEGX_IRELATIVE = 130,
-  R_TILEGX_NUM = 131
-};
-
-typedef enum
-{
-  TILEGX_PIPELINE_X0,
-  TILEGX_PIPELINE_X1,
-  TILEGX_PIPELINE_Y0,
-  TILEGX_PIPELINE_Y1,
-  TILEGX_PIPELINE_Y2,
-} tilegx_pipeline;
-
-typedef unsigned long long tilegx_bundle_bits;
-
-/* These are the bits that determine if a bundle is in the X encoding. */
-#define TILEGX_BUNDLE_MODE_MASK ((tilegx_bundle_bits)3 << 62)
-
-enum
-{
-  /* Maximum number of instructions in a bundle (2 for X, 3 for Y). */
-  TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE = 3,
-
-  /* How many different pipeline encodings are there? X0, X1, Y0, Y1, Y2. */
-  TILEGX_NUM_PIPELINE_ENCODINGS = 5,
-
-  /* Log base 2 of TILEGX_BUNDLE_SIZE_IN_BYTES. */
-  TILEGX_LOG2_BUNDLE_SIZE_IN_BYTES = 3,
-
-  /* Instructions take this many bytes. */
-  TILEGX_BUNDLE_SIZE_IN_BYTES = 1 << TILEGX_LOG2_BUNDLE_SIZE_IN_BYTES,
-
-  /* Log base 2 of TILEGX_BUNDLE_ALIGNMENT_IN_BYTES. */
-  TILEGX_LOG2_BUNDLE_ALIGNMENT_IN_BYTES = 3,
-
-  /* Bundles should be aligned modulo this number of bytes. */
-  TILEGX_BUNDLE_ALIGNMENT_IN_BYTES =
-    (1 << TILEGX_LOG2_BUNDLE_ALIGNMENT_IN_BYTES),
-
-  /* Number of registers (some are magic, such as network I/O). */
-  TILEGX_NUM_REGISTERS = 64,
-};
-
-/* Make a few "tile_" variables to simplify common code between
-   architectures.  */
-
-typedef tilegx_bundle_bits tile_bundle_bits;
-#define TILE_BUNDLE_SIZE_IN_BYTES TILEGX_BUNDLE_SIZE_IN_BYTES
-#define TILE_BUNDLE_ALIGNMENT_IN_BYTES TILEGX_BUNDLE_ALIGNMENT_IN_BYTES
-#define TILE_LOG2_BUNDLE_ALIGNMENT_IN_BYTES \
-  TILEGX_LOG2_BUNDLE_ALIGNMENT_IN_BYTES
-
-/* 64-bit pattern for a { bpt ; nop } bundle. */
-#define TILEGX_BPT_BUNDLE 0x286a44ae51485000ULL
-
-typedef enum
-{
-  TILEGX_OP_TYPE_REGISTER,
-  TILEGX_OP_TYPE_IMMEDIATE,
-  TILEGX_OP_TYPE_ADDRESS,
-  TILEGX_OP_TYPE_SPR
-} tilegx_operand_type;
-
-struct tilegx_operand
-{
-  /* Is this operand a register, immediate or address? */
-  tilegx_operand_type type;
-
-  /* The default relocation type for this operand.  */
-  signed int default_reloc : 16;
-
-  /* How many bits is this value? (used for range checking) */
-  unsigned int num_bits : 5;
-
-  /* Is the value signed? (used for range checking) */
-  unsigned int is_signed : 1;
-
-  /* Is this operand a source register? */
-  unsigned int is_src_reg : 1;
-
-  /* Is this operand written? (i.e. is it a destination register) */
-  unsigned int is_dest_reg : 1;
-
-  /* Is this operand PC-relative? */
-  unsigned int is_pc_relative : 1;
-
-  /* By how many bits do we right shift the value before inserting? */
-  unsigned int rightshift : 2;
-
-  /* Return the bits for this operand to be ORed into an existing bundle. */
-  tilegx_bundle_bits (*insert) (int op);
-
-  /* Extract this operand and return it. */
-  unsigned int (*extract) (tilegx_bundle_bits bundle);
-};
-
-typedef enum
-{
-  TILEGX_OPC_BPT,
-  TILEGX_OPC_INFO,
-  TILEGX_OPC_INFOL,
-  TILEGX_OPC_LD4S_TLS,
-  TILEGX_OPC_LD_TLS,
-  TILEGX_OPC_MOVE,
-  TILEGX_OPC_MOVEI,
-  TILEGX_OPC_MOVELI,
-  TILEGX_OPC_PREFETCH,
-  TILEGX_OPC_PREFETCH_ADD_L1,
-  TILEGX_OPC_PREFETCH_ADD_L1_FAULT,
-  TILEGX_OPC_PREFETCH_ADD_L2,
-  TILEGX_OPC_PREFETCH_ADD_L2_FAULT,
-  TILEGX_OPC_PREFETCH_ADD_L3,
-  TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  TILEGX_OPC_PREFETCH_L1,
-  TILEGX_OPC_PREFETCH_L1_FAULT,
-  TILEGX_OPC_PREFETCH_L2,
-  TILEGX_OPC_PREFETCH_L2_FAULT,
-  TILEGX_OPC_PREFETCH_L3,
-  TILEGX_OPC_PREFETCH_L3_FAULT,
-  TILEGX_OPC_RAISE,
-  TILEGX_OPC_ADD,
-  TILEGX_OPC_ADDI,
-  TILEGX_OPC_ADDLI,
-  TILEGX_OPC_ADDX,
-  TILEGX_OPC_ADDXI,
-  TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXSC,
-  TILEGX_OPC_AND,
-  TILEGX_OPC_ANDI,
-  TILEGX_OPC_BEQZ,
-  TILEGX_OPC_BEQZT,
-  TILEGX_OPC_BFEXTS,
-  TILEGX_OPC_BFEXTU,
-  TILEGX_OPC_BFINS,
-  TILEGX_OPC_BGEZ,
-  TILEGX_OPC_BGEZT,
-  TILEGX_OPC_BGTZ,
-  TILEGX_OPC_BGTZT,
-  TILEGX_OPC_BLBC,
-  TILEGX_OPC_BLBCT,
-  TILEGX_OPC_BLBS,
-  TILEGX_OPC_BLBST,
-  TILEGX_OPC_BLEZ,
-  TILEGX_OPC_BLEZT,
-  TILEGX_OPC_BLTZ,
-  TILEGX_OPC_BLTZT,
-  TILEGX_OPC_BNEZ,
-  TILEGX_OPC_BNEZT,
-  TILEGX_OPC_CLZ,
-  TILEGX_OPC_CMOVEQZ,
-  TILEGX_OPC_CMOVNEZ,
-  TILEGX_OPC_CMPEQ,
-  TILEGX_OPC_CMPEQI,
-  TILEGX_OPC_CMPEXCH,
-  TILEGX_OPC_CMPEXCH4,
-  TILEGX_OPC_CMPLES,
-  TILEGX_OPC_CMPLEU,
-  TILEGX_OPC_CMPLTS,
-  TILEGX_OPC_CMPLTSI,
-  TILEGX_OPC_CMPLTU,
-  TILEGX_OPC_CMPLTUI,
-  TILEGX_OPC_CMPNE,
-  TILEGX_OPC_CMUL,
-  TILEGX_OPC_CMULA,
-  TILEGX_OPC_CMULAF,
-  TILEGX_OPC_CMULF,
-  TILEGX_OPC_CMULFR,
-  TILEGX_OPC_CMULH,
-  TILEGX_OPC_CMULHR,
-  TILEGX_OPC_CRC32_32,
-  TILEGX_OPC_CRC32_8,
-  TILEGX_OPC_CTZ,
-  TILEGX_OPC_DBLALIGN,
-  TILEGX_OPC_DBLALIGN2,
-  TILEGX_OPC_DBLALIGN4,
-  TILEGX_OPC_DBLALIGN6,
-  TILEGX_OPC_DRAIN,
-  TILEGX_OPC_DTLBPR,
-  TILEGX_OPC_EXCH,
-  TILEGX_OPC_EXCH4,
-  TILEGX_OPC_FDOUBLE_ADD_FLAGS,
-  TILEGX_OPC_FDOUBLE_ADDSUB,
-  TILEGX_OPC_FDOUBLE_MUL_FLAGS,
-  TILEGX_OPC_FDOUBLE_PACK1,
-  TILEGX_OPC_FDOUBLE_PACK2,
-  TILEGX_OPC_FDOUBLE_SUB_FLAGS,
-  TILEGX_OPC_FDOUBLE_UNPACK_MAX,
-  TILEGX_OPC_FDOUBLE_UNPACK_MIN,
-  TILEGX_OPC_FETCHADD,
-  TILEGX_OPC_FETCHADD4,
-  TILEGX_OPC_FETCHADDGEZ,
-  TILEGX_OPC_FETCHADDGEZ4,
-  TILEGX_OPC_FETCHAND,
-  TILEGX_OPC_FETCHAND4,
-  TILEGX_OPC_FETCHOR,
-  TILEGX_OPC_FETCHOR4,
-  TILEGX_OPC_FINV,
-  TILEGX_OPC_FLUSH,
-  TILEGX_OPC_FLUSHWB,
-  TILEGX_OPC_FNOP,
-  TILEGX_OPC_FSINGLE_ADD1,
-  TILEGX_OPC_FSINGLE_ADDSUB2,
-  TILEGX_OPC_FSINGLE_MUL1,
-  TILEGX_OPC_FSINGLE_MUL2,
-  TILEGX_OPC_FSINGLE_PACK1,
-  TILEGX_OPC_FSINGLE_PACK2,
-  TILEGX_OPC_FSINGLE_SUB1,
-  TILEGX_OPC_ICOH,
-  TILEGX_OPC_ILL,
-  TILEGX_OPC_INV,
-  TILEGX_OPC_IRET,
-  TILEGX_OPC_J,
-  TILEGX_OPC_JAL,
-  TILEGX_OPC_JALR,
-  TILEGX_OPC_JALRP,
-  TILEGX_OPC_JR,
-  TILEGX_OPC_JRP,
-  TILEGX_OPC_LD,
-  TILEGX_OPC_LD1S,
-  TILEGX_OPC_LD1S_ADD,
-  TILEGX_OPC_LD1U,
-  TILEGX_OPC_LD1U_ADD,
-  TILEGX_OPC_LD2S,
-  TILEGX_OPC_LD2S_ADD,
-  TILEGX_OPC_LD2U,
-  TILEGX_OPC_LD2U_ADD,
-  TILEGX_OPC_LD4S,
-  TILEGX_OPC_LD4S_ADD,
-  TILEGX_OPC_LD4U,
-  TILEGX_OPC_LD4U_ADD,
-  TILEGX_OPC_LD_ADD,
-  TILEGX_OPC_LDNA,
-  TILEGX_OPC_LDNA_ADD,
-  TILEGX_OPC_LDNT,
-  TILEGX_OPC_LDNT1S,
-  TILEGX_OPC_LDNT1S_ADD,
-  TILEGX_OPC_LDNT1U,
-  TILEGX_OPC_LDNT1U_ADD,
-  TILEGX_OPC_LDNT2S,
-  TILEGX_OPC_LDNT2S_ADD,
-  TILEGX_OPC_LDNT2U,
-  TILEGX_OPC_LDNT2U_ADD,
-  TILEGX_OPC_LDNT4S,
-  TILEGX_OPC_LDNT4S_ADD,
-  TILEGX_OPC_LDNT4U,
-  TILEGX_OPC_LDNT4U_ADD,
-  TILEGX_OPC_LDNT_ADD,
-  TILEGX_OPC_LNK,
-  TILEGX_OPC_MF,
-  TILEGX_OPC_MFSPR,
-  TILEGX_OPC_MM,
-  TILEGX_OPC_MNZ,
-  TILEGX_OPC_MTSPR,
-  TILEGX_OPC_MUL_HS_HS,
-  TILEGX_OPC_MUL_HS_HU,
-  TILEGX_OPC_MUL_HS_LS,
-  TILEGX_OPC_MUL_HS_LU,
-  TILEGX_OPC_MUL_HU_HU,
-  TILEGX_OPC_MUL_HU_LS,
-  TILEGX_OPC_MUL_HU_LU,
-  TILEGX_OPC_MUL_LS_LS,
-  TILEGX_OPC_MUL_LS_LU,
-  TILEGX_OPC_MUL_LU_LU,
-  TILEGX_OPC_MULA_HS_HS,
-  TILEGX_OPC_MULA_HS_HU,
-  TILEGX_OPC_MULA_HS_LS,
-  TILEGX_OPC_MULA_HS_LU,
-  TILEGX_OPC_MULA_HU_HU,
-  TILEGX_OPC_MULA_HU_LS,
-  TILEGX_OPC_MULA_HU_LU,
-  TILEGX_OPC_MULA_LS_LS,
-  TILEGX_OPC_MULA_LS_LU,
-  TILEGX_OPC_MULA_LU_LU,
-  TILEGX_OPC_MULAX,
-  TILEGX_OPC_MULX,
-  TILEGX_OPC_MZ,
-  TILEGX_OPC_NAP,
-  TILEGX_OPC_NOP,
-  TILEGX_OPC_NOR,
-  TILEGX_OPC_OR,
-  TILEGX_OPC_ORI,
-  TILEGX_OPC_PCNT,
-  TILEGX_OPC_REVBITS,
-  TILEGX_OPC_REVBYTES,
-  TILEGX_OPC_ROTL,
-  TILEGX_OPC_ROTLI,
-  TILEGX_OPC_SHL,
-  TILEGX_OPC_SHL16INSLI,
-  TILEGX_OPC_SHL1ADD,
-  TILEGX_OPC_SHL1ADDX,
-  TILEGX_OPC_SHL2ADD,
-  TILEGX_OPC_SHL2ADDX,
-  TILEGX_OPC_SHL3ADD,
-  TILEGX_OPC_SHL3ADDX,
-  TILEGX_OPC_SHLI,
-  TILEGX_OPC_SHLX,
-  TILEGX_OPC_SHLXI,
-  TILEGX_OPC_SHRS,
-  TILEGX_OPC_SHRSI,
-  TILEGX_OPC_SHRU,
-  TILEGX_OPC_SHRUI,
-  TILEGX_OPC_SHRUX,
-  TILEGX_OPC_SHRUXI,
-  TILEGX_OPC_SHUFFLEBYTES,
-  TILEGX_OPC_ST,
-  TILEGX_OPC_ST1,
-  TILEGX_OPC_ST1_ADD,
-  TILEGX_OPC_ST2,
-  TILEGX_OPC_ST2_ADD,
-  TILEGX_OPC_ST4,
-  TILEGX_OPC_ST4_ADD,
-  TILEGX_OPC_ST_ADD,
-  TILEGX_OPC_STNT,
-  TILEGX_OPC_STNT1,
-  TILEGX_OPC_STNT1_ADD,
-  TILEGX_OPC_STNT2,
-  TILEGX_OPC_STNT2_ADD,
-  TILEGX_OPC_STNT4,
-  TILEGX_OPC_STNT4_ADD,
-  TILEGX_OPC_STNT_ADD,
-  TILEGX_OPC_SUB,
-  TILEGX_OPC_SUBX,
-  TILEGX_OPC_SUBXSC,
-  TILEGX_OPC_SWINT0,
-  TILEGX_OPC_SWINT1,
-  TILEGX_OPC_SWINT2,
-  TILEGX_OPC_SWINT3,
-  TILEGX_OPC_TBLIDXB0,
-  TILEGX_OPC_TBLIDXB1,
-  TILEGX_OPC_TBLIDXB2,
-  TILEGX_OPC_TBLIDXB3,
-  TILEGX_OPC_V1ADD,
-  TILEGX_OPC_V1ADDI,
-  TILEGX_OPC_V1ADDUC,
-  TILEGX_OPC_V1ADIFFU,
-  TILEGX_OPC_V1AVGU,
-  TILEGX_OPC_V1CMPEQ,
-  TILEGX_OPC_V1CMPEQI,
-  TILEGX_OPC_V1CMPLES,
-  TILEGX_OPC_V1CMPLEU,
-  TILEGX_OPC_V1CMPLTS,
-  TILEGX_OPC_V1CMPLTSI,
-  TILEGX_OPC_V1CMPLTU,
-  TILEGX_OPC_V1CMPLTUI,
-  TILEGX_OPC_V1CMPNE,
-  TILEGX_OPC_V1DDOTPU,
-  TILEGX_OPC_V1DDOTPUA,
-  TILEGX_OPC_V1DDOTPUS,
-  TILEGX_OPC_V1DDOTPUSA,
-  TILEGX_OPC_V1DOTP,
-  TILEGX_OPC_V1DOTPA,
-  TILEGX_OPC_V1DOTPU,
-  TILEGX_OPC_V1DOTPUA,
-  TILEGX_OPC_V1DOTPUS,
-  TILEGX_OPC_V1DOTPUSA,
-  TILEGX_OPC_V1INT_H,
-  TILEGX_OPC_V1INT_L,
-  TILEGX_OPC_V1MAXU,
-  TILEGX_OPC_V1MAXUI,
-  TILEGX_OPC_V1MINU,
-  TILEGX_OPC_V1MINUI,
-  TILEGX_OPC_V1MNZ,
-  TILEGX_OPC_V1MULTU,
-  TILEGX_OPC_V1MULU,
-  TILEGX_OPC_V1MULUS,
-  TILEGX_OPC_V1MZ,
-  TILEGX_OPC_V1SADAU,
-  TILEGX_OPC_V1SADU,
-  TILEGX_OPC_V1SHL,
-  TILEGX_OPC_V1SHLI,
-  TILEGX_OPC_V1SHRS,
-  TILEGX_OPC_V1SHRSI,
-  TILEGX_OPC_V1SHRU,
-  TILEGX_OPC_V1SHRUI,
-  TILEGX_OPC_V1SUB,
-  TILEGX_OPC_V1SUBUC,
-  TILEGX_OPC_V2ADD,
-  TILEGX_OPC_V2ADDI,
-  TILEGX_OPC_V2ADDSC,
-  TILEGX_OPC_V2ADIFFS,
-  TILEGX_OPC_V2AVGS,
-  TILEGX_OPC_V2CMPEQ,
-  TILEGX_OPC_V2CMPEQI,
-  TILEGX_OPC_V2CMPLES,
-  TILEGX_OPC_V2CMPLEU,
-  TILEGX_OPC_V2CMPLTS,
-  TILEGX_OPC_V2CMPLTSI,
-  TILEGX_OPC_V2CMPLTU,
-  TILEGX_OPC_V2CMPLTUI,
-  TILEGX_OPC_V2CMPNE,
-  TILEGX_OPC_V2DOTP,
-  TILEGX_OPC_V2DOTPA,
-  TILEGX_OPC_V2INT_H,
-  TILEGX_OPC_V2INT_L,
-  TILEGX_OPC_V2MAXS,
-  TILEGX_OPC_V2MAXSI,
-  TILEGX_OPC_V2MINS,
-  TILEGX_OPC_V2MINSI,
-  TILEGX_OPC_V2MNZ,
-  TILEGX_OPC_V2MULFSC,
-  TILEGX_OPC_V2MULS,
-  TILEGX_OPC_V2MULTS,
-  TILEGX_OPC_V2MZ,
-  TILEGX_OPC_V2PACKH,
-  TILEGX_OPC_V2PACKL,
-  TILEGX_OPC_V2PACKUC,
-  TILEGX_OPC_V2SADAS,
-  TILEGX_OPC_V2SADAU,
-  TILEGX_OPC_V2SADS,
-  TILEGX_OPC_V2SADU,
-  TILEGX_OPC_V2SHL,
-  TILEGX_OPC_V2SHLI,
-  TILEGX_OPC_V2SHLSC,
-  TILEGX_OPC_V2SHRS,
-  TILEGX_OPC_V2SHRSI,
-  TILEGX_OPC_V2SHRU,
-  TILEGX_OPC_V2SHRUI,
-  TILEGX_OPC_V2SUB,
-  TILEGX_OPC_V2SUBSC,
-  TILEGX_OPC_V4ADD,
-  TILEGX_OPC_V4ADDSC,
-  TILEGX_OPC_V4INT_H,
-  TILEGX_OPC_V4INT_L,
-  TILEGX_OPC_V4PACKSC,
-  TILEGX_OPC_V4SHL,
-  TILEGX_OPC_V4SHLSC,
-  TILEGX_OPC_V4SHRS,
-  TILEGX_OPC_V4SHRU,
-  TILEGX_OPC_V4SUB,
-  TILEGX_OPC_V4SUBSC,
-  TILEGX_OPC_WH64,
-  TILEGX_OPC_XOR,
-  TILEGX_OPC_XORI,
-  TILEGX_OPC_NONE
-} tilegx_mnemonic;
-
-enum
-{
-  TILEGX_MAX_OPERANDS = 4 /* bfexts */
-};
-
-struct tilegx_opcode
-{
-  /* The opcode mnemonic, e.g. "add" */
-  const char *name;
-
-  /* The enum value for this mnemonic. */
-  tilegx_mnemonic mnemonic;
-
-  /* A bit mask of which of the five pipes this instruction
-     is compatible with:
-     X0  0x01
-     X1  0x02
-     Y0  0x04
-     Y1  0x08
-     Y2  0x10 */
-  unsigned char pipes;
-
-  /* How many operands are there? */
-  unsigned char num_operands;
-
-  /* Which register does this write implicitly, or TREG_ZERO if none? */
-  unsigned char implicitly_written_register;
-
-  /* Can this be bundled with other instructions (almost always true). */
-  unsigned char can_bundle;
-
-  /* The description of the operands. Each of these is an
-   * index into the tilegx_operands[] table. */
-  unsigned char operands[TILEGX_NUM_PIPELINE_ENCODINGS][TILEGX_MAX_OPERANDS];
-
-  /* A mask of which bits have predefined values for each pipeline.
-   * This is useful for disassembly. */
-  tilegx_bundle_bits fixed_bit_masks[TILEGX_NUM_PIPELINE_ENCODINGS];
-
-  /* For each bit set in fixed_bit_masks, what the value is for this
-   * instruction. */
-  tilegx_bundle_bits fixed_bit_values[TILEGX_NUM_PIPELINE_ENCODINGS];
-};
-
-/* Used for non-textual disassembly into structs. */
-struct tilegx_decoded_instruction
-{
-  const struct tilegx_opcode *opcode;
-  const struct tilegx_operand *operands[TILEGX_MAX_OPERANDS];
-  long long operand_values[TILEGX_MAX_OPERANDS];
-};
-
-enum
-{
-  ADDI_IMM8_OPCODE_X0 = 1,
-  ADDI_IMM8_OPCODE_X1 = 1,
-  ADDI_OPCODE_Y0 = 0,
-  ADDI_OPCODE_Y1 = 1,
-  ADDLI_OPCODE_X0 = 1,
-  ADDLI_OPCODE_X1 = 0,
-  ADDXI_IMM8_OPCODE_X0 = 2,
-  ADDXI_IMM8_OPCODE_X1 = 2,
-  ADDXI_OPCODE_Y0 = 1,
-  ADDXI_OPCODE_Y1 = 2,
-  ADDXLI_OPCODE_X0 = 2,
-  ADDXLI_OPCODE_X1 = 1,
-  ADDXSC_RRR_0_OPCODE_X0 = 1,
-  ADDXSC_RRR_0_OPCODE_X1 = 1,
-  ADDX_RRR_0_OPCODE_X0 = 2,
-  ADDX_RRR_0_OPCODE_X1 = 2,
-  ADDX_RRR_0_OPCODE_Y0 = 0,
-  ADDX_SPECIAL_0_OPCODE_Y1 = 0,
-  ADD_RRR_0_OPCODE_X0 = 3,
-  ADD_RRR_0_OPCODE_X1 = 3,
-  ADD_RRR_0_OPCODE_Y0 = 1,
-  ADD_SPECIAL_0_OPCODE_Y1 = 1,
-  ANDI_IMM8_OPCODE_X0 = 3,
-  ANDI_IMM8_OPCODE_X1 = 3,
-  ANDI_OPCODE_Y0 = 2,
-  ANDI_OPCODE_Y1 = 3,
-  AND_RRR_0_OPCODE_X0 = 4,
-  AND_RRR_0_OPCODE_X1 = 4,
-  AND_RRR_5_OPCODE_Y0 = 0,
-  AND_RRR_5_OPCODE_Y1 = 0,
-  BEQZT_BRANCH_OPCODE_X1 = 16,
-  BEQZ_BRANCH_OPCODE_X1 = 17,
-  BFEXTS_BF_OPCODE_X0 = 4,
-  BFEXTU_BF_OPCODE_X0 = 5,
-  BFINS_BF_OPCODE_X0 = 6,
-  BF_OPCODE_X0 = 3,
-  BGEZT_BRANCH_OPCODE_X1 = 18,
-  BGEZ_BRANCH_OPCODE_X1 = 19,
-  BGTZT_BRANCH_OPCODE_X1 = 20,
-  BGTZ_BRANCH_OPCODE_X1 = 21,
-  BLBCT_BRANCH_OPCODE_X1 = 22,
-  BLBC_BRANCH_OPCODE_X1 = 23,
-  BLBST_BRANCH_OPCODE_X1 = 24,
-  BLBS_BRANCH_OPCODE_X1 = 25,
-  BLEZT_BRANCH_OPCODE_X1 = 26,
-  BLEZ_BRANCH_OPCODE_X1 = 27,
-  BLTZT_BRANCH_OPCODE_X1 = 28,
-  BLTZ_BRANCH_OPCODE_X1 = 29,
-  BNEZT_BRANCH_OPCODE_X1 = 30,
-  BNEZ_BRANCH_OPCODE_X1 = 31,
-  BRANCH_OPCODE_X1 = 2,
-  CMOVEQZ_RRR_0_OPCODE_X0 = 5,
-  CMOVEQZ_RRR_4_OPCODE_Y0 = 0,
-  CMOVNEZ_RRR_0_OPCODE_X0 = 6,
-  CMOVNEZ_RRR_4_OPCODE_Y0 = 1,
-  CMPEQI_IMM8_OPCODE_X0 = 4,
-  CMPEQI_IMM8_OPCODE_X1 = 4,
-  CMPEQI_OPCODE_Y0 = 3,
-  CMPEQI_OPCODE_Y1 = 4,
-  CMPEQ_RRR_0_OPCODE_X0 = 7,
-  CMPEQ_RRR_0_OPCODE_X1 = 5,
-  CMPEQ_RRR_3_OPCODE_Y0 = 0,
-  CMPEQ_RRR_3_OPCODE_Y1 = 2,
-  CMPEXCH4_RRR_0_OPCODE_X1 = 6,
-  CMPEXCH_RRR_0_OPCODE_X1 = 7,
-  CMPLES_RRR_0_OPCODE_X0 = 8,
-  CMPLES_RRR_0_OPCODE_X1 = 8,
-  CMPLES_RRR_2_OPCODE_Y0 = 0,
-  CMPLES_RRR_2_OPCODE_Y1 = 0,
-  CMPLEU_RRR_0_OPCODE_X0 = 9,
-  CMPLEU_RRR_0_OPCODE_X1 = 9,
-  CMPLEU_RRR_2_OPCODE_Y0 = 1,
-  CMPLEU_RRR_2_OPCODE_Y1 = 1,
-  CMPLTSI_IMM8_OPCODE_X0 = 5,
-  CMPLTSI_IMM8_OPCODE_X1 = 5,
-  CMPLTSI_OPCODE_Y0 = 4,
-  CMPLTSI_OPCODE_Y1 = 5,
-  CMPLTS_RRR_0_OPCODE_X0 = 10,
-  CMPLTS_RRR_0_OPCODE_X1 = 10,
-  CMPLTS_RRR_2_OPCODE_Y0 = 2,
-  CMPLTS_RRR_2_OPCODE_Y1 = 2,
-  CMPLTUI_IMM8_OPCODE_X0 = 6,
-  CMPLTUI_IMM8_OPCODE_X1 = 6,
-  CMPLTU_RRR_0_OPCODE_X0 = 11,
-  CMPLTU_RRR_0_OPCODE_X1 = 11,
-  CMPLTU_RRR_2_OPCODE_Y0 = 3,
-  CMPLTU_RRR_2_OPCODE_Y1 = 3,
-  CMPNE_RRR_0_OPCODE_X0 = 12,
-  CMPNE_RRR_0_OPCODE_X1 = 12,
-  CMPNE_RRR_3_OPCODE_Y0 = 1,
-  CMPNE_RRR_3_OPCODE_Y1 = 3,
-  CMULAF_RRR_0_OPCODE_X0 = 13,
-  CMULA_RRR_0_OPCODE_X0 = 14,
-  CMULFR_RRR_0_OPCODE_X0 = 15,
-  CMULF_RRR_0_OPCODE_X0 = 16,
-  CMULHR_RRR_0_OPCODE_X0 = 17,
-  CMULH_RRR_0_OPCODE_X0 = 18,
-  CMUL_RRR_0_OPCODE_X0 = 19,
-  CNTLZ_UNARY_OPCODE_X0 = 1,
-  CNTLZ_UNARY_OPCODE_Y0 = 1,
-  CNTTZ_UNARY_OPCODE_X0 = 2,
-  CNTTZ_UNARY_OPCODE_Y0 = 2,
-  CRC32_32_RRR_0_OPCODE_X0 = 20,
-  CRC32_8_RRR_0_OPCODE_X0 = 21,
-  DBLALIGN2_RRR_0_OPCODE_X0 = 22,
-  DBLALIGN2_RRR_0_OPCODE_X1 = 13,
-  DBLALIGN4_RRR_0_OPCODE_X0 = 23,
-  DBLALIGN4_RRR_0_OPCODE_X1 = 14,
-  DBLALIGN6_RRR_0_OPCODE_X0 = 24,
-  DBLALIGN6_RRR_0_OPCODE_X1 = 15,
-  DBLALIGN_RRR_0_OPCODE_X0 = 25,
-  DRAIN_UNARY_OPCODE_X1 = 1,
-  DTLBPR_UNARY_OPCODE_X1 = 2,
-  EXCH4_RRR_0_OPCODE_X1 = 16,
-  EXCH_RRR_0_OPCODE_X1 = 17,
-  FDOUBLE_ADDSUB_RRR_0_OPCODE_X0 = 26,
-  FDOUBLE_ADD_FLAGS_RRR_0_OPCODE_X0 = 27,
-  FDOUBLE_MUL_FLAGS_RRR_0_OPCODE_X0 = 28,
-  FDOUBLE_PACK1_RRR_0_OPCODE_X0 = 29,
-  FDOUBLE_PACK2_RRR_0_OPCODE_X0 = 30,
-  FDOUBLE_SUB_FLAGS_RRR_0_OPCODE_X0 = 31,
-  FDOUBLE_UNPACK_MAX_RRR_0_OPCODE_X0 = 32,
-  FDOUBLE_UNPACK_MIN_RRR_0_OPCODE_X0 = 33,
-  FETCHADD4_RRR_0_OPCODE_X1 = 18,
-  FETCHADDGEZ4_RRR_0_OPCODE_X1 = 19,
-  FETCHADDGEZ_RRR_0_OPCODE_X1 = 20,
-  FETCHADD_RRR_0_OPCODE_X1 = 21,
-  FETCHAND4_RRR_0_OPCODE_X1 = 22,
-  FETCHAND_RRR_0_OPCODE_X1 = 23,
-  FETCHOR4_RRR_0_OPCODE_X1 = 24,
-  FETCHOR_RRR_0_OPCODE_X1 = 25,
-  FINV_UNARY_OPCODE_X1 = 3,
-  FLUSHWB_UNARY_OPCODE_X1 = 4,
-  FLUSH_UNARY_OPCODE_X1 = 5,
-  FNOP_UNARY_OPCODE_X0 = 3,
-  FNOP_UNARY_OPCODE_X1 = 6,
-  FNOP_UNARY_OPCODE_Y0 = 3,
-  FNOP_UNARY_OPCODE_Y1 = 8,
-  FSINGLE_ADD1_RRR_0_OPCODE_X0 = 34,
-  FSINGLE_ADDSUB2_RRR_0_OPCODE_X0 = 35,
-  FSINGLE_MUL1_RRR_0_OPCODE_X0 = 36,
-  FSINGLE_MUL2_RRR_0_OPCODE_X0 = 37,
-  FSINGLE_PACK1_UNARY_OPCODE_X0 = 4,
-  FSINGLE_PACK1_UNARY_OPCODE_Y0 = 4,
-  FSINGLE_PACK2_RRR_0_OPCODE_X0 = 38,
-  FSINGLE_SUB1_RRR_0_OPCODE_X0 = 39,
-  ICOH_UNARY_OPCODE_X1 = 7,
-  ILL_UNARY_OPCODE_X1 = 8,
-  ILL_UNARY_OPCODE_Y1 = 9,
-  IMM8_OPCODE_X0 = 4,
-  IMM8_OPCODE_X1 = 3,
-  INV_UNARY_OPCODE_X1 = 9,
-  IRET_UNARY_OPCODE_X1 = 10,
-  JALRP_UNARY_OPCODE_X1 = 11,
-  JALRP_UNARY_OPCODE_Y1 = 10,
-  JALR_UNARY_OPCODE_X1 = 12,
-  JALR_UNARY_OPCODE_Y1 = 11,
-  JAL_JUMP_OPCODE_X1 = 0,
-  JRP_UNARY_OPCODE_X1 = 13,
-  JRP_UNARY_OPCODE_Y1 = 12,
-  JR_UNARY_OPCODE_X1 = 14,
-  JR_UNARY_OPCODE_Y1 = 13,
-  JUMP_OPCODE_X1 = 4,
-  J_JUMP_OPCODE_X1 = 1,
-  LD1S_ADD_IMM8_OPCODE_X1 = 7,
-  LD1S_OPCODE_Y2 = 0,
-  LD1S_UNARY_OPCODE_X1 = 15,
-  LD1U_ADD_IMM8_OPCODE_X1 = 8,
-  LD1U_OPCODE_Y2 = 1,
-  LD1U_UNARY_OPCODE_X1 = 16,
-  LD2S_ADD_IMM8_OPCODE_X1 = 9,
-  LD2S_OPCODE_Y2 = 2,
-  LD2S_UNARY_OPCODE_X1 = 17,
-  LD2U_ADD_IMM8_OPCODE_X1 = 10,
-  LD2U_OPCODE_Y2 = 3,
-  LD2U_UNARY_OPCODE_X1 = 18,
-  LD4S_ADD_IMM8_OPCODE_X1 = 11,
-  LD4S_OPCODE_Y2 = 1,
-  LD4S_UNARY_OPCODE_X1 = 19,
-  LD4U_ADD_IMM8_OPCODE_X1 = 12,
-  LD4U_OPCODE_Y2 = 2,
-  LD4U_UNARY_OPCODE_X1 = 20,
-  LDNA_UNARY_OPCODE_X1 = 21,
-  LDNT1S_ADD_IMM8_OPCODE_X1 = 13,
-  LDNT1S_UNARY_OPCODE_X1 = 22,
-  LDNT1U_ADD_IMM8_OPCODE_X1 = 14,
-  LDNT1U_UNARY_OPCODE_X1 = 23,
-  LDNT2S_ADD_IMM8_OPCODE_X1 = 15,
-  LDNT2S_UNARY_OPCODE_X1 = 24,
-  LDNT2U_ADD_IMM8_OPCODE_X1 = 16,
-  LDNT2U_UNARY_OPCODE_X1 = 25,
-  LDNT4S_ADD_IMM8_OPCODE_X1 = 17,
-  LDNT4S_UNARY_OPCODE_X1 = 26,
-  LDNT4U_ADD_IMM8_OPCODE_X1 = 18,
-  LDNT4U_UNARY_OPCODE_X1 = 27,
-  LDNT_ADD_IMM8_OPCODE_X1 = 19,
-  LDNT_UNARY_OPCODE_X1 = 28,
-  LD_ADD_IMM8_OPCODE_X1 = 20,
-  LD_OPCODE_Y2 = 3,
-  LD_UNARY_OPCODE_X1 = 29,
-  LNK_UNARY_OPCODE_X1 = 30,
-  LNK_UNARY_OPCODE_Y1 = 14,
-  LWNA_ADD_IMM8_OPCODE_X1 = 21,
-  MFSPR_IMM8_OPCODE_X1 = 22,
-  MF_UNARY_OPCODE_X1 = 31,
-  MM_BF_OPCODE_X0 = 7,
-  MNZ_RRR_0_OPCODE_X0 = 40,
-  MNZ_RRR_0_OPCODE_X1 = 26,
-  MNZ_RRR_4_OPCODE_Y0 = 2,
-  MNZ_RRR_4_OPCODE_Y1 = 2,
-  MODE_OPCODE_YA2 = 1,
-  MODE_OPCODE_YB2 = 2,
-  MODE_OPCODE_YC2 = 3,
-  MTSPR_IMM8_OPCODE_X1 = 23,
-  MULAX_RRR_0_OPCODE_X0 = 41,
-  MULAX_RRR_3_OPCODE_Y0 = 2,
-  MULA_HS_HS_RRR_0_OPCODE_X0 = 42,
-  MULA_HS_HS_RRR_9_OPCODE_Y0 = 0,
-  MULA_HS_HU_RRR_0_OPCODE_X0 = 43,
-  MULA_HS_LS_RRR_0_OPCODE_X0 = 44,
-  MULA_HS_LU_RRR_0_OPCODE_X0 = 45,
-  MULA_HU_HU_RRR_0_OPCODE_X0 = 46,
-  MULA_HU_HU_RRR_9_OPCODE_Y0 = 1,
-  MULA_HU_LS_RRR_0_OPCODE_X0 = 47,
-  MULA_HU_LU_RRR_0_OPCODE_X0 = 48,
-  MULA_LS_LS_RRR_0_OPCODE_X0 = 49,
-  MULA_LS_LS_RRR_9_OPCODE_Y0 = 2,
-  MULA_LS_LU_RRR_0_OPCODE_X0 = 50,
-  MULA_LU_LU_RRR_0_OPCODE_X0 = 51,
-  MULA_LU_LU_RRR_9_OPCODE_Y0 = 3,
-  MULX_RRR_0_OPCODE_X0 = 52,
-  MULX_RRR_3_OPCODE_Y0 = 3,
-  MUL_HS_HS_RRR_0_OPCODE_X0 = 53,
-  MUL_HS_HS_RRR_8_OPCODE_Y0 = 0,
-  MUL_HS_HU_RRR_0_OPCODE_X0 = 54,
-  MUL_HS_LS_RRR_0_OPCODE_X0 = 55,
-  MUL_HS_LU_RRR_0_OPCODE_X0 = 56,
-  MUL_HU_HU_RRR_0_OPCODE_X0 = 57,
-  MUL_HU_HU_RRR_8_OPCODE_Y0 = 1,
-  MUL_HU_LS_RRR_0_OPCODE_X0 = 58,
-  MUL_HU_LU_RRR_0_OPCODE_X0 = 59,
-  MUL_LS_LS_RRR_0_OPCODE_X0 = 60,
-  MUL_LS_LS_RRR_8_OPCODE_Y0 = 2,
-  MUL_LS_LU_RRR_0_OPCODE_X0 = 61,
-  MUL_LU_LU_RRR_0_OPCODE_X0 = 62,
-  MUL_LU_LU_RRR_8_OPCODE_Y0 = 3,
-  MZ_RRR_0_OPCODE_X0 = 63,
-  MZ_RRR_0_OPCODE_X1 = 27,
-  MZ_RRR_4_OPCODE_Y0 = 3,
-  MZ_RRR_4_OPCODE_Y1 = 3,
-  NAP_UNARY_OPCODE_X1 = 32,
-  NOP_UNARY_OPCODE_X0 = 5,
-  NOP_UNARY_OPCODE_X1 = 33,
-  NOP_UNARY_OPCODE_Y0 = 5,
-  NOP_UNARY_OPCODE_Y1 = 15,
-  NOR_RRR_0_OPCODE_X0 = 64,
-  NOR_RRR_0_OPCODE_X1 = 28,
-  NOR_RRR_5_OPCODE_Y0 = 1,
-  NOR_RRR_5_OPCODE_Y1 = 1,
-  ORI_IMM8_OPCODE_X0 = 7,
-  ORI_IMM8_OPCODE_X1 = 24,
-  OR_RRR_0_OPCODE_X0 = 65,
-  OR_RRR_0_OPCODE_X1 = 29,
-  OR_RRR_5_OPCODE_Y0 = 2,
-  OR_RRR_5_OPCODE_Y1 = 2,
-  PCNT_UNARY_OPCODE_X0 = 6,
-  PCNT_UNARY_OPCODE_Y0 = 6,
-  REVBITS_UNARY_OPCODE_X0 = 7,
-  REVBITS_UNARY_OPCODE_Y0 = 7,
-  REVBYTES_UNARY_OPCODE_X0 = 8,
-  REVBYTES_UNARY_OPCODE_Y0 = 8,
-  ROTLI_SHIFT_OPCODE_X0 = 1,
-  ROTLI_SHIFT_OPCODE_X1 = 1,
-  ROTLI_SHIFT_OPCODE_Y0 = 0,
-  ROTLI_SHIFT_OPCODE_Y1 = 0,
-  ROTL_RRR_0_OPCODE_X0 = 66,
-  ROTL_RRR_0_OPCODE_X1 = 30,
-  ROTL_RRR_6_OPCODE_Y0 = 0,
-  ROTL_RRR_6_OPCODE_Y1 = 0,
-  RRR_0_OPCODE_X0 = 5,
-  RRR_0_OPCODE_X1 = 5,
-  RRR_0_OPCODE_Y0 = 5,
-  RRR_0_OPCODE_Y1 = 6,
-  RRR_1_OPCODE_Y0 = 6,
-  RRR_1_OPCODE_Y1 = 7,
-  RRR_2_OPCODE_Y0 = 7,
-  RRR_2_OPCODE_Y1 = 8,
-  RRR_3_OPCODE_Y0 = 8,
-  RRR_3_OPCODE_Y1 = 9,
-  RRR_4_OPCODE_Y0 = 9,
-  RRR_4_OPCODE_Y1 = 10,
-  RRR_5_OPCODE_Y0 = 10,
-  RRR_5_OPCODE_Y1 = 11,
-  RRR_6_OPCODE_Y0 = 11,
-  RRR_6_OPCODE_Y1 = 12,
-  RRR_7_OPCODE_Y0 = 12,
-  RRR_7_OPCODE_Y1 = 13,
-  RRR_8_OPCODE_Y0 = 13,
-  RRR_9_OPCODE_Y0 = 14,
-  SHIFT_OPCODE_X0 = 6,
-  SHIFT_OPCODE_X1 = 6,
-  SHIFT_OPCODE_Y0 = 15,
-  SHIFT_OPCODE_Y1 = 14,
-  SHL16INSLI_OPCODE_X0 = 7,
-  SHL16INSLI_OPCODE_X1 = 7,
-  SHL1ADDX_RRR_0_OPCODE_X0 = 67,
-  SHL1ADDX_RRR_0_OPCODE_X1 = 31,
-  SHL1ADDX_RRR_7_OPCODE_Y0 = 1,
-  SHL1ADDX_RRR_7_OPCODE_Y1 = 1,
-  SHL1ADD_RRR_0_OPCODE_X0 = 68,
-  SHL1ADD_RRR_0_OPCODE_X1 = 32,
-  SHL1ADD_RRR_1_OPCODE_Y0 = 0,
-  SHL1ADD_RRR_1_OPCODE_Y1 = 0,
-  SHL2ADDX_RRR_0_OPCODE_X0 = 69,
-  SHL2ADDX_RRR_0_OPCODE_X1 = 33,
-  SHL2ADDX_RRR_7_OPCODE_Y0 = 2,
-  SHL2ADDX_RRR_7_OPCODE_Y1 = 2,
-  SHL2ADD_RRR_0_OPCODE_X0 = 70,
-  SHL2ADD_RRR_0_OPCODE_X1 = 34,
-  SHL2ADD_RRR_1_OPCODE_Y0 = 1,
-  SHL2ADD_RRR_1_OPCODE_Y1 = 1,
-  SHL3ADDX_RRR_0_OPCODE_X0 = 71,
-  SHL3ADDX_RRR_0_OPCODE_X1 = 35,
-  SHL3ADDX_RRR_7_OPCODE_Y0 = 3,
-  SHL3ADDX_RRR_7_OPCODE_Y1 = 3,
-  SHL3ADD_RRR_0_OPCODE_X0 = 72,
-  SHL3ADD_RRR_0_OPCODE_X1 = 36,
-  SHL3ADD_RRR_1_OPCODE_Y0 = 2,
-  SHL3ADD_RRR_1_OPCODE_Y1 = 2,
-  SHLI_SHIFT_OPCODE_X0 = 2,
-  SHLI_SHIFT_OPCODE_X1 = 2,
-  SHLI_SHIFT_OPCODE_Y0 = 1,
-  SHLI_SHIFT_OPCODE_Y1 = 1,
-  SHLXI_SHIFT_OPCODE_X0 = 3,
-  SHLXI_SHIFT_OPCODE_X1 = 3,
-  SHLX_RRR_0_OPCODE_X0 = 73,
-  SHLX_RRR_0_OPCODE_X1 = 37,
-  SHL_RRR_0_OPCODE_X0 = 74,
-  SHL_RRR_0_OPCODE_X1 = 38,
-  SHL_RRR_6_OPCODE_Y0 = 1,
-  SHL_RRR_6_OPCODE_Y1 = 1,
-  SHRSI_SHIFT_OPCODE_X0 = 4,
-  SHRSI_SHIFT_OPCODE_X1 = 4,
-  SHRSI_SHIFT_OPCODE_Y0 = 2,
-  SHRSI_SHIFT_OPCODE_Y1 = 2,
-  SHRS_RRR_0_OPCODE_X0 = 75,
-  SHRS_RRR_0_OPCODE_X1 = 39,
-  SHRS_RRR_6_OPCODE_Y0 = 2,
-  SHRS_RRR_6_OPCODE_Y1 = 2,
-  SHRUI_SHIFT_OPCODE_X0 = 5,
-  SHRUI_SHIFT_OPCODE_X1 = 5,
-  SHRUI_SHIFT_OPCODE_Y0 = 3,
-  SHRUI_SHIFT_OPCODE_Y1 = 3,
-  SHRUXI_SHIFT_OPCODE_X0 = 6,
-  SHRUXI_SHIFT_OPCODE_X1 = 6,
-  SHRUX_RRR_0_OPCODE_X0 = 76,
-  SHRUX_RRR_0_OPCODE_X1 = 40,
-  SHRU_RRR_0_OPCODE_X0 = 77,
-  SHRU_RRR_0_OPCODE_X1 = 41,
-  SHRU_RRR_6_OPCODE_Y0 = 3,
-  SHRU_RRR_6_OPCODE_Y1 = 3,
-  SHUFFLEBYTES_RRR_0_OPCODE_X0 = 78,
-  ST1_ADD_IMM8_OPCODE_X1 = 25,
-  ST1_OPCODE_Y2 = 0,
-  ST1_RRR_0_OPCODE_X1 = 42,
-  ST2_ADD_IMM8_OPCODE_X1 = 26,
-  ST2_OPCODE_Y2 = 1,
-  ST2_RRR_0_OPCODE_X1 = 43,
-  ST4_ADD_IMM8_OPCODE_X1 = 27,
-  ST4_OPCODE_Y2 = 2,
-  ST4_RRR_0_OPCODE_X1 = 44,
-  STNT1_ADD_IMM8_OPCODE_X1 = 28,
-  STNT1_RRR_0_OPCODE_X1 = 45,
-  STNT2_ADD_IMM8_OPCODE_X1 = 29,
-  STNT2_RRR_0_OPCODE_X1 = 46,
-  STNT4_ADD_IMM8_OPCODE_X1 = 30,
-  STNT4_RRR_0_OPCODE_X1 = 47,
-  STNT_ADD_IMM8_OPCODE_X1 = 31,
-  STNT_RRR_0_OPCODE_X1 = 48,
-  ST_ADD_IMM8_OPCODE_X1 = 32,
-  ST_OPCODE_Y2 = 3,
-  ST_RRR_0_OPCODE_X1 = 49,
-  SUBXSC_RRR_0_OPCODE_X0 = 79,
-  SUBXSC_RRR_0_OPCODE_X1 = 50,
-  SUBX_RRR_0_OPCODE_X0 = 80,
-  SUBX_RRR_0_OPCODE_X1 = 51,
-  SUBX_RRR_0_OPCODE_Y0 = 2,
-  SUBX_RRR_0_OPCODE_Y1 = 2,
-  SUB_RRR_0_OPCODE_X0 = 81,
-  SUB_RRR_0_OPCODE_X1 = 52,
-  SUB_RRR_0_OPCODE_Y0 = 3,
-  SUB_RRR_0_OPCODE_Y1 = 3,
-  SWINT0_UNARY_OPCODE_X1 = 34,
-  SWINT1_UNARY_OPCODE_X1 = 35,
-  SWINT2_UNARY_OPCODE_X1 = 36,
-  SWINT3_UNARY_OPCODE_X1 = 37,
-  TBLIDXB0_UNARY_OPCODE_X0 = 9,
-  TBLIDXB0_UNARY_OPCODE_Y0 = 9,
-  TBLIDXB1_UNARY_OPCODE_X0 = 10,
-  TBLIDXB1_UNARY_OPCODE_Y0 = 10,
-  TBLIDXB2_UNARY_OPCODE_X0 = 11,
-  TBLIDXB2_UNARY_OPCODE_Y0 = 11,
-  TBLIDXB3_UNARY_OPCODE_X0 = 12,
-  TBLIDXB3_UNARY_OPCODE_Y0 = 12,
-  UNARY_RRR_0_OPCODE_X0 = 82,
-  UNARY_RRR_0_OPCODE_X1 = 53,
-  UNARY_RRR_1_OPCODE_Y0 = 3,
-  UNARY_RRR_1_OPCODE_Y1 = 3,
-  V1ADDI_IMM8_OPCODE_X0 = 8,
-  V1ADDI_IMM8_OPCODE_X1 = 33,
-  V1ADDUC_RRR_0_OPCODE_X0 = 83,
-  V1ADDUC_RRR_0_OPCODE_X1 = 54,
-  V1ADD_RRR_0_OPCODE_X0 = 84,
-  V1ADD_RRR_0_OPCODE_X1 = 55,
-  V1ADIFFU_RRR_0_OPCODE_X0 = 85,
-  V1AVGU_RRR_0_OPCODE_X0 = 86,
-  V1CMPEQI_IMM8_OPCODE_X0 = 9,
-  V1CMPEQI_IMM8_OPCODE_X1 = 34,
-  V1CMPEQ_RRR_0_OPCODE_X0 = 87,
-  V1CMPEQ_RRR_0_OPCODE_X1 = 56,
-  V1CMPLES_RRR_0_OPCODE_X0 = 88,
-  V1CMPLES_RRR_0_OPCODE_X1 = 57,
-  V1CMPLEU_RRR_0_OPCODE_X0 = 89,
-  V1CMPLEU_RRR_0_OPCODE_X1 = 58,
-  V1CMPLTSI_IMM8_OPCODE_X0 = 10,
-  V1CMPLTSI_IMM8_OPCODE_X1 = 35,
-  V1CMPLTS_RRR_0_OPCODE_X0 = 90,
-  V1CMPLTS_RRR_0_OPCODE_X1 = 59,
-  V1CMPLTUI_IMM8_OPCODE_X0 = 11,
-  V1CMPLTUI_IMM8_OPCODE_X1 = 36,
-  V1CMPLTU_RRR_0_OPCODE_X0 = 91,
-  V1CMPLTU_RRR_0_OPCODE_X1 = 60,
-  V1CMPNE_RRR_0_OPCODE_X0 = 92,
-  V1CMPNE_RRR_0_OPCODE_X1 = 61,
-  V1DDOTPUA_RRR_0_OPCODE_X0 = 161,
-  V1DDOTPUSA_RRR_0_OPCODE_X0 = 93,
-  V1DDOTPUS_RRR_0_OPCODE_X0 = 94,
-  V1DDOTPU_RRR_0_OPCODE_X0 = 162,
-  V1DOTPA_RRR_0_OPCODE_X0 = 95,
-  V1DOTPUA_RRR_0_OPCODE_X0 = 163,
-  V1DOTPUSA_RRR_0_OPCODE_X0 = 96,
-  V1DOTPUS_RRR_0_OPCODE_X0 = 97,
-  V1DOTPU_RRR_0_OPCODE_X0 = 164,
-  V1DOTP_RRR_0_OPCODE_X0 = 98,
-  V1INT_H_RRR_0_OPCODE_X0 = 99,
-  V1INT_H_RRR_0_OPCODE_X1 = 62,
-  V1INT_L_RRR_0_OPCODE_X0 = 100,
-  V1INT_L_RRR_0_OPCODE_X1 = 63,
-  V1MAXUI_IMM8_OPCODE_X0 = 12,
-  V1MAXUI_IMM8_OPCODE_X1 = 37,
-  V1MAXU_RRR_0_OPCODE_X0 = 101,
-  V1MAXU_RRR_0_OPCODE_X1 = 64,
-  V1MINUI_IMM8_OPCODE_X0 = 13,
-  V1MINUI_IMM8_OPCODE_X1 = 38,
-  V1MINU_RRR_0_OPCODE_X0 = 102,
-  V1MINU_RRR_0_OPCODE_X1 = 65,
-  V1MNZ_RRR_0_OPCODE_X0 = 103,
-  V1MNZ_RRR_0_OPCODE_X1 = 66,
-  V1MULTU_RRR_0_OPCODE_X0 = 104,
-  V1MULUS_RRR_0_OPCODE_X0 = 105,
-  V1MULU_RRR_0_OPCODE_X0 = 106,
-  V1MZ_RRR_0_OPCODE_X0 = 107,
-  V1MZ_RRR_0_OPCODE_X1 = 67,
-  V1SADAU_RRR_0_OPCODE_X0 = 108,
-  V1SADU_RRR_0_OPCODE_X0 = 109,
-  V1SHLI_SHIFT_OPCODE_X0 = 7,
-  V1SHLI_SHIFT_OPCODE_X1 = 7,
-  V1SHL_RRR_0_OPCODE_X0 = 110,
-  V1SHL_RRR_0_OPCODE_X1 = 68,
-  V1SHRSI_SHIFT_OPCODE_X0 = 8,
-  V1SHRSI_SHIFT_OPCODE_X1 = 8,
-  V1SHRS_RRR_0_OPCODE_X0 = 111,
-  V1SHRS_RRR_0_OPCODE_X1 = 69,
-  V1SHRUI_SHIFT_OPCODE_X0 = 9,
-  V1SHRUI_SHIFT_OPCODE_X1 = 9,
-  V1SHRU_RRR_0_OPCODE_X0 = 112,
-  V1SHRU_RRR_0_OPCODE_X1 = 70,
-  V1SUBUC_RRR_0_OPCODE_X0 = 113,
-  V1SUBUC_RRR_0_OPCODE_X1 = 71,
-  V1SUB_RRR_0_OPCODE_X0 = 114,
-  V1SUB_RRR_0_OPCODE_X1 = 72,
-  V2ADDI_IMM8_OPCODE_X0 = 14,
-  V2ADDI_IMM8_OPCODE_X1 = 39,
-  V2ADDSC_RRR_0_OPCODE_X0 = 115,
-  V2ADDSC_RRR_0_OPCODE_X1 = 73,
-  V2ADD_RRR_0_OPCODE_X0 = 116,
-  V2ADD_RRR_0_OPCODE_X1 = 74,
-  V2ADIFFS_RRR_0_OPCODE_X0 = 117,
-  V2AVGS_RRR_0_OPCODE_X0 = 118,
-  V2CMPEQI_IMM8_OPCODE_X0 = 15,
-  V2CMPEQI_IMM8_OPCODE_X1 = 40,
-  V2CMPEQ_RRR_0_OPCODE_X0 = 119,
-  V2CMPEQ_RRR_0_OPCODE_X1 = 75,
-  V2CMPLES_RRR_0_OPCODE_X0 = 120,
-  V2CMPLES_RRR_0_OPCODE_X1 = 76,
-  V2CMPLEU_RRR_0_OPCODE_X0 = 121,
-  V2CMPLEU_RRR_0_OPCODE_X1 = 77,
-  V2CMPLTSI_IMM8_OPCODE_X0 = 16,
-  V2CMPLTSI_IMM8_OPCODE_X1 = 41,
-  V2CMPLTS_RRR_0_OPCODE_X0 = 122,
-  V2CMPLTS_RRR_0_OPCODE_X1 = 78,
-  V2CMPLTUI_IMM8_OPCODE_X0 = 17,
-  V2CMPLTUI_IMM8_OPCODE_X1 = 42,
-  V2CMPLTU_RRR_0_OPCODE_X0 = 123,
-  V2CMPLTU_RRR_0_OPCODE_X1 = 79,
-  V2CMPNE_RRR_0_OPCODE_X0 = 124,
-  V2CMPNE_RRR_0_OPCODE_X1 = 80,
-  V2DOTPA_RRR_0_OPCODE_X0 = 125,
-  V2DOTP_RRR_0_OPCODE_X0 = 126,
-  V2INT_H_RRR_0_OPCODE_X0 = 127,
-  V2INT_H_RRR_0_OPCODE_X1 = 81,
-  V2INT_L_RRR_0_OPCODE_X0 = 128,
-  V2INT_L_RRR_0_OPCODE_X1 = 82,
-  V2MAXSI_IMM8_OPCODE_X0 = 18,
-  V2MAXSI_IMM8_OPCODE_X1 = 43,
-  V2MAXS_RRR_0_OPCODE_X0 = 129,
-  V2MAXS_RRR_0_OPCODE_X1 = 83,
-  V2MINSI_IMM8_OPCODE_X0 = 19,
-  V2MINSI_IMM8_OPCODE_X1 = 44,
-  V2MINS_RRR_0_OPCODE_X0 = 130,
-  V2MINS_RRR_0_OPCODE_X1 = 84,
-  V2MNZ_RRR_0_OPCODE_X0 = 131,
-  V2MNZ_RRR_0_OPCODE_X1 = 85,
-  V2MULFSC_RRR_0_OPCODE_X0 = 132,
-  V2MULS_RRR_0_OPCODE_X0 = 133,
-  V2MULTS_RRR_0_OPCODE_X0 = 134,
-  V2MZ_RRR_0_OPCODE_X0 = 135,
-  V2MZ_RRR_0_OPCODE_X1 = 86,
-  V2PACKH_RRR_0_OPCODE_X0 = 136,
-  V2PACKH_RRR_0_OPCODE_X1 = 87,
-  V2PACKL_RRR_0_OPCODE_X0 = 137,
-  V2PACKL_RRR_0_OPCODE_X1 = 88,
-  V2PACKUC_RRR_0_OPCODE_X0 = 138,
-  V2PACKUC_RRR_0_OPCODE_X1 = 89,
-  V2SADAS_RRR_0_OPCODE_X0 = 139,
-  V2SADAU_RRR_0_OPCODE_X0 = 140,
-  V2SADS_RRR_0_OPCODE_X0 = 141,
-  V2SADU_RRR_0_OPCODE_X0 = 142,
-  V2SHLI_SHIFT_OPCODE_X0 = 10,
-  V2SHLI_SHIFT_OPCODE_X1 = 10,
-  V2SHLSC_RRR_0_OPCODE_X0 = 143,
-  V2SHLSC_RRR_0_OPCODE_X1 = 90,
-  V2SHL_RRR_0_OPCODE_X0 = 144,
-  V2SHL_RRR_0_OPCODE_X1 = 91,
-  V2SHRSI_SHIFT_OPCODE_X0 = 11,
-  V2SHRSI_SHIFT_OPCODE_X1 = 11,
-  V2SHRS_RRR_0_OPCODE_X0 = 145,
-  V2SHRS_RRR_0_OPCODE_X1 = 92,
-  V2SHRUI_SHIFT_OPCODE_X0 = 12,
-  V2SHRUI_SHIFT_OPCODE_X1 = 12,
-  V2SHRU_RRR_0_OPCODE_X0 = 146,
-  V2SHRU_RRR_0_OPCODE_X1 = 93,
-  V2SUBSC_RRR_0_OPCODE_X0 = 147,
-  V2SUBSC_RRR_0_OPCODE_X1 = 94,
-  V2SUB_RRR_0_OPCODE_X0 = 148,
-  V2SUB_RRR_0_OPCODE_X1 = 95,
-  V4ADDSC_RRR_0_OPCODE_X0 = 149,
-  V4ADDSC_RRR_0_OPCODE_X1 = 96,
-  V4ADD_RRR_0_OPCODE_X0 = 150,
-  V4ADD_RRR_0_OPCODE_X1 = 97,
-  V4INT_H_RRR_0_OPCODE_X0 = 151,
-  V4INT_H_RRR_0_OPCODE_X1 = 98,
-  V4INT_L_RRR_0_OPCODE_X0 = 152,
-  V4INT_L_RRR_0_OPCODE_X1 = 99,
-  V4PACKSC_RRR_0_OPCODE_X0 = 153,
-  V4PACKSC_RRR_0_OPCODE_X1 = 100,
-  V4SHLSC_RRR_0_OPCODE_X0 = 154,
-  V4SHLSC_RRR_0_OPCODE_X1 = 101,
-  V4SHL_RRR_0_OPCODE_X0 = 155,
-  V4SHL_RRR_0_OPCODE_X1 = 102,
-  V4SHRS_RRR_0_OPCODE_X0 = 156,
-  V4SHRS_RRR_0_OPCODE_X1 = 103,
-  V4SHRU_RRR_0_OPCODE_X0 = 157,
-  V4SHRU_RRR_0_OPCODE_X1 = 104,
-  V4SUBSC_RRR_0_OPCODE_X0 = 158,
-  V4SUBSC_RRR_0_OPCODE_X1 = 105,
-  V4SUB_RRR_0_OPCODE_X0 = 159,
-  V4SUB_RRR_0_OPCODE_X1 = 106,
-  WH64_UNARY_OPCODE_X1 = 38,
-  XORI_IMM8_OPCODE_X0 = 20,
-  XORI_IMM8_OPCODE_X1 = 45,
-  XOR_RRR_0_OPCODE_X0 = 160,
-  XOR_RRR_0_OPCODE_X1 = 107,
-  XOR_RRR_5_OPCODE_Y0 = 3,
-  XOR_RRR_5_OPCODE_Y1 = 3
-};
-
-static __inline unsigned int
-get_BFEnd_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0x3f);
-}
-
-static __inline unsigned int
-get_BFOpcodeExtension_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 24)) & 0xf);
-}
-
-static __inline unsigned int
-get_BFStart_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 18)) & 0x3f);
-}
-
-static __inline unsigned int
-get_BrOff_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 31)) & 0x0000003f) |
-         (((unsigned int)(n >> 37)) & 0x0001ffc0);
-}
-
-static __inline unsigned int
-get_BrType_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 54)) & 0x1f);
-}
-
-static __inline unsigned int
-get_Dest_Imm8_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 31)) & 0x0000003f) |
-         (((unsigned int)(n >> 43)) & 0x000000c0);
-}
-
-static __inline unsigned int
-get_Dest_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 0)) & 0x3f);
-}
-
-static __inline unsigned int
-get_Dest_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 31)) & 0x3f);
-}
-
-static __inline unsigned int
-get_Dest_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 0)) & 0x3f);
-}
-
-static __inline unsigned int
-get_Dest_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 31)) & 0x3f);
-}
-
-static __inline unsigned int
-get_Imm16_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0xffff);
-}
-
-static __inline unsigned int
-get_Imm16_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0xffff);
-}
-
-static __inline unsigned int
-get_Imm8OpcodeExtension_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 20)) & 0xff);
-}
-
-static __inline unsigned int
-get_Imm8OpcodeExtension_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 51)) & 0xff);
-}
-
-static __inline unsigned int
-get_Imm8_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0xff);
-}
-
-static __inline unsigned int
-get_Imm8_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0xff);
-}
-
-static __inline unsigned int
-get_Imm8_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0xff);
-}
-
-static __inline unsigned int
-get_Imm8_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0xff);
-}
-
-static __inline unsigned int
-get_JumpOff_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 31)) & 0x7ffffff);
-}
-
-static __inline unsigned int
-get_JumpOpcodeExtension_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 58)) & 0x1);
-}
-
-static __inline unsigned int
-get_MF_Imm14_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 37)) & 0x3fff);
-}
-
-static __inline unsigned int
-get_MT_Imm14_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 31)) & 0x0000003f) |
-         (((unsigned int)(n >> 37)) & 0x00003fc0);
-}
-
-static __inline unsigned int
-get_Mode(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 62)) & 0x3);
-}
-
-static __inline unsigned int
-get_Opcode_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 28)) & 0x7);
-}
-
-static __inline unsigned int
-get_Opcode_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 59)) & 0x7);
-}
-
-static __inline unsigned int
-get_Opcode_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 27)) & 0xf);
-}
-
-static __inline unsigned int
-get_Opcode_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 58)) & 0xf);
-}
-
-static __inline unsigned int
-get_Opcode_Y2(tilegx_bundle_bits n)
-{
-  return (((n >> 26)) & 0x00000001) |
-         (((unsigned int)(n >> 56)) & 0x00000002);
-}
-
-static __inline unsigned int
-get_RRROpcodeExtension_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 18)) & 0x3ff);
-}
-
-static __inline unsigned int
-get_RRROpcodeExtension_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 49)) & 0x3ff);
-}
-
-static __inline unsigned int
-get_RRROpcodeExtension_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 18)) & 0x3);
-}
-
-static __inline unsigned int
-get_RRROpcodeExtension_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 49)) & 0x3);
-}
-
-static __inline unsigned int
-get_ShAmt_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0x3f);
-}
-
-static __inline unsigned int
-get_ShAmt_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0x3f);
-}
-
-static __inline unsigned int
-get_ShAmt_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0x3f);
-}
-
-static __inline unsigned int
-get_ShAmt_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0x3f);
-}
-
-static __inline unsigned int
-get_ShiftOpcodeExtension_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 18)) & 0x3ff);
-}
-
-static __inline unsigned int
-get_ShiftOpcodeExtension_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 49)) & 0x3ff);
-}
-
-static __inline unsigned int
-get_ShiftOpcodeExtension_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 18)) & 0x3);
-}
-
-static __inline unsigned int
-get_ShiftOpcodeExtension_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 49)) & 0x3);
-}
-
-static __inline unsigned int
-get_SrcA_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 6)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcA_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 37)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcA_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 6)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcA_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 37)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcA_Y2(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 20)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcBDest_Y2(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 51)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcB_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcB_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcB_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0x3f);
-}
-
-static __inline unsigned int
-get_SrcB_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0x3f);
-}
-
-static __inline unsigned int
-get_UnaryOpcodeExtension_X0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0x3f);
-}
-
-static __inline unsigned int
-get_UnaryOpcodeExtension_X1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0x3f);
-}
-
-static __inline unsigned int
-get_UnaryOpcodeExtension_Y0(tilegx_bundle_bits num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((n >> 12)) & 0x3f);
-}
-
-static __inline unsigned int
-get_UnaryOpcodeExtension_Y1(tilegx_bundle_bits n)
-{
-  return (((unsigned int)(n >> 43)) & 0x3f);
-}
-
-static __inline int
-sign_extend(int n, int num_bits)
-{
-  int shift = (int)(sizeof(int) * 8 - num_bits);
-  return (n << shift) >> shift;
-}
-
-static __inline tilegx_bundle_bits
-create_BFEnd_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_BFOpcodeExtension_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0xf) << 24);
-}
-
-static __inline tilegx_bundle_bits
-create_BFStart_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 18);
-}
-
-static __inline tilegx_bundle_bits
-create_BrOff_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x0000003f)) << 31) |
-         (((tilegx_bundle_bits)(n & 0x0001ffc0)) << 37);
-}
-
-static __inline tilegx_bundle_bits
-create_BrType_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x1f)) << 54);
-}
-
-static __inline tilegx_bundle_bits
-create_Dest_Imm8_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x0000003f)) << 31) |
-         (((tilegx_bundle_bits)(n & 0x000000c0)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_Dest_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 0);
-}
-
-static __inline tilegx_bundle_bits
-create_Dest_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 31);
-}
-
-static __inline tilegx_bundle_bits
-create_Dest_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 0);
-}
-
-static __inline tilegx_bundle_bits
-create_Dest_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 31);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm16_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0xffff) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm16_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0xffff)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm8OpcodeExtension_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0xff) << 20);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm8OpcodeExtension_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0xff)) << 51);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm8_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0xff) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm8_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0xff)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm8_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0xff) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_Imm8_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0xff)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_JumpOff_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x7ffffff)) << 31);
-}
-
-static __inline tilegx_bundle_bits
-create_JumpOpcodeExtension_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x1)) << 58);
-}
-
-static __inline tilegx_bundle_bits
-create_MF_Imm14_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3fff)) << 37);
-}
-
-static __inline tilegx_bundle_bits
-create_MT_Imm14_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x0000003f)) << 31) |
-         (((tilegx_bundle_bits)(n & 0x00003fc0)) << 37);
-}
-
-static __inline tilegx_bundle_bits
-create_Mode(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3)) << 62);
-}
-
-static __inline tilegx_bundle_bits
-create_Opcode_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x7) << 28);
-}
-
-static __inline tilegx_bundle_bits
-create_Opcode_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x7)) << 59);
-}
-
-static __inline tilegx_bundle_bits
-create_Opcode_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0xf) << 27);
-}
-
-static __inline tilegx_bundle_bits
-create_Opcode_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0xf)) << 58);
-}
-
-static __inline tilegx_bundle_bits
-create_Opcode_Y2(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x00000001) << 26) |
-         (((tilegx_bundle_bits)(n & 0x00000002)) << 56);
-}
-
-static __inline tilegx_bundle_bits
-create_RRROpcodeExtension_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3ff) << 18);
-}
-
-static __inline tilegx_bundle_bits
-create_RRROpcodeExtension_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3ff)) << 49);
-}
-
-static __inline tilegx_bundle_bits
-create_RRROpcodeExtension_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3) << 18);
-}
-
-static __inline tilegx_bundle_bits
-create_RRROpcodeExtension_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3)) << 49);
-}
-
-static __inline tilegx_bundle_bits
-create_ShAmt_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_ShAmt_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_ShAmt_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_ShAmt_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_ShiftOpcodeExtension_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3ff) << 18);
-}
-
-static __inline tilegx_bundle_bits
-create_ShiftOpcodeExtension_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3ff)) << 49);
-}
-
-static __inline tilegx_bundle_bits
-create_ShiftOpcodeExtension_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3) << 18);
-}
-
-static __inline tilegx_bundle_bits
-create_ShiftOpcodeExtension_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3)) << 49);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcA_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 6);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcA_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 37);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcA_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 6);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcA_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 37);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcA_Y2(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 20);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcBDest_Y2(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 51);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcB_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcB_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcB_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_SrcB_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_UnaryOpcodeExtension_X0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_UnaryOpcodeExtension_X1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 43);
-}
-
-static __inline tilegx_bundle_bits
-create_UnaryOpcodeExtension_Y0(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return ((n & 0x3f) << 12);
-}
-
-static __inline tilegx_bundle_bits
-create_UnaryOpcodeExtension_Y1(int num)
-{
-  const unsigned int n = (unsigned int)num;
-  return (((tilegx_bundle_bits)(n & 0x3f)) << 43);
-}
-
-const struct tilegx_opcode tilegx_opcodes[336] =
-{
- { "bpt", TILEGX_OPC_BPT, 0x2, 0, TREG_ZERO, 0,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffffffff80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a44ae00000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "info", TILEGX_OPC_INFO, 0xf, 1, TREG_ZERO, 1,
-    { { 0 }, { 1 }, { 2 }, { 3 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00fffULL,
-      0xfff807ff80000000ULL,
-      0x0000000078000fffULL,
-      0x3c0007ff80000000ULL,
-      0ULL
-    },
-    {
-      0x0000000040300fffULL,
-      0x181807ff80000000ULL,
-      0x0000000010000fffULL,
-      0x0c0007ff80000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "infol", TILEGX_OPC_INFOL, 0x3, 1, TREG_ZERO, 1,
-    { { 4 }, { 5 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc000000070000fffULL,
-      0xf80007ff80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000070000fffULL,
-      0x380007ff80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld4s_tls", TILEGX_OPC_LD4S_TLS, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1858000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld_tls", TILEGX_OPC_LD_TLS, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18a0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "move", TILEGX_OPC_MOVE, 0xf, 2, TREG_ZERO, 1,
-    { { 8, 9 }, { 6, 7 }, { 10, 11 }, { 12, 13 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0xfffff80000000000ULL,
-      0x00000000780ff000ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      0x000000005107f000ULL,
-      0x283bf80000000000ULL,
-      0x00000000500bf000ULL,
-      0x2c05f80000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "movei", TILEGX_OPC_MOVEI, 0xf, 2, TREG_ZERO, 1,
-    { { 8, 0 }, { 6, 1 }, { 10, 2 }, { 12, 3 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00fc0ULL,
-      0xfff807e000000000ULL,
-      0x0000000078000fc0ULL,
-      0x3c0007e000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000040100fc0ULL,
-      0x180807e000000000ULL,
-      0x0000000000000fc0ULL,
-      0x040007e000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "moveli", TILEGX_OPC_MOVELI, 0x3, 2, TREG_ZERO, 1,
-    { { 8, 4 }, { 6, 5 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc000000070000fc0ULL,
-      0xf80007e000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000010000fc0ULL,
-      0x000007e000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "prefetch", TILEGX_OPC_PREFETCH, 0x12, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff81f80000000ULL,
-      0ULL,
-      0ULL,
-      0xc3f8000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a801f80000000ULL,
-      -1ULL,
-      -1ULL,
-      0x41f8000004000000ULL
-    }
-#endif
-  },
-  { "prefetch_add_l1", TILEGX_OPC_PREFETCH_ADD_L1, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8001f80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1840001f80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "prefetch_add_l1_fault", TILEGX_OPC_PREFETCH_ADD_L1_FAULT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8001f80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1838001f80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "prefetch_add_l2", TILEGX_OPC_PREFETCH_ADD_L2, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8001f80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1850001f80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "prefetch_add_l2_fault", TILEGX_OPC_PREFETCH_ADD_L2_FAULT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8001f80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1848001f80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "prefetch_add_l3", TILEGX_OPC_PREFETCH_ADD_L3, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8001f80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1860001f80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "prefetch_add_l3_fault", TILEGX_OPC_PREFETCH_ADD_L3_FAULT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8001f80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1858001f80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "prefetch_l1", TILEGX_OPC_PREFETCH_L1, 0x12, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff81f80000000ULL,
-      0ULL,
-      0ULL,
-      0xc3f8000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a801f80000000ULL,
-      -1ULL,
-      -1ULL,
-      0x41f8000004000000ULL
-    }
-#endif
-  },
-  { "prefetch_l1_fault", TILEGX_OPC_PREFETCH_L1_FAULT, 0x12, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff81f80000000ULL,
-      0ULL,
-      0ULL,
-      0xc3f8000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a781f80000000ULL,
-      -1ULL,
-      -1ULL,
-      0x41f8000000000000ULL
-    }
-#endif
-  },
-  { "prefetch_l2", TILEGX_OPC_PREFETCH_L2, 0x12, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff81f80000000ULL,
-      0ULL,
-      0ULL,
-      0xc3f8000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a901f80000000ULL,
-      -1ULL,
-      -1ULL,
-      0x43f8000004000000ULL
-    }
-#endif
-  },
-  { "prefetch_l2_fault", TILEGX_OPC_PREFETCH_L2_FAULT, 0x12, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff81f80000000ULL,
-      0ULL,
-      0ULL,
-      0xc3f8000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a881f80000000ULL,
-      -1ULL,
-      -1ULL,
-      0x43f8000000000000ULL
-    }
-#endif
-  },
-  { "prefetch_l3", TILEGX_OPC_PREFETCH_L3, 0x12, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff81f80000000ULL,
-      0ULL,
-      0ULL,
-      0xc3f8000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286aa01f80000000ULL,
-      -1ULL,
-      -1ULL,
-      0x83f8000000000000ULL
-    }
-#endif
-  },
-  { "prefetch_l3_fault", TILEGX_OPC_PREFETCH_L3_FAULT, 0x12, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff81f80000000ULL,
-      0ULL,
-      0ULL,
-      0xc3f8000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a981f80000000ULL,
-      -1ULL,
-      -1ULL,
-      0x81f8000004000000ULL
-    }
-#endif
-  },
-  { "raise", TILEGX_OPC_RAISE, 0x2, 0, TREG_ZERO, 1,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffffffff80000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a44ae80000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "add", TILEGX_OPC_ADD, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x00000000500c0000ULL,
-      0x2806000000000000ULL,
-      0x0000000028040000ULL,
-      0x1802000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "addi", TILEGX_OPC_ADDI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 10, 11, 2 }, { 12, 13, 3 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0x0000000078000000ULL,
-      0x3c00000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000040100000ULL,
-      0x1808000000000000ULL,
-      0ULL,
-      0x0400000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "addli", TILEGX_OPC_ADDLI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 4 }, { 6, 7, 5 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc000000070000000ULL,
-      0xf800000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000010000000ULL,
-      0ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "addx", TILEGX_OPC_ADDX, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050080000ULL,
-      0x2804000000000000ULL,
-      0x0000000028000000ULL,
-      0x1800000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "addxi", TILEGX_OPC_ADDXI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 10, 11, 2 }, { 12, 13, 3 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0x0000000078000000ULL,
-      0x3c00000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000040200000ULL,
-      0x1810000000000000ULL,
-      0x0000000008000000ULL,
-      0x0800000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "addxli", TILEGX_OPC_ADDXLI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 4 }, { 6, 7, 5 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc000000070000000ULL,
-      0xf800000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000020000000ULL,
-      0x0800000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "addxsc", TILEGX_OPC_ADDXSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050040000ULL,
-      0x2802000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "and", TILEGX_OPC_AND, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050100000ULL,
-      0x2808000000000000ULL,
-      0x0000000050000000ULL,
-      0x2c00000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "andi", TILEGX_OPC_ANDI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 10, 11, 2 }, { 12, 13, 3 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0x0000000078000000ULL,
-      0x3c00000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000040300000ULL,
-      0x1818000000000000ULL,
-      0x0000000010000000ULL,
-      0x0c00000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "beqz", TILEGX_OPC_BEQZ, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1440000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "beqzt", TILEGX_OPC_BEQZT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1400000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bfexts", TILEGX_OPC_BFEXTS, 0x1, 4, TREG_ZERO, 1,
-    { { 8, 9, 21, 22 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007f000000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000034000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bfextu", TILEGX_OPC_BFEXTU, 0x1, 4, TREG_ZERO, 1,
-    { { 8, 9, 21, 22 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007f000000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000035000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bfins", TILEGX_OPC_BFINS, 0x1, 4, TREG_ZERO, 1,
-    { { 23, 9, 21, 22 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007f000000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000036000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bgez", TILEGX_OPC_BGEZ, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x14c0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bgezt", TILEGX_OPC_BGEZT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1480000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bgtz", TILEGX_OPC_BGTZ, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1540000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bgtzt", TILEGX_OPC_BGTZT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1500000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "blbc", TILEGX_OPC_BLBC, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x15c0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "blbct", TILEGX_OPC_BLBCT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1580000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "blbs", TILEGX_OPC_BLBS, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1640000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "blbst", TILEGX_OPC_BLBST, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1600000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "blez", TILEGX_OPC_BLEZ, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x16c0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "blezt", TILEGX_OPC_BLEZT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1680000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bltz", TILEGX_OPC_BLTZ, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1740000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bltzt", TILEGX_OPC_BLTZT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1700000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bnez", TILEGX_OPC_BNEZ, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x17c0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "bnezt", TILEGX_OPC_BNEZT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 20 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xffc0000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1780000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "clz", TILEGX_OPC_CLZ, 0x5, 2, TREG_ZERO, 1,
-    { { 8, 9 }, { 0, }, { 10, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051481000ULL,
-      -1ULL,
-      0x00000000300c1000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmoveqz", TILEGX_OPC_CMOVEQZ, 0x5, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 24, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050140000ULL,
-      -1ULL,
-      0x0000000048000000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmovnez", TILEGX_OPC_CMOVNEZ, 0x5, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 24, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050180000ULL,
-      -1ULL,
-      0x0000000048040000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpeq", TILEGX_OPC_CMPEQ, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x00000000501c0000ULL,
-      0x280a000000000000ULL,
-      0x0000000040000000ULL,
-      0x2404000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpeqi", TILEGX_OPC_CMPEQI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 10, 11, 2 }, { 12, 13, 3 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0x0000000078000000ULL,
-      0x3c00000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000040400000ULL,
-      0x1820000000000000ULL,
-      0x0000000018000000ULL,
-      0x1000000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpexch", TILEGX_OPC_CMPEXCH, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x280e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpexch4", TILEGX_OPC_CMPEXCH4, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x280c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmples", TILEGX_OPC_CMPLES, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050200000ULL,
-      0x2810000000000000ULL,
-      0x0000000038000000ULL,
-      0x2000000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpleu", TILEGX_OPC_CMPLEU, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050240000ULL,
-      0x2812000000000000ULL,
-      0x0000000038040000ULL,
-      0x2002000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmplts", TILEGX_OPC_CMPLTS, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050280000ULL,
-      0x2814000000000000ULL,
-      0x0000000038080000ULL,
-      0x2004000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpltsi", TILEGX_OPC_CMPLTSI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 10, 11, 2 }, { 12, 13, 3 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0x0000000078000000ULL,
-      0x3c00000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000040500000ULL,
-      0x1828000000000000ULL,
-      0x0000000020000000ULL,
-      0x1400000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpltu", TILEGX_OPC_CMPLTU, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x00000000502c0000ULL,
-      0x2816000000000000ULL,
-      0x00000000380c0000ULL,
-      0x2006000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpltui", TILEGX_OPC_CMPLTUI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040600000ULL,
-      0x1830000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmpne", TILEGX_OPC_CMPNE, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050300000ULL,
-      0x2818000000000000ULL,
-      0x0000000040040000ULL,
-      0x2406000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmul", TILEGX_OPC_CMUL, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000504c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmula", TILEGX_OPC_CMULA, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050380000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmulaf", TILEGX_OPC_CMULAF, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050340000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmulf", TILEGX_OPC_CMULF, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050400000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmulfr", TILEGX_OPC_CMULFR, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000503c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmulh", TILEGX_OPC_CMULH, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050480000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "cmulhr", TILEGX_OPC_CMULHR, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050440000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "crc32_32", TILEGX_OPC_CRC32_32, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050500000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "crc32_8", TILEGX_OPC_CRC32_8, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050540000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ctz", TILEGX_OPC_CTZ, 0x5, 2, TREG_ZERO, 1,
-    { { 8, 9 }, { 0, }, { 10, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051482000ULL,
-      -1ULL,
-      0x00000000300c2000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "dblalign", TILEGX_OPC_DBLALIGN, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050640000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "dblalign2", TILEGX_OPC_DBLALIGN2, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050580000ULL,
-      0x281a000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "dblalign4", TILEGX_OPC_DBLALIGN4, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000505c0000ULL,
-      0x281c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "dblalign6", TILEGX_OPC_DBLALIGN6, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050600000ULL,
-      0x281e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "drain", TILEGX_OPC_DRAIN, 0x2, 0, TREG_ZERO, 0,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a080000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "dtlbpr", TILEGX_OPC_DTLBPR, 0x2, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a100000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "exch", TILEGX_OPC_EXCH, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2822000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "exch4", TILEGX_OPC_EXCH4, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2820000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_add_flags", TILEGX_OPC_FDOUBLE_ADD_FLAGS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000506c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_addsub", TILEGX_OPC_FDOUBLE_ADDSUB, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050680000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_mul_flags", TILEGX_OPC_FDOUBLE_MUL_FLAGS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050700000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_pack1", TILEGX_OPC_FDOUBLE_PACK1, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050740000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_pack2", TILEGX_OPC_FDOUBLE_PACK2, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050780000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_sub_flags", TILEGX_OPC_FDOUBLE_SUB_FLAGS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000507c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_unpack_max", TILEGX_OPC_FDOUBLE_UNPACK_MAX, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050800000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fdouble_unpack_min", TILEGX_OPC_FDOUBLE_UNPACK_MIN, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050840000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchadd", TILEGX_OPC_FETCHADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x282a000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchadd4", TILEGX_OPC_FETCHADD4, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2824000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchaddgez", TILEGX_OPC_FETCHADDGEZ, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2828000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchaddgez4", TILEGX_OPC_FETCHADDGEZ4, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2826000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchand", TILEGX_OPC_FETCHAND, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x282e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchand4", TILEGX_OPC_FETCHAND4, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x282c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchor", TILEGX_OPC_FETCHOR, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2832000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fetchor4", TILEGX_OPC_FETCHOR4, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2830000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "finv", TILEGX_OPC_FINV, 0x2, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a180000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "flush", TILEGX_OPC_FLUSH, 0x2, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a280000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "flushwb", TILEGX_OPC_FLUSHWB, 0x2, 0, TREG_ZERO, 1,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a200000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fnop", TILEGX_OPC_FNOP, 0xf, 0, TREG_ZERO, 1,
-    { {  }, {  }, {  }, {  }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0xfffff80000000000ULL,
-      0x00000000780ff000ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051483000ULL,
-      0x286a300000000000ULL,
-      0x00000000300c3000ULL,
-      0x1c06400000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fsingle_add1", TILEGX_OPC_FSINGLE_ADD1, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050880000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fsingle_addsub2", TILEGX_OPC_FSINGLE_ADDSUB2, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000508c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fsingle_mul1", TILEGX_OPC_FSINGLE_MUL1, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050900000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fsingle_mul2", TILEGX_OPC_FSINGLE_MUL2, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050940000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fsingle_pack1", TILEGX_OPC_FSINGLE_PACK1, 0x5, 2, TREG_ZERO, 1,
-    { { 8, 9 }, { 0, }, { 10, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051484000ULL,
-      -1ULL,
-      0x00000000300c4000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fsingle_pack2", TILEGX_OPC_FSINGLE_PACK2, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050980000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "fsingle_sub1", TILEGX_OPC_FSINGLE_SUB1, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000509c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "icoh", TILEGX_OPC_ICOH, 0x2, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a380000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ill", TILEGX_OPC_ILL, 0xa, 0, TREG_ZERO, 1,
-    { { 0, }, {  }, { 0, }, {  }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a400000000000ULL,
-      -1ULL,
-      0x1c06480000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "inv", TILEGX_OPC_INV, 0x2, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a480000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "iret", TILEGX_OPC_IRET, 0x2, 0, TREG_ZERO, 1,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a500000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "j", TILEGX_OPC_J, 0x2, 1, TREG_ZERO, 1,
-    { { 0, }, { 25 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfc00000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2400000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "jal", TILEGX_OPC_JAL, 0x2, 1, TREG_LR, 1,
-    { { 0, }, { 25 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfc00000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2000000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "jalr", TILEGX_OPC_JALR, 0xa, 1, TREG_LR, 1,
-    { { 0, }, { 7 }, { 0, }, { 13 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a600000000000ULL,
-      -1ULL,
-      0x1c06580000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "jalrp", TILEGX_OPC_JALRP, 0xa, 1, TREG_LR, 1,
-    { { 0, }, { 7 }, { 0, }, { 13 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a580000000000ULL,
-      -1ULL,
-      0x1c06500000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "jr", TILEGX_OPC_JR, 0xa, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 13 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a700000000000ULL,
-      -1ULL,
-      0x1c06680000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "jrp", TILEGX_OPC_JRP, 0xa, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 13 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286a680000000000ULL,
-      -1ULL,
-      0x1c06600000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld", TILEGX_OPC_LD, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 26, 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286ae80000000000ULL,
-      -1ULL,
-      -1ULL,
-      0x8200000004000000ULL
-    }
-#endif
-  },
-  { "ld1s", TILEGX_OPC_LD1S, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 26, 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a780000000000ULL,
-      -1ULL,
-      -1ULL,
-      0x4000000000000000ULL
-    }
-#endif
-  },
-  { "ld1s_add", TILEGX_OPC_LD1S_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1838000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld1u", TILEGX_OPC_LD1U, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 26, 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a800000000000ULL,
-      -1ULL,
-      -1ULL,
-      0x4000000004000000ULL
-    }
-#endif
-  },
-  { "ld1u_add", TILEGX_OPC_LD1U_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1840000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld2s", TILEGX_OPC_LD2S, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 26, 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a880000000000ULL,
-      -1ULL,
-      -1ULL,
-      0x4200000000000000ULL
-    }
-#endif
-  },
-  { "ld2s_add", TILEGX_OPC_LD2S_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1848000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld2u", TILEGX_OPC_LD2U, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 26, 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a900000000000ULL,
-      -1ULL,
-      -1ULL,
-      0x4200000004000000ULL
-    }
-#endif
-  },
-  { "ld2u_add", TILEGX_OPC_LD2U_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1850000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld4s", TILEGX_OPC_LD4S, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 26, 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286a980000000000ULL,
-      -1ULL,
-      -1ULL,
-      0x8000000004000000ULL
-    }
-#endif
-  },
-  { "ld4s_add", TILEGX_OPC_LD4S_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1858000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld4u", TILEGX_OPC_LD4U, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 26, 14 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x286aa00000000000ULL,
-      -1ULL,
-      -1ULL,
-      0x8200000000000000ULL
-    }
-#endif
-  },
-  { "ld4u_add", TILEGX_OPC_LD4U_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1860000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ld_add", TILEGX_OPC_LD_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18a0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldna", TILEGX_OPC_LDNA, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286aa80000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldna_add", TILEGX_OPC_LDNA_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18a8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt", TILEGX_OPC_LDNT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286ae00000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt1s", TILEGX_OPC_LDNT1S, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286ab00000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt1s_add", TILEGX_OPC_LDNT1S_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1868000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt1u", TILEGX_OPC_LDNT1U, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286ab80000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt1u_add", TILEGX_OPC_LDNT1U_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1870000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt2s", TILEGX_OPC_LDNT2S, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286ac00000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt2s_add", TILEGX_OPC_LDNT2S_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1878000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt2u", TILEGX_OPC_LDNT2U, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286ac80000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt2u_add", TILEGX_OPC_LDNT2U_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1880000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt4s", TILEGX_OPC_LDNT4S, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286ad00000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt4s_add", TILEGX_OPC_LDNT4S_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1888000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt4u", TILEGX_OPC_LDNT4U, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286ad80000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt4u_add", TILEGX_OPC_LDNT4U_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1890000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ldnt_add", TILEGX_OPC_LDNT_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 6, 15, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1898000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "lnk", TILEGX_OPC_LNK, 0xa, 1, TREG_ZERO, 1,
-    { { 0, }, { 6 }, { 0, }, { 12 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286af00000000000ULL,
-      -1ULL,
-      0x1c06700000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mf", TILEGX_OPC_MF, 0x2, 0, TREG_ZERO, 1,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286af80000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mfspr", TILEGX_OPC_MFSPR, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 6, 27 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18b0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mm", TILEGX_OPC_MM, 0x1, 4, TREG_ZERO, 1,
-    { { 23, 9, 21, 22 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007f000000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000037000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mnz", TILEGX_OPC_MNZ, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050a00000ULL,
-      0x2834000000000000ULL,
-      0x0000000048080000ULL,
-      0x2804000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mtspr", TILEGX_OPC_MTSPR, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 28, 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18b8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_hs_hs", TILEGX_OPC_MUL_HS_HS, 0x5, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 10, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050d40000ULL,
-      -1ULL,
-      0x0000000068000000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_hs_hu", TILEGX_OPC_MUL_HS_HU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050d80000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_hs_ls", TILEGX_OPC_MUL_HS_LS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050dc0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_hs_lu", TILEGX_OPC_MUL_HS_LU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050e00000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_hu_hu", TILEGX_OPC_MUL_HU_HU, 0x5, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 10, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050e40000ULL,
-      -1ULL,
-      0x0000000068040000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_hu_ls", TILEGX_OPC_MUL_HU_LS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050e80000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_hu_lu", TILEGX_OPC_MUL_HU_LU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050ec0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_ls_ls", TILEGX_OPC_MUL_LS_LS, 0x5, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 10, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050f00000ULL,
-      -1ULL,
-      0x0000000068080000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_ls_lu", TILEGX_OPC_MUL_LS_LU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050f40000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mul_lu_lu", TILEGX_OPC_MUL_LU_LU, 0x5, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 10, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050f80000ULL,
-      -1ULL,
-      0x00000000680c0000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_hs_hs", TILEGX_OPC_MULA_HS_HS, 0x5, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 24, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050a80000ULL,
-      -1ULL,
-      0x0000000070000000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_hs_hu", TILEGX_OPC_MULA_HS_HU, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050ac0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_hs_ls", TILEGX_OPC_MULA_HS_LS, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050b00000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_hs_lu", TILEGX_OPC_MULA_HS_LU, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050b40000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_hu_hu", TILEGX_OPC_MULA_HU_HU, 0x5, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 24, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050b80000ULL,
-      -1ULL,
-      0x0000000070040000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_hu_ls", TILEGX_OPC_MULA_HU_LS, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050bc0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_hu_lu", TILEGX_OPC_MULA_HU_LU, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050c00000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_ls_ls", TILEGX_OPC_MULA_LS_LS, 0x5, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 24, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050c40000ULL,
-      -1ULL,
-      0x0000000070080000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_ls_lu", TILEGX_OPC_MULA_LS_LU, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050c80000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mula_lu_lu", TILEGX_OPC_MULA_LU_LU, 0x5, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 24, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050cc0000ULL,
-      -1ULL,
-      0x00000000700c0000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mulax", TILEGX_OPC_MULAX, 0x5, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 24, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050a40000ULL,
-      -1ULL,
-      0x0000000040080000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mulx", TILEGX_OPC_MULX, 0x5, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 10, 11, 18 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0x00000000780c0000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000050d00000ULL,
-      -1ULL,
-      0x00000000400c0000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "mz", TILEGX_OPC_MZ, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000050fc0000ULL,
-      0x2836000000000000ULL,
-      0x00000000480c0000ULL,
-      0x2806000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "nap", TILEGX_OPC_NAP, 0x2, 0, TREG_ZERO, 0,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286b000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "nop", TILEGX_OPC_NOP, 0xf, 0, TREG_ZERO, 1,
-    { {  }, {  }, {  }, {  }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0xfffff80000000000ULL,
-      0x00000000780ff000ULL,
-      0x3c07f80000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051485000ULL,
-      0x286b080000000000ULL,
-      0x00000000300c5000ULL,
-      0x1c06780000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "nor", TILEGX_OPC_NOR, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051000000ULL,
-      0x2838000000000000ULL,
-      0x0000000050040000ULL,
-      0x2c02000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "or", TILEGX_OPC_OR, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051040000ULL,
-      0x283a000000000000ULL,
-      0x0000000050080000ULL,
-      0x2c04000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "ori", TILEGX_OPC_ORI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040700000ULL,
-      0x18c0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "pcnt", TILEGX_OPC_PCNT, 0x5, 2, TREG_ZERO, 1,
-    { { 8, 9 }, { 0, }, { 10, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051486000ULL,
-      -1ULL,
-      0x00000000300c6000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "revbits", TILEGX_OPC_REVBITS, 0x5, 2, TREG_ZERO, 1,
-    { { 8, 9 }, { 0, }, { 10, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051487000ULL,
-      -1ULL,
-      0x00000000300c7000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "revbytes", TILEGX_OPC_REVBYTES, 0x5, 2, TREG_ZERO, 1,
-    { { 8, 9 }, { 0, }, { 10, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051488000ULL,
-      -1ULL,
-      0x00000000300c8000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "rotl", TILEGX_OPC_ROTL, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051080000ULL,
-      0x283c000000000000ULL,
-      0x0000000058000000ULL,
-      0x3000000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "rotli", TILEGX_OPC_ROTLI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 10, 11, 31 }, { 12, 13, 32 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000060040000ULL,
-      0x3002000000000000ULL,
-      0x0000000078000000ULL,
-      0x3800000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl", TILEGX_OPC_SHL, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051280000ULL,
-      0x284c000000000000ULL,
-      0x0000000058040000ULL,
-      0x3002000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl16insli", TILEGX_OPC_SHL16INSLI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 4 }, { 6, 7, 5 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc000000070000000ULL,
-      0xf800000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000070000000ULL,
-      0x3800000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl1add", TILEGX_OPC_SHL1ADD, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051100000ULL,
-      0x2840000000000000ULL,
-      0x0000000030000000ULL,
-      0x1c00000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl1addx", TILEGX_OPC_SHL1ADDX, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x00000000510c0000ULL,
-      0x283e000000000000ULL,
-      0x0000000060040000ULL,
-      0x3402000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl2add", TILEGX_OPC_SHL2ADD, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051180000ULL,
-      0x2844000000000000ULL,
-      0x0000000030040000ULL,
-      0x1c02000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl2addx", TILEGX_OPC_SHL2ADDX, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051140000ULL,
-      0x2842000000000000ULL,
-      0x0000000060080000ULL,
-      0x3404000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl3add", TILEGX_OPC_SHL3ADD, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051200000ULL,
-      0x2848000000000000ULL,
-      0x0000000030080000ULL,
-      0x1c04000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shl3addx", TILEGX_OPC_SHL3ADDX, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x00000000511c0000ULL,
-      0x2846000000000000ULL,
-      0x00000000600c0000ULL,
-      0x3406000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shli", TILEGX_OPC_SHLI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 10, 11, 31 }, { 12, 13, 32 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000060080000ULL,
-      0x3004000000000000ULL,
-      0x0000000078040000ULL,
-      0x3802000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shlx", TILEGX_OPC_SHLX, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051240000ULL,
-      0x284a000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shlxi", TILEGX_OPC_SHLXI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000600c0000ULL,
-      0x3006000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shrs", TILEGX_OPC_SHRS, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x00000000512c0000ULL,
-      0x284e000000000000ULL,
-      0x0000000058080000ULL,
-      0x3004000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shrsi", TILEGX_OPC_SHRSI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 10, 11, 31 }, { 12, 13, 32 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000060100000ULL,
-      0x3008000000000000ULL,
-      0x0000000078080000ULL,
-      0x3804000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shru", TILEGX_OPC_SHRU, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051340000ULL,
-      0x2852000000000000ULL,
-      0x00000000580c0000ULL,
-      0x3006000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shrui", TILEGX_OPC_SHRUI, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 10, 11, 31 }, { 12, 13, 32 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000060140000ULL,
-      0x300a000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3806000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shrux", TILEGX_OPC_SHRUX, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051300000ULL,
-      0x2850000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shruxi", TILEGX_OPC_SHRUXI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000060180000ULL,
-      0x300c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "shufflebytes", TILEGX_OPC_SHUFFLEBYTES, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051380000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "st", TILEGX_OPC_ST, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 14, 33 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x2862000000000000ULL,
-      -1ULL,
-      -1ULL,
-      0xc200000004000000ULL
-    }
-#endif
-  },
-  { "st1", TILEGX_OPC_ST1, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 14, 33 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x2854000000000000ULL,
-      -1ULL,
-      -1ULL,
-      0xc000000000000000ULL
-    }
-#endif
-  },
-  { "st1_add", TILEGX_OPC_ST1_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18c8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "st2", TILEGX_OPC_ST2, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 14, 33 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x2856000000000000ULL,
-      -1ULL,
-      -1ULL,
-      0xc000000004000000ULL
-    }
-#endif
-  },
-  { "st2_add", TILEGX_OPC_ST2_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18d0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "st4", TILEGX_OPC_ST4, 0x12, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 14, 33 } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0xc200000004000000ULL
-    },
-    {
-      -1ULL,
-      0x2858000000000000ULL,
-      -1ULL,
-      -1ULL,
-      0xc200000000000000ULL
-    }
-#endif
-  },
-  { "st4_add", TILEGX_OPC_ST4_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18d8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "st_add", TILEGX_OPC_ST_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x1900000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt", TILEGX_OPC_STNT, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x2860000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt1", TILEGX_OPC_STNT1, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x285a000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt1_add", TILEGX_OPC_STNT1_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18e0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt2", TILEGX_OPC_STNT2, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x285c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt2_add", TILEGX_OPC_STNT2_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18e8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt4", TILEGX_OPC_STNT4, 0x2, 2, TREG_ZERO, 1,
-    { { 0, }, { 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x285e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt4_add", TILEGX_OPC_STNT4_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18f0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "stnt_add", TILEGX_OPC_STNT_ADD, 0x2, 3, TREG_ZERO, 1,
-    { { 0, }, { 15, 17, 34 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x18f8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "sub", TILEGX_OPC_SUB, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051440000ULL,
-      0x2868000000000000ULL,
-      0x00000000280c0000ULL,
-      0x1806000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "subx", TILEGX_OPC_SUBX, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000051400000ULL,
-      0x2866000000000000ULL,
-      0x0000000028080000ULL,
-      0x1804000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "subxsc", TILEGX_OPC_SUBXSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000513c0000ULL,
-      0x2864000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "swint0", TILEGX_OPC_SWINT0, 0x2, 0, TREG_ZERO, 0,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286b100000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "swint1", TILEGX_OPC_SWINT1, 0x2, 0, TREG_ZERO, 0,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286b180000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "swint2", TILEGX_OPC_SWINT2, 0x2, 0, TREG_ZERO, 0,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286b200000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "swint3", TILEGX_OPC_SWINT3, 0x2, 0, TREG_ZERO, 0,
-    { { 0, }, {  }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286b280000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "tblidxb0", TILEGX_OPC_TBLIDXB0, 0x5, 2, TREG_ZERO, 1,
-    { { 23, 9 }, { 0, }, { 24, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051489000ULL,
-      -1ULL,
-      0x00000000300c9000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "tblidxb1", TILEGX_OPC_TBLIDXB1, 0x5, 2, TREG_ZERO, 1,
-    { { 23, 9 }, { 0, }, { 24, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x000000005148a000ULL,
-      -1ULL,
-      0x00000000300ca000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "tblidxb2", TILEGX_OPC_TBLIDXB2, 0x5, 2, TREG_ZERO, 1,
-    { { 23, 9 }, { 0, }, { 24, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x000000005148b000ULL,
-      -1ULL,
-      0x00000000300cb000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "tblidxb3", TILEGX_OPC_TBLIDXB3, 0x5, 2, TREG_ZERO, 1,
-    { { 23, 9 }, { 0, }, { 24, 11 }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffff000ULL,
-      0ULL,
-      0x00000000780ff000ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x000000005148c000ULL,
-      -1ULL,
-      0x00000000300cc000ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1add", TILEGX_OPC_V1ADD, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051500000ULL,
-      0x286e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1addi", TILEGX_OPC_V1ADDI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040800000ULL,
-      0x1908000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1adduc", TILEGX_OPC_V1ADDUC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000514c0000ULL,
-      0x286c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1adiffu", TILEGX_OPC_V1ADIFFU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051540000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1avgu", TILEGX_OPC_V1AVGU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051580000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmpeq", TILEGX_OPC_V1CMPEQ, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000515c0000ULL,
-      0x2870000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmpeqi", TILEGX_OPC_V1CMPEQI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040900000ULL,
-      0x1910000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmples", TILEGX_OPC_V1CMPLES, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051600000ULL,
-      0x2872000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmpleu", TILEGX_OPC_V1CMPLEU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051640000ULL,
-      0x2874000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmplts", TILEGX_OPC_V1CMPLTS, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051680000ULL,
-      0x2876000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmpltsi", TILEGX_OPC_V1CMPLTSI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040a00000ULL,
-      0x1918000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmpltu", TILEGX_OPC_V1CMPLTU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000516c0000ULL,
-      0x2878000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmpltui", TILEGX_OPC_V1CMPLTUI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040b00000ULL,
-      0x1920000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1cmpne", TILEGX_OPC_V1CMPNE, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051700000ULL,
-      0x287a000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1ddotpu", TILEGX_OPC_V1DDOTPU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052880000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1ddotpua", TILEGX_OPC_V1DDOTPUA, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052840000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1ddotpus", TILEGX_OPC_V1DDOTPUS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051780000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1ddotpusa", TILEGX_OPC_V1DDOTPUSA, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051740000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1dotp", TILEGX_OPC_V1DOTP, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051880000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1dotpa", TILEGX_OPC_V1DOTPA, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000517c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1dotpu", TILEGX_OPC_V1DOTPU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052900000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1dotpua", TILEGX_OPC_V1DOTPUA, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000528c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1dotpus", TILEGX_OPC_V1DOTPUS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051840000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1dotpusa", TILEGX_OPC_V1DOTPUSA, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051800000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1int_h", TILEGX_OPC_V1INT_H, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000518c0000ULL,
-      0x287c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1int_l", TILEGX_OPC_V1INT_L, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051900000ULL,
-      0x287e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1maxu", TILEGX_OPC_V1MAXU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051940000ULL,
-      0x2880000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1maxui", TILEGX_OPC_V1MAXUI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040c00000ULL,
-      0x1928000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1minu", TILEGX_OPC_V1MINU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051980000ULL,
-      0x2882000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1minui", TILEGX_OPC_V1MINUI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040d00000ULL,
-      0x1930000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1mnz", TILEGX_OPC_V1MNZ, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000519c0000ULL,
-      0x2884000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1multu", TILEGX_OPC_V1MULTU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051a00000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1mulu", TILEGX_OPC_V1MULU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051a80000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1mulus", TILEGX_OPC_V1MULUS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051a40000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1mz", TILEGX_OPC_V1MZ, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051ac0000ULL,
-      0x2886000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1sadau", TILEGX_OPC_V1SADAU, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051b00000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1sadu", TILEGX_OPC_V1SADU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051b40000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1shl", TILEGX_OPC_V1SHL, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051b80000ULL,
-      0x2888000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1shli", TILEGX_OPC_V1SHLI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000601c0000ULL,
-      0x300e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1shrs", TILEGX_OPC_V1SHRS, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051bc0000ULL,
-      0x288a000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1shrsi", TILEGX_OPC_V1SHRSI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000060200000ULL,
-      0x3010000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1shru", TILEGX_OPC_V1SHRU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051c00000ULL,
-      0x288c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1shrui", TILEGX_OPC_V1SHRUI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000060240000ULL,
-      0x3012000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1sub", TILEGX_OPC_V1SUB, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051c80000ULL,
-      0x2890000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v1subuc", TILEGX_OPC_V1SUBUC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051c40000ULL,
-      0x288e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2add", TILEGX_OPC_V2ADD, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051d00000ULL,
-      0x2894000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2addi", TILEGX_OPC_V2ADDI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040e00000ULL,
-      0x1938000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2addsc", TILEGX_OPC_V2ADDSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051cc0000ULL,
-      0x2892000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2adiffs", TILEGX_OPC_V2ADIFFS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051d40000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2avgs", TILEGX_OPC_V2AVGS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051d80000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmpeq", TILEGX_OPC_V2CMPEQ, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051dc0000ULL,
-      0x2896000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmpeqi", TILEGX_OPC_V2CMPEQI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000040f00000ULL,
-      0x1940000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmples", TILEGX_OPC_V2CMPLES, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051e00000ULL,
-      0x2898000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmpleu", TILEGX_OPC_V2CMPLEU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051e40000ULL,
-      0x289a000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmplts", TILEGX_OPC_V2CMPLTS, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051e80000ULL,
-      0x289c000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmpltsi", TILEGX_OPC_V2CMPLTSI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000041000000ULL,
-      0x1948000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmpltu", TILEGX_OPC_V2CMPLTU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051ec0000ULL,
-      0x289e000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmpltui", TILEGX_OPC_V2CMPLTUI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000041100000ULL,
-      0x1950000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2cmpne", TILEGX_OPC_V2CMPNE, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051f00000ULL,
-      0x28a0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2dotp", TILEGX_OPC_V2DOTP, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051f80000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2dotpa", TILEGX_OPC_V2DOTPA, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051f40000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2int_h", TILEGX_OPC_V2INT_H, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000051fc0000ULL,
-      0x28a2000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2int_l", TILEGX_OPC_V2INT_L, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052000000ULL,
-      0x28a4000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2maxs", TILEGX_OPC_V2MAXS, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052040000ULL,
-      0x28a6000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2maxsi", TILEGX_OPC_V2MAXSI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000041200000ULL,
-      0x1958000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2mins", TILEGX_OPC_V2MINS, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052080000ULL,
-      0x28a8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2minsi", TILEGX_OPC_V2MINSI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000041300000ULL,
-      0x1960000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2mnz", TILEGX_OPC_V2MNZ, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000520c0000ULL,
-      0x28aa000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2mulfsc", TILEGX_OPC_V2MULFSC, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052100000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2muls", TILEGX_OPC_V2MULS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052140000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2mults", TILEGX_OPC_V2MULTS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052180000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2mz", TILEGX_OPC_V2MZ, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000521c0000ULL,
-      0x28ac000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2packh", TILEGX_OPC_V2PACKH, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052200000ULL,
-      0x28ae000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2packl", TILEGX_OPC_V2PACKL, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052240000ULL,
-      0x28b0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2packuc", TILEGX_OPC_V2PACKUC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052280000ULL,
-      0x28b2000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2sadas", TILEGX_OPC_V2SADAS, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000522c0000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2sadau", TILEGX_OPC_V2SADAU, 0x1, 3, TREG_ZERO, 1,
-    { { 23, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052300000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2sads", TILEGX_OPC_V2SADS, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052340000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2sadu", TILEGX_OPC_V2SADU, 0x1, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 0, }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052380000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2shl", TILEGX_OPC_V2SHL, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052400000ULL,
-      0x28b6000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2shli", TILEGX_OPC_V2SHLI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000060280000ULL,
-      0x3014000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2shlsc", TILEGX_OPC_V2SHLSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000523c0000ULL,
-      0x28b4000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2shrs", TILEGX_OPC_V2SHRS, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052440000ULL,
-      0x28b8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2shrsi", TILEGX_OPC_V2SHRSI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000602c0000ULL,
-      0x3016000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2shru", TILEGX_OPC_V2SHRU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052480000ULL,
-      0x28ba000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2shrui", TILEGX_OPC_V2SHRUI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 29 }, { 6, 7, 30 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000060300000ULL,
-      0x3018000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2sub", TILEGX_OPC_V2SUB, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052500000ULL,
-      0x28be000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v2subsc", TILEGX_OPC_V2SUBSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000524c0000ULL,
-      0x28bc000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4add", TILEGX_OPC_V4ADD, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052580000ULL,
-      0x28c2000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4addsc", TILEGX_OPC_V4ADDSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052540000ULL,
-      0x28c0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4int_h", TILEGX_OPC_V4INT_H, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000525c0000ULL,
-      0x28c4000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4int_l", TILEGX_OPC_V4INT_L, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052600000ULL,
-      0x28c6000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4packsc", TILEGX_OPC_V4PACKSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052640000ULL,
-      0x28c8000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4shl", TILEGX_OPC_V4SHL, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000526c0000ULL,
-      0x28cc000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4shlsc", TILEGX_OPC_V4SHLSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052680000ULL,
-      0x28ca000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4shrs", TILEGX_OPC_V4SHRS, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052700000ULL,
-      0x28ce000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4shru", TILEGX_OPC_V4SHRU, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052740000ULL,
-      0x28d0000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4sub", TILEGX_OPC_V4SUB, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x00000000527c0000ULL,
-      0x28d4000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "v4subsc", TILEGX_OPC_V4SUBSC, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000052780000ULL,
-      0x28d2000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "wh64", TILEGX_OPC_WH64, 0x2, 1, TREG_ZERO, 1,
-    { { 0, }, { 7 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0ULL,
-      0xfffff80000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      -1ULL,
-      0x286b300000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "xor", TILEGX_OPC_XOR, 0xf, 3, TREG_ZERO, 1,
-    { { 8, 9, 16 }, { 6, 7, 17 }, { 10, 11, 18 }, { 12, 13, 19 }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ffc0000ULL,
-      0xfffe000000000000ULL,
-      0x00000000780c0000ULL,
-      0x3c06000000000000ULL,
-      0ULL
-    },
-    {
-      0x0000000052800000ULL,
-      0x28d6000000000000ULL,
-      0x00000000500c0000ULL,
-      0x2c06000000000000ULL,
-      -1ULL
-    }
-#endif
-  },
-  { "xori", TILEGX_OPC_XORI, 0x3, 3, TREG_ZERO, 1,
-    { { 8, 9, 0 }, { 6, 7, 1 }, { 0, }, { 0, }, { 0, } },
-#ifndef DISASM_ONLY
-    {
-      0xc00000007ff00000ULL,
-      0xfff8000000000000ULL,
-      0ULL,
-      0ULL,
-      0ULL
-    },
-    {
-      0x0000000041400000ULL,
-      0x1968000000000000ULL,
-      -1ULL,
-      -1ULL,
-      -1ULL
-    }
-#endif
-  },
-  { NULL, TILEGX_OPC_NONE, 0, 0, TREG_ZERO, 0, { { 0, } },
-#ifndef DISASM_ONLY
-    { 0, }, { 0, }
-#endif
-  }
-};
-
-#define BITFIELD(start, size) ((start) | (((1 << (size)) - 1) << 6))
-#define CHILD(array_index) (TILEGX_OPC_NONE + (array_index))
-
-static const unsigned short decode_X0_fsm[936] =
-{
-  BITFIELD(22, 9) /* index 0 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_BFEXTS,
-  TILEGX_OPC_BFEXTS, TILEGX_OPC_BFEXTS, TILEGX_OPC_BFEXTS, TILEGX_OPC_BFEXTU,
-  TILEGX_OPC_BFEXTU, TILEGX_OPC_BFEXTU, TILEGX_OPC_BFEXTU, TILEGX_OPC_BFINS,
-  TILEGX_OPC_BFINS, TILEGX_OPC_BFINS, TILEGX_OPC_BFINS, TILEGX_OPC_MM,
-  TILEGX_OPC_MM, TILEGX_OPC_MM, TILEGX_OPC_MM, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, CHILD(528), CHILD(578),
-  CHILD(583), CHILD(588), CHILD(593), CHILD(598), TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, CHILD(603), CHILD(620), CHILD(637), CHILD(654), CHILD(671),
-  CHILD(703), CHILD(797), CHILD(814), CHILD(831), CHILD(848), CHILD(865),
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, CHILD(889), TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  CHILD(906), CHILD(906), CHILD(906), CHILD(906), CHILD(906),
-  BITFIELD(6, 2) /* index 513 */,
-  TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, CHILD(518),
-  BITFIELD(8, 2) /* index 518 */,
-  TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, CHILD(523),
-  BITFIELD(10, 2) /* index 523 */,
-  TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_MOVELI,
-  BITFIELD(20, 2) /* index 528 */,
-  TILEGX_OPC_NONE, CHILD(533), TILEGX_OPC_ADDXI, CHILD(548),
-  BITFIELD(6, 2) /* index 533 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(538),
-  BITFIELD(8, 2) /* index 538 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(543),
-  BITFIELD(10, 2) /* index 543 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_MOVEI,
-  BITFIELD(0, 2) /* index 548 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(553),
-  BITFIELD(2, 2) /* index 553 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(558),
-  BITFIELD(4, 2) /* index 558 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(563),
-  BITFIELD(6, 2) /* index 563 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(568),
-  BITFIELD(8, 2) /* index 568 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(573),
-  BITFIELD(10, 2) /* index 573 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_INFO,
-  BITFIELD(20, 2) /* index 578 */,
-  TILEGX_OPC_CMPEQI, TILEGX_OPC_CMPLTSI, TILEGX_OPC_CMPLTUI, TILEGX_OPC_ORI,
-  BITFIELD(20, 2) /* index 583 */,
-  TILEGX_OPC_V1ADDI, TILEGX_OPC_V1CMPEQI, TILEGX_OPC_V1CMPLTSI,
-  TILEGX_OPC_V1CMPLTUI,
-  BITFIELD(20, 2) /* index 588 */,
-  TILEGX_OPC_V1MAXUI, TILEGX_OPC_V1MINUI, TILEGX_OPC_V2ADDI,
-  TILEGX_OPC_V2CMPEQI,
-  BITFIELD(20, 2) /* index 593 */,
-  TILEGX_OPC_V2CMPLTSI, TILEGX_OPC_V2CMPLTUI, TILEGX_OPC_V2MAXSI,
-  TILEGX_OPC_V2MINSI,
-  BITFIELD(20, 2) /* index 598 */,
-  TILEGX_OPC_XORI, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(18, 4) /* index 603 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_ADDXSC, TILEGX_OPC_ADDX, TILEGX_OPC_ADD,
-  TILEGX_OPC_AND, TILEGX_OPC_CMOVEQZ, TILEGX_OPC_CMOVNEZ, TILEGX_OPC_CMPEQ,
-  TILEGX_OPC_CMPLES, TILEGX_OPC_CMPLEU, TILEGX_OPC_CMPLTS, TILEGX_OPC_CMPLTU,
-  TILEGX_OPC_CMPNE, TILEGX_OPC_CMULAF, TILEGX_OPC_CMULA, TILEGX_OPC_CMULFR,
-  BITFIELD(18, 4) /* index 620 */,
-  TILEGX_OPC_CMULF, TILEGX_OPC_CMULHR, TILEGX_OPC_CMULH, TILEGX_OPC_CMUL,
-  TILEGX_OPC_CRC32_32, TILEGX_OPC_CRC32_8, TILEGX_OPC_DBLALIGN2,
-  TILEGX_OPC_DBLALIGN4, TILEGX_OPC_DBLALIGN6, TILEGX_OPC_DBLALIGN,
-  TILEGX_OPC_FDOUBLE_ADDSUB, TILEGX_OPC_FDOUBLE_ADD_FLAGS,
-  TILEGX_OPC_FDOUBLE_MUL_FLAGS, TILEGX_OPC_FDOUBLE_PACK1,
-  TILEGX_OPC_FDOUBLE_PACK2, TILEGX_OPC_FDOUBLE_SUB_FLAGS,
-  BITFIELD(18, 4) /* index 637 */,
-  TILEGX_OPC_FDOUBLE_UNPACK_MAX, TILEGX_OPC_FDOUBLE_UNPACK_MIN,
-  TILEGX_OPC_FSINGLE_ADD1, TILEGX_OPC_FSINGLE_ADDSUB2,
-  TILEGX_OPC_FSINGLE_MUL1, TILEGX_OPC_FSINGLE_MUL2, TILEGX_OPC_FSINGLE_PACK2,
-  TILEGX_OPC_FSINGLE_SUB1, TILEGX_OPC_MNZ, TILEGX_OPC_MULAX,
-  TILEGX_OPC_MULA_HS_HS, TILEGX_OPC_MULA_HS_HU, TILEGX_OPC_MULA_HS_LS,
-  TILEGX_OPC_MULA_HS_LU, TILEGX_OPC_MULA_HU_HU, TILEGX_OPC_MULA_HU_LS,
-  BITFIELD(18, 4) /* index 654 */,
-  TILEGX_OPC_MULA_HU_LU, TILEGX_OPC_MULA_LS_LS, TILEGX_OPC_MULA_LS_LU,
-  TILEGX_OPC_MULA_LU_LU, TILEGX_OPC_MULX, TILEGX_OPC_MUL_HS_HS,
-  TILEGX_OPC_MUL_HS_HU, TILEGX_OPC_MUL_HS_LS, TILEGX_OPC_MUL_HS_LU,
-  TILEGX_OPC_MUL_HU_HU, TILEGX_OPC_MUL_HU_LS, TILEGX_OPC_MUL_HU_LU,
-  TILEGX_OPC_MUL_LS_LS, TILEGX_OPC_MUL_LS_LU, TILEGX_OPC_MUL_LU_LU,
-  TILEGX_OPC_MZ,
-  BITFIELD(18, 4) /* index 671 */,
-  TILEGX_OPC_NOR, CHILD(688), TILEGX_OPC_ROTL, TILEGX_OPC_SHL1ADDX,
-  TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL2ADDX, TILEGX_OPC_SHL2ADD,
-  TILEGX_OPC_SHL3ADDX, TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHLX, TILEGX_OPC_SHL,
-  TILEGX_OPC_SHRS, TILEGX_OPC_SHRUX, TILEGX_OPC_SHRU, TILEGX_OPC_SHUFFLEBYTES,
-  TILEGX_OPC_SUBXSC,
-  BITFIELD(12, 2) /* index 688 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(693),
-  BITFIELD(14, 2) /* index 693 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(698),
-  BITFIELD(16, 2) /* index 698 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_MOVE,
-  BITFIELD(18, 4) /* index 703 */,
-  TILEGX_OPC_SUBX, TILEGX_OPC_SUB, CHILD(720), TILEGX_OPC_V1ADDUC,
-  TILEGX_OPC_V1ADD, TILEGX_OPC_V1ADIFFU, TILEGX_OPC_V1AVGU,
-  TILEGX_OPC_V1CMPEQ, TILEGX_OPC_V1CMPLES, TILEGX_OPC_V1CMPLEU,
-  TILEGX_OPC_V1CMPLTS, TILEGX_OPC_V1CMPLTU, TILEGX_OPC_V1CMPNE,
-  TILEGX_OPC_V1DDOTPUSA, TILEGX_OPC_V1DDOTPUS, TILEGX_OPC_V1DOTPA,
-  BITFIELD(12, 4) /* index 720 */,
-  TILEGX_OPC_NONE, CHILD(737), CHILD(742), CHILD(747), CHILD(752), CHILD(757),
-  CHILD(762), CHILD(767), CHILD(772), CHILD(777), CHILD(782), CHILD(787),
-  CHILD(792), TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 737 */,
-  TILEGX_OPC_CLZ, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 742 */,
-  TILEGX_OPC_CTZ, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 747 */,
-  TILEGX_OPC_FNOP, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 752 */,
-  TILEGX_OPC_FSINGLE_PACK1, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 757 */,
-  TILEGX_OPC_NOP, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 762 */,
-  TILEGX_OPC_PCNT, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 767 */,
-  TILEGX_OPC_REVBITS, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 772 */,
-  TILEGX_OPC_REVBYTES, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 777 */,
-  TILEGX_OPC_TBLIDXB0, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 782 */,
-  TILEGX_OPC_TBLIDXB1, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 787 */,
-  TILEGX_OPC_TBLIDXB2, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(16, 2) /* index 792 */,
-  TILEGX_OPC_TBLIDXB3, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(18, 4) /* index 797 */,
-  TILEGX_OPC_V1DOTPUSA, TILEGX_OPC_V1DOTPUS, TILEGX_OPC_V1DOTP,
-  TILEGX_OPC_V1INT_H, TILEGX_OPC_V1INT_L, TILEGX_OPC_V1MAXU,
-  TILEGX_OPC_V1MINU, TILEGX_OPC_V1MNZ, TILEGX_OPC_V1MULTU, TILEGX_OPC_V1MULUS,
-  TILEGX_OPC_V1MULU, TILEGX_OPC_V1MZ, TILEGX_OPC_V1SADAU, TILEGX_OPC_V1SADU,
-  TILEGX_OPC_V1SHL, TILEGX_OPC_V1SHRS,
-  BITFIELD(18, 4) /* index 814 */,
-  TILEGX_OPC_V1SHRU, TILEGX_OPC_V1SUBUC, TILEGX_OPC_V1SUB, TILEGX_OPC_V2ADDSC,
-  TILEGX_OPC_V2ADD, TILEGX_OPC_V2ADIFFS, TILEGX_OPC_V2AVGS,
-  TILEGX_OPC_V2CMPEQ, TILEGX_OPC_V2CMPLES, TILEGX_OPC_V2CMPLEU,
-  TILEGX_OPC_V2CMPLTS, TILEGX_OPC_V2CMPLTU, TILEGX_OPC_V2CMPNE,
-  TILEGX_OPC_V2DOTPA, TILEGX_OPC_V2DOTP, TILEGX_OPC_V2INT_H,
-  BITFIELD(18, 4) /* index 831 */,
-  TILEGX_OPC_V2INT_L, TILEGX_OPC_V2MAXS, TILEGX_OPC_V2MINS, TILEGX_OPC_V2MNZ,
-  TILEGX_OPC_V2MULFSC, TILEGX_OPC_V2MULS, TILEGX_OPC_V2MULTS, TILEGX_OPC_V2MZ,
-  TILEGX_OPC_V2PACKH, TILEGX_OPC_V2PACKL, TILEGX_OPC_V2PACKUC,
-  TILEGX_OPC_V2SADAS, TILEGX_OPC_V2SADAU, TILEGX_OPC_V2SADS,
-  TILEGX_OPC_V2SADU, TILEGX_OPC_V2SHLSC,
-  BITFIELD(18, 4) /* index 848 */,
-  TILEGX_OPC_V2SHL, TILEGX_OPC_V2SHRS, TILEGX_OPC_V2SHRU, TILEGX_OPC_V2SUBSC,
-  TILEGX_OPC_V2SUB, TILEGX_OPC_V4ADDSC, TILEGX_OPC_V4ADD, TILEGX_OPC_V4INT_H,
-  TILEGX_OPC_V4INT_L, TILEGX_OPC_V4PACKSC, TILEGX_OPC_V4SHLSC,
-  TILEGX_OPC_V4SHL, TILEGX_OPC_V4SHRS, TILEGX_OPC_V4SHRU, TILEGX_OPC_V4SUBSC,
-  TILEGX_OPC_V4SUB,
-  BITFIELD(18, 3) /* index 865 */,
-  CHILD(874), CHILD(877), CHILD(880), CHILD(883), CHILD(886), TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(21, 1) /* index 874 */,
-  TILEGX_OPC_XOR, TILEGX_OPC_NONE,
-  BITFIELD(21, 1) /* index 877 */,
-  TILEGX_OPC_V1DDOTPUA, TILEGX_OPC_NONE,
-  BITFIELD(21, 1) /* index 880 */,
-  TILEGX_OPC_V1DDOTPU, TILEGX_OPC_NONE,
-  BITFIELD(21, 1) /* index 883 */,
-  TILEGX_OPC_V1DOTPUA, TILEGX_OPC_NONE,
-  BITFIELD(21, 1) /* index 886 */,
-  TILEGX_OPC_V1DOTPU, TILEGX_OPC_NONE,
-  BITFIELD(18, 4) /* index 889 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_ROTLI, TILEGX_OPC_SHLI, TILEGX_OPC_SHLXI,
-  TILEGX_OPC_SHRSI, TILEGX_OPC_SHRUI, TILEGX_OPC_SHRUXI, TILEGX_OPC_V1SHLI,
-  TILEGX_OPC_V1SHRSI, TILEGX_OPC_V1SHRUI, TILEGX_OPC_V2SHLI,
-  TILEGX_OPC_V2SHRSI, TILEGX_OPC_V2SHRUI, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE,
-  BITFIELD(0, 2) /* index 906 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(911),
-  BITFIELD(2, 2) /* index 911 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(916),
-  BITFIELD(4, 2) /* index 916 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(921),
-  BITFIELD(6, 2) /* index 921 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(926),
-  BITFIELD(8, 2) /* index 926 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(931),
-  BITFIELD(10, 2) /* index 931 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  TILEGX_OPC_INFOL,
-};
-
-static const unsigned short decode_X1_fsm[1266] =
-{
-  BITFIELD(53, 9) /* index 0 */,
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513), CHILD(513),
-  CHILD(513), CHILD(513), CHILD(513), CHILD(513), TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI,
-  TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_ADDXLI, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_BEQZT,
-  TILEGX_OPC_BEQZT, TILEGX_OPC_BEQZ, TILEGX_OPC_BEQZ, TILEGX_OPC_BGEZT,
-  TILEGX_OPC_BGEZT, TILEGX_OPC_BGEZ, TILEGX_OPC_BGEZ, TILEGX_OPC_BGTZT,
-  TILEGX_OPC_BGTZT, TILEGX_OPC_BGTZ, TILEGX_OPC_BGTZ, TILEGX_OPC_BLBCT,
-  TILEGX_OPC_BLBCT, TILEGX_OPC_BLBC, TILEGX_OPC_BLBC, TILEGX_OPC_BLBST,
-  TILEGX_OPC_BLBST, TILEGX_OPC_BLBS, TILEGX_OPC_BLBS, TILEGX_OPC_BLEZT,
-  TILEGX_OPC_BLEZT, TILEGX_OPC_BLEZ, TILEGX_OPC_BLEZ, TILEGX_OPC_BLTZT,
-  TILEGX_OPC_BLTZT, TILEGX_OPC_BLTZ, TILEGX_OPC_BLTZ, TILEGX_OPC_BNEZT,
-  TILEGX_OPC_BNEZT, TILEGX_OPC_BNEZ, TILEGX_OPC_BNEZ, CHILD(528), CHILD(578),
-  CHILD(598), CHILD(703), CHILD(723), CHILD(728), CHILD(753), CHILD(758),
-  CHILD(763), CHILD(768), CHILD(773), CHILD(778), TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL,
-  TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_JAL, TILEGX_OPC_J, TILEGX_OPC_J,
-  TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J,
-  TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J,
-  TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J,
-  TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J,
-  TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J,
-  TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J, TILEGX_OPC_J,
-  CHILD(783), CHILD(800), CHILD(832), CHILD(849), CHILD(1168), CHILD(1185),
-  CHILD(1202), TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, CHILD(1219), TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236), CHILD(1236),
-  CHILD(1236),
-  BITFIELD(37, 2) /* index 513 */,
-  TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, CHILD(518),
-  BITFIELD(39, 2) /* index 518 */,
-  TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, CHILD(523),
-  BITFIELD(41, 2) /* index 523 */,
-  TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_ADDLI, TILEGX_OPC_MOVELI,
-  BITFIELD(51, 2) /* index 528 */,
-  TILEGX_OPC_NONE, CHILD(533), TILEGX_OPC_ADDXI, CHILD(548),
-  BITFIELD(37, 2) /* index 533 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(538),
-  BITFIELD(39, 2) /* index 538 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(543),
-  BITFIELD(41, 2) /* index 543 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_MOVEI,
-  BITFIELD(31, 2) /* index 548 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(553),
-  BITFIELD(33, 2) /* index 553 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(558),
-  BITFIELD(35, 2) /* index 558 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(563),
-  BITFIELD(37, 2) /* index 563 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(568),
-  BITFIELD(39, 2) /* index 568 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(573),
-  BITFIELD(41, 2) /* index 573 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_INFO,
-  BITFIELD(51, 2) /* index 578 */,
-  TILEGX_OPC_CMPEQI, TILEGX_OPC_CMPLTSI, TILEGX_OPC_CMPLTUI, CHILD(583),
-  BITFIELD(31, 2) /* index 583 */,
-  TILEGX_OPC_LD1S_ADD, TILEGX_OPC_LD1S_ADD, TILEGX_OPC_LD1S_ADD, CHILD(588),
-  BITFIELD(33, 2) /* index 588 */,
-  TILEGX_OPC_LD1S_ADD, TILEGX_OPC_LD1S_ADD, TILEGX_OPC_LD1S_ADD, CHILD(593),
-  BITFIELD(35, 2) /* index 593 */,
-  TILEGX_OPC_LD1S_ADD, TILEGX_OPC_LD1S_ADD, TILEGX_OPC_LD1S_ADD,
-  TILEGX_OPC_PREFETCH_ADD_L1_FAULT,
-  BITFIELD(51, 2) /* index 598 */,
-  CHILD(603), CHILD(618), CHILD(633), CHILD(648),
-  BITFIELD(31, 2) /* index 603 */,
-  TILEGX_OPC_LD1U_ADD, TILEGX_OPC_LD1U_ADD, TILEGX_OPC_LD1U_ADD, CHILD(608),
-  BITFIELD(33, 2) /* index 608 */,
-  TILEGX_OPC_LD1U_ADD, TILEGX_OPC_LD1U_ADD, TILEGX_OPC_LD1U_ADD, CHILD(613),
-  BITFIELD(35, 2) /* index 613 */,
-  TILEGX_OPC_LD1U_ADD, TILEGX_OPC_LD1U_ADD, TILEGX_OPC_LD1U_ADD,
-  TILEGX_OPC_PREFETCH_ADD_L1,
-  BITFIELD(31, 2) /* index 618 */,
-  TILEGX_OPC_LD2S_ADD, TILEGX_OPC_LD2S_ADD, TILEGX_OPC_LD2S_ADD, CHILD(623),
-  BITFIELD(33, 2) /* index 623 */,
-  TILEGX_OPC_LD2S_ADD, TILEGX_OPC_LD2S_ADD, TILEGX_OPC_LD2S_ADD, CHILD(628),
-  BITFIELD(35, 2) /* index 628 */,
-  TILEGX_OPC_LD2S_ADD, TILEGX_OPC_LD2S_ADD, TILEGX_OPC_LD2S_ADD,
-  TILEGX_OPC_PREFETCH_ADD_L2_FAULT,
-  BITFIELD(31, 2) /* index 633 */,
-  TILEGX_OPC_LD2U_ADD, TILEGX_OPC_LD2U_ADD, TILEGX_OPC_LD2U_ADD, CHILD(638),
-  BITFIELD(33, 2) /* index 638 */,
-  TILEGX_OPC_LD2U_ADD, TILEGX_OPC_LD2U_ADD, TILEGX_OPC_LD2U_ADD, CHILD(643),
-  BITFIELD(35, 2) /* index 643 */,
-  TILEGX_OPC_LD2U_ADD, TILEGX_OPC_LD2U_ADD, TILEGX_OPC_LD2U_ADD,
-  TILEGX_OPC_PREFETCH_ADD_L2,
-  BITFIELD(31, 2) /* index 648 */,
-  CHILD(653), CHILD(653), CHILD(653), CHILD(673),
-  BITFIELD(43, 2) /* index 653 */,
-  CHILD(658), TILEGX_OPC_LD4S_ADD, TILEGX_OPC_LD4S_ADD, TILEGX_OPC_LD4S_ADD,
-  BITFIELD(45, 2) /* index 658 */,
-  CHILD(663), TILEGX_OPC_LD4S_ADD, TILEGX_OPC_LD4S_ADD, TILEGX_OPC_LD4S_ADD,
-  BITFIELD(47, 2) /* index 663 */,
-  CHILD(668), TILEGX_OPC_LD4S_ADD, TILEGX_OPC_LD4S_ADD, TILEGX_OPC_LD4S_ADD,
-  BITFIELD(49, 2) /* index 668 */,
-  TILEGX_OPC_LD4S_TLS, TILEGX_OPC_LD4S_ADD, TILEGX_OPC_LD4S_ADD,
-  TILEGX_OPC_LD4S_ADD,
-  BITFIELD(33, 2) /* index 673 */,
-  CHILD(653), CHILD(653), CHILD(653), CHILD(678),
-  BITFIELD(35, 2) /* index 678 */,
-  CHILD(653), CHILD(653), CHILD(653), CHILD(683),
-  BITFIELD(43, 2) /* index 683 */,
-  CHILD(688), TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  TILEGX_OPC_PREFETCH_ADD_L3_FAULT, TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  BITFIELD(45, 2) /* index 688 */,
-  CHILD(693), TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  TILEGX_OPC_PREFETCH_ADD_L3_FAULT, TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  BITFIELD(47, 2) /* index 693 */,
-  CHILD(698), TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  TILEGX_OPC_PREFETCH_ADD_L3_FAULT, TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  BITFIELD(49, 2) /* index 698 */,
-  TILEGX_OPC_LD4S_TLS, TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  TILEGX_OPC_PREFETCH_ADD_L3_FAULT, TILEGX_OPC_PREFETCH_ADD_L3_FAULT,
-  BITFIELD(51, 2) /* index 703 */,
-  CHILD(708), TILEGX_OPC_LDNT1S_ADD, TILEGX_OPC_LDNT1U_ADD,
-  TILEGX_OPC_LDNT2S_ADD,
-  BITFIELD(31, 2) /* index 708 */,
-  TILEGX_OPC_LD4U_ADD, TILEGX_OPC_LD4U_ADD, TILEGX_OPC_LD4U_ADD, CHILD(713),
-  BITFIELD(33, 2) /* index 713 */,
-  TILEGX_OPC_LD4U_ADD, TILEGX_OPC_LD4U_ADD, TILEGX_OPC_LD4U_ADD, CHILD(718),
-  BITFIELD(35, 2) /* index 718 */,
-  TILEGX_OPC_LD4U_ADD, TILEGX_OPC_LD4U_ADD, TILEGX_OPC_LD4U_ADD,
-  TILEGX_OPC_PREFETCH_ADD_L3,
-  BITFIELD(51, 2) /* index 723 */,
-  TILEGX_OPC_LDNT2U_ADD, TILEGX_OPC_LDNT4S_ADD, TILEGX_OPC_LDNT4U_ADD,
-  TILEGX_OPC_LDNT_ADD,
-  BITFIELD(51, 2) /* index 728 */,
-  CHILD(733), TILEGX_OPC_LDNA_ADD, TILEGX_OPC_MFSPR, TILEGX_OPC_MTSPR,
-  BITFIELD(43, 2) /* index 733 */,
-  CHILD(738), TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD,
-  BITFIELD(45, 2) /* index 738 */,
-  CHILD(743), TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD,
-  BITFIELD(47, 2) /* index 743 */,
-  CHILD(748), TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD,
-  BITFIELD(49, 2) /* index 748 */,
-  TILEGX_OPC_LD_TLS, TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD, TILEGX_OPC_LD_ADD,
-  BITFIELD(51, 2) /* index 753 */,
-  TILEGX_OPC_ORI, TILEGX_OPC_ST1_ADD, TILEGX_OPC_ST2_ADD, TILEGX_OPC_ST4_ADD,
-  BITFIELD(51, 2) /* index 758 */,
-  TILEGX_OPC_STNT1_ADD, TILEGX_OPC_STNT2_ADD, TILEGX_OPC_STNT4_ADD,
-  TILEGX_OPC_STNT_ADD,
-  BITFIELD(51, 2) /* index 763 */,
-  TILEGX_OPC_ST_ADD, TILEGX_OPC_V1ADDI, TILEGX_OPC_V1CMPEQI,
-  TILEGX_OPC_V1CMPLTSI,
-  BITFIELD(51, 2) /* index 768 */,
-  TILEGX_OPC_V1CMPLTUI, TILEGX_OPC_V1MAXUI, TILEGX_OPC_V1MINUI,
-  TILEGX_OPC_V2ADDI,
-  BITFIELD(51, 2) /* index 773 */,
-  TILEGX_OPC_V2CMPEQI, TILEGX_OPC_V2CMPLTSI, TILEGX_OPC_V2CMPLTUI,
-  TILEGX_OPC_V2MAXSI,
-  BITFIELD(51, 2) /* index 778 */,
-  TILEGX_OPC_V2MINSI, TILEGX_OPC_XORI, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(49, 4) /* index 783 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_ADDXSC, TILEGX_OPC_ADDX, TILEGX_OPC_ADD,
-  TILEGX_OPC_AND, TILEGX_OPC_CMPEQ, TILEGX_OPC_CMPEXCH4, TILEGX_OPC_CMPEXCH,
-  TILEGX_OPC_CMPLES, TILEGX_OPC_CMPLEU, TILEGX_OPC_CMPLTS, TILEGX_OPC_CMPLTU,
-  TILEGX_OPC_CMPNE, TILEGX_OPC_DBLALIGN2, TILEGX_OPC_DBLALIGN4,
-  TILEGX_OPC_DBLALIGN6,
-  BITFIELD(49, 4) /* index 800 */,
-  TILEGX_OPC_EXCH4, TILEGX_OPC_EXCH, TILEGX_OPC_FETCHADD4,
-  TILEGX_OPC_FETCHADDGEZ4, TILEGX_OPC_FETCHADDGEZ, TILEGX_OPC_FETCHADD,
-  TILEGX_OPC_FETCHAND4, TILEGX_OPC_FETCHAND, TILEGX_OPC_FETCHOR4,
-  TILEGX_OPC_FETCHOR, TILEGX_OPC_MNZ, TILEGX_OPC_MZ, TILEGX_OPC_NOR,
-  CHILD(817), TILEGX_OPC_ROTL, TILEGX_OPC_SHL1ADDX,
-  BITFIELD(43, 2) /* index 817 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(822),
-  BITFIELD(45, 2) /* index 822 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(827),
-  BITFIELD(47, 2) /* index 827 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_MOVE,
-  BITFIELD(49, 4) /* index 832 */,
-  TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL2ADDX, TILEGX_OPC_SHL2ADD,
-  TILEGX_OPC_SHL3ADDX, TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHLX, TILEGX_OPC_SHL,
-  TILEGX_OPC_SHRS, TILEGX_OPC_SHRUX, TILEGX_OPC_SHRU, TILEGX_OPC_ST1,
-  TILEGX_OPC_ST2, TILEGX_OPC_ST4, TILEGX_OPC_STNT1, TILEGX_OPC_STNT2,
-  TILEGX_OPC_STNT4,
-  BITFIELD(46, 7) /* index 849 */,
-  TILEGX_OPC_STNT, TILEGX_OPC_STNT, TILEGX_OPC_STNT, TILEGX_OPC_STNT,
-  TILEGX_OPC_STNT, TILEGX_OPC_STNT, TILEGX_OPC_STNT, TILEGX_OPC_STNT,
-  TILEGX_OPC_ST, TILEGX_OPC_ST, TILEGX_OPC_ST, TILEGX_OPC_ST, TILEGX_OPC_ST,
-  TILEGX_OPC_ST, TILEGX_OPC_ST, TILEGX_OPC_ST, TILEGX_OPC_SUBXSC,
-  TILEGX_OPC_SUBXSC, TILEGX_OPC_SUBXSC, TILEGX_OPC_SUBXSC, TILEGX_OPC_SUBXSC,
-  TILEGX_OPC_SUBXSC, TILEGX_OPC_SUBXSC, TILEGX_OPC_SUBXSC, TILEGX_OPC_SUBX,
-  TILEGX_OPC_SUBX, TILEGX_OPC_SUBX, TILEGX_OPC_SUBX, TILEGX_OPC_SUBX,
-  TILEGX_OPC_SUBX, TILEGX_OPC_SUBX, TILEGX_OPC_SUBX, TILEGX_OPC_SUB,
-  TILEGX_OPC_SUB, TILEGX_OPC_SUB, TILEGX_OPC_SUB, TILEGX_OPC_SUB,
-  TILEGX_OPC_SUB, TILEGX_OPC_SUB, TILEGX_OPC_SUB, CHILD(978), CHILD(987),
-  CHILD(1066), CHILD(1150), CHILD(1159), TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_V1ADDUC, TILEGX_OPC_V1ADDUC, TILEGX_OPC_V1ADDUC,
-  TILEGX_OPC_V1ADDUC, TILEGX_OPC_V1ADDUC, TILEGX_OPC_V1ADDUC,
-  TILEGX_OPC_V1ADDUC, TILEGX_OPC_V1ADDUC, TILEGX_OPC_V1ADD, TILEGX_OPC_V1ADD,
-  TILEGX_OPC_V1ADD, TILEGX_OPC_V1ADD, TILEGX_OPC_V1ADD, TILEGX_OPC_V1ADD,
-  TILEGX_OPC_V1ADD, TILEGX_OPC_V1ADD, TILEGX_OPC_V1CMPEQ, TILEGX_OPC_V1CMPEQ,
-  TILEGX_OPC_V1CMPEQ, TILEGX_OPC_V1CMPEQ, TILEGX_OPC_V1CMPEQ,
-  TILEGX_OPC_V1CMPEQ, TILEGX_OPC_V1CMPEQ, TILEGX_OPC_V1CMPEQ,
-  TILEGX_OPC_V1CMPLES, TILEGX_OPC_V1CMPLES, TILEGX_OPC_V1CMPLES,
-  TILEGX_OPC_V1CMPLES, TILEGX_OPC_V1CMPLES, TILEGX_OPC_V1CMPLES,
-  TILEGX_OPC_V1CMPLES, TILEGX_OPC_V1CMPLES, TILEGX_OPC_V1CMPLEU,
-  TILEGX_OPC_V1CMPLEU, TILEGX_OPC_V1CMPLEU, TILEGX_OPC_V1CMPLEU,
-  TILEGX_OPC_V1CMPLEU, TILEGX_OPC_V1CMPLEU, TILEGX_OPC_V1CMPLEU,
-  TILEGX_OPC_V1CMPLEU, TILEGX_OPC_V1CMPLTS, TILEGX_OPC_V1CMPLTS,
-  TILEGX_OPC_V1CMPLTS, TILEGX_OPC_V1CMPLTS, TILEGX_OPC_V1CMPLTS,
-  TILEGX_OPC_V1CMPLTS, TILEGX_OPC_V1CMPLTS, TILEGX_OPC_V1CMPLTS,
-  TILEGX_OPC_V1CMPLTU, TILEGX_OPC_V1CMPLTU, TILEGX_OPC_V1CMPLTU,
-  TILEGX_OPC_V1CMPLTU, TILEGX_OPC_V1CMPLTU, TILEGX_OPC_V1CMPLTU,
-  TILEGX_OPC_V1CMPLTU, TILEGX_OPC_V1CMPLTU, TILEGX_OPC_V1CMPNE,
-  TILEGX_OPC_V1CMPNE, TILEGX_OPC_V1CMPNE, TILEGX_OPC_V1CMPNE,
-  TILEGX_OPC_V1CMPNE, TILEGX_OPC_V1CMPNE, TILEGX_OPC_V1CMPNE,
-  TILEGX_OPC_V1CMPNE, TILEGX_OPC_V1INT_H, TILEGX_OPC_V1INT_H,
-  TILEGX_OPC_V1INT_H, TILEGX_OPC_V1INT_H, TILEGX_OPC_V1INT_H,
-  TILEGX_OPC_V1INT_H, TILEGX_OPC_V1INT_H, TILEGX_OPC_V1INT_H,
-  TILEGX_OPC_V1INT_L, TILEGX_OPC_V1INT_L, TILEGX_OPC_V1INT_L,
-  TILEGX_OPC_V1INT_L, TILEGX_OPC_V1INT_L, TILEGX_OPC_V1INT_L,
-  TILEGX_OPC_V1INT_L, TILEGX_OPC_V1INT_L,
-  BITFIELD(43, 3) /* index 978 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_DRAIN, TILEGX_OPC_DTLBPR, TILEGX_OPC_FINV,
-  TILEGX_OPC_FLUSHWB, TILEGX_OPC_FLUSH, TILEGX_OPC_FNOP, TILEGX_OPC_ICOH,
-  BITFIELD(43, 3) /* index 987 */,
-  CHILD(996), TILEGX_OPC_INV, TILEGX_OPC_IRET, TILEGX_OPC_JALRP,
-  TILEGX_OPC_JALR, TILEGX_OPC_JRP, TILEGX_OPC_JR, CHILD(1051),
-  BITFIELD(31, 2) /* index 996 */,
-  CHILD(1001), CHILD(1026), TILEGX_OPC_ILL, TILEGX_OPC_ILL,
-  BITFIELD(33, 2) /* index 1001 */,
-  TILEGX_OPC_ILL, TILEGX_OPC_ILL, TILEGX_OPC_ILL, CHILD(1006),
-  BITFIELD(35, 2) /* index 1006 */,
-  TILEGX_OPC_ILL, CHILD(1011), TILEGX_OPC_ILL, TILEGX_OPC_ILL,
-  BITFIELD(37, 2) /* index 1011 */,
-  TILEGX_OPC_ILL, CHILD(1016), TILEGX_OPC_ILL, TILEGX_OPC_ILL,
-  BITFIELD(39, 2) /* index 1016 */,
-  TILEGX_OPC_ILL, CHILD(1021), TILEGX_OPC_ILL, TILEGX_OPC_ILL,
-  BITFIELD(41, 2) /* index 1021 */,
-  TILEGX_OPC_ILL, TILEGX_OPC_ILL, TILEGX_OPC_BPT, TILEGX_OPC_ILL,
-  BITFIELD(33, 2) /* index 1026 */,
-  TILEGX_OPC_ILL, TILEGX_OPC_ILL, TILEGX_OPC_ILL, CHILD(1031),
-  BITFIELD(35, 2) /* index 1031 */,
-  TILEGX_OPC_ILL, CHILD(1036), TILEGX_OPC_ILL, TILEGX_OPC_ILL,
-  BITFIELD(37, 2) /* index 1036 */,
-  TILEGX_OPC_ILL, CHILD(1041), TILEGX_OPC_ILL, TILEGX_OPC_ILL,
-  BITFIELD(39, 2) /* index 1041 */,
-  TILEGX_OPC_ILL, CHILD(1046), TILEGX_OPC_ILL, TILEGX_OPC_ILL,
-  BITFIELD(41, 2) /* index 1046 */,
-  TILEGX_OPC_ILL, TILEGX_OPC_ILL, TILEGX_OPC_RAISE, TILEGX_OPC_ILL,
-  BITFIELD(31, 2) /* index 1051 */,
-  TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, CHILD(1056),
-  BITFIELD(33, 2) /* index 1056 */,
-  TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, CHILD(1061),
-  BITFIELD(35, 2) /* index 1061 */,
-  TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, TILEGX_OPC_LD1S,
-  TILEGX_OPC_PREFETCH_L1_FAULT,
-  BITFIELD(43, 3) /* index 1066 */,
-  CHILD(1075), CHILD(1090), CHILD(1105), CHILD(1120), CHILD(1135),
-  TILEGX_OPC_LDNA, TILEGX_OPC_LDNT1S, TILEGX_OPC_LDNT1U,
-  BITFIELD(31, 2) /* index 1075 */,
-  TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, CHILD(1080),
-  BITFIELD(33, 2) /* index 1080 */,
-  TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, CHILD(1085),
-  BITFIELD(35, 2) /* index 1085 */,
-  TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, TILEGX_OPC_PREFETCH,
-  BITFIELD(31, 2) /* index 1090 */,
-  TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, CHILD(1095),
-  BITFIELD(33, 2) /* index 1095 */,
-  TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, CHILD(1100),
-  BITFIELD(35, 2) /* index 1100 */,
-  TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, TILEGX_OPC_LD2S,
-  TILEGX_OPC_PREFETCH_L2_FAULT,
-  BITFIELD(31, 2) /* index 1105 */,
-  TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, CHILD(1110),
-  BITFIELD(33, 2) /* index 1110 */,
-  TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, CHILD(1115),
-  BITFIELD(35, 2) /* index 1115 */,
-  TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, TILEGX_OPC_PREFETCH_L2,
-  BITFIELD(31, 2) /* index 1120 */,
-  TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, CHILD(1125),
-  BITFIELD(33, 2) /* index 1125 */,
-  TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, CHILD(1130),
-  BITFIELD(35, 2) /* index 1130 */,
-  TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, TILEGX_OPC_LD4S,
-  TILEGX_OPC_PREFETCH_L3_FAULT,
-  BITFIELD(31, 2) /* index 1135 */,
-  TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, CHILD(1140),
-  BITFIELD(33, 2) /* index 1140 */,
-  TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, CHILD(1145),
-  BITFIELD(35, 2) /* index 1145 */,
-  TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, TILEGX_OPC_PREFETCH_L3,
-  BITFIELD(43, 3) /* index 1150 */,
-  TILEGX_OPC_LDNT2S, TILEGX_OPC_LDNT2U, TILEGX_OPC_LDNT4S, TILEGX_OPC_LDNT4U,
-  TILEGX_OPC_LDNT, TILEGX_OPC_LD, TILEGX_OPC_LNK, TILEGX_OPC_MF,
-  BITFIELD(43, 3) /* index 1159 */,
-  TILEGX_OPC_NAP, TILEGX_OPC_NOP, TILEGX_OPC_SWINT0, TILEGX_OPC_SWINT1,
-  TILEGX_OPC_SWINT2, TILEGX_OPC_SWINT3, TILEGX_OPC_WH64, TILEGX_OPC_NONE,
-  BITFIELD(49, 4) /* index 1168 */,
-  TILEGX_OPC_V1MAXU, TILEGX_OPC_V1MINU, TILEGX_OPC_V1MNZ, TILEGX_OPC_V1MZ,
-  TILEGX_OPC_V1SHL, TILEGX_OPC_V1SHRS, TILEGX_OPC_V1SHRU, TILEGX_OPC_V1SUBUC,
-  TILEGX_OPC_V1SUB, TILEGX_OPC_V2ADDSC, TILEGX_OPC_V2ADD, TILEGX_OPC_V2CMPEQ,
-  TILEGX_OPC_V2CMPLES, TILEGX_OPC_V2CMPLEU, TILEGX_OPC_V2CMPLTS,
-  TILEGX_OPC_V2CMPLTU,
-  BITFIELD(49, 4) /* index 1185 */,
-  TILEGX_OPC_V2CMPNE, TILEGX_OPC_V2INT_H, TILEGX_OPC_V2INT_L,
-  TILEGX_OPC_V2MAXS, TILEGX_OPC_V2MINS, TILEGX_OPC_V2MNZ, TILEGX_OPC_V2MZ,
-  TILEGX_OPC_V2PACKH, TILEGX_OPC_V2PACKL, TILEGX_OPC_V2PACKUC,
-  TILEGX_OPC_V2SHLSC, TILEGX_OPC_V2SHL, TILEGX_OPC_V2SHRS, TILEGX_OPC_V2SHRU,
-  TILEGX_OPC_V2SUBSC, TILEGX_OPC_V2SUB,
-  BITFIELD(49, 4) /* index 1202 */,
-  TILEGX_OPC_V4ADDSC, TILEGX_OPC_V4ADD, TILEGX_OPC_V4INT_H,
-  TILEGX_OPC_V4INT_L, TILEGX_OPC_V4PACKSC, TILEGX_OPC_V4SHLSC,
-  TILEGX_OPC_V4SHL, TILEGX_OPC_V4SHRS, TILEGX_OPC_V4SHRU, TILEGX_OPC_V4SUBSC,
-  TILEGX_OPC_V4SUB, TILEGX_OPC_XOR, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(49, 4) /* index 1219 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_ROTLI, TILEGX_OPC_SHLI, TILEGX_OPC_SHLXI,
-  TILEGX_OPC_SHRSI, TILEGX_OPC_SHRUI, TILEGX_OPC_SHRUXI, TILEGX_OPC_V1SHLI,
-  TILEGX_OPC_V1SHRSI, TILEGX_OPC_V1SHRUI, TILEGX_OPC_V2SHLI,
-  TILEGX_OPC_V2SHRSI, TILEGX_OPC_V2SHRUI, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE,
-  BITFIELD(31, 2) /* index 1236 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(1241),
-  BITFIELD(33, 2) /* index 1241 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(1246),
-  BITFIELD(35, 2) /* index 1246 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(1251),
-  BITFIELD(37, 2) /* index 1251 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(1256),
-  BITFIELD(39, 2) /* index 1256 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  CHILD(1261),
-  BITFIELD(41, 2) /* index 1261 */,
-  TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI, TILEGX_OPC_SHL16INSLI,
-  TILEGX_OPC_INFOL,
-};
-
-static const unsigned short decode_Y0_fsm[178] =
-{
-  BITFIELD(27, 4) /* index 0 */,
-  CHILD(17), TILEGX_OPC_ADDXI, CHILD(32), TILEGX_OPC_CMPEQI,
-  TILEGX_OPC_CMPLTSI, CHILD(62), CHILD(67), CHILD(118), CHILD(123),
-  CHILD(128), CHILD(133), CHILD(153), CHILD(158), CHILD(163), CHILD(168),
-  CHILD(173),
-  BITFIELD(6, 2) /* index 17 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(22),
-  BITFIELD(8, 2) /* index 22 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(27),
-  BITFIELD(10, 2) /* index 27 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_MOVEI,
-  BITFIELD(0, 2) /* index 32 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(37),
-  BITFIELD(2, 2) /* index 37 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(42),
-  BITFIELD(4, 2) /* index 42 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(47),
-  BITFIELD(6, 2) /* index 47 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(52),
-  BITFIELD(8, 2) /* index 52 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(57),
-  BITFIELD(10, 2) /* index 57 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_INFO,
-  BITFIELD(18, 2) /* index 62 */,
-  TILEGX_OPC_ADDX, TILEGX_OPC_ADD, TILEGX_OPC_SUBX, TILEGX_OPC_SUB,
-  BITFIELD(15, 5) /* index 67 */,
-  TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL1ADD,
-  TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL1ADD,
-  TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL2ADD,
-  TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL2ADD,
-  TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL2ADD,
-  TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHL3ADD,
-  TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHL3ADD,
-  TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHL3ADD, CHILD(100),
-  CHILD(109), TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(12, 3) /* index 100 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_CLZ, TILEGX_OPC_CTZ, TILEGX_OPC_FNOP,
-  TILEGX_OPC_FSINGLE_PACK1, TILEGX_OPC_NOP, TILEGX_OPC_PCNT,
-  TILEGX_OPC_REVBITS,
-  BITFIELD(12, 3) /* index 109 */,
-  TILEGX_OPC_REVBYTES, TILEGX_OPC_TBLIDXB0, TILEGX_OPC_TBLIDXB1,
-  TILEGX_OPC_TBLIDXB2, TILEGX_OPC_TBLIDXB3, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  TILEGX_OPC_NONE,
-  BITFIELD(18, 2) /* index 118 */,
-  TILEGX_OPC_CMPLES, TILEGX_OPC_CMPLEU, TILEGX_OPC_CMPLTS, TILEGX_OPC_CMPLTU,
-  BITFIELD(18, 2) /* index 123 */,
-  TILEGX_OPC_CMPEQ, TILEGX_OPC_CMPNE, TILEGX_OPC_MULAX, TILEGX_OPC_MULX,
-  BITFIELD(18, 2) /* index 128 */,
-  TILEGX_OPC_CMOVEQZ, TILEGX_OPC_CMOVNEZ, TILEGX_OPC_MNZ, TILEGX_OPC_MZ,
-  BITFIELD(18, 2) /* index 133 */,
-  TILEGX_OPC_AND, TILEGX_OPC_NOR, CHILD(138), TILEGX_OPC_XOR,
-  BITFIELD(12, 2) /* index 138 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(143),
-  BITFIELD(14, 2) /* index 143 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(148),
-  BITFIELD(16, 2) /* index 148 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_MOVE,
-  BITFIELD(18, 2) /* index 153 */,
-  TILEGX_OPC_ROTL, TILEGX_OPC_SHL, TILEGX_OPC_SHRS, TILEGX_OPC_SHRU,
-  BITFIELD(18, 2) /* index 158 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_SHL1ADDX, TILEGX_OPC_SHL2ADDX,
-  TILEGX_OPC_SHL3ADDX,
-  BITFIELD(18, 2) /* index 163 */,
-  TILEGX_OPC_MUL_HS_HS, TILEGX_OPC_MUL_HU_HU, TILEGX_OPC_MUL_LS_LS,
-  TILEGX_OPC_MUL_LU_LU,
-  BITFIELD(18, 2) /* index 168 */,
-  TILEGX_OPC_MULA_HS_HS, TILEGX_OPC_MULA_HU_HU, TILEGX_OPC_MULA_LS_LS,
-  TILEGX_OPC_MULA_LU_LU,
-  BITFIELD(18, 2) /* index 173 */,
-  TILEGX_OPC_ROTLI, TILEGX_OPC_SHLI, TILEGX_OPC_SHRSI, TILEGX_OPC_SHRUI,
-};
-
-static const unsigned short decode_Y1_fsm[167] =
-{
-  BITFIELD(58, 4) /* index 0 */,
-  TILEGX_OPC_NONE, CHILD(17), TILEGX_OPC_ADDXI, CHILD(32), TILEGX_OPC_CMPEQI,
-  TILEGX_OPC_CMPLTSI, CHILD(62), CHILD(67), CHILD(117), CHILD(122),
-  CHILD(127), CHILD(132), CHILD(152), CHILD(157), CHILD(162), TILEGX_OPC_NONE,
-  BITFIELD(37, 2) /* index 17 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(22),
-  BITFIELD(39, 2) /* index 22 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, CHILD(27),
-  BITFIELD(41, 2) /* index 27 */,
-  TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_ADDI, TILEGX_OPC_MOVEI,
-  BITFIELD(31, 2) /* index 32 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(37),
-  BITFIELD(33, 2) /* index 37 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(42),
-  BITFIELD(35, 2) /* index 42 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(47),
-  BITFIELD(37, 2) /* index 47 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(52),
-  BITFIELD(39, 2) /* index 52 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, CHILD(57),
-  BITFIELD(41, 2) /* index 57 */,
-  TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_ANDI, TILEGX_OPC_INFO,
-  BITFIELD(49, 2) /* index 62 */,
-  TILEGX_OPC_ADDX, TILEGX_OPC_ADD, TILEGX_OPC_SUBX, TILEGX_OPC_SUB,
-  BITFIELD(47, 4) /* index 67 */,
-  TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL1ADD,
-  TILEGX_OPC_SHL1ADD, TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL2ADD,
-  TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL2ADD, TILEGX_OPC_SHL3ADD,
-  TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHL3ADD, TILEGX_OPC_SHL3ADD, CHILD(84),
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_NONE,
-  BITFIELD(43, 3) /* index 84 */,
-  CHILD(93), CHILD(96), CHILD(99), CHILD(102), CHILD(105), CHILD(108),
-  CHILD(111), CHILD(114),
-  BITFIELD(46, 1) /* index 93 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_FNOP,
-  BITFIELD(46, 1) /* index 96 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_ILL,
-  BITFIELD(46, 1) /* index 99 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_JALRP,
-  BITFIELD(46, 1) /* index 102 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_JALR,
-  BITFIELD(46, 1) /* index 105 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_JRP,
-  BITFIELD(46, 1) /* index 108 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_JR,
-  BITFIELD(46, 1) /* index 111 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_LNK,
-  BITFIELD(46, 1) /* index 114 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_NOP,
-  BITFIELD(49, 2) /* index 117 */,
-  TILEGX_OPC_CMPLES, TILEGX_OPC_CMPLEU, TILEGX_OPC_CMPLTS, TILEGX_OPC_CMPLTU,
-  BITFIELD(49, 2) /* index 122 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_CMPEQ, TILEGX_OPC_CMPNE,
-  BITFIELD(49, 2) /* index 127 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_NONE, TILEGX_OPC_MNZ, TILEGX_OPC_MZ,
-  BITFIELD(49, 2) /* index 132 */,
-  TILEGX_OPC_AND, TILEGX_OPC_NOR, CHILD(137), TILEGX_OPC_XOR,
-  BITFIELD(43, 2) /* index 137 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(142),
-  BITFIELD(45, 2) /* index 142 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, CHILD(147),
-  BITFIELD(47, 2) /* index 147 */,
-  TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_OR, TILEGX_OPC_MOVE,
-  BITFIELD(49, 2) /* index 152 */,
-  TILEGX_OPC_ROTL, TILEGX_OPC_SHL, TILEGX_OPC_SHRS, TILEGX_OPC_SHRU,
-  BITFIELD(49, 2) /* index 157 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_SHL1ADDX, TILEGX_OPC_SHL2ADDX,
-  TILEGX_OPC_SHL3ADDX,
-  BITFIELD(49, 2) /* index 162 */,
-  TILEGX_OPC_ROTLI, TILEGX_OPC_SHLI, TILEGX_OPC_SHRSI, TILEGX_OPC_SHRUI,
-};
-
-static const unsigned short decode_Y2_fsm[118] =
-{
-  BITFIELD(62, 2) /* index 0 */,
-  TILEGX_OPC_NONE, CHILD(5), CHILD(66), CHILD(109),
-  BITFIELD(55, 3) /* index 5 */,
-  CHILD(14), CHILD(14), CHILD(14), CHILD(17), CHILD(40), CHILD(40), CHILD(40),
-  CHILD(43),
-  BITFIELD(26, 1) /* index 14 */,
-  TILEGX_OPC_LD1S, TILEGX_OPC_LD1U,
-  BITFIELD(26, 1) /* index 17 */,
-  CHILD(20), CHILD(30),
-  BITFIELD(51, 2) /* index 20 */,
-  TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, CHILD(25),
-  BITFIELD(53, 2) /* index 25 */,
-  TILEGX_OPC_LD1S, TILEGX_OPC_LD1S, TILEGX_OPC_LD1S,
-  TILEGX_OPC_PREFETCH_L1_FAULT,
-  BITFIELD(51, 2) /* index 30 */,
-  TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, CHILD(35),
-  BITFIELD(53, 2) /* index 35 */,
-  TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, TILEGX_OPC_LD1U, TILEGX_OPC_PREFETCH,
-  BITFIELD(26, 1) /* index 40 */,
-  TILEGX_OPC_LD2S, TILEGX_OPC_LD2U,
-  BITFIELD(26, 1) /* index 43 */,
-  CHILD(46), CHILD(56),
-  BITFIELD(51, 2) /* index 46 */,
-  TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, CHILD(51),
-  BITFIELD(53, 2) /* index 51 */,
-  TILEGX_OPC_LD2S, TILEGX_OPC_LD2S, TILEGX_OPC_LD2S,
-  TILEGX_OPC_PREFETCH_L2_FAULT,
-  BITFIELD(51, 2) /* index 56 */,
-  TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, CHILD(61),
-  BITFIELD(53, 2) /* index 61 */,
-  TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, TILEGX_OPC_LD2U, TILEGX_OPC_PREFETCH_L2,
-  BITFIELD(56, 2) /* index 66 */,
-  CHILD(71), CHILD(74), CHILD(90), CHILD(93),
-  BITFIELD(26, 1) /* index 71 */,
-  TILEGX_OPC_NONE, TILEGX_OPC_LD4S,
-  BITFIELD(26, 1) /* index 74 */,
-  TILEGX_OPC_NONE, CHILD(77),
-  BITFIELD(51, 2) /* index 77 */,
-  TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, CHILD(82),
-  BITFIELD(53, 2) /* index 82 */,
-  TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, TILEGX_OPC_LD4S, CHILD(87),
-  BITFIELD(55, 1) /* index 87 */,
-  TILEGX_OPC_LD4S, TILEGX_OPC_PREFETCH_L3_FAULT,
-  BITFIELD(26, 1) /* index 90 */,
-  TILEGX_OPC_LD4U, TILEGX_OPC_LD,
-  BITFIELD(26, 1) /* index 93 */,
-  CHILD(96), TILEGX_OPC_LD,
-  BITFIELD(51, 2) /* index 96 */,
-  TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, CHILD(101),
-  BITFIELD(53, 2) /* index 101 */,
-  TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, TILEGX_OPC_LD4U, CHILD(106),
-  BITFIELD(55, 1) /* index 106 */,
-  TILEGX_OPC_LD4U, TILEGX_OPC_PREFETCH_L3,
-  BITFIELD(26, 1) /* index 109 */,
-  CHILD(112), CHILD(115),
-  BITFIELD(57, 1) /* index 112 */,
-  TILEGX_OPC_ST1, TILEGX_OPC_ST4,
-  BITFIELD(57, 1) /* index 115 */,
-  TILEGX_OPC_ST2, TILEGX_OPC_ST,
-};
-
-#undef BITFIELD
-#undef CHILD
-
-const unsigned short * const
-tilegx_bundle_decoder_fsms[TILEGX_NUM_PIPELINE_ENCODINGS] =
-{
-  decode_X0_fsm,
-  decode_X1_fsm,
-  decode_Y0_fsm,
-  decode_Y1_fsm,
-  decode_Y2_fsm
-};
-
-const struct tilegx_operand tilegx_operands[35] =
-{
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_IMM8_X0),
-    8, 1, 0, 0, 0, 0,
-    create_Imm8_X0, get_Imm8_X0
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_IMM8_X1),
-    8, 1, 0, 0, 0, 0,
-    create_Imm8_X1, get_Imm8_X1
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_IMM8_Y0),
-    8, 1, 0, 0, 0, 0,
-    create_Imm8_Y0, get_Imm8_Y0
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_IMM8_Y1),
-    8, 1, 0, 0, 0, 0,
-    create_Imm8_Y1, get_Imm8_Y1
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_IMM16_X0_HW0_LAST),
-    16, 1, 0, 0, 0, 0,
-    create_Imm16_X0, get_Imm16_X0
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_IMM16_X1_HW0_LAST),
-    16, 1, 0, 0, 0, 0,
-    create_Imm16_X1, get_Imm16_X1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 0, 1, 0, 0,
-    create_Dest_X1, get_Dest_X1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcA_X1, get_SrcA_X1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 0, 1, 0, 0,
-    create_Dest_X0, get_Dest_X0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcA_X0, get_SrcA_X0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 0, 1, 0, 0,
-    create_Dest_Y0, get_Dest_Y0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcA_Y0, get_SrcA_Y0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 0, 1, 0, 0,
-    create_Dest_Y1, get_Dest_Y1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcA_Y1, get_SrcA_Y1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcA_Y2, get_SrcA_Y2
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 1, 0, 0,
-    create_SrcA_X1, get_SrcA_X1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcB_X0, get_SrcB_X0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcB_X1, get_SrcB_X1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcB_Y0, get_SrcB_Y0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcB_Y1, get_SrcB_Y1
-  },
-  {
-    TILEGX_OP_TYPE_ADDRESS, BFD_RELOC(TILEGX_BROFF_X1),
-    17, 1, 0, 0, 1, TILEGX_LOG2_BUNDLE_ALIGNMENT_IN_BYTES,
-    create_BrOff_X1, get_BrOff_X1
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_MMSTART_X0),
-    6, 0, 0, 0, 0, 0,
-    create_BFStart_X0, get_BFStart_X0
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_MMEND_X0),
-    6, 0, 0, 0, 0, 0,
-    create_BFEnd_X0, get_BFEnd_X0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 1, 0, 0,
-    create_Dest_X0, get_Dest_X0
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 1, 0, 0,
-    create_Dest_Y0, get_Dest_Y0
-  },
-  {
-    TILEGX_OP_TYPE_ADDRESS, BFD_RELOC(TILEGX_JUMPOFF_X1),
-    27, 1, 0, 0, 1, TILEGX_LOG2_BUNDLE_ALIGNMENT_IN_BYTES,
-    create_JumpOff_X1, get_JumpOff_X1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 0, 1, 0, 0,
-    create_SrcBDest_Y2, get_SrcBDest_Y2
-  },
-  {
-    TILEGX_OP_TYPE_SPR, BFD_RELOC(TILEGX_MF_IMM14_X1),
-    14, 0, 0, 0, 0, 0,
-    create_MF_Imm14_X1, get_MF_Imm14_X1
-  },
-  {
-    TILEGX_OP_TYPE_SPR, BFD_RELOC(TILEGX_MT_IMM14_X1),
-    14, 0, 0, 0, 0, 0,
-    create_MT_Imm14_X1, get_MT_Imm14_X1
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_SHAMT_X0),
-    6, 0, 0, 0, 0, 0,
-    create_ShAmt_X0, get_ShAmt_X0
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_SHAMT_X1),
-    6, 0, 0, 0, 0, 0,
-    create_ShAmt_X1, get_ShAmt_X1
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_SHAMT_Y0),
-    6, 0, 0, 0, 0, 0,
-    create_ShAmt_Y0, get_ShAmt_Y0
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_SHAMT_Y1),
-    6, 0, 0, 0, 0, 0,
-    create_ShAmt_Y1, get_ShAmt_Y1
-  },
-  {
-    TILEGX_OP_TYPE_REGISTER, BFD_RELOC(NONE),
-    6, 0, 1, 0, 0, 0,
-    create_SrcBDest_Y2, get_SrcBDest_Y2
-  },
-  {
-    TILEGX_OP_TYPE_IMMEDIATE, BFD_RELOC(TILEGX_DEST_IMM8_X1),
-    8, 1, 0, 0, 0, 0,
-    create_Dest_Imm8_X1, get_Dest_Imm8_X1
-  }
-};
-
-/* Given a set of bundle bits and a specific pipe, returns which
- * instruction the bundle contains in that pipe.
- */
-const struct tilegx_opcode *
-find_opcode(tilegx_bundle_bits bits, tilegx_pipeline pipe)
-{
-  const unsigned short *table = tilegx_bundle_decoder_fsms[pipe];
-  int index = 0;
-
-  while (1)
-  {
-    unsigned short bitspec = table[index];
-    unsigned int bitfield =
-      ((unsigned int)(bits >> (bitspec & 63))) & (bitspec >> 6);
-
-    unsigned short next = table[index + 1 + bitfield];
-    if (next <= TILEGX_OPC_NONE)
-      return &tilegx_opcodes[next];
-
-    index = next - TILEGX_OPC_NONE;
-  }
-}
-
-int
-parse_insn_tilegx(tilegx_bundle_bits bits,
-                  unsigned long long pc,
-                  struct tilegx_decoded_instruction
-                  decoded[TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE])
-{
-  int num_instructions = 0;
-  int pipe;
-
-  int min_pipe, max_pipe;
-  if ((bits & TILEGX_BUNDLE_MODE_MASK) == 0)
-  {
-    min_pipe = TILEGX_PIPELINE_X0;
-    max_pipe = TILEGX_PIPELINE_X1;
-  }
-  else
-  {
-    min_pipe = TILEGX_PIPELINE_Y0;
-    max_pipe = TILEGX_PIPELINE_Y2;
-  }
-
-  /* For each pipe, find an instruction that fits. */
-  for (pipe = min_pipe; pipe <= max_pipe; pipe++)
-  {
-    const struct tilegx_opcode *opc;
-    struct tilegx_decoded_instruction *d;
-    int i;
-
-    d = &decoded[num_instructions++];
-    opc = find_opcode (bits, (tilegx_pipeline)pipe);
-    d->opcode = opc;
-
-    /* Decode each operand, sign extending, etc. as appropriate. */
-    for (i = 0; i < opc->num_operands; i++)
-    {
-      const struct tilegx_operand *op =
-        &tilegx_operands[opc->operands[pipe][i]];
-      int raw_opval = op->extract (bits);
-      long long opval;
-
-      if (op->is_signed)
-      {
-        /* Sign-extend the operand. */
-        int shift = (int)((sizeof(int) * 8) - op->num_bits);
-        raw_opval = (raw_opval << shift) >> shift;
-      }
-
-      /* Adjust PC-relative scaled branch offsets. */
-      if (op->type == TILEGX_OP_TYPE_ADDRESS)
-        opval = (raw_opval * TILEGX_BUNDLE_SIZE_IN_BYTES) + pc;
-      else
-        opval = raw_opval;
-
-      /* Record the final value. */
-      d->operands[i] = op;
-      d->operand_values[i] = opval;
-    }
-  }
-
-  return num_instructions;
-}
-
-struct tilegx_spr
-{
-  /* The number */
-  int number;
-
-  /* The name */
-  const char *name;
-};
-
-static int
-tilegx_spr_compare (const void *a_ptr, const void *b_ptr)
-{
-  const struct tilegx_spr *a = (const struct tilegx_spr *) a_ptr;
-  const struct tilegx_spr *b = (const struct tilegx_spr *) b_ptr;
-  return (a->number - b->number);
-}
-
-const struct tilegx_spr tilegx_sprs[] = {
-  { 0, "MPL_MEM_ERROR_SET_0" },
-  { 1, "MPL_MEM_ERROR_SET_1" },
-  { 2, "MPL_MEM_ERROR_SET_2" },
-  { 3, "MPL_MEM_ERROR_SET_3" },
-  { 4, "MPL_MEM_ERROR" },
-  { 5, "MEM_ERROR_CBOX_ADDR" },
-  { 6, "MEM_ERROR_CBOX_STATUS" },
-  { 7, "MEM_ERROR_ENABLE" },
-  { 8, "MEM_ERROR_MBOX_ADDR" },
-  { 9, "MEM_ERROR_MBOX_STATUS" },
-  { 10, "SBOX_ERROR" },
-  { 11, "XDN_DEMUX_ERROR" },
-  { 256, "MPL_SINGLE_STEP_3_SET_0" },
-  { 257, "MPL_SINGLE_STEP_3_SET_1" },
-  { 258, "MPL_SINGLE_STEP_3_SET_2" },
-  { 259, "MPL_SINGLE_STEP_3_SET_3" },
-  { 260, "MPL_SINGLE_STEP_3" },
-  { 261, "SINGLE_STEP_CONTROL_3" },
-  { 512, "MPL_SINGLE_STEP_2_SET_0" },
-  { 513, "MPL_SINGLE_STEP_2_SET_1" },
-  { 514, "MPL_SINGLE_STEP_2_SET_2" },
-  { 515, "MPL_SINGLE_STEP_2_SET_3" },
-  { 516, "MPL_SINGLE_STEP_2" },
-  { 517, "SINGLE_STEP_CONTROL_2" },
-  { 768, "MPL_SINGLE_STEP_1_SET_0" },
-  { 769, "MPL_SINGLE_STEP_1_SET_1" },
-  { 770, "MPL_SINGLE_STEP_1_SET_2" },
-  { 771, "MPL_SINGLE_STEP_1_SET_3" },
-  { 772, "MPL_SINGLE_STEP_1" },
-  { 773, "SINGLE_STEP_CONTROL_1" },
-  { 1024, "MPL_SINGLE_STEP_0_SET_0" },
-  { 1025, "MPL_SINGLE_STEP_0_SET_1" },
-  { 1026, "MPL_SINGLE_STEP_0_SET_2" },
-  { 1027, "MPL_SINGLE_STEP_0_SET_3" },
-  { 1028, "MPL_SINGLE_STEP_0" },
-  { 1029, "SINGLE_STEP_CONTROL_0" },
-  { 1280, "MPL_IDN_COMPLETE_SET_0" },
-  { 1281, "MPL_IDN_COMPLETE_SET_1" },
-  { 1282, "MPL_IDN_COMPLETE_SET_2" },
-  { 1283, "MPL_IDN_COMPLETE_SET_3" },
-  { 1284, "MPL_IDN_COMPLETE" },
-  { 1285, "IDN_COMPLETE_PENDING" },
-  { 1536, "MPL_UDN_COMPLETE_SET_0" },
-  { 1537, "MPL_UDN_COMPLETE_SET_1" },
-  { 1538, "MPL_UDN_COMPLETE_SET_2" },
-  { 1539, "MPL_UDN_COMPLETE_SET_3" },
-  { 1540, "MPL_UDN_COMPLETE" },
-  { 1541, "UDN_COMPLETE_PENDING" },
-  { 1792, "MPL_ITLB_MISS_SET_0" },
-  { 1793, "MPL_ITLB_MISS_SET_1" },
-  { 1794, "MPL_ITLB_MISS_SET_2" },
-  { 1795, "MPL_ITLB_MISS_SET_3" },
-  { 1796, "MPL_ITLB_MISS" },
-  { 1797, "ITLB_TSB_BASE_ADDR_0" },
-  { 1798, "ITLB_TSB_BASE_ADDR_1" },
-  { 1920, "ITLB_CURRENT_ATTR" },
-  { 1921, "ITLB_CURRENT_PA" },
-  { 1922, "ITLB_CURRENT_VA" },
-  { 1923, "ITLB_INDEX" },
-  { 1924, "ITLB_MATCH_0" },
-  { 1925, "ITLB_PERF" },
-  { 1926, "ITLB_PR" },
-  { 1927, "ITLB_TSB_ADDR_0" },
-  { 1928, "ITLB_TSB_ADDR_1" },
-  { 1929, "ITLB_TSB_FILL_CURRENT_ATTR" },
-  { 1930, "ITLB_TSB_FILL_MATCH" },
-  { 1931, "NUMBER_ITLB" },
-  { 1932, "REPLACEMENT_ITLB" },
-  { 1933, "WIRED_ITLB" },
-  { 2048, "MPL_ILL_SET_0" },
-  { 2049, "MPL_ILL_SET_1" },
-  { 2050, "MPL_ILL_SET_2" },
-  { 2051, "MPL_ILL_SET_3" },
-  { 2052, "MPL_ILL" },
-  { 2304, "MPL_GPV_SET_0" },
-  { 2305, "MPL_GPV_SET_1" },
-  { 2306, "MPL_GPV_SET_2" },
-  { 2307, "MPL_GPV_SET_3" },
-  { 2308, "MPL_GPV" },
-  { 2309, "GPV_REASON" },
-  { 2560, "MPL_IDN_ACCESS_SET_0" },
-  { 2561, "MPL_IDN_ACCESS_SET_1" },
-  { 2562, "MPL_IDN_ACCESS_SET_2" },
-  { 2563, "MPL_IDN_ACCESS_SET_3" },
-  { 2564, "MPL_IDN_ACCESS" },
-  { 2565, "IDN_DEMUX_COUNT_0" },
-  { 2566, "IDN_DEMUX_COUNT_1" },
-  { 2567, "IDN_FLUSH_EGRESS" },
-  { 2568, "IDN_PENDING" },
-  { 2569, "IDN_ROUTE_ORDER" },
-  { 2570, "IDN_SP_FIFO_CNT" },
-  { 2688, "IDN_DATA_AVAIL" },
-  { 2816, "MPL_UDN_ACCESS_SET_0" },
-  { 2817, "MPL_UDN_ACCESS_SET_1" },
-  { 2818, "MPL_UDN_ACCESS_SET_2" },
-  { 2819, "MPL_UDN_ACCESS_SET_3" },
-  { 2820, "MPL_UDN_ACCESS" },
-  { 2821, "UDN_DEMUX_COUNT_0" },
-  { 2822, "UDN_DEMUX_COUNT_1" },
-  { 2823, "UDN_DEMUX_COUNT_2" },
-  { 2824, "UDN_DEMUX_COUNT_3" },
-  { 2825, "UDN_FLUSH_EGRESS" },
-  { 2826, "UDN_PENDING" },
-  { 2827, "UDN_ROUTE_ORDER" },
-  { 2828, "UDN_SP_FIFO_CNT" },
-  { 2944, "UDN_DATA_AVAIL" },
-  { 3072, "MPL_SWINT_3_SET_0" },
-  { 3073, "MPL_SWINT_3_SET_1" },
-  { 3074, "MPL_SWINT_3_SET_2" },
-  { 3075, "MPL_SWINT_3_SET_3" },
-  { 3076, "MPL_SWINT_3" },
-  { 3328, "MPL_SWINT_2_SET_0" },
-  { 3329, "MPL_SWINT_2_SET_1" },
-  { 3330, "MPL_SWINT_2_SET_2" },
-  { 3331, "MPL_SWINT_2_SET_3" },
-  { 3332, "MPL_SWINT_2" },
-  { 3584, "MPL_SWINT_1_SET_0" },
-  { 3585, "MPL_SWINT_1_SET_1" },
-  { 3586, "MPL_SWINT_1_SET_2" },
-  { 3587, "MPL_SWINT_1_SET_3" },
-  { 3588, "MPL_SWINT_1" },
-  { 3840, "MPL_SWINT_0_SET_0" },
-  { 3841, "MPL_SWINT_0_SET_1" },
-  { 3842, "MPL_SWINT_0_SET_2" },
-  { 3843, "MPL_SWINT_0_SET_3" },
-  { 3844, "MPL_SWINT_0" },
-  { 4096, "MPL_ILL_TRANS_SET_0" },
-  { 4097, "MPL_ILL_TRANS_SET_1" },
-  { 4098, "MPL_ILL_TRANS_SET_2" },
-  { 4099, "MPL_ILL_TRANS_SET_3" },
-  { 4100, "MPL_ILL_TRANS" },
-  { 4101, "ILL_TRANS_REASON" },
-  { 4102, "ILL_VA_PC" },
-  { 4352, "MPL_UNALIGN_DATA_SET_0" },
-  { 4353, "MPL_UNALIGN_DATA_SET_1" },
-  { 4354, "MPL_UNALIGN_DATA_SET_2" },
-  { 4355, "MPL_UNALIGN_DATA_SET_3" },
-  { 4356, "MPL_UNALIGN_DATA" },
-  { 4608, "MPL_DTLB_MISS_SET_0" },
-  { 4609, "MPL_DTLB_MISS_SET_1" },
-  { 4610, "MPL_DTLB_MISS_SET_2" },
-  { 4611, "MPL_DTLB_MISS_SET_3" },
-  { 4612, "MPL_DTLB_MISS" },
-  { 4613, "DTLB_TSB_BASE_ADDR_0" },
-  { 4614, "DTLB_TSB_BASE_ADDR_1" },
-  { 4736, "AAR" },
-  { 4737, "CACHE_PINNED_WAYS" },
-  { 4738, "DTLB_BAD_ADDR" },
-  { 4739, "DTLB_BAD_ADDR_REASON" },
-  { 4740, "DTLB_CURRENT_ATTR" },
-  { 4741, "DTLB_CURRENT_PA" },
-  { 4742, "DTLB_CURRENT_VA" },
-  { 4743, "DTLB_INDEX" },
-  { 4744, "DTLB_MATCH_0" },
-  { 4745, "DTLB_PERF" },
-  { 4746, "DTLB_TSB_ADDR_0" },
-  { 4747, "DTLB_TSB_ADDR_1" },
-  { 4748, "DTLB_TSB_FILL_CURRENT_ATTR" },
-  { 4749, "DTLB_TSB_FILL_MATCH" },
-  { 4750, "NUMBER_DTLB" },
-  { 4751, "REPLACEMENT_DTLB" },
-  { 4752, "WIRED_DTLB" },
-  { 4864, "MPL_DTLB_ACCESS_SET_0" },
-  { 4865, "MPL_DTLB_ACCESS_SET_1" },
-  { 4866, "MPL_DTLB_ACCESS_SET_2" },
-  { 4867, "MPL_DTLB_ACCESS_SET_3" },
-  { 4868, "MPL_DTLB_ACCESS" },
-  { 5120, "MPL_IDN_FIREWALL_SET_0" },
-  { 5121, "MPL_IDN_FIREWALL_SET_1" },
-  { 5122, "MPL_IDN_FIREWALL_SET_2" },
-  { 5123, "MPL_IDN_FIREWALL_SET_3" },
-  { 5124, "MPL_IDN_FIREWALL" },
-  { 5125, "IDN_DIRECTION_PROTECT" },
-  { 5376, "MPL_UDN_FIREWALL_SET_0" },
-  { 5377, "MPL_UDN_FIREWALL_SET_1" },
-  { 5378, "MPL_UDN_FIREWALL_SET_2" },
-  { 5379, "MPL_UDN_FIREWALL_SET_3" },
-  { 5380, "MPL_UDN_FIREWALL" },
-  { 5381, "UDN_DIRECTION_PROTECT" },
-  { 5632, "MPL_TILE_TIMER_SET_0" },
-  { 5633, "MPL_TILE_TIMER_SET_1" },
-  { 5634, "MPL_TILE_TIMER_SET_2" },
-  { 5635, "MPL_TILE_TIMER_SET_3" },
-  { 5636, "MPL_TILE_TIMER" },
-  { 5637, "TILE_TIMER_CONTROL" },
-  { 5888, "MPL_AUX_TILE_TIMER_SET_0" },
-  { 5889, "MPL_AUX_TILE_TIMER_SET_1" },
-  { 5890, "MPL_AUX_TILE_TIMER_SET_2" },
-  { 5891, "MPL_AUX_TILE_TIMER_SET_3" },
-  { 5892, "MPL_AUX_TILE_TIMER" },
-  { 5893, "AUX_TILE_TIMER_CONTROL" },
-  { 6144, "MPL_IDN_TIMER_SET_0" },
-  { 6145, "MPL_IDN_TIMER_SET_1" },
-  { 6146, "MPL_IDN_TIMER_SET_2" },
-  { 6147, "MPL_IDN_TIMER_SET_3" },
-  { 6148, "MPL_IDN_TIMER" },
-  { 6149, "IDN_DEADLOCK_COUNT" },
-  { 6150, "IDN_DEADLOCK_TIMEOUT" },
-  { 6400, "MPL_UDN_TIMER_SET_0" },
-  { 6401, "MPL_UDN_TIMER_SET_1" },
-  { 6402, "MPL_UDN_TIMER_SET_2" },
-  { 6403, "MPL_UDN_TIMER_SET_3" },
-  { 6404, "MPL_UDN_TIMER" },
-  { 6405, "UDN_DEADLOCK_COUNT" },
-  { 6406, "UDN_DEADLOCK_TIMEOUT" },
-  { 6656, "MPL_IDN_AVAIL_SET_0" },
-  { 6657, "MPL_IDN_AVAIL_SET_1" },
-  { 6658, "MPL_IDN_AVAIL_SET_2" },
-  { 6659, "MPL_IDN_AVAIL_SET_3" },
-  { 6660, "MPL_IDN_AVAIL" },
-  { 6661, "IDN_AVAIL_EN" },
-  { 6912, "MPL_UDN_AVAIL_SET_0" },
-  { 6913, "MPL_UDN_AVAIL_SET_1" },
-  { 6914, "MPL_UDN_AVAIL_SET_2" },
-  { 6915, "MPL_UDN_AVAIL_SET_3" },
-  { 6916, "MPL_UDN_AVAIL" },
-  { 6917, "UDN_AVAIL_EN" },
-  { 7168, "MPL_IPI_3_SET_0" },
-  { 7169, "MPL_IPI_3_SET_1" },
-  { 7170, "MPL_IPI_3_SET_2" },
-  { 7171, "MPL_IPI_3_SET_3" },
-  { 7172, "MPL_IPI_3" },
-  { 7173, "IPI_EVENT_3" },
-  { 7174, "IPI_EVENT_RESET_3" },
-  { 7175, "IPI_EVENT_SET_3" },
-  { 7176, "IPI_MASK_3" },
-  { 7177, "IPI_MASK_RESET_3" },
-  { 7178, "IPI_MASK_SET_3" },
-  { 7424, "MPL_IPI_2_SET_0" },
-  { 7425, "MPL_IPI_2_SET_1" },
-  { 7426, "MPL_IPI_2_SET_2" },
-  { 7427, "MPL_IPI_2_SET_3" },
-  { 7428, "MPL_IPI_2" },
-  { 7429, "IPI_EVENT_2" },
-  { 7430, "IPI_EVENT_RESET_2" },
-  { 7431, "IPI_EVENT_SET_2" },
-  { 7432, "IPI_MASK_2" },
-  { 7433, "IPI_MASK_RESET_2" },
-  { 7434, "IPI_MASK_SET_2" },
-  { 7680, "MPL_IPI_1_SET_0" },
-  { 7681, "MPL_IPI_1_SET_1" },
-  { 7682, "MPL_IPI_1_SET_2" },
-  { 7683, "MPL_IPI_1_SET_3" },
-  { 7684, "MPL_IPI_1" },
-  { 7685, "IPI_EVENT_1" },
-  { 7686, "IPI_EVENT_RESET_1" },
-  { 7687, "IPI_EVENT_SET_1" },
-  { 7688, "IPI_MASK_1" },
-  { 7689, "IPI_MASK_RESET_1" },
-  { 7690, "IPI_MASK_SET_1" },
-  { 7936, "MPL_IPI_0_SET_0" },
-  { 7937, "MPL_IPI_0_SET_1" },
-  { 7938, "MPL_IPI_0_SET_2" },
-  { 7939, "MPL_IPI_0_SET_3" },
-  { 7940, "MPL_IPI_0" },
-  { 7941, "IPI_EVENT_0" },
-  { 7942, "IPI_EVENT_RESET_0" },
-  { 7943, "IPI_EVENT_SET_0" },
-  { 7944, "IPI_MASK_0" },
-  { 7945, "IPI_MASK_RESET_0" },
-  { 7946, "IPI_MASK_SET_0" },
-  { 8192, "MPL_PERF_COUNT_SET_0" },
-  { 8193, "MPL_PERF_COUNT_SET_1" },
-  { 8194, "MPL_PERF_COUNT_SET_2" },
-  { 8195, "MPL_PERF_COUNT_SET_3" },
-  { 8196, "MPL_PERF_COUNT" },
-  { 8197, "PERF_COUNT_0" },
-  { 8198, "PERF_COUNT_1" },
-  { 8199, "PERF_COUNT_CTL" },
-  { 8200, "PERF_COUNT_DN_CTL" },
-  { 8201, "PERF_COUNT_STS" },
-  { 8202, "WATCH_MASK" },
-  { 8203, "WATCH_VAL" },
-  { 8448, "MPL_AUX_PERF_COUNT_SET_0" },
-  { 8449, "MPL_AUX_PERF_COUNT_SET_1" },
-  { 8450, "MPL_AUX_PERF_COUNT_SET_2" },
-  { 8451, "MPL_AUX_PERF_COUNT_SET_3" },
-  { 8452, "MPL_AUX_PERF_COUNT" },
-  { 8453, "AUX_PERF_COUNT_0" },
-  { 8454, "AUX_PERF_COUNT_1" },
-  { 8455, "AUX_PERF_COUNT_CTL" },
-  { 8456, "AUX_PERF_COUNT_STS" },
-  { 8704, "MPL_INTCTRL_3_SET_0" },
-  { 8705, "MPL_INTCTRL_3_SET_1" },
-  { 8706, "MPL_INTCTRL_3_SET_2" },
-  { 8707, "MPL_INTCTRL_3_SET_3" },
-  { 8708, "MPL_INTCTRL_3" },
-  { 8709, "INTCTRL_3_STATUS" },
-  { 8710, "INTERRUPT_MASK_3" },
-  { 8711, "INTERRUPT_MASK_RESET_3" },
-  { 8712, "INTERRUPT_MASK_SET_3" },
-  { 8713, "INTERRUPT_VECTOR_BASE_3" },
-  { 8714, "SINGLE_STEP_EN_0_3" },
-  { 8715, "SINGLE_STEP_EN_1_3" },
-  { 8716, "SINGLE_STEP_EN_2_3" },
-  { 8717, "SINGLE_STEP_EN_3_3" },
-  { 8832, "EX_CONTEXT_3_0" },
-  { 8833, "EX_CONTEXT_3_1" },
-  { 8834, "SYSTEM_SAVE_3_0" },
-  { 8835, "SYSTEM_SAVE_3_1" },
-  { 8836, "SYSTEM_SAVE_3_2" },
-  { 8837, "SYSTEM_SAVE_3_3" },
-  { 8960, "MPL_INTCTRL_2_SET_0" },
-  { 8961, "MPL_INTCTRL_2_SET_1" },
-  { 8962, "MPL_INTCTRL_2_SET_2" },
-  { 8963, "MPL_INTCTRL_2_SET_3" },
-  { 8964, "MPL_INTCTRL_2" },
-  { 8965, "INTCTRL_2_STATUS" },
-  { 8966, "INTERRUPT_MASK_2" },
-  { 8967, "INTERRUPT_MASK_RESET_2" },
-  { 8968, "INTERRUPT_MASK_SET_2" },
-  { 8969, "INTERRUPT_VECTOR_BASE_2" },
-  { 8970, "SINGLE_STEP_EN_0_2" },
-  { 8971, "SINGLE_STEP_EN_1_2" },
-  { 8972, "SINGLE_STEP_EN_2_2" },
-  { 8973, "SINGLE_STEP_EN_3_2" },
-  { 9088, "EX_CONTEXT_2_0" },
-  { 9089, "EX_CONTEXT_2_1" },
-  { 9090, "SYSTEM_SAVE_2_0" },
-  { 9091, "SYSTEM_SAVE_2_1" },
-  { 9092, "SYSTEM_SAVE_2_2" },
-  { 9093, "SYSTEM_SAVE_2_3" },
-  { 9216, "MPL_INTCTRL_1_SET_0" },
-  { 9217, "MPL_INTCTRL_1_SET_1" },
-  { 9218, "MPL_INTCTRL_1_SET_2" },
-  { 9219, "MPL_INTCTRL_1_SET_3" },
-  { 9220, "MPL_INTCTRL_1" },
-  { 9221, "INTCTRL_1_STATUS" },
-  { 9222, "INTERRUPT_MASK_1" },
-  { 9223, "INTERRUPT_MASK_RESET_1" },
-  { 9224, "INTERRUPT_MASK_SET_1" },
-  { 9225, "INTERRUPT_VECTOR_BASE_1" },
-  { 9226, "SINGLE_STEP_EN_0_1" },
-  { 9227, "SINGLE_STEP_EN_1_1" },
-  { 9228, "SINGLE_STEP_EN_2_1" },
-  { 9229, "SINGLE_STEP_EN_3_1" },
-  { 9344, "EX_CONTEXT_1_0" },
-  { 9345, "EX_CONTEXT_1_1" },
-  { 9346, "SYSTEM_SAVE_1_0" },
-  { 9347, "SYSTEM_SAVE_1_1" },
-  { 9348, "SYSTEM_SAVE_1_2" },
-  { 9349, "SYSTEM_SAVE_1_3" },
-  { 9472, "MPL_INTCTRL_0_SET_0" },
-  { 9473, "MPL_INTCTRL_0_SET_1" },
-  { 9474, "MPL_INTCTRL_0_SET_2" },
-  { 9475, "MPL_INTCTRL_0_SET_3" },
-  { 9476, "MPL_INTCTRL_0" },
-  { 9477, "INTCTRL_0_STATUS" },
-  { 9478, "INTERRUPT_MASK_0" },
-  { 9479, "INTERRUPT_MASK_RESET_0" },
-  { 9480, "INTERRUPT_MASK_SET_0" },
-  { 9481, "INTERRUPT_VECTOR_BASE_0" },
-  { 9482, "SINGLE_STEP_EN_0_0" },
-  { 9483, "SINGLE_STEP_EN_1_0" },
-  { 9484, "SINGLE_STEP_EN_2_0" },
-  { 9485, "SINGLE_STEP_EN_3_0" },
-  { 9600, "EX_CONTEXT_0_0" },
-  { 9601, "EX_CONTEXT_0_1" },
-  { 9602, "SYSTEM_SAVE_0_0" },
-  { 9603, "SYSTEM_SAVE_0_1" },
-  { 9604, "SYSTEM_SAVE_0_2" },
-  { 9605, "SYSTEM_SAVE_0_3" },
-  { 9728, "MPL_BOOT_ACCESS_SET_0" },
-  { 9729, "MPL_BOOT_ACCESS_SET_1" },
-  { 9730, "MPL_BOOT_ACCESS_SET_2" },
-  { 9731, "MPL_BOOT_ACCESS_SET_3" },
-  { 9732, "MPL_BOOT_ACCESS" },
-  { 9733, "BIG_ENDIAN_CONFIG" },
-  { 9734, "CACHE_INVALIDATION_COMPRESSION_MODE" },
-  { 9735, "CACHE_INVALIDATION_MASK_0" },
-  { 9736, "CACHE_INVALIDATION_MASK_1" },
-  { 9737, "CACHE_INVALIDATION_MASK_2" },
-  { 9738, "CBOX_CACHEASRAM_CONFIG" },
-  { 9739, "CBOX_CACHE_CONFIG" },
-  { 9740, "CBOX_HOME_MAP_ADDR" },
-  { 9741, "CBOX_HOME_MAP_DATA" },
-  { 9742, "CBOX_MMAP_0" },
-  { 9743, "CBOX_MMAP_1" },
-  { 9744, "CBOX_MMAP_2" },
-  { 9745, "CBOX_MMAP_3" },
-  { 9746, "CBOX_MSR" },
-  { 9747, "DIAG_BCST_CTL" },
-  { 9748, "DIAG_BCST_MASK" },
-  { 9749, "DIAG_BCST_TRIGGER" },
-  { 9750, "DIAG_MUX_CTL" },
-  { 9751, "DIAG_TRACE_CTL" },
-  { 9752, "DIAG_TRACE_DATA" },
-  { 9753, "DIAG_TRACE_STS" },
-  { 9754, "IDN_DEMUX_BUF_THRESH" },
-  { 9755, "L1_I_PIN_WAY_0" },
-  { 9756, "MEM_ROUTE_ORDER" },
-  { 9757, "MEM_STRIPE_CONFIG" },
-  { 9758, "PERF_COUNT_PLS" },
-  { 9759, "PSEUDO_RANDOM_NUMBER_MODIFY" },
-  { 9760, "QUIESCE_CTL" },
-  { 9761, "RSHIM_COORD" },
-  { 9762, "SBOX_CONFIG" },
-  { 9763, "UDN_DEMUX_BUF_THRESH" },
-  { 9764, "XDN_CORE_STARVATION_COUNT" },
-  { 9765, "XDN_ROUND_ROBIN_ARB_CTL" },
-  { 9856, "CYCLE_MODIFY" },
-  { 9857, "I_AAR" },
-  { 9984, "MPL_WORLD_ACCESS_SET_0" },
-  { 9985, "MPL_WORLD_ACCESS_SET_1" },
-  { 9986, "MPL_WORLD_ACCESS_SET_2" },
-  { 9987, "MPL_WORLD_ACCESS_SET_3" },
-  { 9988, "MPL_WORLD_ACCESS" },
-  { 9989, "DONE" },
-  { 9990, "DSTREAM_PF" },
-  { 9991, "FAIL" },
-  { 9992, "INTERRUPT_CRITICAL_SECTION" },
-  { 9993, "PASS" },
-  { 9994, "PSEUDO_RANDOM_NUMBER" },
-  { 9995, "TILE_COORD" },
-  { 9996, "TILE_RTF_HWM" },
-  { 10112, "CMPEXCH_VALUE" },
-  { 10113, "CYCLE" },
-  { 10114, "EVENT_BEGIN" },
-  { 10115, "EVENT_END" },
-  { 10116, "PROC_STATUS" },
-  { 10117, "SIM_CONTROL" },
-  { 10118, "SIM_SOCKET" },
-  { 10119, "STATUS_SATURATE" },
-  { 10240, "MPL_I_ASID_SET_0" },
-  { 10241, "MPL_I_ASID_SET_1" },
-  { 10242, "MPL_I_ASID_SET_2" },
-  { 10243, "MPL_I_ASID_SET_3" },
-  { 10244, "MPL_I_ASID" },
-  { 10245, "I_ASID" },
-  { 10496, "MPL_D_ASID_SET_0" },
-  { 10497, "MPL_D_ASID_SET_1" },
-  { 10498, "MPL_D_ASID_SET_2" },
-  { 10499, "MPL_D_ASID_SET_3" },
-  { 10500, "MPL_D_ASID" },
-  { 10501, "D_ASID" },
-  { 10752, "MPL_DOUBLE_FAULT_SET_0" },
-  { 10753, "MPL_DOUBLE_FAULT_SET_1" },
-  { 10754, "MPL_DOUBLE_FAULT_SET_2" },
-  { 10755, "MPL_DOUBLE_FAULT_SET_3" },
-  { 10756, "MPL_DOUBLE_FAULT" },
-  { 10757, "LAST_INTERRUPT_REASON" },
-};
-
-const int tilegx_num_sprs = 441;
-
-const char *
-get_tilegx_spr_name (int num)
-{
-  void *result;
-  struct tilegx_spr key;
-
-  key.number = num;
-  result = bsearch((const void *) &key, (const void *) tilegx_sprs,
-                   tilegx_num_sprs, sizeof (struct tilegx_spr),
-                   tilegx_spr_compare);
-
-  if (result == NULL)
-  {
-    return (NULL);
-  }
-  else
-  {
-    struct tilegx_spr *result_ptr = (struct tilegx_spr *) result;
-    return (result_ptr->name);
-  }
-}
-
-int
-print_insn_tilegx (unsigned char * memaddr)
-{
-  struct tilegx_decoded_instruction
-    decoded[TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE];
-  unsigned char opbuf[TILEGX_BUNDLE_SIZE_IN_BYTES];
-  int i, num_instructions, num_printed;
-  tilegx_mnemonic padding_mnemonic;
-
-  memcpy((void *)opbuf, (void *)memaddr, TILEGX_BUNDLE_SIZE_IN_BYTES);
-
-  /* Parse the instructions in the bundle. */
-  num_instructions =
-    parse_insn_tilegx (*(unsigned long long *)opbuf, (unsigned long long)memaddr, decoded);
-
-  /* Print the instructions in the bundle. */
-  printf("{ ");
-  num_printed = 0;
-
-  /* Determine which nop opcode is used for padding and should be skipped. */
-  padding_mnemonic = TILEGX_OPC_FNOP;
-  for (i = 0; i < num_instructions; i++)
-  {
-    if (!decoded[i].opcode->can_bundle)
-    {
-      /* Instructions that cannot be bundled are padded out with nops,
-         rather than fnops. Displaying them is always clutter. */
-      padding_mnemonic = TILEGX_OPC_NOP;
-      break;
-    }
-  }
-
-  for (i = 0; i < num_instructions; i++)
-  {
-    const struct tilegx_opcode *opcode = decoded[i].opcode;
-    const char *name;
-    int j;
-
-    /* Do not print out fnops, unless everything is an fnop, in
-       which case we will print out just the last one. */
-    if (opcode->mnemonic == padding_mnemonic
-        && (num_printed > 0 || i + 1 < num_instructions))
-      continue;
-
-    if (num_printed > 0)
-      printf(" ; ");
-    ++num_printed;
-
-    name = opcode->name;
-    if (name == NULL)
-      name = "<invalid>";
-    printf("%s", name);
-
-    for (j = 0; j < opcode->num_operands; j++)
-    {
-      unsigned long long num;
-      const struct tilegx_operand *op;
-      const char *spr_name;
-
-      if (j > 0)
-        printf (",");
-      printf (" ");
-
-      num = decoded[i].operand_values[j];
-
-      op = decoded[i].operands[j];
-      switch (op->type)
-      {
-      case TILEGX_OP_TYPE_REGISTER:
-        printf ("%s", tilegx_register_names[(int)num]);
-        break;
-      case TILEGX_OP_TYPE_SPR:
-        spr_name = get_tilegx_spr_name(num);
-        if (spr_name != NULL)
-          printf ("%s", spr_name);
-        else
-          printf ("%d", (int)num);
-        break;
-      case TILEGX_OP_TYPE_IMMEDIATE:
-        printf ("%d", (int)num);
-        break;
-      case TILEGX_OP_TYPE_ADDRESS:
-        printf ("0x%016llx", num);
-        break;
-      default:
-        abort ();
-      }
-    }
-  }
-  printf (" }\n");
-
-  return TILEGX_BUNDLE_SIZE_IN_BYTES;
-}
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX_64.c b/src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX_64.c
deleted file mode 100644
index d69ecd6170..0000000000
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeTILEGX_64.c
+++ /dev/null
@@ -1,2563 +0,0 @@
-/*
- *    Stack-less Just-In-Time compiler
- *
- *    Copyright 2013-2013 Tilera Corporation(jiwang@tilera.com). All rights reserved.
- *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are
- * permitted provided that the following conditions are met:
- *
- *   1. Redistributions of source code must retain the above copyright notice, this list of
- *      conditions and the following disclaimer.
- *
- *   2. Redistributions in binary form must reproduce the above copyright notice, this list
- *      of conditions and the following disclaimer in the documentation and/or other materials
- *      provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
- * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
- * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* TileGX architecture. */
-/* Contributed by Tilera Corporation. */
-#include "sljitNativeTILEGX-encoder.c"
-
-#define SIMM_8BIT_MAX (0x7f)
-#define SIMM_8BIT_MIN (-0x80)
-#define SIMM_16BIT_MAX (0x7fff)
-#define SIMM_16BIT_MIN (-0x8000)
-#define SIMM_17BIT_MAX (0xffff)
-#define SIMM_17BIT_MIN (-0x10000)
-#define SIMM_32BIT_MAX (0x7fffffff)
-#define SIMM_32BIT_MIN (-0x7fffffff - 1)
-#define SIMM_48BIT_MAX (0x7fffffff0000L)
-#define SIMM_48BIT_MIN (-0x800000000000L)
-#define IMM16(imm) ((imm) & 0xffff)
-
-#define UIMM_16BIT_MAX (0xffff)
-
-#define TMP_REG1 (SLJIT_NUMBER_OF_REGISTERS + 2)
-#define TMP_REG2 (SLJIT_NUMBER_OF_REGISTERS + 3)
-#define TMP_REG3 (SLJIT_NUMBER_OF_REGISTERS + 4)
-#define ADDR_TMP (SLJIT_NUMBER_OF_REGISTERS + 5)
-#define PIC_ADDR_REG TMP_REG2
-
-static const sljit_u8 reg_map[SLJIT_NUMBER_OF_REGISTERS + 6] = {
-	63, 0, 1, 2, 3, 4, 30, 31, 32, 33, 34, 54, 5, 16, 6, 7
-};
-
-#define SLJIT_LOCALS_REG_mapped 54
-#define TMP_REG1_mapped 5
-#define TMP_REG2_mapped 16
-#define TMP_REG3_mapped 6
-#define ADDR_TMP_mapped 7
-
-/* Flags are keept in volatile registers. */
-#define EQUAL_FLAG 8
-/* And carry flag as well. */
-#define ULESS_FLAG 9
-#define UGREATER_FLAG 10
-#define LESS_FLAG 11
-#define GREATER_FLAG 12
-#define OVERFLOW_FLAG 13
-
-#define ZERO 63
-#define RA 55
-#define TMP_EREG1 14
-#define TMP_EREG2 15
-
-#define LOAD_DATA 0x01
-#define WORD_DATA 0x00
-#define BYTE_DATA 0x02
-#define HALF_DATA 0x04
-#define INT_DATA 0x06
-#define SIGNED_DATA 0x08
-#define DOUBLE_DATA 0x10
-
-/* Separates integer and floating point registers */
-#define GPR_REG 0xf
-
-#define MEM_MASK 0x1f
-
-#define WRITE_BACK 0x00020
-#define ARG_TEST 0x00040
-#define ALT_KEEP_CACHE 0x00080
-#define CUMULATIVE_OP 0x00100
-#define LOGICAL_OP 0x00200
-#define IMM_OP 0x00400
-#define SRC2_IMM 0x00800
-
-#define UNUSED_DEST 0x01000
-#define REG_DEST 0x02000
-#define REG1_SOURCE 0x04000
-#define REG2_SOURCE 0x08000
-#define SLOW_SRC1 0x10000
-#define SLOW_SRC2 0x20000
-#define SLOW_DEST 0x40000
-
-/* Only these flags are set. UNUSED_DEST is not set when no flags should be set.
- */
-#define CHECK_FLAGS(list) (!(flags & UNUSED_DEST) || (op & GET_FLAGS(~(list))))
-
-SLJIT_API_FUNC_ATTRIBUTE const char *sljit_get_platform_name(void)
-{
-	return "TileGX" SLJIT_CPUINFO;
-}
-
-/* Length of an instruction word */
-typedef sljit_uw sljit_ins;
-
-struct jit_instr {
-	const struct tilegx_opcode* opcode; 
-	tilegx_pipeline pipe;
-	unsigned long input_registers;
-	unsigned long output_registers;
-	int operand_value[4];
-	int line;
-};
-
-/* Opcode Helper Macros */
-#define TILEGX_X_MODE 0
-
-#define X_MODE create_Mode(TILEGX_X_MODE)
-
-#define FNOP_X0 \
-	create_Opcode_X0(RRR_0_OPCODE_X0) | \
-	create_RRROpcodeExtension_X0(UNARY_RRR_0_OPCODE_X0) | \
-	create_UnaryOpcodeExtension_X0(FNOP_UNARY_OPCODE_X0)
-
-#define FNOP_X1 \
-	create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \
-	create_UnaryOpcodeExtension_X1(FNOP_UNARY_OPCODE_X1)
-
-#define NOP \
-	create_Mode(TILEGX_X_MODE) | FNOP_X0 | FNOP_X1
-
-#define ANOP_X0 \
-	create_Opcode_X0(RRR_0_OPCODE_X0) | \
-	create_RRROpcodeExtension_X0(UNARY_RRR_0_OPCODE_X0) | \
-	create_UnaryOpcodeExtension_X0(NOP_UNARY_OPCODE_X0)
-
-#define BPT create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \
-	create_UnaryOpcodeExtension_X1(ILL_UNARY_OPCODE_X1) | \
-	create_Dest_X1(0x1C) | create_SrcA_X1(0x25) | ANOP_X0
-
-#define ADD_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(ADD_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define ADDI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \
-	create_Imm8OpcodeExtension_X1(ADDI_IMM8_OPCODE_X1) | FNOP_X0
-
-#define SUB_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(SUB_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define NOR_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(NOR_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define OR_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(OR_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define AND_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(AND_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define XOR_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(XOR_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define CMOVNEZ_X0 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X0(RRR_0_OPCODE_X0) | \
-	create_RRROpcodeExtension_X0(CMOVNEZ_RRR_0_OPCODE_X0) | FNOP_X1
-
-#define CMOVEQZ_X0 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X0(RRR_0_OPCODE_X0) | \
-	create_RRROpcodeExtension_X0(CMOVEQZ_RRR_0_OPCODE_X0) | FNOP_X1
-
-#define ADDLI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(ADDLI_OPCODE_X1) | FNOP_X0
-
-#define V4INT_L_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(V4INT_L_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define BFEXTU_X0 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X0(BF_OPCODE_X0) | \
-	create_BFOpcodeExtension_X0(BFEXTU_BF_OPCODE_X0) | FNOP_X1
-
-#define BFEXTS_X0 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X0(BF_OPCODE_X0) | \
-	create_BFOpcodeExtension_X0(BFEXTS_BF_OPCODE_X0) | FNOP_X1
-
-#define SHL16INSLI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHL16INSLI_OPCODE_X1) | FNOP_X0
-
-#define ST_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(ST_RRR_0_OPCODE_X1) | create_Dest_X1(0x0) | FNOP_X0
-
-#define LD_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \
-	create_UnaryOpcodeExtension_X1(LD_UNARY_OPCODE_X1) | FNOP_X0
-
-#define JR_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \
-	create_UnaryOpcodeExtension_X1(JR_UNARY_OPCODE_X1) | FNOP_X0
-
-#define JALR_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \
-	create_UnaryOpcodeExtension_X1(JALR_UNARY_OPCODE_X1) | FNOP_X0
-
-#define CLZ_X0 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X0(RRR_0_OPCODE_X0) | \
-	create_RRROpcodeExtension_X0(UNARY_RRR_0_OPCODE_X0) | \
-	create_UnaryOpcodeExtension_X0(CNTLZ_UNARY_OPCODE_X0) | FNOP_X1
-
-#define CMPLTUI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \
-	create_Imm8OpcodeExtension_X1(CMPLTUI_IMM8_OPCODE_X1) | FNOP_X0
-
-#define CMPLTU_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(CMPLTU_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define CMPLTS_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(CMPLTS_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define XORI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \
-	create_Imm8OpcodeExtension_X1(XORI_IMM8_OPCODE_X1) | FNOP_X0
-
-#define ORI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \
-	create_Imm8OpcodeExtension_X1(ORI_IMM8_OPCODE_X1) | FNOP_X0
-
-#define ANDI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \
-	create_Imm8OpcodeExtension_X1(ANDI_IMM8_OPCODE_X1) | FNOP_X0
-
-#define SHLI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHIFT_OPCODE_X1) | \
-	create_ShiftOpcodeExtension_X1(SHLI_SHIFT_OPCODE_X1) | FNOP_X0
-
-#define SHL_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(SHL_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define SHRSI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHIFT_OPCODE_X1) | \
-	create_ShiftOpcodeExtension_X1(SHRSI_SHIFT_OPCODE_X1) | FNOP_X0
-
-#define SHRS_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(SHRS_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define SHRUI_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHIFT_OPCODE_X1) | \
-	create_ShiftOpcodeExtension_X1(SHRUI_SHIFT_OPCODE_X1) | FNOP_X0
-
-#define SHRU_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \
-	create_RRROpcodeExtension_X1(SHRU_RRR_0_OPCODE_X1) | FNOP_X0
-
-#define BEQZ_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(BRANCH_OPCODE_X1) | \
-	create_BrType_X1(BEQZ_BRANCH_OPCODE_X1) | FNOP_X0
-
-#define BNEZ_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(BRANCH_OPCODE_X1) | \
-	create_BrType_X1(BNEZ_BRANCH_OPCODE_X1) | FNOP_X0
-
-#define J_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(JUMP_OPCODE_X1) | \
-	create_JumpOpcodeExtension_X1(J_JUMP_OPCODE_X1) | FNOP_X0
-
-#define JAL_X1 \
-	create_Mode(TILEGX_X_MODE) | create_Opcode_X1(JUMP_OPCODE_X1) | \
-	create_JumpOpcodeExtension_X1(JAL_JUMP_OPCODE_X1) | FNOP_X0
-
-#define DEST_X0(x) create_Dest_X0(x)
-#define SRCA_X0(x) create_SrcA_X0(x)
-#define SRCB_X0(x) create_SrcB_X0(x)
-#define DEST_X1(x) create_Dest_X1(x)
-#define SRCA_X1(x) create_SrcA_X1(x)
-#define SRCB_X1(x) create_SrcB_X1(x)
-#define IMM16_X1(x) create_Imm16_X1(x)
-#define IMM8_X1(x) create_Imm8_X1(x)
-#define BFSTART_X0(x) create_BFStart_X0(x)
-#define BFEND_X0(x) create_BFEnd_X0(x)
-#define SHIFTIMM_X1(x) create_ShAmt_X1(x)
-#define JOFF_X1(x) create_JumpOff_X1(x)
-#define BOFF_X1(x) create_BrOff_X1(x)
-
-static const tilegx_mnemonic data_transfer_insts[16] = {
-	/* u w s */ TILEGX_OPC_ST   /* st */,
-	/* u w l */ TILEGX_OPC_LD   /* ld */,
-	/* u b s */ TILEGX_OPC_ST1  /* st1 */,
-	/* u b l */ TILEGX_OPC_LD1U /* ld1u */,
-	/* u h s */ TILEGX_OPC_ST2  /* st2 */,
-	/* u h l */ TILEGX_OPC_LD2U /* ld2u */,
-	/* u i s */ TILEGX_OPC_ST4  /* st4 */,
-	/* u i l */ TILEGX_OPC_LD4U /* ld4u */,
-	/* s w s */ TILEGX_OPC_ST   /* st */,
-	/* s w l */ TILEGX_OPC_LD   /* ld */,
-	/* s b s */ TILEGX_OPC_ST1  /* st1 */,
-	/* s b l */ TILEGX_OPC_LD1S /* ld1s */,
-	/* s h s */ TILEGX_OPC_ST2  /* st2 */,
-	/* s h l */ TILEGX_OPC_LD2S /* ld2s */,
-	/* s i s */ TILEGX_OPC_ST4  /* st4 */,
-	/* s i l */ TILEGX_OPC_LD4S /* ld4s */,
-};
-
-#ifdef TILEGX_JIT_DEBUG
-static sljit_s32 push_inst_debug(struct sljit_compiler *compiler, sljit_ins ins, int line)
-{
-	sljit_ins *ptr = (sljit_ins *)ensure_buf(compiler, sizeof(sljit_ins));
-	FAIL_IF(!ptr);
-	*ptr = ins;
-	compiler->size++;
-	printf("|%04d|S0|:\t\t", line);
-	print_insn_tilegx(ptr);
-	return SLJIT_SUCCESS;
-}
-
-static sljit_s32 push_inst_nodebug(struct sljit_compiler *compiler, sljit_ins ins)
-{
-	sljit_ins *ptr = (sljit_ins *)ensure_buf(compiler, sizeof(sljit_ins));
-	FAIL_IF(!ptr);
-	*ptr = ins;
-	compiler->size++;
-	return SLJIT_SUCCESS;
-}
-
-#define push_inst(a, b) push_inst_debug(a, b, __LINE__)
-#else
-static sljit_s32 push_inst(struct sljit_compiler *compiler, sljit_ins ins)
-{
-	sljit_ins *ptr = (sljit_ins *)ensure_buf(compiler, sizeof(sljit_ins));
-	FAIL_IF(!ptr);
-	*ptr = ins;
-	compiler->size++;
-	return SLJIT_SUCCESS;
-}
-#endif
-
-#define BUNDLE_FORMAT_MASK(p0, p1, p2) \
-	((p0) | ((p1) << 8) | ((p2) << 16))
-
-#define BUNDLE_FORMAT(p0, p1, p2) \
-	{ \
-		{ \
-			(tilegx_pipeline)(p0), \
-			(tilegx_pipeline)(p1), \
-			(tilegx_pipeline)(p2) \
-		}, \
-		BUNDLE_FORMAT_MASK(1 << (p0), 1 << (p1), (1 << (p2))) \
-	}
-
-#define NO_PIPELINE TILEGX_NUM_PIPELINE_ENCODINGS
-
-#define tilegx_is_x_pipeline(p) ((int)(p) <= (int)TILEGX_PIPELINE_X1)
-
-#define PI(encoding) \
-	push_inst(compiler, encoding)
-
-#define PB3(opcode, dst, srca, srcb) \
-	push_3_buffer(compiler, opcode, dst, srca, srcb, __LINE__)
-
-#define PB2(opcode, dst, src) \
-	push_2_buffer(compiler, opcode, dst, src, __LINE__)
-
-#define JR(reg) \
-	push_jr_buffer(compiler, TILEGX_OPC_JR, reg, __LINE__)
-
-#define ADD(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_ADD, dst, srca, srcb, __LINE__)
-
-#define SUB(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_SUB, dst, srca, srcb, __LINE__)
-
-#define MUL(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_MULX, dst, srca, srcb, __LINE__)
-
-#define NOR(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_NOR, dst, srca, srcb, __LINE__)
-
-#define OR(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_OR, dst, srca, srcb, __LINE__)
-
-#define XOR(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_XOR, dst, srca, srcb, __LINE__)
-
-#define AND(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_AND, dst, srca, srcb, __LINE__)
-
-#define CLZ(dst, src) \
-	push_2_buffer(compiler, TILEGX_OPC_CLZ, dst, src, __LINE__)
-
-#define SHLI(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_SHLI, dst, srca, srcb, __LINE__)
-
-#define SHRUI(dst, srca, imm) \
-	push_3_buffer(compiler, TILEGX_OPC_SHRUI, dst, srca, imm, __LINE__)
-
-#define XORI(dst, srca, imm) \
-	push_3_buffer(compiler, TILEGX_OPC_XORI, dst, srca, imm, __LINE__)
-
-#define ORI(dst, srca, imm) \
-	push_3_buffer(compiler, TILEGX_OPC_ORI, dst, srca, imm, __LINE__)
-
-#define CMPLTU(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_CMPLTU, dst, srca, srcb, __LINE__)
-
-#define CMPLTS(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_CMPLTS, dst, srca, srcb, __LINE__)
-
-#define CMPLTUI(dst, srca, imm) \
-	push_3_buffer(compiler, TILEGX_OPC_CMPLTUI, dst, srca, imm, __LINE__)
-
-#define CMOVNEZ(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_CMOVNEZ, dst, srca, srcb, __LINE__)
-
-#define CMOVEQZ(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_CMOVEQZ, dst, srca, srcb, __LINE__)
-
-#define ADDLI(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_ADDLI, dst, srca, srcb, __LINE__)
-
-#define SHL16INSLI(dst, srca, srcb) \
-	push_3_buffer(compiler, TILEGX_OPC_SHL16INSLI, dst, srca, srcb, __LINE__)
-
-#define LD_ADD(dst, addr, adjust) \
-	push_3_buffer(compiler, TILEGX_OPC_LD_ADD, dst, addr, adjust, __LINE__)
-
-#define ST_ADD(src, addr, adjust) \
-	push_3_buffer(compiler, TILEGX_OPC_ST_ADD, src, addr, adjust, __LINE__)
-
-#define LD(dst, addr) \
-	push_2_buffer(compiler, TILEGX_OPC_LD, dst, addr, __LINE__)
-
-#define BFEXTU(dst, src, start, end) \
-	push_4_buffer(compiler, TILEGX_OPC_BFEXTU, dst, src, start, end, __LINE__)
-
-#define BFEXTS(dst, src, start, end) \
-	push_4_buffer(compiler, TILEGX_OPC_BFEXTS, dst, src, start, end, __LINE__)
-
-#define ADD_SOLO(dest, srca, srcb) \
-	push_inst(compiler, ADD_X1 | DEST_X1(dest) | SRCA_X1(srca) | SRCB_X1(srcb))
-
-#define ADDI_SOLO(dest, srca, imm) \
-	push_inst(compiler, ADDI_X1 | DEST_X1(dest) | SRCA_X1(srca) | IMM8_X1(imm))
-
-#define ADDLI_SOLO(dest, srca, imm) \
-	push_inst(compiler, ADDLI_X1 | DEST_X1(dest) | SRCA_X1(srca) | IMM16_X1(imm))
-
-#define SHL16INSLI_SOLO(dest, srca, imm) \
-	push_inst(compiler, SHL16INSLI_X1 | DEST_X1(dest) | SRCA_X1(srca) | IMM16_X1(imm))
-
-#define JALR_SOLO(reg) \
-	push_inst(compiler, JALR_X1 | SRCA_X1(reg))
-
-#define JR_SOLO(reg) \
-	push_inst(compiler, JR_X1 | SRCA_X1(reg))
-
-struct Format {
-	/* Mapping of bundle issue slot to assigned pipe. */
-	tilegx_pipeline pipe[TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE];
-
-	/* Mask of pipes used by this bundle. */
-	unsigned int pipe_mask;
-};
-
-const struct Format formats[] =
-{
-	/* In Y format we must always have something in Y2, since it has
-	* no fnop, so this conveys that Y2 must always be used. */
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y0, TILEGX_PIPELINE_Y2, NO_PIPELINE),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y1, TILEGX_PIPELINE_Y2, NO_PIPELINE),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y2, TILEGX_PIPELINE_Y0, NO_PIPELINE),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y2, TILEGX_PIPELINE_Y1, NO_PIPELINE),
-
-	/* Y format has three instructions. */
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y0, TILEGX_PIPELINE_Y1, TILEGX_PIPELINE_Y2),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y0, TILEGX_PIPELINE_Y2, TILEGX_PIPELINE_Y1),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y1, TILEGX_PIPELINE_Y0, TILEGX_PIPELINE_Y2),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y1, TILEGX_PIPELINE_Y2, TILEGX_PIPELINE_Y0),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y2, TILEGX_PIPELINE_Y0, TILEGX_PIPELINE_Y1),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_Y2, TILEGX_PIPELINE_Y1, TILEGX_PIPELINE_Y0),
-
-	/* X format has only two instructions. */
-	BUNDLE_FORMAT(TILEGX_PIPELINE_X0, TILEGX_PIPELINE_X1, NO_PIPELINE),
-	BUNDLE_FORMAT(TILEGX_PIPELINE_X1, TILEGX_PIPELINE_X0, NO_PIPELINE)
-};
-
-
-struct jit_instr inst_buf[TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE];
-unsigned long inst_buf_index;
-
-tilegx_pipeline get_any_valid_pipe(const struct tilegx_opcode* opcode)
-{
-	/* FIXME: tile: we could pregenerate this. */
-	int pipe;
-	for (pipe = 0; ((opcode->pipes & (1 << pipe)) == 0 && pipe < TILEGX_NUM_PIPELINE_ENCODINGS); pipe++)
-		;
-	return (tilegx_pipeline)(pipe);
-}
-
-void insert_nop(tilegx_mnemonic opc, int line)
-{
-	const struct tilegx_opcode* opcode = NULL;
-
-	memmove(&inst_buf[1], &inst_buf[0], inst_buf_index * sizeof inst_buf[0]);
-
-	opcode = &tilegx_opcodes[opc];
-	inst_buf[0].opcode = opcode;
-	inst_buf[0].pipe = get_any_valid_pipe(opcode);
-	inst_buf[0].input_registers = 0;
-	inst_buf[0].output_registers = 0;
-	inst_buf[0].line = line;
-	++inst_buf_index;
-}
-
-const struct Format* compute_format()
-{
-	unsigned int compatible_pipes = BUNDLE_FORMAT_MASK(
-		inst_buf[0].opcode->pipes,
-		inst_buf[1].opcode->pipes,
-		(inst_buf_index == 3 ? inst_buf[2].opcode->pipes : (1 << NO_PIPELINE)));
-
-	const struct Format* match = NULL;
-	const struct Format *b = NULL;
-	unsigned int i;
-	for (i = 0; i < sizeof formats / sizeof formats[0]; i++) {
-		b = &formats[i];
-		if ((b->pipe_mask & compatible_pipes) == b->pipe_mask) {
-			match = b;
-			break;
-		}
-	}
-
-	return match;
-}
-
-sljit_s32 assign_pipes()
-{
-	unsigned long output_registers = 0;
-	unsigned int i = 0;
-
-	if (inst_buf_index == 1) {
-		tilegx_mnemonic opc = inst_buf[0].opcode->can_bundle
-					? TILEGX_OPC_FNOP : TILEGX_OPC_NOP;
-		insert_nop(opc, __LINE__);
-	}
-
-	const struct Format* match = compute_format();
-
-	if (match == NULL)
-		return -1;
-
-	for (i = 0; i < inst_buf_index; i++) {
-
-		if ((i > 0) && ((inst_buf[i].input_registers & output_registers) != 0))
-			return -1;
-
-		if ((i > 0) && ((inst_buf[i].output_registers & output_registers) != 0))
-			return -1;
-
-		/* Don't include Rzero in the match set, to avoid triggering
-		   needlessly on 'prefetch' instrs. */
-
-		output_registers |= inst_buf[i].output_registers & 0xFFFFFFFFFFFFFFL;
-
-		inst_buf[i].pipe = match->pipe[i];
-	}
-
-	/* If only 2 instrs, and in Y-mode, insert a nop. */
-	if (inst_buf_index == 2 && !tilegx_is_x_pipeline(match->pipe[0])) {
-		insert_nop(TILEGX_OPC_FNOP, __LINE__);
-
-		/* Select the yet unassigned pipe. */
-		tilegx_pipeline pipe = (tilegx_pipeline)(((TILEGX_PIPELINE_Y0
-					+ TILEGX_PIPELINE_Y1 + TILEGX_PIPELINE_Y2)
-					- (inst_buf[1].pipe + inst_buf[2].pipe)));
-
-		inst_buf[0].pipe = pipe;
-	}
-
-	return 0;
-}
-
-tilegx_bundle_bits get_bundle_bit(struct jit_instr *inst)
-{
-	int i, val;
-	const struct tilegx_opcode* opcode = inst->opcode;
-	tilegx_bundle_bits bits = opcode->fixed_bit_values[inst->pipe];
-
-	const struct tilegx_operand* operand = NULL;
-	for (i = 0; i < opcode->num_operands; i++) {
-		operand = &tilegx_operands[opcode->operands[inst->pipe][i]];
-		val = inst->operand_value[i];
-
-		bits |= operand->insert(val);
-	}
-
-	return bits;
-}
-
-static sljit_s32 update_buffer(struct sljit_compiler *compiler)
-{
-	int i;
-	int orig_index = inst_buf_index;
-	struct jit_instr inst0 = inst_buf[0];
-	struct jit_instr inst1 = inst_buf[1];
-	struct jit_instr inst2 = inst_buf[2];
-	tilegx_bundle_bits bits = 0;
-
-	/* If the bundle is valid as is, perform the encoding and return 1. */
-	if (assign_pipes() == 0) {
-		for (i = 0; i < inst_buf_index; i++) {
-			bits |= get_bundle_bit(inst_buf + i);
-#ifdef TILEGX_JIT_DEBUG
-			printf("|%04d", inst_buf[i].line);
-#endif
-		}
-#ifdef TILEGX_JIT_DEBUG
-		if (inst_buf_index == 3)
-			printf("|M0|:\t");
-		else
-			printf("|M0|:\t\t");
-		print_insn_tilegx(&bits);
-#endif
-
-		inst_buf_index = 0;
-
-#ifdef TILEGX_JIT_DEBUG
-		return push_inst_nodebug(compiler, bits);
-#else
-		return push_inst(compiler, bits);
-#endif
-	}
-
-	/* If the bundle is invalid, split it in two. First encode the first two
-	   (or possibly 1) instructions, and then the last, separately. Note that
-	   assign_pipes may have re-ordered the instrs (by inserting no-ops in
-	   lower slots) so we need to reset them. */
-
-	inst_buf_index = orig_index - 1;
-	inst_buf[0] = inst0;
-	inst_buf[1] = inst1;
-	inst_buf[2] = inst2;
-	if (assign_pipes() == 0) {
-		for (i = 0; i < inst_buf_index; i++) {
-			bits |= get_bundle_bit(inst_buf + i);
-#ifdef TILEGX_JIT_DEBUG
-			printf("|%04d", inst_buf[i].line);
-#endif
-		}
-
-#ifdef TILEGX_JIT_DEBUG
-		if (inst_buf_index == 3)
-			printf("|M1|:\t");
-		else
-			printf("|M1|:\t\t");
-		print_insn_tilegx(&bits);
-#endif
-
-		if ((orig_index - 1) == 2) {
-			inst_buf[0] = inst2;
-			inst_buf_index = 1;
-		} else if ((orig_index - 1) == 1) {
-			inst_buf[0] = inst1;
-			inst_buf_index = 1;
-		} else
-			SLJIT_UNREACHABLE();
-
-#ifdef TILEGX_JIT_DEBUG
-		return push_inst_nodebug(compiler, bits);
-#else
-		return push_inst(compiler, bits);
-#endif
-	} else {
-		/* We had 3 instrs of which the first 2 can't live in the same bundle.
-		   Split those two. Note that we don't try to then combine the second
-		   and third instr into a single bundle.  First instruction: */
-		inst_buf_index = 1;
-		inst_buf[0] = inst0;
-		inst_buf[1] = inst1;
-		inst_buf[2] = inst2;
-		if (assign_pipes() == 0) {
-			for (i = 0; i < inst_buf_index; i++) {
-				bits |= get_bundle_bit(inst_buf + i);
-#ifdef TILEGX_JIT_DEBUG
-				printf("|%04d", inst_buf[i].line);
-#endif
-			}
-
-#ifdef TILEGX_JIT_DEBUG
-			if (inst_buf_index == 3)
-				printf("|M2|:\t");
-			else
-				printf("|M2|:\t\t");
-			print_insn_tilegx(&bits);
-#endif
-
-			inst_buf[0] = inst1;
-			inst_buf[1] = inst2;
-			inst_buf_index = orig_index - 1;
-#ifdef TILEGX_JIT_DEBUG
-			return push_inst_nodebug(compiler, bits);
-#else
-			return push_inst(compiler, bits);
-#endif
-		} else
-			SLJIT_UNREACHABLE();
-	}
-
-	SLJIT_UNREACHABLE();
-}
-
-static sljit_s32 flush_buffer(struct sljit_compiler *compiler)
-{
-	while (inst_buf_index != 0) {
-		FAIL_IF(update_buffer(compiler));
-	}
-	return SLJIT_SUCCESS;
-}
-
-static sljit_s32 push_4_buffer(struct sljit_compiler *compiler, tilegx_mnemonic opc, int op0, int op1, int op2, int op3, int line)
-{
-	if (inst_buf_index == TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE)
-		FAIL_IF(update_buffer(compiler));
-
-	const struct tilegx_opcode* opcode = &tilegx_opcodes[opc];
-	inst_buf[inst_buf_index].opcode = opcode;
-	inst_buf[inst_buf_index].pipe = get_any_valid_pipe(opcode);
-	inst_buf[inst_buf_index].operand_value[0] = op0;
-	inst_buf[inst_buf_index].operand_value[1] = op1;
-	inst_buf[inst_buf_index].operand_value[2] = op2;
-	inst_buf[inst_buf_index].operand_value[3] = op3;
-	inst_buf[inst_buf_index].input_registers = 1L << op1;
-	inst_buf[inst_buf_index].output_registers = 1L << op0;
-	inst_buf[inst_buf_index].line = line;
-	inst_buf_index++;
-
-	return SLJIT_SUCCESS;
-}
-
-static sljit_s32 push_3_buffer(struct sljit_compiler *compiler, tilegx_mnemonic opc, int op0, int op1, int op2, int line)
-{
-	if (inst_buf_index == TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE)
-		FAIL_IF(update_buffer(compiler));
-
-	const struct tilegx_opcode* opcode = &tilegx_opcodes[opc];
-	inst_buf[inst_buf_index].opcode = opcode;
-	inst_buf[inst_buf_index].pipe = get_any_valid_pipe(opcode);
-	inst_buf[inst_buf_index].operand_value[0] = op0;
-	inst_buf[inst_buf_index].operand_value[1] = op1;
-	inst_buf[inst_buf_index].operand_value[2] = op2;
-	inst_buf[inst_buf_index].line = line;
-
-	switch (opc) {
-	case TILEGX_OPC_ST_ADD:
-		inst_buf[inst_buf_index].input_registers = (1L << op0) | (1L << op1);
-		inst_buf[inst_buf_index].output_registers = 1L << op0;
-		break;
-	case TILEGX_OPC_LD_ADD:
-		inst_buf[inst_buf_index].input_registers = 1L << op1;
-		inst_buf[inst_buf_index].output_registers = (1L << op0) | (1L << op1);
-		break;
-	case TILEGX_OPC_ADD:
-	case TILEGX_OPC_AND:
-	case TILEGX_OPC_SUB:
-	case TILEGX_OPC_MULX:
-	case TILEGX_OPC_OR:
-	case TILEGX_OPC_XOR:
-	case TILEGX_OPC_NOR:
-	case TILEGX_OPC_SHL:
-	case TILEGX_OPC_SHRU:
-	case TILEGX_OPC_SHRS:
-	case TILEGX_OPC_CMPLTU:
-	case TILEGX_OPC_CMPLTS:
-	case TILEGX_OPC_CMOVEQZ:
-	case TILEGX_OPC_CMOVNEZ:
-		inst_buf[inst_buf_index].input_registers = (1L << op1) | (1L << op2);
-		inst_buf[inst_buf_index].output_registers = 1L << op0;
-		break;
-	case TILEGX_OPC_ADDLI:
-	case TILEGX_OPC_XORI:
-	case TILEGX_OPC_ORI:
-	case TILEGX_OPC_SHLI:
-	case TILEGX_OPC_SHRUI:
-	case TILEGX_OPC_SHRSI:
-	case TILEGX_OPC_SHL16INSLI:
-	case TILEGX_OPC_CMPLTUI:
-	case TILEGX_OPC_CMPLTSI:
-		inst_buf[inst_buf_index].input_registers = 1L << op1;
-		inst_buf[inst_buf_index].output_registers = 1L << op0;
-		break;
-	default:
-		printf("unrecoginzed opc: %s\n", opcode->name);
-		SLJIT_UNREACHABLE();
-	}
-
-	inst_buf_index++;
-
-	return SLJIT_SUCCESS;
-}
-
-static sljit_s32 push_2_buffer(struct sljit_compiler *compiler, tilegx_mnemonic opc, int op0, int op1, int line)
-{
-	if (inst_buf_index == TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE)
-		FAIL_IF(update_buffer(compiler));
-
-	const struct tilegx_opcode* opcode = &tilegx_opcodes[opc];
-	inst_buf[inst_buf_index].opcode = opcode;
-	inst_buf[inst_buf_index].pipe = get_any_valid_pipe(opcode);
-	inst_buf[inst_buf_index].operand_value[0] = op0;
-	inst_buf[inst_buf_index].operand_value[1] = op1;
-	inst_buf[inst_buf_index].line = line;
-
-	switch (opc) {
-	case TILEGX_OPC_BEQZ:
-	case TILEGX_OPC_BNEZ:
-		inst_buf[inst_buf_index].input_registers = 1L << op0;
-		break;
-	case TILEGX_OPC_ST:
-	case TILEGX_OPC_ST1:
-	case TILEGX_OPC_ST2:
-	case TILEGX_OPC_ST4:
-		inst_buf[inst_buf_index].input_registers = (1L << op0) | (1L << op1);
-		inst_buf[inst_buf_index].output_registers = 0;
-		break;
-	case TILEGX_OPC_CLZ:
-	case TILEGX_OPC_LD:
-	case TILEGX_OPC_LD1U:
-	case TILEGX_OPC_LD1S:
-	case TILEGX_OPC_LD2U:
-	case TILEGX_OPC_LD2S:
-	case TILEGX_OPC_LD4U:
-	case TILEGX_OPC_LD4S:
-		inst_buf[inst_buf_index].input_registers = 1L << op1;
-		inst_buf[inst_buf_index].output_registers = 1L << op0;
-		break;
-	default:
-		printf("unrecoginzed opc: %s\n", opcode->name);
-		SLJIT_UNREACHABLE();
-	}
-
-	inst_buf_index++;
-
-	return SLJIT_SUCCESS;
-}
-
-static sljit_s32 push_0_buffer(struct sljit_compiler *compiler, tilegx_mnemonic opc, int line)
-{
-	if (inst_buf_index == TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE)
-		FAIL_IF(update_buffer(compiler));
-
-	const struct tilegx_opcode* opcode = &tilegx_opcodes[opc];
-	inst_buf[inst_buf_index].opcode = opcode;
-	inst_buf[inst_buf_index].pipe = get_any_valid_pipe(opcode);
-	inst_buf[inst_buf_index].input_registers = 0;
-	inst_buf[inst_buf_index].output_registers = 0;
-	inst_buf[inst_buf_index].line = line;
-	inst_buf_index++;
-
-	return SLJIT_SUCCESS;
-}
-
-static sljit_s32 push_jr_buffer(struct sljit_compiler *compiler, tilegx_mnemonic opc, int op0, int line)
-{
-	if (inst_buf_index == TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE)
-		FAIL_IF(update_buffer(compiler));
-
-	const struct tilegx_opcode* opcode = &tilegx_opcodes[opc];
-	inst_buf[inst_buf_index].opcode = opcode;
-	inst_buf[inst_buf_index].pipe = get_any_valid_pipe(opcode);
-	inst_buf[inst_buf_index].operand_value[0] = op0;
-	inst_buf[inst_buf_index].input_registers = 1L << op0;
-	inst_buf[inst_buf_index].output_registers = 0;
-	inst_buf[inst_buf_index].line = line;
-	inst_buf_index++;
- 
-	return flush_buffer(compiler);
-}
-
-static SLJIT_INLINE sljit_ins * detect_jump_type(struct sljit_jump *jump, sljit_ins *code_ptr, sljit_ins *code)
-{
-	sljit_sw diff;
-	sljit_uw target_addr;
-	sljit_ins *inst;
-
-	if (jump->flags & SLJIT_REWRITABLE_JUMP)
-		return code_ptr;
-
-	if (jump->flags & JUMP_ADDR)
-		target_addr = jump->u.target;
-	else {
-		SLJIT_ASSERT(jump->flags & JUMP_LABEL);
-		target_addr = (sljit_uw)(code + jump->u.label->size);
-	}
-
-	inst = (sljit_ins *)jump->addr;
-	if (jump->flags & IS_COND)
-		inst--;
-
-	diff = ((sljit_sw) target_addr - (sljit_sw) inst) >> 3;
-	if (diff <= SIMM_17BIT_MAX && diff >= SIMM_17BIT_MIN) {
-		jump->flags |= PATCH_B;
-
-		if (!(jump->flags & IS_COND)) {
-			if (jump->flags & IS_JAL) {
-				jump->flags &= ~(PATCH_B);
-				jump->flags |= PATCH_J;
-				inst[0] = JAL_X1;
-
-#ifdef TILEGX_JIT_DEBUG
-				printf("[runtime relocate]%04d:\t", __LINE__);
-				print_insn_tilegx(inst);
-#endif
-			} else {
-				inst[0] = BEQZ_X1 | SRCA_X1(ZERO);
-
-#ifdef TILEGX_JIT_DEBUG
-				printf("[runtime relocate]%04d:\t", __LINE__);
-				print_insn_tilegx(inst);
-#endif
-			}
-
-			return inst;
-		}
-
-		inst[0] = inst[0] ^ (0x7L << 55);
-
-#ifdef TILEGX_JIT_DEBUG
-		printf("[runtime relocate]%04d:\t", __LINE__);
-		print_insn_tilegx(inst);
-#endif
-		jump->addr -= sizeof(sljit_ins);
-		return inst;
-	}
-
-	if (jump->flags & IS_COND) {
-		if ((target_addr & ~0x3FFFFFFFL) == ((jump->addr + sizeof(sljit_ins)) & ~0x3FFFFFFFL)) {
-			jump->flags |= PATCH_J;
-			inst[0] = (inst[0] & ~(BOFF_X1(-1))) | BOFF_X1(2);
-			inst[1] = J_X1;
-			return inst + 1;
-		}
-
-		return code_ptr;
-	}
-
-	if ((target_addr & ~0x3FFFFFFFL) == ((jump->addr + sizeof(sljit_ins)) & ~0x3FFFFFFFL)) {
-		jump->flags |= PATCH_J;
-
-		if (jump->flags & IS_JAL) {
-			inst[0] = JAL_X1;
-
-#ifdef TILEGX_JIT_DEBUG
-			printf("[runtime relocate]%04d:\t", __LINE__);
-			print_insn_tilegx(inst);
-#endif
-
-		} else {
-			inst[0] = J_X1;
-
-#ifdef TILEGX_JIT_DEBUG
-			printf("[runtime relocate]%04d:\t", __LINE__);
-			print_insn_tilegx(inst);
-#endif
-		}
-
-		return inst;
-	}
-
-	return code_ptr;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE void * sljit_generate_code(struct sljit_compiler *compiler)
-{
-	struct sljit_memory_fragment *buf;
-	sljit_ins *code;
-	sljit_ins *code_ptr;
-	sljit_ins *buf_ptr;
-	sljit_ins *buf_end;
-	sljit_uw word_count;
-	sljit_uw addr;
-
-	struct sljit_label *label;
-	struct sljit_jump *jump;
-	struct sljit_const *const_;
-
-	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_generate_code(compiler));
-	reverse_buf(compiler);
-
-	code = (sljit_ins *)SLJIT_MALLOC_EXEC(compiler->size * sizeof(sljit_ins));
-	PTR_FAIL_WITH_EXEC_IF(code);
-	buf = compiler->buf;
-
-	code_ptr = code;
-	word_count = 0;
-	label = compiler->labels;
-	jump = compiler->jumps;
-	const_ = compiler->consts;
-	do {
-		buf_ptr = (sljit_ins *)buf->memory;
-		buf_end = buf_ptr + (buf->used_size >> 3);
-		do {
-			*code_ptr = *buf_ptr++;
-			SLJIT_ASSERT(!label || label->size >= word_count);
-			SLJIT_ASSERT(!jump || jump->addr >= word_count);
-			SLJIT_ASSERT(!const_ || const_->addr >= word_count);
-			/* These structures are ordered by their address. */
-			if (label && label->size == word_count) {
-				/* Just recording the address. */
-				label->addr = (sljit_uw) code_ptr;
-				label->size = code_ptr - code;
-				label = label->next;
-			}
-
-			if (jump && jump->addr == word_count) {
-				if (jump->flags & IS_JAL)
-					jump->addr = (sljit_uw)(code_ptr - 4);
-				else
-					jump->addr = (sljit_uw)(code_ptr - 3);
-
-				code_ptr = detect_jump_type(jump, code_ptr, code);
-				jump = jump->next;
-			}
-
-			if (const_ && const_->addr == word_count) {
-				/* Just recording the address. */
-				const_->addr = (sljit_uw) code_ptr;
-				const_ = const_->next;
-			}
-
-			code_ptr++;
-			word_count++;
-		} while (buf_ptr < buf_end);
-
-		buf = buf->next;
-	} while (buf);
-
-	if (label && label->size == word_count) {
-		label->addr = (sljit_uw) code_ptr;
-		label->size = code_ptr - code;
-		label = label->next;
-	}
-
-	SLJIT_ASSERT(!label);
-	SLJIT_ASSERT(!jump);
-	SLJIT_ASSERT(!const_);
-	SLJIT_ASSERT(code_ptr - code <= (sljit_sw)compiler->size);
-
-	jump = compiler->jumps;
-	while (jump) {
-		do {
-			addr = (jump->flags & JUMP_LABEL) ? jump->u.label->addr : jump->u.target;
-			buf_ptr = (sljit_ins *)jump->addr;
-
-			if (jump->flags & PATCH_B) {
-				addr = (sljit_sw)(addr - (jump->addr)) >> 3;
-				SLJIT_ASSERT((sljit_sw) addr <= SIMM_17BIT_MAX && (sljit_sw) addr >= SIMM_17BIT_MIN);
-				buf_ptr[0] = (buf_ptr[0] & ~(BOFF_X1(-1))) | BOFF_X1(addr);
-
-#ifdef TILEGX_JIT_DEBUG
-				printf("[runtime relocate]%04d:\t", __LINE__);
-				print_insn_tilegx(buf_ptr);
-#endif
-				break;
-			}
-
-			if (jump->flags & PATCH_J) {
-				SLJIT_ASSERT((addr & ~0x3FFFFFFFL) == ((jump->addr + sizeof(sljit_ins)) & ~0x3FFFFFFFL));
-				addr = (sljit_sw)(addr - (jump->addr)) >> 3;
-				buf_ptr[0] = (buf_ptr[0] & ~(JOFF_X1(-1))) | JOFF_X1(addr);
-
-#ifdef TILEGX_JIT_DEBUG
-				printf("[runtime relocate]%04d:\t", __LINE__);
-				print_insn_tilegx(buf_ptr);
-#endif
-				break;
-			}
-
-			SLJIT_ASSERT(!(jump->flags & IS_JAL));
-
-			/* Set the fields of immediate loads. */
-			buf_ptr[0] = (buf_ptr[0] & ~(0xFFFFL << 43)) | (((addr >> 32) & 0xFFFFL) << 43);
-			buf_ptr[1] = (buf_ptr[1] & ~(0xFFFFL << 43)) | (((addr >> 16) & 0xFFFFL) << 43);
-			buf_ptr[2] = (buf_ptr[2] & ~(0xFFFFL << 43)) | ((addr & 0xFFFFL) << 43);
-		} while (0);
-
-		jump = jump->next;
-	}
-
-	compiler->error = SLJIT_ERR_COMPILED;
-	compiler->executable_size = (code_ptr - code) * sizeof(sljit_ins);
-	SLJIT_CACHE_FLUSH(code, code_ptr);
-	return code;
-}
-
-static sljit_s32 load_immediate(struct sljit_compiler *compiler, sljit_s32 dst_ar, sljit_sw imm)
-{
-
-	if (imm <= SIMM_16BIT_MAX && imm >= SIMM_16BIT_MIN)
-		return ADDLI(dst_ar, ZERO, imm);
-
-	if (imm <= SIMM_32BIT_MAX && imm >= SIMM_32BIT_MIN) {
-		FAIL_IF(ADDLI(dst_ar, ZERO, imm >> 16));
-		return SHL16INSLI(dst_ar, dst_ar, imm);
-	}
-
-	if (imm <= SIMM_48BIT_MAX && imm >= SIMM_48BIT_MIN) {
-		FAIL_IF(ADDLI(dst_ar, ZERO, imm >> 32));
-		FAIL_IF(SHL16INSLI(dst_ar, dst_ar, imm >> 16));
-		return SHL16INSLI(dst_ar, dst_ar, imm);
-	}
-
-	FAIL_IF(ADDLI(dst_ar, ZERO, imm >> 48));
-	FAIL_IF(SHL16INSLI(dst_ar, dst_ar, imm >> 32));
-	FAIL_IF(SHL16INSLI(dst_ar, dst_ar, imm >> 16));
-	return SHL16INSLI(dst_ar, dst_ar, imm);
-}
-
-static sljit_s32 emit_const(struct sljit_compiler *compiler, sljit_s32 dst_ar, sljit_sw imm, int flush)
-{
-	/* Should *not* be optimized as load_immediate, as pcre relocation
-	   mechanism will match this fixed 4-instruction pattern. */
-	if (flush) {
-		FAIL_IF(ADDLI_SOLO(dst_ar, ZERO, imm >> 32));
-		FAIL_IF(SHL16INSLI_SOLO(dst_ar, dst_ar, imm >> 16));
-		return SHL16INSLI_SOLO(dst_ar, dst_ar, imm);
-	}
-
-	FAIL_IF(ADDLI(dst_ar, ZERO, imm >> 32));
-	FAIL_IF(SHL16INSLI(dst_ar, dst_ar, imm >> 16));
-	return SHL16INSLI(dst_ar, dst_ar, imm);
-}
-
-static sljit_s32 emit_const_64(struct sljit_compiler *compiler, sljit_s32 dst_ar, sljit_sw imm, int flush)
-{
-	/* Should *not* be optimized as load_immediate, as pcre relocation
-	   mechanism will match this fixed 4-instruction pattern. */
-	if (flush) {
-		FAIL_IF(ADDLI_SOLO(reg_map[dst_ar], ZERO, imm >> 48));
-		FAIL_IF(SHL16INSLI_SOLO(reg_map[dst_ar], reg_map[dst_ar], imm >> 32));
-		FAIL_IF(SHL16INSLI_SOLO(reg_map[dst_ar], reg_map[dst_ar], imm >> 16));
-		return SHL16INSLI_SOLO(reg_map[dst_ar], reg_map[dst_ar], imm);
-	}
-
-	FAIL_IF(ADDLI(reg_map[dst_ar], ZERO, imm >> 48));
-	FAIL_IF(SHL16INSLI(reg_map[dst_ar], reg_map[dst_ar], imm >> 32));
-	FAIL_IF(SHL16INSLI(reg_map[dst_ar], reg_map[dst_ar], imm >> 16));
-	return SHL16INSLI(reg_map[dst_ar], reg_map[dst_ar], imm);
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_enter(struct sljit_compiler *compiler,
-	sljit_s32 options, sljit_s32 args, sljit_s32 scratches, sljit_s32 saveds,
-	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
-{
-	sljit_ins base;
-	sljit_s32 i, tmp;
- 
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_enter(compiler, options, args, scratches, saveds, fscratches, fsaveds, local_size));
-	set_emit_enter(compiler, options, args, scratches, saveds, fscratches, fsaveds, local_size);
-
-	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
-	local_size = (local_size + 7) & ~7;
-	compiler->local_size = local_size;
-
-	if (local_size <= SIMM_16BIT_MAX) {
-		/* Frequent case. */
-		FAIL_IF(ADDLI(SLJIT_LOCALS_REG_mapped, SLJIT_LOCALS_REG_mapped, -local_size));
-		base = SLJIT_LOCALS_REG_mapped;
-	} else {
-		FAIL_IF(load_immediate(compiler, TMP_REG1_mapped, local_size));
-		FAIL_IF(ADD(TMP_REG2_mapped, SLJIT_LOCALS_REG_mapped, ZERO));
-		FAIL_IF(SUB(SLJIT_LOCALS_REG_mapped, SLJIT_LOCALS_REG_mapped, TMP_REG1_mapped));
-		base = TMP_REG2_mapped;
-		local_size = 0;
-	}
-
-	/* Save the return address. */
-	FAIL_IF(ADDLI(ADDR_TMP_mapped, base, local_size - 8));
-	FAIL_IF(ST_ADD(ADDR_TMP_mapped, RA, -8));
-
-	/* Save the S registers. */
-	tmp = saveds < SLJIT_NUMBER_OF_SAVED_REGISTERS ? (SLJIT_S0 + 1 - saveds) : SLJIT_FIRST_SAVED_REG;
-	for (i = SLJIT_S0; i >= tmp; i--) {
-		FAIL_IF(ST_ADD(ADDR_TMP_mapped, reg_map[i], -8));
-	}
-
-	/* Save the R registers that need to be reserved. */
-	for (i = scratches; i >= SLJIT_FIRST_SAVED_REG; i--) {
-		FAIL_IF(ST_ADD(ADDR_TMP_mapped, reg_map[i], -8));
-	}
-
-	/* Move the arguments to S registers. */
-	for (i = 0; i < args; i++) {
-		FAIL_IF(ADD(reg_map[SLJIT_S0 - i], i, ZERO));
-	}
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_set_context(struct sljit_compiler *compiler,
-	sljit_s32 options, sljit_s32 args, sljit_s32 scratches, sljit_s32 saveds,
-	sljit_s32 fscratches, sljit_s32 fsaveds, sljit_s32 local_size)
-{
-	CHECK_ERROR();
-	CHECK(check_sljit_set_context(compiler, options, args, scratches, saveds, fscratches, fsaveds, local_size));
-	set_set_context(compiler, options, args, scratches, saveds, fscratches, fsaveds, local_size);
-
-	local_size += GET_SAVED_REGISTERS_SIZE(scratches, saveds, 1);
-	compiler->local_size = (local_size + 7) & ~7;
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_return(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 src, sljit_sw srcw)
-{
-	sljit_s32 local_size;
-	sljit_ins base;
-	sljit_s32 i, tmp;
-	sljit_s32 saveds;
-
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_return(compiler, op, src, srcw));
-
-	FAIL_IF(emit_mov_before_return(compiler, op, src, srcw));
-
-	local_size = compiler->local_size;
-	if (local_size <= SIMM_16BIT_MAX)
-		base = SLJIT_LOCALS_REG_mapped;
-	else {
-		FAIL_IF(load_immediate(compiler, TMP_REG1_mapped, local_size));
-		FAIL_IF(ADD(TMP_REG1_mapped, SLJIT_LOCALS_REG_mapped, TMP_REG1_mapped));
-		base = TMP_REG1_mapped;
-		local_size = 0;
-	}
-
-	/* Restore the return address. */
-	FAIL_IF(ADDLI(ADDR_TMP_mapped, base, local_size - 8));
-	FAIL_IF(LD_ADD(RA, ADDR_TMP_mapped, -8));
-
-	/* Restore the S registers. */
-	saveds = compiler->saveds;
-	tmp = saveds < SLJIT_NUMBER_OF_SAVED_REGISTERS ? (SLJIT_S0 + 1 - saveds) : SLJIT_FIRST_SAVED_REG;
-	for (i = SLJIT_S0; i >= tmp; i--) {
-		FAIL_IF(LD_ADD(reg_map[i], ADDR_TMP_mapped, -8));
-	}
-
-	/* Restore the R registers that need to be reserved. */
-	for (i = compiler->scratches; i >= SLJIT_FIRST_SAVED_REG; i--) {
-		FAIL_IF(LD_ADD(reg_map[i], ADDR_TMP_mapped, -8));
-	}
-
-	if (compiler->local_size <= SIMM_16BIT_MAX)
-		FAIL_IF(ADDLI(SLJIT_LOCALS_REG_mapped, SLJIT_LOCALS_REG_mapped, compiler->local_size));
-	else
-		FAIL_IF(ADD(SLJIT_LOCALS_REG_mapped, TMP_REG1_mapped, ZERO));
-
-	return JR(RA);
-}
-
-/* reg_ar is an absoulute register! */
-
-/* Can perform an operation using at most 1 instruction. */
-static sljit_s32 getput_arg_fast(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg_ar, sljit_s32 arg, sljit_sw argw)
-{
-	SLJIT_ASSERT(arg & SLJIT_MEM);
-
-	if ((!(flags & WRITE_BACK) || !(arg & REG_MASK))
-			&& !(arg & OFFS_REG_MASK) && argw <= SIMM_16BIT_MAX && argw >= SIMM_16BIT_MIN) {
-		/* Works for both absoulte and relative addresses. */
-		if (SLJIT_UNLIKELY(flags & ARG_TEST))
-			return 1;
-
-		FAIL_IF(ADDLI(ADDR_TMP_mapped, reg_map[arg & REG_MASK], argw));
-
-		if (flags & LOAD_DATA)
-			FAIL_IF(PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, ADDR_TMP_mapped));
-		else
-			FAIL_IF(PB2(data_transfer_insts[flags & MEM_MASK], ADDR_TMP_mapped, reg_ar));
-
-		return -1;
-	}
-
-	return 0;
-}
-
-/* See getput_arg below.
-   Note: can_cache is called only for binary operators. Those
-   operators always uses word arguments without write back. */
-static sljit_s32 can_cache(sljit_s32 arg, sljit_sw argw, sljit_s32 next_arg, sljit_sw next_argw)
-{
-	SLJIT_ASSERT((arg & SLJIT_MEM) && (next_arg & SLJIT_MEM));
-
-	/* Simple operation except for updates. */
-	if (arg & OFFS_REG_MASK) {
-		argw &= 0x3;
-		next_argw &= 0x3;
-		if (argw && argw == next_argw
-				&& (arg == next_arg || (arg & OFFS_REG_MASK) == (next_arg & OFFS_REG_MASK)))
-			return 1;
-		return 0;
-	}
-
-	if (arg == next_arg) {
-		if (((next_argw - argw) <= SIMM_16BIT_MAX
-				&& (next_argw - argw) >= SIMM_16BIT_MIN))
-			return 1;
-
-		return 0;
-	}
-
-	return 0;
-}
-
-/* Emit the necessary instructions. See can_cache above. */
-static sljit_s32 getput_arg(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg_ar, sljit_s32 arg, sljit_sw argw, sljit_s32 next_arg, sljit_sw next_argw)
-{
-	sljit_s32 tmp_ar, base;
-
-	SLJIT_ASSERT(arg & SLJIT_MEM);
-	if (!(next_arg & SLJIT_MEM)) {
-		next_arg = 0;
-		next_argw = 0;
-	}
-
-	if ((flags & MEM_MASK) <= GPR_REG && (flags & LOAD_DATA))
-		tmp_ar = reg_ar;
-	else
-		tmp_ar = TMP_REG1_mapped;
-
-	base = arg & REG_MASK;
-
-	if (SLJIT_UNLIKELY(arg & OFFS_REG_MASK)) {
-		argw &= 0x3;
-
-		if ((flags & WRITE_BACK) && reg_ar == reg_map[base]) {
-			SLJIT_ASSERT(!(flags & LOAD_DATA) && reg_map[TMP_REG1] != reg_ar);
-			FAIL_IF(ADD(TMP_REG1_mapped, reg_ar, ZERO));
-			reg_ar = TMP_REG1_mapped;
-		}
-
-		/* Using the cache. */
-		if (argw == compiler->cache_argw) {
-			if (!(flags & WRITE_BACK)) {
-				if (arg == compiler->cache_arg) {
-					if (flags & LOAD_DATA)
-						return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, TMP_REG3_mapped);
-					else
-						return PB2(data_transfer_insts[flags & MEM_MASK], TMP_REG3_mapped, reg_ar);
-				}
-
-				if ((SLJIT_MEM | (arg & OFFS_REG_MASK)) == compiler->cache_arg) {
-					if (arg == next_arg && argw == (next_argw & 0x3)) {
-						compiler->cache_arg = arg;
-						compiler->cache_argw = argw;
-						FAIL_IF(ADD(TMP_REG3_mapped, reg_map[base], TMP_REG3_mapped));
-						if (flags & LOAD_DATA)
-							return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, TMP_REG3_mapped);
-						else
-							return PB2(data_transfer_insts[flags & MEM_MASK], TMP_REG3_mapped, reg_ar);
-					}
-
-					FAIL_IF(ADD(tmp_ar, reg_map[base], TMP_REG3_mapped));
-					if (flags & LOAD_DATA)
-						return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, tmp_ar);
-					else
-						return PB2(data_transfer_insts[flags & MEM_MASK], tmp_ar, reg_ar);
-				}
-			} else {
-				if ((SLJIT_MEM | (arg & OFFS_REG_MASK)) == compiler->cache_arg) {
-					FAIL_IF(ADD(reg_map[base], reg_map[base], TMP_REG3_mapped));
-					if (flags & LOAD_DATA)
-						return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, reg_map[base]);
-					else
-						return PB2(data_transfer_insts[flags & MEM_MASK], reg_map[base], reg_ar);
-				}
-			}
-		}
-
-		if (SLJIT_UNLIKELY(argw)) {
-			compiler->cache_arg = SLJIT_MEM | (arg & OFFS_REG_MASK);
-			compiler->cache_argw = argw;
-			FAIL_IF(SHLI(TMP_REG3_mapped, reg_map[OFFS_REG(arg)], argw));
-		}
-
-		if (!(flags & WRITE_BACK)) {
-			if (arg == next_arg && argw == (next_argw & 0x3)) {
-				compiler->cache_arg = arg;
-				compiler->cache_argw = argw;
-				FAIL_IF(ADD(TMP_REG3_mapped, reg_map[base], reg_map[!argw ? OFFS_REG(arg) : TMP_REG3]));
-				tmp_ar = TMP_REG3_mapped;
-			} else
-				FAIL_IF(ADD(tmp_ar, reg_map[base], reg_map[!argw ? OFFS_REG(arg) : TMP_REG3]));
-
-			if (flags & LOAD_DATA)
-				return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, tmp_ar);
-			else
-				return PB2(data_transfer_insts[flags & MEM_MASK], tmp_ar, reg_ar);
-		}
-
-		FAIL_IF(ADD(reg_map[base], reg_map[base], reg_map[!argw ? OFFS_REG(arg) : TMP_REG3]));
-
-		if (flags & LOAD_DATA)
-			return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, reg_map[base]);
-		else
-			return PB2(data_transfer_insts[flags & MEM_MASK], reg_map[base], reg_ar);
-	}
-
-	if (SLJIT_UNLIKELY(flags & WRITE_BACK) && base) {
-		/* Update only applies if a base register exists. */
-		if (reg_ar == reg_map[base]) {
-			SLJIT_ASSERT(!(flags & LOAD_DATA) && TMP_REG1_mapped != reg_ar);
-			if (argw <= SIMM_16BIT_MAX && argw >= SIMM_16BIT_MIN) {
-				FAIL_IF(ADDLI(ADDR_TMP_mapped, reg_map[base], argw));
-				if (flags & LOAD_DATA)
-					FAIL_IF(PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, ADDR_TMP_mapped));
-				else
-					FAIL_IF(PB2(data_transfer_insts[flags & MEM_MASK], ADDR_TMP_mapped, reg_ar));
-
-				if (argw)
-					return ADDLI(reg_map[base], reg_map[base], argw);
-
-				return SLJIT_SUCCESS;
-			}
-
-			FAIL_IF(ADD(TMP_REG1_mapped, reg_ar, ZERO));
-			reg_ar = TMP_REG1_mapped;
-		}
-
-		if (argw <= SIMM_16BIT_MAX && argw >= SIMM_16BIT_MIN) {
-			if (argw)
-				FAIL_IF(ADDLI(reg_map[base], reg_map[base], argw));
-		} else {
-			if (compiler->cache_arg == SLJIT_MEM
-					&& argw - compiler->cache_argw <= SIMM_16BIT_MAX
-					&& argw - compiler->cache_argw >= SIMM_16BIT_MIN) {
-				if (argw != compiler->cache_argw) {
-					FAIL_IF(ADD(TMP_REG3_mapped, TMP_REG3_mapped, argw - compiler->cache_argw));
-					compiler->cache_argw = argw;
-				}
-
-				FAIL_IF(ADD(reg_map[base], reg_map[base], TMP_REG3_mapped));
-			} else {
-				compiler->cache_arg = SLJIT_MEM;
-				compiler->cache_argw = argw;
-				FAIL_IF(load_immediate(compiler, TMP_REG3_mapped, argw));
-				FAIL_IF(ADD(reg_map[base], reg_map[base], TMP_REG3_mapped));
-			}
-		}
-
-		if (flags & LOAD_DATA)
-			return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, reg_map[base]);
-		else
-			return PB2(data_transfer_insts[flags & MEM_MASK], reg_map[base], reg_ar);
-	}
-
-	if (compiler->cache_arg == arg
-			&& argw - compiler->cache_argw <= SIMM_16BIT_MAX
-			&& argw - compiler->cache_argw >= SIMM_16BIT_MIN) {
-		if (argw != compiler->cache_argw) {
-			FAIL_IF(ADDLI(TMP_REG3_mapped, TMP_REG3_mapped, argw - compiler->cache_argw));
-			compiler->cache_argw = argw;
-		}
-
-		if (flags & LOAD_DATA)
-			return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, TMP_REG3_mapped);
-		else
-			return PB2(data_transfer_insts[flags & MEM_MASK], TMP_REG3_mapped, reg_ar);
-	}
-
-	if (compiler->cache_arg == SLJIT_MEM
-			&& argw - compiler->cache_argw <= SIMM_16BIT_MAX
-			&& argw - compiler->cache_argw >= SIMM_16BIT_MIN) {
-		if (argw != compiler->cache_argw)
-			FAIL_IF(ADDLI(TMP_REG3_mapped, TMP_REG3_mapped, argw - compiler->cache_argw));
-	} else {
-		compiler->cache_arg = SLJIT_MEM;
-		FAIL_IF(load_immediate(compiler, TMP_REG3_mapped, argw));
-	}
-
-	compiler->cache_argw = argw;
-
-	if (!base) {
-		if (flags & LOAD_DATA)
-			return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, TMP_REG3_mapped);
-		else
-			return PB2(data_transfer_insts[flags & MEM_MASK], TMP_REG3_mapped, reg_ar);
-	}
-
-	if (arg == next_arg
-			&& next_argw - argw <= SIMM_16BIT_MAX
-			&& next_argw - argw >= SIMM_16BIT_MIN) {
-		compiler->cache_arg = arg;
-		FAIL_IF(ADD(TMP_REG3_mapped, TMP_REG3_mapped, reg_map[base]));
-		if (flags & LOAD_DATA)
-			return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, TMP_REG3_mapped);
-		else
-			return PB2(data_transfer_insts[flags & MEM_MASK], TMP_REG3_mapped, reg_ar);
-	}
-
-	FAIL_IF(ADD(tmp_ar, TMP_REG3_mapped, reg_map[base]));
-
-	if (flags & LOAD_DATA)
-		return PB2(data_transfer_insts[flags & MEM_MASK], reg_ar, tmp_ar);
-	else
-		return PB2(data_transfer_insts[flags & MEM_MASK], tmp_ar, reg_ar);
-}
-
-static SLJIT_INLINE sljit_s32 emit_op_mem(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg_ar, sljit_s32 arg, sljit_sw argw)
-{
-	if (getput_arg_fast(compiler, flags, reg_ar, arg, argw))
-		return compiler->error;
-
-	compiler->cache_arg = 0;
-	compiler->cache_argw = 0;
-	return getput_arg(compiler, flags, reg_ar, arg, argw, 0, 0);
-}
-
-static SLJIT_INLINE sljit_s32 emit_op_mem2(struct sljit_compiler *compiler, sljit_s32 flags, sljit_s32 reg, sljit_s32 arg1, sljit_sw arg1w, sljit_s32 arg2, sljit_sw arg2w)
-{
-	if (getput_arg_fast(compiler, flags, reg, arg1, arg1w))
-		return compiler->error;
-	return getput_arg(compiler, flags, reg, arg1, arg1w, arg2, arg2w);
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fast_enter(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw)
-{
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_fast_enter(compiler, dst, dstw));
-	ADJUST_LOCAL_OFFSET(dst, dstw);
-
-	/* For UNUSED dst. Uncommon, but possible. */
-	if (dst == SLJIT_UNUSED)
-		return SLJIT_SUCCESS;
-
-	if (FAST_IS_REG(dst))
-		return ADD(reg_map[dst], RA, ZERO);
-
-	/* Memory. */
-	return emit_op_mem(compiler, WORD_DATA, RA, dst, dstw);
-}
-
-static SLJIT_INLINE sljit_s32 emit_single_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags, sljit_s32 dst, sljit_s32 src1, sljit_sw src2)
-{
-	sljit_s32 overflow_ra = 0;
-
-	switch (GET_OPCODE(op)) {
-	case SLJIT_MOV:
-	case SLJIT_MOV_P:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if (dst != src2)
-			return ADD(reg_map[dst], reg_map[src2], ZERO);
-		return SLJIT_SUCCESS;
-
-	case SLJIT_MOV_U32:
-	case SLJIT_MOV_S32:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
-			if (op == SLJIT_MOV_S32)
-				return BFEXTS(reg_map[dst], reg_map[src2], 0, 31);
-
-			return BFEXTU(reg_map[dst], reg_map[src2], 0, 31);
-		} else if (dst != src2) {
-			SLJIT_ASSERT(src2 == 0);
-			return ADD(reg_map[dst], reg_map[src2], ZERO);
-		}
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_MOV_U8:
-	case SLJIT_MOV_S8:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
-			if (op == SLJIT_MOV_S8)
-				return BFEXTS(reg_map[dst], reg_map[src2], 0, 7);
-
-			return BFEXTU(reg_map[dst], reg_map[src2], 0, 7);
-		} else if (dst != src2) {
-			SLJIT_ASSERT(src2 == 0);
-			return ADD(reg_map[dst], reg_map[src2], ZERO);
-		}
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_MOV_U16:
-	case SLJIT_MOV_S16:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if ((flags & (REG_DEST | REG2_SOURCE)) == (REG_DEST | REG2_SOURCE)) {
-			if (op == SLJIT_MOV_S16)
-				return BFEXTS(reg_map[dst], reg_map[src2], 0, 15);
-
-			return BFEXTU(reg_map[dst], reg_map[src2], 0, 15);
-		} else if (dst != src2) {
-			SLJIT_ASSERT(src2 == 0);
-			return ADD(reg_map[dst], reg_map[src2], ZERO);
-		}
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_NOT:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if (op & SLJIT_SET_E)
-			FAIL_IF(NOR(EQUAL_FLAG, reg_map[src2], reg_map[src2]));
-		if (CHECK_FLAGS(SLJIT_SET_E))
-			FAIL_IF(NOR(reg_map[dst], reg_map[src2], reg_map[src2]));
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_CLZ:
-		SLJIT_ASSERT(src1 == TMP_REG1 && !(flags & SRC2_IMM));
-		if (op & SLJIT_SET_E)
-			FAIL_IF(CLZ(EQUAL_FLAG, reg_map[src2]));
-		if (CHECK_FLAGS(SLJIT_SET_E))
-			FAIL_IF(CLZ(reg_map[dst], reg_map[src2]));
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_ADD:
-		if (flags & SRC2_IMM) {
-			if (op & SLJIT_SET_O) {
-				FAIL_IF(SHRUI(TMP_EREG1, reg_map[src1], 63));
-				if (src2 < 0)
-					FAIL_IF(XORI(TMP_EREG1, TMP_EREG1, 1));
-			}
-
-			if (op & SLJIT_SET_E)
-				FAIL_IF(ADDLI(EQUAL_FLAG, reg_map[src1], src2));
-
-			if (op & SLJIT_SET_C) {
-				if (src2 >= 0)
-					FAIL_IF(ORI(ULESS_FLAG ,reg_map[src1], src2));
-				else {
-					FAIL_IF(ADDLI(ULESS_FLAG ,ZERO, src2));
-					FAIL_IF(OR(ULESS_FLAG,reg_map[src1],ULESS_FLAG));
-				}
-			}
-
-			/* dst may be the same as src1 or src2. */
-			if (CHECK_FLAGS(SLJIT_SET_E))
-				FAIL_IF(ADDLI(reg_map[dst], reg_map[src1], src2));
-
-			if (op & SLJIT_SET_O) {
-				FAIL_IF(SHRUI(OVERFLOW_FLAG, reg_map[dst], 63));
-
-				if (src2 < 0)
-					FAIL_IF(XORI(OVERFLOW_FLAG, OVERFLOW_FLAG, 1));
-			}
-		} else {
-			if (op & SLJIT_SET_O) {
-				FAIL_IF(XOR(TMP_EREG1, reg_map[src1], reg_map[src2]));
-				FAIL_IF(SHRUI(TMP_EREG1, TMP_EREG1, 63));
-
-				if (src1 != dst)
-					overflow_ra = reg_map[src1];
-				else if (src2 != dst)
-					overflow_ra = reg_map[src2];
-				else {
-					/* Rare ocasion. */
-					FAIL_IF(ADD(TMP_EREG2, reg_map[src1], ZERO));
-					overflow_ra = TMP_EREG2;
-				}
-			}
-
-			if (op & SLJIT_SET_E)
-				FAIL_IF(ADD(EQUAL_FLAG ,reg_map[src1], reg_map[src2]));
-
-			if (op & SLJIT_SET_C)
-				FAIL_IF(OR(ULESS_FLAG,reg_map[src1], reg_map[src2]));
-
-			/* dst may be the same as src1 or src2. */
-			if (CHECK_FLAGS(SLJIT_SET_E))
-				FAIL_IF(ADD(reg_map[dst],reg_map[src1], reg_map[src2]));
-
-			if (op & SLJIT_SET_O) {
-				FAIL_IF(XOR(OVERFLOW_FLAG,reg_map[dst], overflow_ra));
-				FAIL_IF(SHRUI(OVERFLOW_FLAG, OVERFLOW_FLAG, 63));
-			}
-		}
-
-		/* a + b >= a | b (otherwise, the carry should be set to 1). */
-		if (op & SLJIT_SET_C)
-			FAIL_IF(CMPLTU(ULESS_FLAG ,reg_map[dst] ,ULESS_FLAG));
-
-		if (op & SLJIT_SET_O)
-			return CMOVNEZ(OVERFLOW_FLAG, TMP_EREG1, ZERO);
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_ADDC:
-		if (flags & SRC2_IMM) {
-			if (op & SLJIT_SET_C) {
-				if (src2 >= 0)
-					FAIL_IF(ORI(TMP_EREG1, reg_map[src1], src2));
-				else {
-					FAIL_IF(ADDLI(TMP_EREG1, ZERO, src2));
-					FAIL_IF(OR(TMP_EREG1, reg_map[src1], TMP_EREG1));
-				}
-			}
-
-			FAIL_IF(ADDLI(reg_map[dst], reg_map[src1], src2));
-
-		} else {
-			if (op & SLJIT_SET_C)
-				FAIL_IF(OR(TMP_EREG1, reg_map[src1], reg_map[src2]));
-
-			/* dst may be the same as src1 or src2. */
-			FAIL_IF(ADD(reg_map[dst], reg_map[src1], reg_map[src2]));
-		}
-
-		if (op & SLJIT_SET_C)
-			FAIL_IF(CMPLTU(TMP_EREG1, reg_map[dst], TMP_EREG1));
-
-		FAIL_IF(ADD(reg_map[dst], reg_map[dst], ULESS_FLAG));
-
-		if (!(op & SLJIT_SET_C))
-			return SLJIT_SUCCESS;
-
-		/* Set TMP_EREG2 (dst == 0) && (ULESS_FLAG == 1). */
-		FAIL_IF(CMPLTUI(TMP_EREG2, reg_map[dst], 1));
-		FAIL_IF(AND(TMP_EREG2, TMP_EREG2, ULESS_FLAG));
-		/* Set carry flag. */
-		return OR(ULESS_FLAG, TMP_EREG2, TMP_EREG1);
-
-	case SLJIT_SUB:
-		if ((flags & SRC2_IMM) && ((op & (SLJIT_SET_U | SLJIT_SET_S)) || src2 == SIMM_16BIT_MIN)) {
-			FAIL_IF(ADDLI(TMP_REG2_mapped, ZERO, src2));
-			src2 = TMP_REG2;
-			flags &= ~SRC2_IMM;
-		}
-
-		if (flags & SRC2_IMM) {
-			if (op & SLJIT_SET_O) {
-				FAIL_IF(SHRUI(TMP_EREG1,reg_map[src1], 63));
-
-				if (src2 < 0)
-					FAIL_IF(XORI(TMP_EREG1, TMP_EREG1, 1));
-
-				if (src1 != dst)
-					overflow_ra = reg_map[src1];
-				else {
-					/* Rare ocasion. */
-					FAIL_IF(ADD(TMP_EREG2, reg_map[src1], ZERO));
-					overflow_ra = TMP_EREG2;
-				}
-			}
-
-			if (op & SLJIT_SET_E)
-				FAIL_IF(ADDLI(EQUAL_FLAG, reg_map[src1], -src2));
-
-			if (op & SLJIT_SET_C) {
-				FAIL_IF(load_immediate(compiler, ADDR_TMP_mapped, src2));
-				FAIL_IF(CMPLTU(ULESS_FLAG, reg_map[src1], ADDR_TMP_mapped));
-			}
-
-			/* dst may be the same as src1 or src2. */
-			if (CHECK_FLAGS(SLJIT_SET_E))
-				FAIL_IF(ADDLI(reg_map[dst], reg_map[src1], -src2));
-
-		} else {
-
-			if (op & SLJIT_SET_O) {
-				FAIL_IF(XOR(TMP_EREG1, reg_map[src1], reg_map[src2]));
-				FAIL_IF(SHRUI(TMP_EREG1, TMP_EREG1, 63));
-
-				if (src1 != dst)
-					overflow_ra = reg_map[src1];
-				else {
-					/* Rare ocasion. */
-					FAIL_IF(ADD(TMP_EREG2, reg_map[src1], ZERO));
-					overflow_ra = TMP_EREG2;
-				}
-			}
-
-			if (op & SLJIT_SET_E)
-				FAIL_IF(SUB(EQUAL_FLAG, reg_map[src1], reg_map[src2]));
-
-			if (op & (SLJIT_SET_U | SLJIT_SET_C))
-				FAIL_IF(CMPLTU(ULESS_FLAG, reg_map[src1], reg_map[src2]));
-
-			if (op & SLJIT_SET_U)
-				FAIL_IF(CMPLTU(UGREATER_FLAG, reg_map[src2], reg_map[src1]));
-
-			if (op & SLJIT_SET_S) {
-				FAIL_IF(CMPLTS(LESS_FLAG ,reg_map[src1] ,reg_map[src2]));
-				FAIL_IF(CMPLTS(GREATER_FLAG ,reg_map[src2] ,reg_map[src1]));
-			}
-
-			/* dst may be the same as src1 or src2. */
-			if (CHECK_FLAGS(SLJIT_SET_E | SLJIT_SET_U | SLJIT_SET_S | SLJIT_SET_C))
-				FAIL_IF(SUB(reg_map[dst], reg_map[src1], reg_map[src2]));
-		}
-
-		if (op & SLJIT_SET_O) {
-			FAIL_IF(XOR(OVERFLOW_FLAG, reg_map[dst], overflow_ra));
-			FAIL_IF(SHRUI(OVERFLOW_FLAG, OVERFLOW_FLAG, 63));
-			return CMOVEQZ(OVERFLOW_FLAG, TMP_EREG1, ZERO);
-		}
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_SUBC:
-		if ((flags & SRC2_IMM) && src2 == SIMM_16BIT_MIN) {
-			FAIL_IF(ADDLI(TMP_REG2_mapped, ZERO, src2));
-			src2 = TMP_REG2;
-			flags &= ~SRC2_IMM;
-		}
-
-		if (flags & SRC2_IMM) {
-			if (op & SLJIT_SET_C) {
-				FAIL_IF(load_immediate(compiler, ADDR_TMP_mapped, -src2));
-				FAIL_IF(CMPLTU(TMP_EREG1, reg_map[src1], ADDR_TMP_mapped));
-			}
-
-			/* dst may be the same as src1 or src2. */
-			FAIL_IF(ADDLI(reg_map[dst], reg_map[src1], -src2));
-
-		} else {
-			if (op & SLJIT_SET_C)
-				FAIL_IF(CMPLTU(TMP_EREG1, reg_map[src1], reg_map[src2]));
-				/* dst may be the same as src1 or src2. */
-			FAIL_IF(SUB(reg_map[dst], reg_map[src1], reg_map[src2]));
-		}
-
-		if (op & SLJIT_SET_C)
-			FAIL_IF(CMOVEQZ(TMP_EREG1, reg_map[dst], ULESS_FLAG));
-
-		FAIL_IF(SUB(reg_map[dst], reg_map[dst], ULESS_FLAG));
-
-		if (op & SLJIT_SET_C)
-			FAIL_IF(ADD(ULESS_FLAG, TMP_EREG1, ZERO));
-
-		return SLJIT_SUCCESS;
-
-	case SLJIT_MUL:
-		if (flags & SRC2_IMM) {
-			FAIL_IF(load_immediate(compiler, TMP_REG2_mapped, src2));
-			src2 = TMP_REG2;
-			flags &= ~SRC2_IMM;
-		}
-
-		FAIL_IF(MUL(reg_map[dst], reg_map[src1], reg_map[src2]));
-
-		return SLJIT_SUCCESS;
-
-#define EMIT_LOGICAL(op_imm, op_norm) \
-	if (flags & SRC2_IMM) { \
-		FAIL_IF(load_immediate(compiler, ADDR_TMP_mapped, src2)); \
-		if (op & SLJIT_SET_E) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_norm, EQUAL_FLAG, reg_map[src1], \
-				ADDR_TMP_mapped, __LINE__)); \
-		if (CHECK_FLAGS(SLJIT_SET_E)) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_norm, reg_map[dst], reg_map[src1], \
-				ADDR_TMP_mapped, __LINE__)); \
-	} else { \
-		if (op & SLJIT_SET_E) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_norm, EQUAL_FLAG, reg_map[src1], \
-				reg_map[src2], __LINE__)); \
-		if (CHECK_FLAGS(SLJIT_SET_E)) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_norm, reg_map[dst], reg_map[src1], \
-				reg_map[src2], __LINE__)); \
-	}
-
-	case SLJIT_AND:
-		EMIT_LOGICAL(TILEGX_OPC_ANDI, TILEGX_OPC_AND);
-		return SLJIT_SUCCESS;
-
-	case SLJIT_OR:
-		EMIT_LOGICAL(TILEGX_OPC_ORI, TILEGX_OPC_OR);
-		return SLJIT_SUCCESS;
-
-	case SLJIT_XOR:
-		EMIT_LOGICAL(TILEGX_OPC_XORI, TILEGX_OPC_XOR);
-		return SLJIT_SUCCESS;
-
-#define EMIT_SHIFT(op_imm, op_norm) \
-	if (flags & SRC2_IMM) { \
-		if (op & SLJIT_SET_E) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_imm, EQUAL_FLAG, reg_map[src1], \
-				src2 & 0x3F, __LINE__)); \
-		if (CHECK_FLAGS(SLJIT_SET_E)) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_imm, reg_map[dst], reg_map[src1], \
-				src2 & 0x3F, __LINE__)); \
-	} else { \
-		if (op & SLJIT_SET_E) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_norm, EQUAL_FLAG, reg_map[src1], \
-				reg_map[src2], __LINE__)); \
-		if (CHECK_FLAGS(SLJIT_SET_E)) \
-			FAIL_IF(push_3_buffer( \
-				compiler, op_norm, reg_map[dst], reg_map[src1], \
-				reg_map[src2], __LINE__)); \
-	}
-
-	case SLJIT_SHL:
-		EMIT_SHIFT(TILEGX_OPC_SHLI, TILEGX_OPC_SHL);
-		return SLJIT_SUCCESS;
-
-	case SLJIT_LSHR:
-		EMIT_SHIFT(TILEGX_OPC_SHRUI, TILEGX_OPC_SHRU);
-		return SLJIT_SUCCESS;
-
-	case SLJIT_ASHR:
-		EMIT_SHIFT(TILEGX_OPC_SHRSI, TILEGX_OPC_SHRS);
-		return SLJIT_SUCCESS;
-	}
-
-	SLJIT_UNREACHABLE();
-	return SLJIT_SUCCESS;
-}
-
-static sljit_s32 emit_op(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 flags, sljit_s32 dst, sljit_sw dstw, sljit_s32 src1, sljit_sw src1w, sljit_s32 src2, sljit_sw src2w)
-{
-	/* arg1 goes to TMP_REG1 or src reg.
-	   arg2 goes to TMP_REG2, imm or src reg.
-	   TMP_REG3 can be used for caching.
-	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
-	sljit_s32 dst_r = TMP_REG2;
-	sljit_s32 src1_r;
-	sljit_sw src2_r = 0;
-	sljit_s32 sugg_src2_r = TMP_REG2;
-
-	if (!(flags & ALT_KEEP_CACHE)) {
-		compiler->cache_arg = 0;
-		compiler->cache_argw = 0;
-	}
-
-	if (SLJIT_UNLIKELY(dst == SLJIT_UNUSED)) {
-		if (op >= SLJIT_MOV && op <= SLJIT_MOVU_S32 && !(src2 & SLJIT_MEM))
-			return SLJIT_SUCCESS;
-		if (GET_FLAGS(op))
-			flags |= UNUSED_DEST;
-	} else if (FAST_IS_REG(dst)) {
-		dst_r = dst;
-		flags |= REG_DEST;
-		if (op >= SLJIT_MOV && op <= SLJIT_MOVU_S32)
-			sugg_src2_r = dst_r;
-	} else if ((dst & SLJIT_MEM) && !getput_arg_fast(compiler, flags | ARG_TEST, TMP_REG1_mapped, dst, dstw))
-		flags |= SLOW_DEST;
-
-	if (flags & IMM_OP) {
-		if ((src2 & SLJIT_IMM) && src2w) {
-			if ((!(flags & LOGICAL_OP)
-					&& (src2w <= SIMM_16BIT_MAX && src2w >= SIMM_16BIT_MIN))
-					|| ((flags & LOGICAL_OP) && !(src2w & ~UIMM_16BIT_MAX))) {
-				flags |= SRC2_IMM;
-				src2_r = src2w;
-			}
-		}
-
-		if (!(flags & SRC2_IMM) && (flags & CUMULATIVE_OP) && (src1 & SLJIT_IMM) && src1w) {
-			if ((!(flags & LOGICAL_OP)
-					&& (src1w <= SIMM_16BIT_MAX && src1w >= SIMM_16BIT_MIN))
-					|| ((flags & LOGICAL_OP) && !(src1w & ~UIMM_16BIT_MAX))) {
-				flags |= SRC2_IMM;
-				src2_r = src1w;
-
-				/* And swap arguments. */
-				src1 = src2;
-				src1w = src2w;
-				src2 = SLJIT_IMM;
-				/* src2w = src2_r unneeded. */
-			}
-		}
-	}
-
-	/* Source 1. */
-	if (FAST_IS_REG(src1)) {
-		src1_r = src1;
-		flags |= REG1_SOURCE;
-	} else if (src1 & SLJIT_IMM) {
-		if (src1w) {
-			FAIL_IF(load_immediate(compiler, TMP_REG1_mapped, src1w));
-			src1_r = TMP_REG1;
-		} else
-			src1_r = 0;
-	} else {
-		if (getput_arg_fast(compiler, flags | LOAD_DATA, TMP_REG1_mapped, src1, src1w))
-			FAIL_IF(compiler->error);
-		else
-			flags |= SLOW_SRC1;
-		src1_r = TMP_REG1;
-	}
-
-	/* Source 2. */
-	if (FAST_IS_REG(src2)) {
-		src2_r = src2;
-		flags |= REG2_SOURCE;
-		if (!(flags & REG_DEST) && op >= SLJIT_MOV && op <= SLJIT_MOVU_S32)
-			dst_r = src2_r;
-	} else if (src2 & SLJIT_IMM) {
-		if (!(flags & SRC2_IMM)) {
-			if (src2w) {
-				FAIL_IF(load_immediate(compiler, reg_map[sugg_src2_r], src2w));
-				src2_r = sugg_src2_r;
-			} else {
-				src2_r = 0;
-				if ((op >= SLJIT_MOV && op <= SLJIT_MOVU_S32) && (dst & SLJIT_MEM))
-					dst_r = 0;
-			}
-		}
-	} else {
-		if (getput_arg_fast(compiler, flags | LOAD_DATA, reg_map[sugg_src2_r], src2, src2w))
-			FAIL_IF(compiler->error);
-		else
-			flags |= SLOW_SRC2;
-		src2_r = sugg_src2_r;
-	}
-
-	if ((flags & (SLOW_SRC1 | SLOW_SRC2)) == (SLOW_SRC1 | SLOW_SRC2)) {
-		SLJIT_ASSERT(src2_r == TMP_REG2);
-		if (!can_cache(src1, src1w, src2, src2w) && can_cache(src1, src1w, dst, dstw)) {
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG2_mapped, src2, src2w, src1, src1w));
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG1_mapped, src1, src1w, dst, dstw));
-		} else {
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG1_mapped, src1, src1w, src2, src2w));
-			FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG2_mapped, src2, src2w, dst, dstw));
-		}
-	} else if (flags & SLOW_SRC1)
-		FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, TMP_REG1_mapped, src1, src1w, dst, dstw));
-	else if (flags & SLOW_SRC2)
-		FAIL_IF(getput_arg(compiler, flags | LOAD_DATA, reg_map[sugg_src2_r], src2, src2w, dst, dstw));
-
-	FAIL_IF(emit_single_op(compiler, op, flags, dst_r, src1_r, src2_r));
-
-	if (dst & SLJIT_MEM) {
-		if (!(flags & SLOW_DEST)) {
-			getput_arg_fast(compiler, flags, reg_map[dst_r], dst, dstw);
-			return compiler->error;
-		}
-
-		return getput_arg(compiler, flags, reg_map[dst_r], dst, dstw, 0, 0);
-	}
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_flags(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 dst, sljit_sw dstw, sljit_s32 src, sljit_sw srcw, sljit_s32 type)
-{
-	sljit_s32 sugg_dst_ar, dst_ar;
-	sljit_s32 flags = GET_ALL_FLAGS(op);
-	sljit_s32 mem_type = (op & SLJIT_I32_OP) ? (INT_DATA | SIGNED_DATA) : WORD_DATA;
-
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_op_flags(compiler, op, dst, dstw, src, srcw, type));
-	ADJUST_LOCAL_OFFSET(dst, dstw);
-
-	op = GET_OPCODE(op);
-	if (op == SLJIT_MOV_S32 || op == SLJIT_MOV_U32)
-		mem_type = INT_DATA | SIGNED_DATA;
-	sugg_dst_ar = reg_map[(op < SLJIT_ADD && FAST_IS_REG(dst)) ? dst : TMP_REG2];
-
-	compiler->cache_arg = 0;
-	compiler->cache_argw = 0;
-	if (op >= SLJIT_ADD && (src & SLJIT_MEM)) {
-		ADJUST_LOCAL_OFFSET(src, srcw);
-		FAIL_IF(emit_op_mem2(compiler, mem_type | LOAD_DATA, TMP_REG1_mapped, src, srcw, dst, dstw));
-		src = TMP_REG1;
-		srcw = 0;
-	}
-
-	switch (type & 0xff) {
-	case SLJIT_EQUAL:
-	case SLJIT_NOT_EQUAL:
-		FAIL_IF(CMPLTUI(sugg_dst_ar, EQUAL_FLAG, 1));
-		dst_ar = sugg_dst_ar;
-		break;
-	case SLJIT_LESS:
-	case SLJIT_GREATER_EQUAL:
-		dst_ar = ULESS_FLAG;
-		break;
-	case SLJIT_GREATER:
-	case SLJIT_LESS_EQUAL:
-		dst_ar = UGREATER_FLAG;
-		break;
-	case SLJIT_SIG_LESS:
-	case SLJIT_SIG_GREATER_EQUAL:
-		dst_ar = LESS_FLAG;
-		break;
-	case SLJIT_SIG_GREATER:
-	case SLJIT_SIG_LESS_EQUAL:
-		dst_ar = GREATER_FLAG;
-		break;
-	case SLJIT_OVERFLOW:
-	case SLJIT_NOT_OVERFLOW:
-		dst_ar = OVERFLOW_FLAG;
-		break;
-	case SLJIT_MUL_OVERFLOW:
-	case SLJIT_MUL_NOT_OVERFLOW:
-		FAIL_IF(CMPLTUI(sugg_dst_ar, OVERFLOW_FLAG, 1));
-		dst_ar = sugg_dst_ar;
-		type ^= 0x1; /* Flip type bit for the XORI below. */
-		break;
-
-	default:
-		SLJIT_UNREACHABLE();
-		dst_ar = sugg_dst_ar;
-		break;
-	}
-
-	if (type & 0x1) {
-		FAIL_IF(XORI(sugg_dst_ar, dst_ar, 1));
-		dst_ar = sugg_dst_ar;
-	}
-
-	if (op >= SLJIT_ADD) {
-		if (TMP_REG2_mapped != dst_ar)
-			FAIL_IF(ADD(TMP_REG2_mapped, dst_ar, ZERO));
-		return emit_op(compiler, op | flags, mem_type | CUMULATIVE_OP | LOGICAL_OP | IMM_OP | ALT_KEEP_CACHE, dst, dstw, src, srcw, TMP_REG2, 0);
-	}
-
-	if (dst & SLJIT_MEM)
-		return emit_op_mem(compiler, mem_type, dst_ar, dst, dstw);
-
-	if (sugg_dst_ar != dst_ar)
-		return ADD(sugg_dst_ar, dst_ar, ZERO);
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op0(struct sljit_compiler *compiler, sljit_s32 op) {
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_op0(compiler, op));
-
-	op = GET_OPCODE(op);
-	switch (op) {
-	case SLJIT_NOP:
-		return push_0_buffer(compiler, TILEGX_OPC_FNOP, __LINE__);
-
-	case SLJIT_BREAKPOINT:
-		return PI(BPT);
-
-	case SLJIT_LMUL_UW:
-	case SLJIT_LMUL_SW:
-	case SLJIT_DIVMOD_UW:
-	case SLJIT_DIVMOD_SW:
-	case SLJIT_DIV_UW:
-	case SLJIT_DIV_SW:
-		SLJIT_UNREACHABLE();
-	case SLJIT_ENDBR:
-	case SLJIT_SKIP_FRAMES_BEFORE_RETURN:
-		return SLJIT_SUCCESS;
-	}
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op1(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 dst, sljit_sw dstw, sljit_s32 src, sljit_sw srcw)
-{
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_op1(compiler, op, dst, dstw, src, srcw));
-	ADJUST_LOCAL_OFFSET(dst, dstw);
-	ADJUST_LOCAL_OFFSET(src, srcw);
-
-	switch (GET_OPCODE(op)) {
-	case SLJIT_MOV:
-	case SLJIT_MOV_P:
-		return emit_op(compiler, SLJIT_MOV, WORD_DATA, dst, dstw, TMP_REG1, 0, src, srcw);
-
-	case SLJIT_MOV_U32:
-		return emit_op(compiler, SLJIT_MOV_U32, INT_DATA, dst, dstw, TMP_REG1, 0, src, srcw);
-
-	case SLJIT_MOV_S32:
-		return emit_op(compiler, SLJIT_MOV_S32, INT_DATA | SIGNED_DATA, dst, dstw, TMP_REG1, 0, src, srcw);
-
-	case SLJIT_MOV_U8:
-		return emit_op(compiler, SLJIT_MOV_U8, BYTE_DATA, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u8) srcw : srcw);
-
-	case SLJIT_MOV_S8:
-		return emit_op(compiler, SLJIT_MOV_S8, BYTE_DATA | SIGNED_DATA, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s8) srcw : srcw);
-
-	case SLJIT_MOV_U16:
-		return emit_op(compiler, SLJIT_MOV_U16, HALF_DATA, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u16) srcw : srcw);
-
-	case SLJIT_MOV_S16:
-		return emit_op(compiler, SLJIT_MOV_S16, HALF_DATA | SIGNED_DATA, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s16) srcw : srcw);
-
-	case SLJIT_MOVU:
-	case SLJIT_MOVU_P:
-		return emit_op(compiler, SLJIT_MOV, WORD_DATA | WRITE_BACK, dst, dstw, TMP_REG1, 0, src, srcw);
-
-	case SLJIT_MOVU_U32:
-		return emit_op(compiler, SLJIT_MOV_U32, INT_DATA | WRITE_BACK, dst, dstw, TMP_REG1, 0, src, srcw);
-
-	case SLJIT_MOVU_S32:
-		return emit_op(compiler, SLJIT_MOV_S32, INT_DATA | SIGNED_DATA | WRITE_BACK, dst, dstw, TMP_REG1, 0, src, srcw);
-
-	case SLJIT_MOVU_U8:
-		return emit_op(compiler, SLJIT_MOV_U8, BYTE_DATA | WRITE_BACK, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u8) srcw : srcw);
-
-	case SLJIT_MOVU_S8:
-		return emit_op(compiler, SLJIT_MOV_S8, BYTE_DATA | SIGNED_DATA | WRITE_BACK, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s8) srcw : srcw);
-
-	case SLJIT_MOVU_U16:
-		return emit_op(compiler, SLJIT_MOV_U16, HALF_DATA | WRITE_BACK, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_u16) srcw : srcw);
-
-	case SLJIT_MOVU_S16:
-		return emit_op(compiler, SLJIT_MOV_S16, HALF_DATA | SIGNED_DATA | WRITE_BACK, dst, dstw, TMP_REG1, 0, src, (src & SLJIT_IMM) ? (sljit_s16) srcw : srcw);
-
-	case SLJIT_NOT:
-		return emit_op(compiler, op, 0, dst, dstw, TMP_REG1, 0, src, srcw);
-
-	case SLJIT_NEG:
-		return emit_op(compiler, SLJIT_SUB | GET_ALL_FLAGS(op), IMM_OP, dst, dstw, SLJIT_IMM, 0, src, srcw);
-
-	case SLJIT_CLZ:
-		return emit_op(compiler, op, (op & SLJIT_I32_OP) ? INT_DATA : WORD_DATA, dst, dstw, TMP_REG1, 0, src, srcw);
-	}
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op2(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 dst, sljit_sw dstw, sljit_s32 src1, sljit_sw src1w, sljit_s32 src2, sljit_sw src2w)
-{
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_op2(compiler, op, dst, dstw, src1, src1w, src2, src2w));
-	ADJUST_LOCAL_OFFSET(dst, dstw);
-	ADJUST_LOCAL_OFFSET(src1, src1w);
-	ADJUST_LOCAL_OFFSET(src2, src2w);
-
-	switch (GET_OPCODE(op)) {
-	case SLJIT_ADD:
-	case SLJIT_ADDC:
-		return emit_op(compiler, op, CUMULATIVE_OP | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
-
-	case SLJIT_SUB:
-	case SLJIT_SUBC:
-		return emit_op(compiler, op, IMM_OP, dst, dstw, src1, src1w, src2, src2w);
-
-	case SLJIT_MUL:
-		return emit_op(compiler, op, CUMULATIVE_OP, dst, dstw, src1, src1w, src2, src2w);
-
-	case SLJIT_AND:
-	case SLJIT_OR:
-	case SLJIT_XOR:
-		return emit_op(compiler, op, CUMULATIVE_OP | LOGICAL_OP | IMM_OP, dst, dstw, src1, src1w, src2, src2w);
-
-	case SLJIT_SHL:
-	case SLJIT_LSHR:
-	case SLJIT_ASHR:
-		if (src2 & SLJIT_IMM)
-			src2w &= 0x3f;
-		if (op & SLJIT_I32_OP)
-			src2w &= 0x1f;
-
-		return emit_op(compiler, op, IMM_OP, dst, dstw, src1, src1w, src2, src2w);
-	}
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_src(struct sljit_compiler *compiler, sljit_s32 op,
-	sljit_s32 src, sljit_sw srcw)
-{
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_op_src(compiler, op, src, srcw));
-	ADJUST_LOCAL_OFFSET(src, srcw);
-
-	switch (op) {
-	case SLJIT_FAST_RETURN:
-		if (FAST_IS_REG(src))
-			FAIL_IF(ADD(RA, reg_map[src], ZERO));
-
-		else
-			FAIL_IF(emit_op_mem(compiler, WORD_DATA | LOAD_DATA, RA, src, srcw));
-
-		return JR(RA);
-	case SLJIT_SKIP_FRAMES_BEFORE_FAST_RETURN:
-		return SLJIT_SUCCESS;
-	}
-
-	return SLJIT_SUCCESS;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_label * sljit_emit_label(struct sljit_compiler *compiler)
-{
-	struct sljit_label *label;
-
-	flush_buffer(compiler);
-
-	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_emit_label(compiler));
-
-	if (compiler->last_label && compiler->last_label->size == compiler->size)
-		return compiler->last_label;
-
-	label = (struct sljit_label *)ensure_abuf(compiler, sizeof(struct sljit_label));
-	PTR_FAIL_IF(!label);
-	set_label(label, compiler);
-	return label;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_ijump(struct sljit_compiler *compiler, sljit_s32 type, sljit_s32 src, sljit_sw srcw)
-{
-	sljit_s32 src_r = TMP_REG2;
-	struct sljit_jump *jump = NULL;
-
-	flush_buffer(compiler);
-
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_ijump(compiler, type, src, srcw));
-	ADJUST_LOCAL_OFFSET(src, srcw);
-
-	if (FAST_IS_REG(src)) {
-		if (reg_map[src] != 0)
-			src_r = src;
-		else
-			FAIL_IF(ADD_SOLO(TMP_REG2_mapped, reg_map[src], ZERO));
-	}
-
-	if (type >= SLJIT_CALL0) {
-		SLJIT_ASSERT(reg_map[PIC_ADDR_REG] == 16 && PIC_ADDR_REG == TMP_REG2);
-		if (src & (SLJIT_IMM | SLJIT_MEM)) {
-			if (src & SLJIT_IMM)
-				FAIL_IF(emit_const(compiler, reg_map[PIC_ADDR_REG], srcw, 1));
-			else {
-				SLJIT_ASSERT(src_r == TMP_REG2 && (src & SLJIT_MEM));
-				FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, TMP_REG2, 0, TMP_REG1, 0, src, srcw));
-			}
-
-			FAIL_IF(ADD_SOLO(0, reg_map[SLJIT_R0], ZERO));
-
-			FAIL_IF(ADDI_SOLO(54, 54, -16));
-
-			FAIL_IF(JALR_SOLO(reg_map[PIC_ADDR_REG]));
-
-			return ADDI_SOLO(54, 54, 16);
-		}
-
-		/* Register input. */
-		if (type >= SLJIT_CALL1)
-			FAIL_IF(ADD_SOLO(0, reg_map[SLJIT_R0], ZERO));
-
-		FAIL_IF(ADD_SOLO(reg_map[PIC_ADDR_REG], reg_map[src_r], ZERO));
-
-		FAIL_IF(ADDI_SOLO(54, 54, -16));
-
-		FAIL_IF(JALR_SOLO(reg_map[src_r]));
-
-		return ADDI_SOLO(54, 54, 16);
-	}
-
-	if (src & SLJIT_IMM) {
-		jump = (struct sljit_jump *)ensure_abuf(compiler, sizeof(struct sljit_jump));
-		FAIL_IF(!jump);
-		set_jump(jump, compiler, JUMP_ADDR | ((type >= SLJIT_FAST_CALL) ? IS_JAL : 0));
-		jump->u.target = srcw;
-		FAIL_IF(emit_const(compiler, TMP_REG2_mapped, 0, 1));
-
-		if (type >= SLJIT_FAST_CALL) {
-			FAIL_IF(ADD_SOLO(ZERO, ZERO, ZERO));
-			jump->addr = compiler->size;
-			FAIL_IF(JR_SOLO(reg_map[src_r]));
-		} else {
-			jump->addr = compiler->size;
-			FAIL_IF(JR_SOLO(reg_map[src_r]));
-		}
-
-		return SLJIT_SUCCESS;
-
-	} else if (src & SLJIT_MEM) {
-		FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, TMP_REG2, 0, TMP_REG1, 0, src, srcw));
-		flush_buffer(compiler);
-	}
-
-	FAIL_IF(JR_SOLO(reg_map[src_r]));
-
-	if (jump)
-		jump->addr = compiler->size;
-
-	return SLJIT_SUCCESS;
-}
-
-#define BR_Z(src) \
-	inst = BEQZ_X1 | SRCA_X1(src); \
-	flags = IS_COND;
-
-#define BR_NZ(src) \
-	inst = BNEZ_X1 | SRCA_X1(src); \
-	flags = IS_COND;
-
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_jump * sljit_emit_jump(struct sljit_compiler *compiler, sljit_s32 type)
-{
-	struct sljit_jump *jump;
-	sljit_ins inst;
-	sljit_s32 flags = 0;
-
-	flush_buffer(compiler);
-
-	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_emit_jump(compiler, type));
-
-	jump = (struct sljit_jump *)ensure_abuf(compiler, sizeof(struct sljit_jump));
-	PTR_FAIL_IF(!jump);
-	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
-	type &= 0xff;
-
-	switch (type) {
-	case SLJIT_EQUAL:
-		BR_NZ(EQUAL_FLAG);
-		break;
-	case SLJIT_NOT_EQUAL:
-		BR_Z(EQUAL_FLAG);
-		break;
-	case SLJIT_LESS:
-		BR_Z(ULESS_FLAG);
-		break;
-	case SLJIT_GREATER_EQUAL:
-		BR_NZ(ULESS_FLAG);
-		break;
-	case SLJIT_GREATER:
-		BR_Z(UGREATER_FLAG);
-		break;
-	case SLJIT_LESS_EQUAL:
-		BR_NZ(UGREATER_FLAG);
-		break;
-	case SLJIT_SIG_LESS:
-		BR_Z(LESS_FLAG);
-		break;
-	case SLJIT_SIG_GREATER_EQUAL:
-		BR_NZ(LESS_FLAG);
-		break;
-	case SLJIT_SIG_GREATER:
-		BR_Z(GREATER_FLAG);
-		break;
-	case SLJIT_SIG_LESS_EQUAL:
-		BR_NZ(GREATER_FLAG);
-		break;
-	case SLJIT_OVERFLOW:
-	case SLJIT_MUL_OVERFLOW:
-		BR_Z(OVERFLOW_FLAG);
-		break;
-	case SLJIT_NOT_OVERFLOW:
-	case SLJIT_MUL_NOT_OVERFLOW:
-		BR_NZ(OVERFLOW_FLAG);
-		break;
-	default:
-		/* Not conditional branch. */
-		inst = 0;
-		break;
-	}
-
-	jump->flags |= flags;
-
-	if (inst) {
-		inst = inst | ((type <= SLJIT_JUMP) ? BOFF_X1(5) : BOFF_X1(6));
-		PTR_FAIL_IF(PI(inst));
-	}
-
-	PTR_FAIL_IF(emit_const(compiler, TMP_REG2_mapped, 0, 1));
-	if (type <= SLJIT_JUMP) {
-		jump->addr = compiler->size;
-		PTR_FAIL_IF(JR_SOLO(TMP_REG2_mapped));
-	} else {
-		SLJIT_ASSERT(reg_map[PIC_ADDR_REG] == 16 && PIC_ADDR_REG == TMP_REG2);
-		/* Cannot be optimized out if type is >= CALL0. */
-		jump->flags |= IS_JAL | (type >= SLJIT_CALL0 ? SLJIT_REWRITABLE_JUMP : 0);
-		PTR_FAIL_IF(ADD_SOLO(0, reg_map[SLJIT_R0], ZERO));
-		jump->addr = compiler->size;
-		PTR_FAIL_IF(JALR_SOLO(TMP_REG2_mapped));
-	}
-
-	return jump;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop1(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 dst, sljit_sw dstw, sljit_s32 src, sljit_sw srcw)
-{
-	SLJIT_UNREACHABLE();
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_fop2(struct sljit_compiler *compiler, sljit_s32 op, sljit_s32 dst, sljit_sw dstw, sljit_s32 src1, sljit_sw src1w, sljit_s32 src2, sljit_sw src2w)
-{
-	SLJIT_UNREACHABLE();
-}
-
-SLJIT_API_FUNC_ATTRIBUTE struct sljit_const * sljit_emit_const(struct sljit_compiler *compiler, sljit_s32 dst, sljit_sw dstw, sljit_sw init_value)
-{
-	struct sljit_const *const_;
-	sljit_s32 reg;
-
-	flush_buffer(compiler);
-
-	CHECK_ERROR_PTR();
-	CHECK_PTR(check_sljit_emit_const(compiler, dst, dstw, init_value));
-	ADJUST_LOCAL_OFFSET(dst, dstw);
-
-	const_ = (struct sljit_const *)ensure_abuf(compiler, sizeof(struct sljit_const));
-	PTR_FAIL_IF(!const_);
-	set_const(const_, compiler);
-
-	reg = FAST_IS_REG(dst) ? dst : TMP_REG2;
-
-	PTR_FAIL_IF(emit_const_64(compiler, reg, init_value, 1));
-
-	if (dst & SLJIT_MEM)
-		PTR_FAIL_IF(emit_op(compiler, SLJIT_MOV, WORD_DATA, dst, dstw, TMP_REG1, 0, TMP_REG2, 0));
-	return const_;
-}
-
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target)
-{
-	sljit_ins *inst = (sljit_ins *)addr;
-
-	inst[0] = (inst[0] & ~(0xFFFFL << 43)) | (((new_target >> 32) & 0xffff) << 43);
-	inst[1] = (inst[1] & ~(0xFFFFL << 43)) | (((new_target >> 16) & 0xffff) << 43);
-	inst[2] = (inst[2] & ~(0xFFFFL << 43)) | ((new_target & 0xffff) << 43);
-	SLJIT_CACHE_FLUSH(inst, inst + 3);
-}
-
-SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant)
-{
-	sljit_ins *inst = (sljit_ins *)addr;
-
-	inst[0] = (inst[0] & ~(0xFFFFL << 43)) | (((new_constant >> 48) & 0xFFFFL) << 43);
-	inst[1] = (inst[1] & ~(0xFFFFL << 43)) | (((new_constant >> 32) & 0xFFFFL) << 43);
-	inst[2] = (inst[2] & ~(0xFFFFL << 43)) | (((new_constant >> 16) & 0xFFFFL) << 43);
-	inst[3] = (inst[3] & ~(0xFFFFL << 43)) | ((new_constant & 0xFFFFL) << 43);
-	SLJIT_CACHE_FLUSH(inst, inst + 4);
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_get_register_index(sljit_s32 reg)
-{
-	CHECK_REG_INDEX(check_sljit_get_register_index(reg));
-	return reg_map[reg];
-}
-
-SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_emit_op_custom(struct sljit_compiler *compiler,
-	void *instruction, sljit_s32 size)
-{
-	CHECK_ERROR();
-	CHECK(check_sljit_emit_op_custom(compiler, instruction, size));
-	return SLJIT_ERR_UNSUPPORTED;
-}
-
diff --git a/src/3rdparty/pcre2/src/sljit/sljitNativeX86_common.c b/src/3rdparty/pcre2/src/sljit/sljitNativeX86_common.c
index 74965e3251..ddcc5ebf76 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitNativeX86_common.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitNativeX86_common.c
@@ -506,7 +506,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	reverse_buf(compiler);
 
 	/* Second code generation pass. */
-	code = (sljit_u8*)SLJIT_MALLOC_EXEC(compiler->size);
+	code = (sljit_u8*)SLJIT_MALLOC_EXEC(compiler->size, compiler->exec_allocator_data);
 	PTR_FAIL_WITH_EXEC_IF(code);
 	buf = compiler->buf;
 
@@ -557,7 +557,7 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 					SLJIT_ASSERT(put_label->label);
 					put_label->addr = (sljit_uw)code_ptr;
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
-					code_ptr = generate_put_label_code(put_label, code_ptr, (sljit_uw)(SLJIT_ADD_EXEC_OFFSET(code, executable_offset) + put_label->label->size));
+					code_ptr = generate_put_label_code(put_label, code_ptr, (sljit_uw)SLJIT_ADD_EXEC_OFFSET(code, executable_offset) + put_label->label->size);
 #endif
 					put_label = put_label->next;
 					break;
@@ -629,7 +629,11 @@ SLJIT_API_FUNC_ATTRIBUTE void* sljit_generate_code(struct sljit_compiler *compil
 	compiler->error = SLJIT_ERR_COMPILED;
 	compiler->executable_offset = executable_offset;
 	compiler->executable_size = code_ptr - code;
-	return (void*)(code + executable_offset);
+
+	code = (sljit_u8*)SLJIT_ADD_EXEC_OFFSET(code, executable_offset);
+
+	SLJIT_UPDATE_WX_FLAGS(code, (sljit_u8*)SLJIT_ADD_EXEC_OFFSET(code_ptr, executable_offset), 1);
+	return (void*)code;
 }
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_s32 sljit_has_cpu_feature(sljit_s32 feature_type)
@@ -725,15 +729,16 @@ static SLJIT_INLINE sljit_s32 emit_endbranch(struct sljit_compiler *compiler)
 #else
 	*inst = 0xfa;
 #endif
-#else
+#else /* !SLJIT_CONFIG_X86_CET */
 	SLJIT_UNUSED_ARG(compiler);
-#endif
+#endif /* SLJIT_CONFIG_X86_CET */
 	return SLJIT_SUCCESS;
 }
 
+#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET) && defined (__SHSTK__)
+
 static SLJIT_INLINE sljit_s32 emit_rdssp(struct sljit_compiler *compiler, sljit_s32 reg)
 {
-#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET)
 	sljit_u8 *inst;
 	sljit_s32 size;
 
@@ -753,16 +758,11 @@ static SLJIT_INLINE sljit_s32 emit_rdssp(struct sljit_compiler *compiler, sljit_
 	*inst++ = 0x0f;
 	*inst++ = 0x1e;
 	*inst = (0x3 << 6) | (0x1 << 3) | (reg_map[reg] & 0x7);
-#else
-	SLJIT_UNUSED_ARG(compiler);
-	SLJIT_UNUSED_ARG(reg);
-#endif
 	return SLJIT_SUCCESS;
 }
 
 static SLJIT_INLINE sljit_s32 emit_incssp(struct sljit_compiler *compiler, sljit_s32 reg)
 {
-#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET)
 	sljit_u8 *inst;
 	sljit_s32 size;
 
@@ -782,29 +782,28 @@ static SLJIT_INLINE sljit_s32 emit_incssp(struct sljit_compiler *compiler, sljit
 	*inst++ = 0x0f;
 	*inst++ = 0xae;
 	*inst = (0x3 << 6) | (0x5 << 3) | (reg_map[reg] & 0x7);
-#else
-	SLJIT_UNUSED_ARG(compiler);
-	SLJIT_UNUSED_ARG(reg);
-#endif
 	return SLJIT_SUCCESS;
 }
 
+#endif /* SLJIT_CONFIG_X86_CET && __SHSTK__ */
+
 static SLJIT_INLINE sljit_s32 cpu_has_shadow_stack(void)
 {
-#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET)
+#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET) && defined (__SHSTK__)
 	return _get_ssp() != 0;
-#else
+#else /* !SLJIT_CONFIG_X86_CET || !__SHSTK__ */
 	return 0;
-#endif
+#endif /* SLJIT_CONFIG_X86_CET && __SHSTK__ */
 }
 
 static SLJIT_INLINE sljit_s32 adjust_shadow_stack(struct sljit_compiler *compiler,
 	sljit_s32 src, sljit_sw srcw, sljit_s32 base, sljit_sw disp)
 {
-#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET)
-	sljit_u8 *inst;
+#if (defined SLJIT_CONFIG_X86_CET && SLJIT_CONFIG_X86_CET) && defined (__SHSTK__)
+	sljit_u8 *inst, *jz_after_cmp_inst;
+	sljit_uw size_jz_after_cmp_inst;
 
-	sljit_s32 size_before_rdssp_inst = compiler->size;
+	sljit_uw size_before_rdssp_inst = compiler->size;
 
 	/* Generate "RDSSP TMP_REG1". */
 	FAIL_IF(emit_rdssp(compiler, TMP_REG1));
@@ -839,8 +838,8 @@ static SLJIT_INLINE sljit_s32 adjust_shadow_stack(struct sljit_compiler *compile
 	FAIL_IF(!inst);
 	INC_SIZE(2);
 	*inst++ = get_jump_code(SLJIT_EQUAL) - 0x10;
-	sljit_uw size_jz_after_cmp_inst = compiler->size;
-	sljit_u8 *jz_after_cmp_inst = inst;
+	size_jz_after_cmp_inst = compiler->size;
+	jz_after_cmp_inst = inst;
 
 #if (defined SLJIT_CONFIG_X86_64 && SLJIT_CONFIG_X86_64)
 	/* REX_W is not necessary. */
@@ -860,13 +859,13 @@ static SLJIT_INLINE sljit_s32 adjust_shadow_stack(struct sljit_compiler *compile
 	*inst = size_before_rdssp_inst - compiler->size;
 
 	*jz_after_cmp_inst = compiler->size - size_jz_after_cmp_inst;
-#else /* SLJIT_CONFIG_X86_CET */
+#else /* !SLJIT_CONFIG_X86_CET || !__SHSTK__ */
 	SLJIT_UNUSED_ARG(compiler);
 	SLJIT_UNUSED_ARG(src);
 	SLJIT_UNUSED_ARG(srcw);
 	SLJIT_UNUSED_ARG(base);
 	SLJIT_UNUSED_ARG(disp);
-#endif /* SLJIT_CONFIG_X86_CET */
+#endif /* SLJIT_CONFIG_X86_CET && __SHSTK__ */
 	return SLJIT_SUCCESS;
 }
 
@@ -3123,15 +3122,21 @@ SLJIT_API_FUNC_ATTRIBUTE struct sljit_put_label* sljit_emit_put_label(struct slj
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_jump_addr(sljit_uw addr, sljit_uw new_target, sljit_sw executable_offset)
 {
 	SLJIT_UNUSED_ARG(executable_offset);
+
+	SLJIT_UPDATE_WX_FLAGS((void*)addr, (void*)(addr + sizeof(sljit_uw)), 0);
 #if (defined SLJIT_CONFIG_X86_32 && SLJIT_CONFIG_X86_32)
 	sljit_unaligned_store_sw((void*)addr, new_target - (addr + 4) - (sljit_uw)executable_offset);
 #else
 	sljit_unaligned_store_sw((void*)addr, (sljit_sw) new_target);
 #endif
+	SLJIT_UPDATE_WX_FLAGS((void*)addr, (void*)(addr + sizeof(sljit_uw)), 1);
 }
 
 SLJIT_API_FUNC_ATTRIBUTE void sljit_set_const(sljit_uw addr, sljit_sw new_constant, sljit_sw executable_offset)
 {
 	SLJIT_UNUSED_ARG(executable_offset);
+
+	SLJIT_UPDATE_WX_FLAGS((void*)addr, (void*)(addr + sizeof(sljit_sw)), 0);
 	sljit_unaligned_store_sw((void*)addr, new_constant);
+	SLJIT_UPDATE_WX_FLAGS((void*)addr, (void*)(addr + sizeof(sljit_sw)), 1);
 }
diff --git a/src/3rdparty/pcre2/src/sljit/sljitProtExecAllocator.c b/src/3rdparty/pcre2/src/sljit/sljitProtExecAllocator.c
new file mode 100644
index 0000000000..147175afa6
--- /dev/null
+++ b/src/3rdparty/pcre2/src/sljit/sljitProtExecAllocator.c
@@ -0,0 +1,474 @@
+/*
+ *    Stack-less Just-In-Time compiler
+ *
+ *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are
+ * permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this list of
+ *      conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *      of conditions and the following disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+   This file contains a simple executable memory allocator
+
+   It is assumed, that executable code blocks are usually medium (or sometimes
+   large) memory blocks, and the allocator is not too frequently called (less
+   optimized than other allocators). Thus, using it as a generic allocator is
+   not suggested.
+
+   How does it work:
+     Memory is allocated in continuous memory areas called chunks by alloc_chunk()
+     Chunk format:
+     [ block ][ block ] ... [ block ][ block terminator ]
+
+   All blocks and the block terminator is started with block_header. The block
+   header contains the size of the previous and the next block. These sizes
+   can also contain special values.
+     Block size:
+       0 - The block is a free_block, with a different size member.
+       1 - The block is a block terminator.
+       n - The block is used at the moment, and the value contains its size.
+     Previous block size:
+       0 - This is the first block of the memory chunk.
+       n - The size of the previous block.
+
+   Using these size values we can go forward or backward on the block chain.
+   The unused blocks are stored in a chain list pointed by free_blocks. This
+   list is useful if we need to find a suitable memory area when the allocator
+   is called.
+
+   When a block is freed, the new free block is connected to its adjacent free
+   blocks if possible.
+
+     [ free block ][ used block ][ free block ]
+   and "used block" is freed, the three blocks are connected together:
+     [           one big free block           ]
+*/
+
+/* --------------------------------------------------------------------- */
+/*  System (OS) functions                                                */
+/* --------------------------------------------------------------------- */
+
+/* 64 KByte. */
+#define CHUNK_SIZE	0x10000
+
+struct chunk_header {
+	void *executable;
+};
+
+/*
+   alloc_chunk / free_chunk :
+     * allocate executable system memory chunks
+     * the size is always divisible by CHUNK_SIZE
+   SLJIT_ALLOCATOR_LOCK / SLJIT_ALLOCATOR_UNLOCK :
+     * provided as part of sljitUtils
+     * only the allocator requires this lock, sljit is fully thread safe
+       as it only uses local variables
+*/
+
+#ifndef __NetBSD__
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifndef O_NOATIME
+#define O_NOATIME 0
+#endif
+
+/* this is a linux extension available since kernel 3.11 */
+#ifndef O_TMPFILE
+#define O_TMPFILE 020200000
+#endif
+
+#ifndef _GNU_SOURCE
+char *secure_getenv(const char *name);
+int mkostemp(char *template, int flags);
+#endif
+
+static SLJIT_INLINE int create_tempfile(void)
+{
+	int fd;
+	char tmp_name[256];
+	size_t tmp_name_len = 0;
+	char *dir;
+	struct stat st;
+#if defined(SLJIT_SINGLE_THREADED) && SLJIT_SINGLE_THREADED
+	mode_t mode;
+#endif
+
+#ifdef HAVE_MEMFD_CREATE
+	/* this is a GNU extension, make sure to use -D_GNU_SOURCE */
+	fd = memfd_create("sljit", MFD_CLOEXEC);
+	if (fd != -1) {
+		fchmod(fd, 0);
+		return fd;
+	}
+#endif
+
+	dir = secure_getenv("TMPDIR");
+
+	if (dir) {
+		tmp_name_len = strlen(dir);
+		if (tmp_name_len > 0 && tmp_name_len < sizeof(tmp_name)) {
+			if ((stat(dir, &st) == 0) && S_ISDIR(st.st_mode))
+				strcpy(tmp_name, dir);
+		}
+	}
+
+#ifdef P_tmpdir
+	if (!tmp_name_len) {
+		tmp_name_len = strlen(P_tmpdir);
+		if (tmp_name_len > 0 && tmp_name_len < sizeof(tmp_name))
+			strcpy(tmp_name, P_tmpdir);
+	}
+#endif
+	if (!tmp_name_len) {
+		strcpy(tmp_name, "/tmp");
+		tmp_name_len = 4;
+	}
+
+	SLJIT_ASSERT(tmp_name_len > 0 && tmp_name_len < sizeof(tmp_name));
+
+	if (tmp_name[tmp_name_len - 1] == '/')
+		tmp_name[--tmp_name_len] = '\0';
+
+#ifdef __linux__
+	/*
+	 * the previous trimming might had left an empty string if TMPDIR="/"
+	 * so work around the problem below
+	 */
+	fd = open(tmp_name_len ? tmp_name : "/",
+		O_TMPFILE | O_EXCL | O_RDWR | O_NOATIME | O_CLOEXEC, 0);
+	if (fd != -1)
+		return fd;
+#endif
+
+	if (tmp_name_len + 7 >= sizeof(tmp_name))
+		return -1;
+
+	strcpy(tmp_name + tmp_name_len, "/XXXXXX");
+#if defined(SLJIT_SINGLE_THREADED) && SLJIT_SINGLE_THREADED
+	mode = umask(0777);
+#endif
+	fd = mkostemp(tmp_name, O_CLOEXEC | O_NOATIME);
+#if defined(SLJIT_SINGLE_THREADED) && SLJIT_SINGLE_THREADED
+	umask(mode);
+#else
+	fchmod(fd, 0);
+#endif
+
+	if (fd == -1)
+		return -1;
+
+	if (unlink(tmp_name)) {
+		close(fd);
+		return -1;
+	}
+
+	return fd;
+}
+
+static SLJIT_INLINE struct chunk_header* alloc_chunk(sljit_uw size)
+{
+	struct chunk_header *retval;
+	int fd;
+
+	fd = create_tempfile();
+	if (fd == -1)
+		return NULL;
+
+	if (ftruncate(fd, size)) {
+		close(fd);
+		return NULL;
+	}
+
+	retval = (struct chunk_header *)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+
+	if (retval == MAP_FAILED) {
+		close(fd);
+		return NULL;
+	}
+
+	retval->executable = mmap(NULL, size, PROT_READ | PROT_EXEC, MAP_SHARED, fd, 0);
+
+	if (retval->executable == MAP_FAILED) {
+		munmap((void *)retval, size);
+		close(fd);
+		return NULL;
+	}
+
+	close(fd);
+	return retval;
+}
+#else
+/*
+ * MAP_REMAPDUP is a NetBSD extension available sinde 8.0, make sure to
+ * adjust your feature macros (ex: -D_NETBSD_SOURCE) as needed
+ */
+static SLJIT_INLINE struct chunk_header* alloc_chunk(sljit_uw size)
+{
+	struct chunk_header *retval;
+
+	retval = (struct chunk_header *)mmap(NULL, size,
+			PROT_READ | PROT_WRITE | PROT_MPROTECT(PROT_EXEC),
+			MAP_ANON | MAP_SHARED, -1, 0);
+
+	if (retval == MAP_FAILED)
+		return NULL;
+
+	retval->executable = mremap(retval, size, NULL, size, MAP_REMAPDUP);
+	if (retval->executable == MAP_FAILED) {
+		munmap((void *)retval, size);
+		return NULL;
+	}
+
+	if (mprotect(retval->executable, size, PROT_READ | PROT_EXEC) == -1) {
+		munmap(retval->executable, size);
+		munmap((void *)retval, size);
+		return NULL;
+	}
+
+	return retval;
+}
+#endif /* NetBSD */
+
+static SLJIT_INLINE void free_chunk(void *chunk, sljit_uw size)
+{
+	struct chunk_header *header = ((struct chunk_header *)chunk) - 1;
+
+	munmap(header->executable, size);
+	munmap((void *)header, size);
+}
+
+/* --------------------------------------------------------------------- */
+/*  Common functions                                                     */
+/* --------------------------------------------------------------------- */
+
+#define CHUNK_MASK	(~(CHUNK_SIZE - 1))
+
+struct block_header {
+	sljit_uw size;
+	sljit_uw prev_size;
+	sljit_sw executable_offset;
+};
+
+struct free_block {
+	struct block_header header;
+	struct free_block *next;
+	struct free_block *prev;
+	sljit_uw size;
+};
+
+#define AS_BLOCK_HEADER(base, offset) \
+	((struct block_header*)(((sljit_u8*)base) + offset))
+#define AS_FREE_BLOCK(base, offset) \
+	((struct free_block*)(((sljit_u8*)base) + offset))
+#define MEM_START(base)		((void*)((base) + 1))
+#define ALIGN_SIZE(size)	(((size) + sizeof(struct block_header) + 7) & ~7)
+
+static struct free_block* free_blocks;
+static sljit_uw allocated_size;
+static sljit_uw total_size;
+
+static SLJIT_INLINE void sljit_insert_free_block(struct free_block *free_block, sljit_uw size)
+{
+	free_block->header.size = 0;
+	free_block->size = size;
+
+	free_block->next = free_blocks;
+	free_block->prev = NULL;
+	if (free_blocks)
+		free_blocks->prev = free_block;
+	free_blocks = free_block;
+}
+
+static SLJIT_INLINE void sljit_remove_free_block(struct free_block *free_block)
+{
+	if (free_block->next)
+		free_block->next->prev = free_block->prev;
+
+	if (free_block->prev)
+		free_block->prev->next = free_block->next;
+	else {
+		SLJIT_ASSERT(free_blocks == free_block);
+		free_blocks = free_block->next;
+	}
+}
+
+SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
+{
+	struct chunk_header *chunk_header;
+	struct block_header *header;
+	struct block_header *next_header;
+	struct free_block *free_block;
+	sljit_uw chunk_size;
+	sljit_sw executable_offset;
+
+	SLJIT_ALLOCATOR_LOCK();
+	if (size < (64 - sizeof(struct block_header)))
+		size = (64 - sizeof(struct block_header));
+	size = ALIGN_SIZE(size);
+
+	free_block = free_blocks;
+	while (free_block) {
+		if (free_block->size >= size) {
+			chunk_size = free_block->size;
+			if (chunk_size > size + 64) {
+				/* We just cut a block from the end of the free block. */
+				chunk_size -= size;
+				free_block->size = chunk_size;
+				header = AS_BLOCK_HEADER(free_block, chunk_size);
+				header->prev_size = chunk_size;
+				header->executable_offset = free_block->header.executable_offset;
+				AS_BLOCK_HEADER(header, size)->prev_size = size;
+			}
+			else {
+				sljit_remove_free_block(free_block);
+				header = (struct block_header*)free_block;
+				size = chunk_size;
+			}
+			allocated_size += size;
+			header->size = size;
+			SLJIT_ALLOCATOR_UNLOCK();
+			return MEM_START(header);
+		}
+		free_block = free_block->next;
+	}
+
+	chunk_size = sizeof(struct chunk_header) + sizeof(struct block_header);
+	chunk_size = (chunk_size + size + CHUNK_SIZE - 1) & CHUNK_MASK;
+
+	chunk_header = alloc_chunk(chunk_size);
+	if (!chunk_header) {
+		SLJIT_ALLOCATOR_UNLOCK();
+		return NULL;
+	}
+
+	executable_offset = (sljit_sw)((sljit_u8*)chunk_header->executable - (sljit_u8*)chunk_header);
+
+	chunk_size -= sizeof(struct chunk_header) + sizeof(struct block_header);
+	total_size += chunk_size;
+
+	header = (struct block_header *)(chunk_header + 1);
+
+	header->prev_size = 0;
+	header->executable_offset = executable_offset;
+	if (chunk_size > size + 64) {
+		/* Cut the allocated space into a free and a used block. */
+		allocated_size += size;
+		header->size = size;
+		chunk_size -= size;
+
+		free_block = AS_FREE_BLOCK(header, size);
+		free_block->header.prev_size = size;
+		free_block->header.executable_offset = executable_offset;
+		sljit_insert_free_block(free_block, chunk_size);
+		next_header = AS_BLOCK_HEADER(free_block, chunk_size);
+	}
+	else {
+		/* All space belongs to this allocation. */
+		allocated_size += chunk_size;
+		header->size = chunk_size;
+		next_header = AS_BLOCK_HEADER(header, chunk_size);
+	}
+	next_header->size = 1;
+	next_header->prev_size = chunk_size;
+	next_header->executable_offset = executable_offset;
+	SLJIT_ALLOCATOR_UNLOCK();
+	return MEM_START(header);
+}
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_exec(void* ptr)
+{
+	struct block_header *header;
+	struct free_block* free_block;
+
+	SLJIT_ALLOCATOR_LOCK();
+	header = AS_BLOCK_HEADER(ptr, -(sljit_sw)sizeof(struct block_header));
+	header = AS_BLOCK_HEADER(header, -header->executable_offset);
+	allocated_size -= header->size;
+
+	/* Connecting free blocks together if possible. */
+
+	/* If header->prev_size == 0, free_block will equal to header.
+	   In this case, free_block->header.size will be > 0. */
+	free_block = AS_FREE_BLOCK(header, -(sljit_sw)header->prev_size);
+	if (SLJIT_UNLIKELY(!free_block->header.size)) {
+		free_block->size += header->size;
+		header = AS_BLOCK_HEADER(free_block, free_block->size);
+		header->prev_size = free_block->size;
+	}
+	else {
+		free_block = (struct free_block*)header;
+		sljit_insert_free_block(free_block, header->size);
+	}
+
+	header = AS_BLOCK_HEADER(free_block, free_block->size);
+	if (SLJIT_UNLIKELY(!header->size)) {
+		free_block->size += ((struct free_block*)header)->size;
+		sljit_remove_free_block((struct free_block*)header);
+		header = AS_BLOCK_HEADER(free_block, free_block->size);
+		header->prev_size = free_block->size;
+	}
+
+	/* The whole chunk is free. */
+	if (SLJIT_UNLIKELY(!free_block->header.prev_size && header->size == 1)) {
+		/* If this block is freed, we still have (allocated_size / 2) free space. */
+		if (total_size - free_block->size > (allocated_size * 3 / 2)) {
+			total_size -= free_block->size;
+			sljit_remove_free_block(free_block);
+			free_chunk(free_block, free_block->size +
+				sizeof(struct chunk_header) +
+				sizeof(struct block_header));
+		}
+	}
+
+	SLJIT_ALLOCATOR_UNLOCK();
+}
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_unused_memory_exec(void)
+{
+	struct free_block* free_block;
+	struct free_block* next_free_block;
+
+	SLJIT_ALLOCATOR_LOCK();
+
+	free_block = free_blocks;
+	while (free_block) {
+		next_free_block = free_block->next;
+		if (!free_block->header.prev_size && 
+				AS_BLOCK_HEADER(free_block, free_block->size)->size == 1) {
+			total_size -= free_block->size;
+			sljit_remove_free_block(free_block);
+			free_chunk(free_block, free_block->size +
+				sizeof(struct chunk_header) +
+				sizeof(struct block_header));
+		}
+		free_block = next_free_block;
+	}
+
+	SLJIT_ASSERT((total_size && free_blocks) || (!total_size && !free_blocks));
+	SLJIT_ALLOCATOR_UNLOCK();
+}
+
+SLJIT_API_FUNC_ATTRIBUTE sljit_sw sljit_exec_offset(void* ptr)
+{
+	return ((struct block_header *)(ptr))[-1].executable_offset;
+}
diff --git a/src/3rdparty/pcre2/src/sljit/sljitUtils.c b/src/3rdparty/pcre2/src/sljit/sljitUtils.c
index 0276fa1b8b..08ca35cf37 100644
--- a/src/3rdparty/pcre2/src/sljit/sljitUtils.c
+++ b/src/3rdparty/pcre2/src/sljit/sljitUtils.c
@@ -28,131 +28,50 @@
 /*  Locks                                                                   */
 /* ------------------------------------------------------------------------ */
 
-#if (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR) || (defined SLJIT_UTIL_GLOBAL_LOCK && SLJIT_UTIL_GLOBAL_LOCK)
+/* Executable Allocator */
 
+#if (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR) \
+	&& !(defined SLJIT_WX_EXECUTABLE_ALLOCATOR && SLJIT_WX_EXECUTABLE_ALLOCATOR)
 #if (defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED)
-
-#if (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR)
-
-static SLJIT_INLINE void allocator_grab_lock(void)
-{
-	/* Always successful. */
-}
-
-static SLJIT_INLINE void allocator_release_lock(void)
-{
-	/* Always successful. */
-}
-
-#endif /* SLJIT_EXECUTABLE_ALLOCATOR */
-
-#if (defined SLJIT_UTIL_GLOBAL_LOCK && SLJIT_UTIL_GLOBAL_LOCK)
-
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_grab_lock(void)
-{
-	/* Always successful. */
-}
-
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_release_lock(void)
-{
-	/* Always successful. */
-}
-
-#endif /* SLJIT_UTIL_GLOBAL_LOCK */
-
-#elif defined(_WIN32) /* SLJIT_SINGLE_THREADED */
-
-#include "windows.h"
-
-#if (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR)
-
-static HANDLE allocator_mutex = 0;
-
-static SLJIT_INLINE void allocator_grab_lock(void)
-{
-	/* No idea what to do if an error occures. Static mutexes should never fail... */
-	if (!allocator_mutex)
-		allocator_mutex = CreateMutex(NULL, TRUE, NULL);
-	else
-		WaitForSingleObject(allocator_mutex, INFINITE);
-}
-
-static SLJIT_INLINE void allocator_release_lock(void)
-{
-	ReleaseMutex(allocator_mutex);
-}
-
-#endif /* SLJIT_EXECUTABLE_ALLOCATOR */
-
-#if (defined SLJIT_UTIL_GLOBAL_LOCK && SLJIT_UTIL_GLOBAL_LOCK)
-
-static HANDLE global_mutex = 0;
-
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_grab_lock(void)
-{
-	/* No idea what to do if an error occures. Static mutexes should never fail... */
-	if (!global_mutex)
-		global_mutex = CreateMutex(NULL, TRUE, NULL);
-	else
-		WaitForSingleObject(global_mutex, INFINITE);
-}
-
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_release_lock(void)
-{
-	ReleaseMutex(global_mutex);
-}
-
-#endif /* SLJIT_UTIL_GLOBAL_LOCK */
-
-#else /* _WIN32 */
-
-#if (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR)
-
+#define SLJIT_ALLOCATOR_LOCK()
+#define SLJIT_ALLOCATOR_UNLOCK()
+#elif !(defined _WIN32)
 #include <pthread.h>
 
-static pthread_mutex_t allocator_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-static SLJIT_INLINE void allocator_grab_lock(void)
-{
-	pthread_mutex_lock(&allocator_mutex);
-}
+static pthread_mutex_t allocator_lock = PTHREAD_MUTEX_INITIALIZER;
 
-static SLJIT_INLINE void allocator_release_lock(void)
-{
-	pthread_mutex_unlock(&allocator_mutex);
-}
+#define SLJIT_ALLOCATOR_LOCK() pthread_mutex_lock(&allocator_lock)
+#define SLJIT_ALLOCATOR_UNLOCK() pthread_mutex_unlock(&allocator_lock)
+#else /* windows */
+static HANDLE allocator_lock;
 
-#endif /* SLJIT_EXECUTABLE_ALLOCATOR */
-
-#if (defined SLJIT_UTIL_GLOBAL_LOCK && SLJIT_UTIL_GLOBAL_LOCK)
-
-#include <pthread.h>
-
-static pthread_mutex_t global_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_grab_lock(void)
-{
-	pthread_mutex_lock(&global_mutex);
-}
-
-SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_release_lock(void)
+static SLJIT_INLINE void allocator_grab_lock(void)
 {
-	pthread_mutex_unlock(&global_mutex);
+	HANDLE lock;
+	if (SLJIT_UNLIKELY(!allocator_lock)) {
+		lock = CreateMutex(NULL, FALSE, NULL);
+		if (InterlockedCompareExchangePointer(&allocator_lock, lock, NULL))
+			CloseHandle(lock);
+	}
+	WaitForSingleObject(allocator_lock, INFINITE);
 }
 
-#endif /* SLJIT_UTIL_GLOBAL_LOCK */
-
-#endif /* _WIN32 */
+#define SLJIT_ALLOCATOR_LOCK() allocator_grab_lock()
+#define SLJIT_ALLOCATOR_UNLOCK() ReleaseMutex(allocator_lock)
+#endif /* thread implementation */
+#endif /* SLJIT_EXECUTABLE_ALLOCATOR && !SLJIT_WX_EXECUTABLE_ALLOCATOR */
 
 /* ------------------------------------------------------------------------ */
 /*  Stack                                                                   */
 /* ------------------------------------------------------------------------ */
 
-#if (defined SLJIT_UTIL_STACK && SLJIT_UTIL_STACK) || (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR)
+#if ((defined SLJIT_UTIL_STACK && SLJIT_UTIL_STACK) \
+	&& !(defined SLJIT_UTIL_SIMPLE_STACK_ALLOCATION && SLJIT_UTIL_SIMPLE_STACK_ALLOCATION)) \
+	|| ((defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR) \
+	&& !((defined SLJIT_PROT_EXECUTABLE_ALLOCATOR && SLJIT_PROT_EXECUTABLE_ALLOCATOR) \
+	|| (defined SLJIT_WX_EXECUTABLE_ALLOCATOR && SLJIT_WX_EXECUTABLE_ALLOCATOR)))
 
-#ifdef _WIN32
-#include "windows.h"
-#else /* !_WIN32 */
+#ifndef _WIN32
 /* Provides mmap function. */
 #include <sys/types.h>
 #include <sys/mman.h>
@@ -163,56 +82,84 @@ SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_release_lock(void)
 #endif /* MAP_ANONYMOUS */
 #endif /* !MAP_ANON */
 
-#ifndef MADV_DONTNEED
-#ifdef POSIX_MADV_DONTNEED
-#define MADV_DONTNEED POSIX_MADV_DONTNEED
-#endif /* POSIX_MADV_DONTNEED */
-#endif /* !MADV_DONTNEED */
-
-/* For detecting the page size. */
-#include <unistd.h>
-
 #ifndef MAP_ANON
 
 #include <fcntl.h>
 
-/* Some old systems does not have MAP_ANON. */
-static sljit_s32 dev_zero = -1;
+#ifdef O_CLOEXEC
+#define SLJIT_CLOEXEC	O_CLOEXEC
+#else /* !O_CLOEXEC */
+#define SLJIT_CLOEXEC	0
+#endif /* O_CLOEXEC */
+
+/* Some old systems do not have MAP_ANON. */
+static int dev_zero = -1;
 
 #if (defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED)
 
-static SLJIT_INLINE sljit_s32 open_dev_zero(void)
+static SLJIT_INLINE int open_dev_zero(void)
 {
-	dev_zero = open("/dev/zero", O_RDWR);
+	dev_zero = open("/dev/zero", O_RDWR | SLJIT_CLOEXEC);
+
 	return dev_zero < 0;
 }
 
-#else /* SLJIT_SINGLE_THREADED */
+#else /* !SLJIT_SINGLE_THREADED */
 
 #include <pthread.h>
 
 static pthread_mutex_t dev_zero_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-static SLJIT_INLINE sljit_s32 open_dev_zero(void)
+static SLJIT_INLINE int open_dev_zero(void)
 {
 	pthread_mutex_lock(&dev_zero_mutex);
-	/* The dev_zero might be initialized by another thread during the waiting. */
-	if (dev_zero < 0) {
-		dev_zero = open("/dev/zero", O_RDWR);
-	}
+	if (SLJIT_UNLIKELY(dev_zero < 0))
+		dev_zero = open("/dev/zero", O_RDWR | SLJIT_CLOEXEC);
+
 	pthread_mutex_unlock(&dev_zero_mutex);
 	return dev_zero < 0;
 }
 
 #endif /* SLJIT_SINGLE_THREADED */
-
+#undef SLJIT_CLOEXEC
 #endif /* !MAP_ANON */
+#endif /* !_WIN32 */
+#endif /* open_dev_zero */
 
-#endif /* _WIN32 */
+#if (defined SLJIT_UTIL_STACK && SLJIT_UTIL_STACK) \
+	|| (defined SLJIT_EXECUTABLE_ALLOCATOR && SLJIT_EXECUTABLE_ALLOCATOR)
 
-#endif /* SLJIT_UTIL_STACK || SLJIT_EXECUTABLE_ALLOCATOR */
+#ifdef _WIN32
 
-#endif /* SLJIT_EXECUTABLE_ALLOCATOR || SLJIT_UTIL_GLOBAL_LOCK */
+static SLJIT_INLINE sljit_sw get_page_alignment(void) {
+	SYSTEM_INFO si;
+	static sljit_sw sljit_page_align;
+	if (!sljit_page_align) {
+		GetSystemInfo(&si);
+		sljit_page_align = si.dwPageSize - 1;
+	}
+	return sljit_page_align;
+}
+
+#else
+
+#include <unistd.h>
+
+static SLJIT_INLINE sljit_sw get_page_alignment(void) {
+	static sljit_sw sljit_page_align;
+	if (!sljit_page_align) {
+		sljit_page_align = sysconf(_SC_PAGESIZE);
+		/* Should never happen. */
+		if (sljit_page_align < 0)
+			sljit_page_align = 4096;
+		sljit_page_align--;
+	}
+	return sljit_page_align;
+}
+
+#endif /* _WIN32 */
+
+#endif /* get_page_alignment() */
 
 #if (defined SLJIT_UTIL_STACK && SLJIT_UTIL_STACK)
 
@@ -264,16 +211,6 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_u8 *SLJIT_FUNC sljit_stack_resize(struct sljit_st
 
 #ifdef _WIN32
 
-SLJIT_INLINE static sljit_sw get_page_alignment(void) {
-	SYSTEM_INFO si;
-	static sljit_sw sljit_page_align;
-	if (!sljit_page_align) {
-		GetSystemInfo(&si);
-		sljit_page_align = si.dwPageSize - 1;
-	}
-	return sljit_page_align;
-}
-
 SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_free_stack(struct sljit_stack *stack, void *allocator_data)
 {
 	SLJIT_UNUSED_ARG(allocator_data);
@@ -281,19 +218,7 @@ SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_free_stack(struct sljit_stack *st
 	SLJIT_FREE(stack, allocator_data);
 }
 
-#else /* ! defined _WIN32 */
-
-SLJIT_INLINE static sljit_sw get_page_alignment(void) {
-	static sljit_sw sljit_page_align;
-	if (!sljit_page_align) {
-		sljit_page_align = sysconf(_SC_PAGESIZE);
-		/* Should never happen. */
-		if (sljit_page_align < 0)
-			sljit_page_align = 4096;
-		sljit_page_align--;
-	}
-	return sljit_page_align;
-}
+#else /* !_WIN32 */
 
 SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_free_stack(struct sljit_stack *stack, void *allocator_data)
 {
@@ -302,7 +227,7 @@ SLJIT_API_FUNC_ATTRIBUTE void SLJIT_FUNC sljit_free_stack(struct sljit_stack *st
 	SLJIT_FREE(stack, allocator_data);
 }
 
-#endif /* defined _WIN32 */
+#endif /* _WIN32 */
 
 SLJIT_API_FUNC_ATTRIBUTE struct sljit_stack* SLJIT_FUNC sljit_allocate_stack(sljit_uw start_size, sljit_uw max_size, void *allocator_data)
 {
@@ -342,11 +267,9 @@ SLJIT_API_FUNC_ATTRIBUTE struct sljit_stack* SLJIT_FUNC sljit_allocate_stack(slj
 #ifdef MAP_ANON
 	ptr = mmap(NULL, max_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
 #else /* !MAP_ANON */
-	if (dev_zero < 0) {
-		if (open_dev_zero() != 0) {
-			SLJIT_FREE(stack, allocator_data);
-			return NULL;
-		}
+	if (SLJIT_UNLIKELY((dev_zero < 0) && open_dev_zero())) {
+		SLJIT_FREE(stack, allocator_data);
+		return NULL;
 	}
 	ptr = mmap(NULL, max_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, dev_zero, 0);
 #endif /* MAP_ANON */
@@ -365,7 +288,7 @@ SLJIT_API_FUNC_ATTRIBUTE struct sljit_stack* SLJIT_FUNC sljit_allocate_stack(slj
 
 SLJIT_API_FUNC_ATTRIBUTE sljit_u8 *SLJIT_FUNC sljit_stack_resize(struct sljit_stack *stack, sljit_u8 *new_start)
 {
-#if defined _WIN32 || defined(MADV_DONTNEED)
+#if defined _WIN32 || defined(POSIX_MADV_DONTNEED)
 	sljit_uw aligned_old_start;
 	sljit_uw aligned_new_start;
 	sljit_sw page_align;
@@ -389,15 +312,19 @@ SLJIT_API_FUNC_ATTRIBUTE sljit_u8 *SLJIT_FUNC sljit_stack_resize(struct sljit_st
 				return NULL;
 		}
 	}
-#elif defined(MADV_DONTNEED)
+#elif defined(POSIX_MADV_DONTNEED)
 	if (stack->start < new_start) {
 		page_align = get_page_alignment();
 
 		aligned_new_start = (sljit_uw)new_start & ~page_align;
 		aligned_old_start = ((sljit_uw)stack->start) & ~page_align;
-		/* If madvise is available, we release the unnecessary space. */
-		if (aligned_new_start > aligned_old_start)
-			madvise((void*)aligned_old_start, aligned_new_start - aligned_old_start, MADV_DONTNEED);
+
+		if (aligned_new_start > aligned_old_start) {
+			posix_madvise((void*)aligned_old_start, aligned_new_start - aligned_old_start, POSIX_MADV_DONTNEED);
+#ifdef MADV_FREE
+			madvise((void*)aligned_old_start, aligned_new_start - aligned_old_start, MADV_FREE);
+#endif /* MADV_FREE */
+		}
 	}
 #endif /* _WIN32 */
 
diff --git a/src/3rdparty/pcre2/src/sljit/sljitWXExecAllocator.c b/src/3rdparty/pcre2/src/sljit/sljitWXExecAllocator.c
new file mode 100644
index 0000000000..6ef71f7d83
--- /dev/null
+++ b/src/3rdparty/pcre2/src/sljit/sljitWXExecAllocator.c
@@ -0,0 +1,225 @@
+/*
+ *    Stack-less Just-In-Time compiler
+ *
+ *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are
+ * permitted provided that the following conditions are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright notice, this list of
+ *      conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *      of conditions and the following disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+   This file contains a simple W^X executable memory allocator for POSIX
+   like systems and Windows
+
+   In *NIX, MAP_ANON is required (that is considered a feature) so make
+   sure to set the right availability macros for your system or the code
+   will fail to build.
+
+   If your system doesn't support mapping of anonymous pages (ex: IRIX) it
+   is also likely that it doesn't need this allocator and should be using
+   the standard one instead.
+
+   It allocates a separate map for each code block and may waste a lot of
+   memory, because whatever was requested, will be rounded up to the page
+   size (minimum 4KB, but could be even bigger).
+
+   It changes the page permissions (RW <-> RX) as needed and therefore, if you
+   will be updating the code after it has been generated, need to make sure to
+   block any concurrent execution, or could result in a SIGBUS, that could
+   even manifest itself at a different address than the one that was being
+   modified.
+
+   Only use if you are unable to use the regular allocator because of security
+   restrictions and adding exceptions to your application or the system are
+   not possible.
+*/
+
+#define SLJIT_UPDATE_WX_FLAGS(from, to, enable_exec) \
+	sljit_update_wx_flags((from), (to), (enable_exec))
+
+#ifndef _WIN32
+#include <sys/types.h>
+#include <sys/mman.h>
+
+#ifdef __NetBSD__
+#if defined(PROT_MPROTECT)
+#define check_se_protected(ptr, size) (0)
+#define SLJIT_PROT_WX PROT_MPROTECT(PROT_EXEC)
+#else /* !PROT_MPROTECT */
+#ifdef _NETBSD_SOURCE
+#include <sys/param.h>
+#else /* !_NETBSD_SOURCE */
+typedef unsigned int	u_int;
+#define devmajor_t sljit_s32
+#endif /* _NETBSD_SOURCE */
+#include <sys/sysctl.h>
+#include <unistd.h>
+
+#define check_se_protected(ptr, size) netbsd_se_protected()
+
+static SLJIT_INLINE int netbsd_se_protected(void)
+{
+	int mib[3];
+	int paxflags;
+	size_t len = sizeof(paxflags);
+
+	mib[0] = CTL_PROC;
+	mib[1] = getpid();
+	mib[2] = PROC_PID_PAXFLAGS;
+
+	if (SLJIT_UNLIKELY(sysctl(mib, 3, &paxflags, &len, NULL, 0) < 0))
+		return -1;
+
+	return (paxflags & CTL_PROC_PAXFLAGS_MPROTECT) ? -1 : 0;
+}
+#endif /* PROT_MPROTECT */
+#else /* POSIX */
+#define check_se_protected(ptr, size) generic_se_protected(ptr, size)
+
+static SLJIT_INLINE int generic_se_protected(void *ptr, sljit_uw size)
+{
+	if (SLJIT_LIKELY(!mprotect(ptr, size, PROT_EXEC)))
+		return mprotect(ptr, size, PROT_READ | PROT_WRITE);
+
+	return -1;
+}
+#endif /* NetBSD */
+
+#if defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED
+#define SLJIT_SE_LOCK()
+#define SLJIT_SE_UNLOCK()
+#else /* !SLJIT_SINGLE_THREADED */
+#include <pthread.h>
+#define SLJIT_SE_LOCK()	pthread_mutex_lock(&se_lock)
+#define SLJIT_SE_UNLOCK()	pthread_mutex_unlock(&se_lock)
+#endif /* SLJIT_SINGLE_THREADED */
+
+#ifndef SLJIT_PROT_WX
+#define SLJIT_PROT_WX 0
+#endif /* !SLJIT_PROT_WX */
+
+SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
+{
+#if !(defined SLJIT_SINGLE_THREADED && SLJIT_SINGLE_THREADED)
+	static pthread_mutex_t se_lock = PTHREAD_MUTEX_INITIALIZER;
+#endif
+	static int se_protected = !SLJIT_PROT_WX;
+	sljit_uw* ptr;
+
+	if (SLJIT_UNLIKELY(se_protected < 0))
+		return NULL;
+
+	size += sizeof(sljit_uw);
+	ptr = (sljit_uw*)mmap(NULL, size, PROT_READ | PROT_WRITE | SLJIT_PROT_WX,
+				MAP_PRIVATE | MAP_ANON, -1, 0);
+
+	if (ptr == MAP_FAILED)
+		return NULL;
+
+	if (SLJIT_UNLIKELY(se_protected > 0)) {
+		SLJIT_SE_LOCK();
+		se_protected = check_se_protected(ptr, size);
+		SLJIT_SE_UNLOCK();
+		if (SLJIT_UNLIKELY(se_protected < 0)) {
+			munmap((void *)ptr, size);
+			return NULL;
+		}
+	}
+
+	*ptr++ = size;
+	return ptr;
+}
+
+#undef SLJIT_PROT_WX
+#undef SLJIT_SE_UNLOCK
+#undef SLJIT_SE_LOCK
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_exec(void* ptr)
+{
+	sljit_uw *start_ptr = ((sljit_uw*)ptr) - 1;
+	munmap((void*)start_ptr, *start_ptr);
+}
+
+static void sljit_update_wx_flags(void *from, void *to, sljit_s32 enable_exec)
+{
+	sljit_uw page_mask = (sljit_uw)get_page_alignment();
+	sljit_uw start = (sljit_uw)from;
+	sljit_uw end = (sljit_uw)to;
+	int prot = PROT_READ | (enable_exec ? PROT_EXEC : PROT_WRITE);
+
+	SLJIT_ASSERT(start < end);
+
+	start &= ~page_mask;
+	end = (end + page_mask) & ~page_mask;
+
+	mprotect((void*)start, end - start, prot);
+}
+
+#else /* windows */
+
+SLJIT_API_FUNC_ATTRIBUTE void* sljit_malloc_exec(sljit_uw size)
+{
+	sljit_uw *ptr;
+
+	size += sizeof(sljit_uw);
+	ptr = (sljit_uw*)VirtualAlloc(NULL, size,
+				MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
+
+	if (!ptr)
+		return NULL;
+
+	*ptr++ = size;
+
+	return ptr;
+}
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_exec(void* ptr)
+{
+	sljit_uw start = (sljit_uw)ptr - sizeof(sljit_uw);
+#if defined(SLJIT_DEBUG) && SLJIT_DEBUG
+	sljit_uw page_mask = (sljit_uw)get_page_alignment();
+
+	SLJIT_ASSERT(!(start & page_mask));
+#endif
+	VirtualFree((void*)start, 0, MEM_RELEASE);
+}
+
+static void sljit_update_wx_flags(void *from, void *to, sljit_s32 enable_exec)
+{
+	DWORD oldprot;
+	sljit_uw page_mask = (sljit_uw)get_page_alignment();
+	sljit_uw start = (sljit_uw)from;
+	sljit_uw end = (sljit_uw)to;
+	DWORD prot = enable_exec ? PAGE_EXECUTE : PAGE_READWRITE;
+
+	SLJIT_ASSERT(start < end);
+
+	start &= ~page_mask;
+	end = (end + page_mask) & ~page_mask;
+
+	VirtualProtect((void*)start, end - start, prot, &oldprot);
+}
+
+#endif /* !windows */
+
+SLJIT_API_FUNC_ATTRIBUTE void sljit_free_unused_memory_exec(void)
+{
+	/* This allocator does not keep unused memory for future allocations. */
+}
-- 
2.31.1

