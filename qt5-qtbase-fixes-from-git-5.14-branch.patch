diff --git a/config.tests/arch/write_info.pri b/config.tests/arch/write_info.pri
index 666b9e5cbb..5b43ce1cd5 100644
--- a/config.tests/arch/write_info.pri
+++ b/config.tests/arch/write_info.pri
@@ -4,10 +4,7 @@ targetinfofile ~= s/pro$/target.txt/
 win32 {
     ext = .exe
 } else:wasm {
-    equals(WASM_OBJECT_FILES, 1): \
-        ext = .o
-    else: \
-        ext = .wasm
+    ext = .wasm
 }
 
 content = $${file_prefix}$${TARGET}$${ext}
diff --git a/doc/global/config.qdocconf b/doc/global/config.qdocconf
index 0b276c400f..16d4e5c63a 100644
--- a/doc/global/config.qdocconf
+++ b/doc/global/config.qdocconf
@@ -11,6 +11,12 @@ dita.metadata.default.audience = programmer
 navigation.homepage = index.html
 navigation.hometitle = "Qt $QT_VER"
 
+#Words to ignore for auto-linking
+ignorewords += \
+    macOS \
+    WebChannel \
+    OpenGL
+
 sourcedirs += includes $$BUILDDIR
 
 url = http://doc.qt.io/qt-5
diff --git a/examples/corelib/mimetypes/mimetypebrowser/main.cpp b/examples/corelib/mimetypes/mimetypebrowser/main.cpp
index cf87004a01..679d97dc7b 100644
--- a/examples/corelib/mimetypes/mimetypebrowser/main.cpp
+++ b/examples/corelib/mimetypes/mimetypebrowser/main.cpp
@@ -51,7 +51,7 @@
 #include "mainwindow.h"
 
 #include <QApplication>
-#include <QDesktopWidget>
+#include <QScreen>
 
 #include <QCommandLineParser>
 #include <QCommandLineOption>
@@ -68,7 +68,7 @@ int main(int argc, char *argv[])
     parser.process(app);
 
     MainWindow mainWindow;
-    const QRect availableGeometry = QApplication::desktop()->availableGeometry(&mainWindow);
+    const QRect availableGeometry = mainWindow.screen()->availableGeometry();
     mainWindow.resize(availableGeometry.width() / 3, availableGeometry.height() / 2);
     mainWindow.show();
 
diff --git a/examples/network/http/main.cpp b/examples/network/http/main.cpp
index b7d254ff22..f126c7846a 100644
--- a/examples/network/http/main.cpp
+++ b/examples/network/http/main.cpp
@@ -49,8 +49,8 @@
 ****************************************************************************/
 
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QDir>
+#include <QScreen>
 
 #include "httpwindow.h"
 
@@ -59,7 +59,7 @@ int main(int argc, char *argv[])
     QApplication app(argc, argv);
 
     HttpWindow httpWin;
-    const QRect availableSize = QApplication::desktop()->availableGeometry(&httpWin);
+    const QRect availableSize = httpWin.screen()->availableGeometry();
     httpWin.resize(availableSize.width() / 5, availableSize.height() / 5);
     httpWin.move((availableSize.width() - httpWin.width()) / 2, (availableSize.height() - httpWin.height()) / 2);
 
diff --git a/examples/opengl/threadedqopenglwidget/main.cpp b/examples/opengl/threadedqopenglwidget/main.cpp
index 983f608543..975def030b 100644
--- a/examples/opengl/threadedqopenglwidget/main.cpp
+++ b/examples/opengl/threadedqopenglwidget/main.cpp
@@ -50,7 +50,7 @@
 
 #include <QApplication>
 #include <QMainWindow>
-#include <QDesktopWidget>
+#include <QScreen>
 #include <QSurfaceFormat>
 #include <QOpenGLContext>
 #include <QCommandLineParser>
@@ -90,7 +90,7 @@ int main( int argc, char ** argv )
     // The rendering for the four QOpenGLWidgets happens on four separate threads.
 
     GLWidget topLevelGlWidget;
-    QPoint pos = QApplication::desktop()->availableGeometry(&topLevelGlWidget).topLeft() + QPoint(200, 200);
+    QPoint pos = topLevelGlWidget.screen()->availableGeometry().topLeft() + QPoint(200, 200);
     topLevelGlWidget.setWindowTitle(QStringLiteral("Threaded QOpenGLWidget example top level"));
     topLevelGlWidget.resize(200, 200);
     topLevelGlWidget.move(pos);
diff --git a/examples/widgets/desktop/screenshot/main.cpp b/examples/widgets/desktop/screenshot/main.cpp
index 825c40b236..96b0d57daa 100644
--- a/examples/widgets/desktop/screenshot/main.cpp
+++ b/examples/widgets/desktop/screenshot/main.cpp
@@ -49,7 +49,7 @@
 ****************************************************************************/
 
 #include <QApplication>
-#include <QDesktopWidget>
+#include <QScreen>
 
 #include "screenshot.h"
 
@@ -58,7 +58,8 @@ int main(int argc, char *argv[])
     QApplication app(argc, argv);
 
     Screenshot screenshot;
-    screenshot.move(QApplication::desktop()->availableGeometry(&screenshot).topLeft() + QPoint(20, 20));
+    screenshot.move(screenshot.screen()->availableGeometry().topLeft() + QPoint(20, 20));
     screenshot.show();
+
     return app.exec();
 }
diff --git a/examples/widgets/desktop/screenshot/screenshot.cpp b/examples/widgets/desktop/screenshot/screenshot.cpp
index 715e6c780e..ce5597bbdd 100644
--- a/examples/widgets/desktop/screenshot/screenshot.cpp
+++ b/examples/widgets/desktop/screenshot/screenshot.cpp
@@ -59,7 +59,7 @@ Screenshot::Screenshot()
     screenshotLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
     screenshotLabel->setAlignment(Qt::AlignCenter);
 
-    const QRect screenGeometry = QApplication::desktop()->screenGeometry(this);
+    const QRect screenGeometry = screen()->geometry();
     screenshotLabel->setMinimumSize(screenGeometry.width() / 8, screenGeometry.height() / 8);
 
     QVBoxLayout *mainLayout = new QVBoxLayout(this);
diff --git a/examples/widgets/dialogs/classwizard/classwizard.cpp b/examples/widgets/dialogs/classwizard/classwizard.cpp
index 81adf85b0d..8421289eab 100644
--- a/examples/widgets/dialogs/classwizard/classwizard.cpp
+++ b/examples/widgets/dialogs/classwizard/classwizard.cpp
@@ -118,9 +118,9 @@ void ClassWizard::accept()
     block += "public:\n";
 
     if (field("qobjectCtor").toBool()) {
-        block += "    " + className + "(QObject *parent = 0);\n";
+        block += "    " + className + "(QObject *parent = nullptr);\n";
     } else if (field("qwidgetCtor").toBool()) {
-        block += "    " + className + "(QWidget *parent = 0);\n";
+        block += "    " + className + "(QWidget *parent = nullptr);\n";
     } else if (field("defaultCtor").toBool()) {
         block += "    " + className + "();\n";
         if (field("copyCtor").toBool()) {
diff --git a/examples/widgets/dialogs/classwizard/classwizard.h b/examples/widgets/dialogs/classwizard/classwizard.h
index fee0f6df66..0c386f0553 100644
--- a/examples/widgets/dialogs/classwizard/classwizard.h
+++ b/examples/widgets/dialogs/classwizard/classwizard.h
@@ -67,7 +67,7 @@ class ClassWizard : public QWizard
     Q_OBJECT
 
 public:
-    ClassWizard(QWidget *parent = 0);
+    ClassWizard(QWidget *parent = nullptr);
 
     void accept() override;
 };
@@ -79,7 +79,7 @@ class IntroPage : public QWizardPage
     Q_OBJECT
 
 public:
-    IntroPage(QWidget *parent = 0);
+    IntroPage(QWidget *parent = nullptr);
 
 private:
     QLabel *label;
@@ -92,7 +92,7 @@ class ClassInfoPage : public QWizardPage
     Q_OBJECT
 
 public:
-    ClassInfoPage(QWidget *parent = 0);
+    ClassInfoPage(QWidget *parent = nullptr);
 
 private:
     QLabel *classNameLabel;
@@ -114,7 +114,7 @@ class CodeStylePage : public QWizardPage
     Q_OBJECT
 
 public:
-    CodeStylePage(QWidget *parent = 0);
+    CodeStylePage(QWidget *parent = nullptr);
 
 protected:
     void initializePage() override;
@@ -135,7 +135,7 @@ class OutputFilesPage : public QWizardPage
     Q_OBJECT
 
 public:
-    OutputFilesPage(QWidget *parent = 0);
+    OutputFilesPage(QWidget *parent = nullptr);
 
 protected:
     void initializePage() override;
@@ -154,7 +154,7 @@ class ConclusionPage : public QWizardPage
     Q_OBJECT
 
 public:
-    ConclusionPage(QWidget *parent = 0);
+    ConclusionPage(QWidget *parent = nullptr);
 
 protected:
     void initializePage() override;
diff --git a/examples/widgets/dialogs/extension/finddialog.h b/examples/widgets/dialogs/extension/finddialog.h
index 858e1c929b..9b4b5b5f3d 100644
--- a/examples/widgets/dialogs/extension/finddialog.h
+++ b/examples/widgets/dialogs/extension/finddialog.h
@@ -68,7 +68,7 @@ class FindDialog : public QDialog
     Q_OBJECT
 
 public:
-    FindDialog(QWidget *parent = 0);
+    FindDialog(QWidget *parent = nullptr);
 
 private:
     QLabel *label;
diff --git a/examples/widgets/dialogs/findfiles/window.h b/examples/widgets/dialogs/findfiles/window.h
index 949df704bb..b74ba5e70c 100644
--- a/examples/widgets/dialogs/findfiles/window.h
+++ b/examples/widgets/dialogs/findfiles/window.h
@@ -68,7 +68,7 @@ class Window : public QWidget
     Q_OBJECT
 
 public:
-    Window(QWidget *parent = 0);
+    Window(QWidget *parent = nullptr);
 
 private slots:
     void browse();
diff --git a/examples/widgets/dialogs/licensewizard/licensewizard.h b/examples/widgets/dialogs/licensewizard/licensewizard.h
index c7709d88b3..e2890e484f 100644
--- a/examples/widgets/dialogs/licensewizard/licensewizard.h
+++ b/examples/widgets/dialogs/licensewizard/licensewizard.h
@@ -72,7 +72,7 @@ public:
            Page_Conclusion };
 //! [2]
 
-    LicenseWizard(QWidget *parent = 0);
+    LicenseWizard(QWidget *parent = nullptr);
 
 private slots:
     void showHelp();
@@ -86,7 +86,7 @@ class IntroPage : public QWizardPage
     Q_OBJECT
 
 public:
-    IntroPage(QWidget *parent = 0);
+    IntroPage(QWidget *parent = nullptr);
 
     int nextId() const override;
 
@@ -103,7 +103,7 @@ class EvaluatePage : public QWizardPage
     Q_OBJECT
 
 public:
-    EvaluatePage(QWidget *parent = 0);
+    EvaluatePage(QWidget *parent = nullptr);
 
     int nextId() const override;
 
@@ -120,7 +120,7 @@ class RegisterPage : public QWizardPage
     Q_OBJECT
 
 public:
-    RegisterPage(QWidget *parent = 0);
+    RegisterPage(QWidget *parent = nullptr);
 
     int nextId() const override;
 
@@ -136,7 +136,7 @@ class DetailsPage : public QWizardPage
     Q_OBJECT
 
 public:
-    DetailsPage(QWidget *parent = 0);
+    DetailsPage(QWidget *parent = nullptr);
 
     int nextId() const override;
 
@@ -155,7 +155,7 @@ class ConclusionPage : public QWizardPage
     Q_OBJECT
 
 public:
-    ConclusionPage(QWidget *parent = 0);
+    ConclusionPage(QWidget *parent = nullptr);
 
     void initializePage() override;
     int nextId() const override;
diff --git a/examples/widgets/dialogs/standarddialogs/dialog.h b/examples/widgets/dialogs/standarddialogs/dialog.h
index 0d1c8d3e54..6d9cbdc07a 100644
--- a/examples/widgets/dialogs/standarddialogs/dialog.h
+++ b/examples/widgets/dialogs/standarddialogs/dialog.h
@@ -66,7 +66,7 @@ class Dialog : public QWidget
     Q_OBJECT
 
 public:
-    Dialog(QWidget *parent = 0);
+    Dialog(QWidget *parent = nullptr);
 
 private slots:
     void setInteger();
diff --git a/examples/widgets/dialogs/standarddialogs/main.cpp b/examples/widgets/dialogs/standarddialogs/main.cpp
index f7417f0e45..19ed2bf66f 100644
--- a/examples/widgets/dialogs/standarddialogs/main.cpp
+++ b/examples/widgets/dialogs/standarddialogs/main.cpp
@@ -49,8 +49,8 @@
 ****************************************************************************/
 
 #include <QApplication>
+#include <QScreen>
 #include <QStyleHints>
-#include <QDesktopWidget>
 #include <QTranslator>
 #include <QLocale>
 #include <QLibraryInfo>
@@ -73,7 +73,7 @@ int main(int argc, char *argv[])
 
     Dialog dialog;
     if (!QGuiApplication::styleHints()->showIsFullScreen() && !QGuiApplication::styleHints()->showIsMaximized()) {
-        const QRect availableGeometry = QApplication::desktop()->availableGeometry(&dialog);
+        const QRect availableGeometry = dialog.screen()->availableGeometry();
         dialog.resize(availableGeometry.width() / 3, availableGeometry.height() * 2 / 3);
         dialog.move((availableGeometry.width() - dialog.width()) / 2,
                     (availableGeometry.height() - dialog.height()) / 2);
diff --git a/examples/widgets/dialogs/tabdialog/tabdialog.h b/examples/widgets/dialogs/tabdialog/tabdialog.h
index 2db47c9ddd..b7c6c5b8da 100644
--- a/examples/widgets/dialogs/tabdialog/tabdialog.h
+++ b/examples/widgets/dialogs/tabdialog/tabdialog.h
@@ -65,7 +65,7 @@ class GeneralTab : public QWidget
     Q_OBJECT
 
 public:
-    explicit GeneralTab(const QFileInfo &fileInfo, QWidget *parent = 0);
+    explicit GeneralTab(const QFileInfo &fileInfo, QWidget *parent = nullptr);
 };
 //! [0]
 
@@ -76,7 +76,7 @@ class PermissionsTab : public QWidget
     Q_OBJECT
 
 public:
-    explicit PermissionsTab(const QFileInfo &fileInfo, QWidget *parent = 0);
+    explicit PermissionsTab(const QFileInfo &fileInfo, QWidget *parent = nullptr);
 };
 //! [1]
 
@@ -87,7 +87,7 @@ class ApplicationsTab : public QWidget
     Q_OBJECT
 
 public:
-    explicit ApplicationsTab(const QFileInfo &fileInfo, QWidget *parent = 0);
+    explicit ApplicationsTab(const QFileInfo &fileInfo, QWidget *parent = nullptr);
 };
 //! [2]
 
@@ -98,7 +98,7 @@ class TabDialog : public QDialog
     Q_OBJECT
 
 public:
-    explicit TabDialog(const QString &fileName, QWidget *parent = 0);
+    explicit TabDialog(const QString &fileName, QWidget *parent = nullptr);
 
 private:
     QTabWidget *tabWidget;
diff --git a/examples/widgets/effects/blurpicker/blurpicker.h b/examples/widgets/effects/blurpicker/blurpicker.h
index 3f444419a8..dc7fc4dabb 100644
--- a/examples/widgets/effects/blurpicker/blurpicker.h
+++ b/examples/widgets/effects/blurpicker/blurpicker.h
@@ -63,7 +63,7 @@ class BlurPicker: public QGraphicsView
     Q_PROPERTY(qreal index READ index WRITE setIndex)
 
 public:
-    BlurPicker(QWidget *parent = 0);
+    BlurPicker(QWidget *parent = nullptr);
 
     qreal index() const;
     void setIndex(qreal);
diff --git a/examples/widgets/effects/fademessage/fademessage.h b/examples/widgets/effects/fademessage/fademessage.h
index d17a1616ce..4d84c4ed21 100644
--- a/examples/widgets/effects/fademessage/fademessage.h
+++ b/examples/widgets/effects/fademessage/fademessage.h
@@ -62,7 +62,7 @@ class FadeMessage: public QGraphicsView
     Q_OBJECT
 
 public:
-    FadeMessage(QWidget *parent = 0);
+    FadeMessage(QWidget *parent = nullptr);
 
 private:
     void setupScene();
diff --git a/examples/widgets/gestures/imagegestures/imagewidget.cpp b/examples/widgets/gestures/imagegestures/imagewidget.cpp
index 0a6b963559..fb5351f949 100644
--- a/examples/widgets/gestures/imagegestures/imagewidget.cpp
+++ b/examples/widgets/gestures/imagegestures/imagewidget.cpp
@@ -50,26 +50,23 @@
 
 #include "imagewidget.h"
 
-#include <QtWidgets>
+#include <QDir>
+#include <QImageReader>
+#include <QGestureEvent>
+#include <QPainter>
 
 Q_LOGGING_CATEGORY(lcExample, "qt.examples.imagegestures")
 
 //! [constructor]
 ImageWidget::ImageWidget(QWidget *parent)
-    : QWidget(parent),
-    position(0),
-    horizontalOffset(0),
-    verticalOffset(0),
-    rotationAngle(0),
-    scaleFactor(1),
-    currentStepScaleFactor(1)
-
+    : QWidget(parent), position(0), horizontalOffset(0), verticalOffset(0)
+    , rotationAngle(0), scaleFactor(1), currentStepScaleFactor(1)
 {
-    setMinimumSize(QSize(100,100));
+    setMinimumSize(QSize(100, 100));
 }
 //! [constructor]
 
-void ImageWidget::grabGestures(const QList<Qt::GestureType> &gestures)
+void ImageWidget::grabGestures(const QVector<Qt::GestureType> &gestures)
 {
     //! [enable gestures]
     for (Qt::GestureType gesture : gestures)
@@ -96,11 +93,11 @@ void ImageWidget::paintEvent(QPaintEvent*)
     const qreal wh = height();
     const qreal ww = width();
 
-    p.translate(ww/2, wh/2);
+    p.translate(ww / 2, wh / 2);
     p.translate(horizontalOffset, verticalOffset);
     p.rotate(rotationAngle);
     p.scale(currentStepScaleFactor * scaleFactor, currentStepScaleFactor * scaleFactor);
-    p.translate(-iw/2, -ih/2);
+    p.translate(-iw / 2, -ih / 2);
     p.drawImage(0, 0, currentImage);
 }
 //! [paint method]
@@ -198,8 +195,7 @@ void ImageWidget::openDirectory(const QString &path)
 {
     this->path = path;
     QDir dir(path);
-    QStringList nameFilters;
-    nameFilters << "*.jpg" << "*.png";
+    const QStringList nameFilters{"*.jpg", "*.png"};
     files = dir.entryList(nameFilters, QDir::Files|QDir::Readable, QDir::Name);
 
     position = 0;
@@ -207,7 +203,7 @@ void ImageWidget::openDirectory(const QString &path)
     update();
 }
 
-QImage ImageWidget::loadImage(const QString &fileName)
+QImage ImageWidget::loadImage(const QString &fileName) const
 {
     QImageReader reader(fileName);
     reader.setAutoTransform(true);
diff --git a/examples/widgets/gestures/imagegestures/imagewidget.h b/examples/widgets/gestures/imagegestures/imagewidget.h
index 5e92541067..ae5eb7bc2b 100644
--- a/examples/widgets/gestures/imagegestures/imagewidget.h
+++ b/examples/widgets/gestures/imagegestures/imagewidget.h
@@ -51,9 +51,9 @@
 #ifndef IMAGEWIDGET_H
 #define IMAGEWIDGET_H
 
-#include <QWidget>
 #include <QImage>
-#include <QtWidgets>
+#include <QLoggingCategory>
+#include <QWidget>
 
 QT_BEGIN_NAMESPACE
 class QGestureEvent;
@@ -70,9 +70,9 @@ class ImageWidget : public QWidget
     Q_OBJECT
 
 public:
-    ImageWidget(QWidget *parent = 0);
+    ImageWidget(QWidget *parent = nullptr);
     void openDirectory(const QString &path);
-    void grabGestures(const QList<Qt::GestureType> &gestures);
+    void grabGestures(const QVector<Qt::GestureType> &gestures);
 
 protected:
     bool event(QEvent *event) override;
@@ -87,7 +87,7 @@ private:
     void swipeTriggered(QSwipeGesture*);
 //! [class definition begin]
 
-    QImage loadImage(const QString &fileName);
+    QImage loadImage(const QString &fileName) const;
     void loadImage();
     void goNextImage();
     void goPrevImage();
diff --git a/examples/widgets/gestures/imagegestures/main.cpp b/examples/widgets/gestures/imagegestures/main.cpp
index ecd7462bd3..4f8d4ec15e 100644
--- a/examples/widgets/gestures/imagegestures/main.cpp
+++ b/examples/widgets/gestures/imagegestures/main.cpp
@@ -102,7 +102,7 @@ int main(int argc, char *argv[])
         return -1;
     }
 
-    QList<Qt::GestureType> gestures;
+    QVector<Qt::GestureType> gestures;
     if (!commandLineParser.isSet(disablePanOption))
         gestures << Qt::PanGesture;
     if (!commandLineParser.isSet(disablePinchOption))
diff --git a/examples/widgets/gestures/imagegestures/mainwidget.cpp b/examples/widgets/gestures/imagegestures/mainwidget.cpp
index c4e63e9e7d..d1c786a93a 100644
--- a/examples/widgets/gestures/imagegestures/mainwidget.cpp
+++ b/examples/widgets/gestures/imagegestures/mainwidget.cpp
@@ -72,7 +72,7 @@ void MainWidget::openDirectory(const QString &path)
     imageWidget->openDirectory(path);
 }
 
-void MainWidget::grabGestures(const QList<Qt::GestureType> &gestures)
+void MainWidget::grabGestures(const QVector<Qt::GestureType> &gestures)
 {
     imageWidget->grabGestures(gestures);
 }
diff --git a/examples/widgets/gestures/imagegestures/mainwidget.h b/examples/widgets/gestures/imagegestures/mainwidget.h
index f3763ffffc..1600597251 100644
--- a/examples/widgets/gestures/imagegestures/mainwidget.h
+++ b/examples/widgets/gestures/imagegestures/mainwidget.h
@@ -60,8 +60,8 @@ class MainWidget : public QMainWindow
     Q_OBJECT
 
 public:
-    MainWidget(QWidget *parent = 0);
-    void grabGestures(const QList<Qt::GestureType> &gestures);
+    MainWidget(QWidget *parent = nullptr);
+    void grabGestures(const QVector<Qt::GestureType> &gestures);
 
 public slots:
     void openDirectory(const QString &path);
diff --git a/examples/widgets/graphicsview/collidingmice/mouse.cpp b/examples/widgets/graphicsview/collidingmice/mouse.cpp
index 556e58d19b..8375092c39 100644
--- a/examples/widgets/graphicsview/collidingmice/mouse.cpp
+++ b/examples/widgets/graphicsview/collidingmice/mouse.cpp
@@ -69,8 +69,9 @@ static qreal normalizeAngle(qreal angle)
 }
 
 //! [0]
-Mouse::Mouse()
-    : color(QRandomGenerator::global()->bounded(256), QRandomGenerator::global()->bounded(256), QRandomGenerator::global()->bounded(256))
+Mouse::Mouse() : color(QRandomGenerator::global()->bounded(256),
+                       QRandomGenerator::global()->bounded(256),
+                       QRandomGenerator::global()->bounded(256))
 {
     setRotation(QRandomGenerator::global()->bounded(360 * 16));
 }
diff --git a/examples/widgets/graphicsview/flowlayout/flowlayout.cpp b/examples/widgets/graphicsview/flowlayout/flowlayout.cpp
index 54914b3746..03cf320568 100644
--- a/examples/widgets/graphicsview/flowlayout/flowlayout.cpp
+++ b/examples/widgets/graphicsview/flowlayout/flowlayout.cpp
@@ -62,7 +62,7 @@ FlowLayout::FlowLayout(QGraphicsLayoutItem *parent) : QGraphicsLayout(parent)
 void FlowLayout::insertItem(int index, QGraphicsLayoutItem *item)
 {
     item->setParentLayoutItem(this);
-    if (index > m_items.count())
+    if (index > m_items.count() || index < 0)
         index = m_items.count();
     m_items.insert(index, item);
     invalidate();
diff --git a/examples/widgets/itemviews/dirview/main.cpp b/examples/widgets/itemviews/dirview/main.cpp
index 9fecffda40..fcdf4c7ba4 100644
--- a/examples/widgets/itemviews/dirview/main.cpp
+++ b/examples/widgets/itemviews/dirview/main.cpp
@@ -49,9 +49,9 @@
 ****************************************************************************/
 
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QFileSystemModel>
 #include <QFileIconProvider>
+#include <QScreen>
 #include <QTreeView>
 #include <QCommandLineParser>
 #include <QCommandLineOption>
@@ -92,7 +92,7 @@ int main(int argc, char *argv[])
     tree.setAnimated(false);
     tree.setIndentation(20);
     tree.setSortingEnabled(true);
-    const QSize availableSize = QApplication::desktop()->availableGeometry(&tree).size();
+    const QSize availableSize = tree.screen()->availableGeometry().size();
     tree.resize(availableSize / 2);
     tree.setColumnWidth(0, tree.width() / 3);
 
diff --git a/examples/widgets/itemviews/frozencolumn/main.cpp b/examples/widgets/itemviews/frozencolumn/main.cpp
index 6f2b4a8d71..2965617ba1 100644
--- a/examples/widgets/itemviews/frozencolumn/main.cpp
+++ b/examples/widgets/itemviews/frozencolumn/main.cpp
@@ -71,7 +71,7 @@ int main(int argc, char* argv[])
         model->setHorizontalHeaderLabels(list);
 
         int row = 0;
-        QStandardItem *newItem = 0;
+        QStandardItem *newItem = nullptr;
         while (!stream.atEnd()) {
             line = stream.readLine();
             if (!line.startsWith('#') && line.contains(',')) {
diff --git a/examples/widgets/itemviews/interview/model.cpp b/examples/widgets/itemviews/interview/model.cpp
index feaf8bb98c..519164999d 100644
--- a/examples/widgets/itemviews/interview/model.cpp
+++ b/examples/widgets/itemviews/interview/model.cpp
@@ -132,7 +132,7 @@ bool Model::hasChildren(const QModelIndex &parent) const
 Qt::ItemFlags Model::flags(const QModelIndex &index) const
 {
     if (!index.isValid())
-        return 0;
+        return {};
     return Qt::ItemIsDragEnabled|QAbstractItemModel::flags(index);
 }
 
@@ -146,7 +146,7 @@ Model::Node *Model::node(int row, Node *parent) const
 
 Model::Node *Model::parent(Node *child) const
 {
-    return child ? child->parent : 0;
+    return child ? child->parent : nullptr;
 }
 
 int Model::row(Node *node) const
diff --git a/examples/widgets/itemviews/stardelegate/main.cpp b/examples/widgets/itemviews/stardelegate/main.cpp
index 452976bba0..5ca85a6151 100644
--- a/examples/widgets/itemviews/stardelegate/main.cpp
+++ b/examples/widgets/itemviews/stardelegate/main.cpp
@@ -48,7 +48,8 @@
 **
 ****************************************************************************/
 
-#include <QtWidgets>
+#include <QApplication>
+#include <QTableWidget>
 
 #include "stardelegate.h"
 #include "stareditor.h"
@@ -57,7 +58,7 @@
 //! [0]
 void populateTableWidget(QTableWidget *tableWidget)
 {
-    static const struct {
+    static constexpr struct {
         const char *title;
         const char *genre;
         const char *artist;
@@ -70,12 +71,12 @@ void populateTableWidget(QTableWidget *tableWidget)
         { "Sex Bomb", "Pop", "Tom Jones", 3 },
         { "Barbie Girl", "Pop", "Aqua", 5 },
 //! [2]
-        { 0, 0, 0, 0 }
+        { nullptr, nullptr, nullptr, 0 }
 //! [2] //! [3]
     };
 //! [3] //! [4]
 
-    for (int row = 0; staticData[row].title != 0; ++row) {
+    for (int row = 0; staticData[row].title != nullptr; ++row) {
         QTableWidgetItem *item0 = new QTableWidgetItem(staticData[row].title);
         QTableWidgetItem *item1 = new QTableWidgetItem(staticData[row].genre);
         QTableWidgetItem *item2 = new QTableWidgetItem(staticData[row].artist);
diff --git a/examples/widgets/mainwindows/application/mainwindow.cpp b/examples/widgets/mainwindows/application/mainwindow.cpp
index 7886c4afac..d0c009427f 100644
--- a/examples/widgets/mainwindows/application/mainwindow.cpp
+++ b/examples/widgets/mainwindows/application/mainwindow.cpp
@@ -281,7 +281,7 @@ void MainWindow::readSettings()
     QSettings settings(QCoreApplication::organizationName(), QCoreApplication::applicationName());
     const QByteArray geometry = settings.value("geometry", QByteArray()).toByteArray();
     if (geometry.isEmpty()) {
-        const QRect availableGeometry = QApplication::desktop()->availableGeometry(this);
+        const QRect availableGeometry = screen()->availableGeometry();
         resize(availableGeometry.width() / 3, availableGeometry.height() / 2);
         move((availableGeometry.width() - width()) / 2,
              (availableGeometry.height() - height()) / 2);
diff --git a/examples/widgets/mainwindows/mdi/mainwindow.cpp b/examples/widgets/mainwindows/mdi/mainwindow.cpp
index b952d19e2e..ccfa7435d7 100644
--- a/examples/widgets/mainwindows/mdi/mainwindow.cpp
+++ b/examples/widgets/mainwindows/mdi/mainwindow.cpp
@@ -464,7 +464,7 @@ void MainWindow::readSettings()
     QSettings settings(QCoreApplication::organizationName(), QCoreApplication::applicationName());
     const QByteArray geometry = settings.value("geometry", QByteArray()).toByteArray();
     if (geometry.isEmpty()) {
-        const QRect availableGeometry = QApplication::desktop()->availableGeometry(this);
+        const QRect availableGeometry = screen()->availableGeometry();
         resize(availableGeometry.width() / 3, availableGeometry.height() / 2);
         move((availableGeometry.width() - width()) / 2,
              (availableGeometry.height() - height()) / 2);
diff --git a/examples/widgets/mainwindows/sdi/mainwindow.cpp b/examples/widgets/mainwindows/sdi/mainwindow.cpp
index a1fb42158e..c3cd131923 100644
--- a/examples/widgets/mainwindows/sdi/mainwindow.cpp
+++ b/examples/widgets/mainwindows/sdi/mainwindow.cpp
@@ -167,7 +167,7 @@ void MainWindow::tile(const QMainWindow *previous)
     if (!topFrameWidth)
         topFrameWidth = 40;
     const QPoint pos = previous->pos() + 2 * QPoint(topFrameWidth, topFrameWidth);
-    if (QApplication::desktop()->availableGeometry(this).contains(rect().bottomRight() + pos))
+    if (screen()->availableGeometry().contains(rect().bottomRight() + pos))
         move(pos);
 }
 
@@ -290,7 +290,7 @@ void MainWindow::readSettings()
     QSettings settings(QCoreApplication::organizationName(), QCoreApplication::applicationName());
     const QByteArray geometry = settings.value("geometry", QByteArray()).toByteArray();
     if (geometry.isEmpty()) {
-        const QRect availableGeometry = QApplication::desktop()->availableGeometry(this);
+        const QRect availableGeometry = screen()->availableGeometry();
         resize(availableGeometry.width() / 3, availableGeometry.height() / 2);
         move((availableGeometry.width() - width()) / 2,
              (availableGeometry.height() - height()) / 2);
diff --git a/examples/widgets/painting/deform/pathdeform.cpp b/examples/widgets/painting/deform/pathdeform.cpp
index 64e81f8cab..d5c8746247 100644
--- a/examples/widgets/painting/deform/pathdeform.cpp
+++ b/examples/widgets/painting/deform/pathdeform.cpp
@@ -262,7 +262,7 @@ PathDeformWidget::PathDeformWidget(QWidget *parent, bool smallScreen)
     QHBoxLayout *mainLayout = new QHBoxLayout(this);
     mainLayout->addWidget(m_renderer);
 
-    m_controls = new PathDeformControls(0, m_renderer, smallScreen);
+    m_controls = new PathDeformControls(nullptr, m_renderer, smallScreen);
     m_controls->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);
 
     if (!smallScreen)
diff --git a/examples/widgets/painting/fontsampler/mainwindow.h b/examples/widgets/painting/fontsampler/mainwindow.h
index ffb2839ffa..34e54440d4 100644
--- a/examples/widgets/painting/fontsampler/mainwindow.h
+++ b/examples/widgets/painting/fontsampler/mainwindow.h
@@ -70,7 +70,7 @@ class MainWindow : public QMainWindow, private Ui::MainWindowBase
     Q_OBJECT
 
 public:
-    MainWindow(QWidget *parent = 0);
+    MainWindow(QWidget *parent = nullptr);
 
 public slots:
     void on_clearAction_triggered();
diff --git a/examples/widgets/painting/gradients/gradients.cpp b/examples/widgets/painting/gradients/gradients.cpp
index a4528ce06f..d62ae93a15 100644
--- a/examples/widgets/painting/gradients/gradients.cpp
+++ b/examples/widgets/painting/gradients/gradients.cpp
@@ -102,9 +102,9 @@ uint ShadeWidget::colorAt(int x)
     generateShade();
 
     QPolygonF pts = m_hoverPoints->points();
-    for (int i=1; i < pts.size(); ++i) {
-        if (pts.at(i-1).x() <= x && pts.at(i).x() >= x) {
-            QLineF l(pts.at(i-1), pts.at(i));
+    for (int i = 1; i < pts.size(); ++i) {
+        if (pts.at(i - 1).x() <= x && pts.at(i).x() >= x) {
+            QLineF l(pts.at(i - 1), pts.at(i));
             l.setLength(l.length() * ((x - l.x1()) / l.dx()));
             return m_shade.pixel(qRound(qMin(l.x2(), (qreal(m_shade.width() - 1)))),
                                  qRound(qMin(l.y2(), qreal(m_shade.height() - 1))));
@@ -118,9 +118,9 @@ void ShadeWidget::setGradientStops(const QGradientStops &stops)
     if (m_shade_type == ARGBShade) {
         m_alpha_gradient = QLinearGradient(0, 0, width(), 0);
 
-        for (int i=0; i<stops.size(); ++i) {
-            QColor c = stops.at(i).second;
-            m_alpha_gradient.setColorAt(stops.at(i).first, QColor(c.red(), c.green(), c.blue()));
+        for (const auto &stop : stops) {
+            QColor c = stop.second;
+            m_alpha_gradient.setColorAt(stop.first, QColor(c.red(), c.green(), c.blue()));
         }
 
         m_shade = QImage();
@@ -223,13 +223,13 @@ void GradientEditor::pointsUpdated()
     std::sort(points.begin(), points.end(), x_less_than);
 
     for (int i = 0; i < points.size(); ++i) {
-        qreal x = int(points.at(i).x());
-        if (i + 1 < points.size() && x == points.at(i + 1).x())
+        const int x = int(points.at(i).x());
+        if (i + 1 < points.size() && x == int(points.at(i + 1).x()))
             continue;
-        QColor color((0x00ff0000 & m_red_shade->colorAt(int(x))) >> 16,
-                     (0x0000ff00 & m_green_shade->colorAt(int(x))) >> 8,
-                     (0x000000ff & m_blue_shade->colorAt(int(x))),
-                     (0xff000000 & m_alpha_shade->colorAt(int(x))) >> 24);
+        QColor color((0x00ff0000 & m_red_shade->colorAt(x)) >> 16,
+                     (0x0000ff00 & m_green_shade->colorAt(x)) >> 8,
+                     (0x000000ff & m_blue_shade->colorAt(x)),
+                     (0xff000000 & m_alpha_shade->colorAt(x)) >> 24);
 
         if (x / w > 1)
             return;
@@ -568,8 +568,8 @@ void GradientRenderer::paint(QPainter *p)
         g = QConicalGradient(pts.at(0), angle);
     }
 
-    for (int i = 0; i < m_stops.size(); ++i)
-        g.setColorAt(m_stops.at(i).first, m_stops.at(i).second);
+    for (const auto &stop : qAsConst(m_stops))
+        g.setColorAt(stop.first, stop.second);
 
     g.setSpread(m_spread);
 
diff --git a/examples/widgets/painting/gradients/gradients.h b/examples/widgets/painting/gradients/gradients.h
index c6525d18f8..45ef5d0f93 100644
--- a/examples/widgets/painting/gradients/gradients.h
+++ b/examples/widgets/painting/gradients/gradients.h
@@ -157,7 +157,7 @@ class GradientWidget : public QWidget
     Q_OBJECT
 
 public:
-    GradientWidget(QWidget *parent);
+    GradientWidget(QWidget *parent = nullptr);
 
 public slots:
     void setDefault1() { setDefault(1); }
diff --git a/examples/widgets/painting/gradients/main.cpp b/examples/widgets/painting/gradients/main.cpp
index 539d67e40e..0ddf7a4579 100644
--- a/examples/widgets/painting/gradients/main.cpp
+++ b/examples/widgets/painting/gradients/main.cpp
@@ -58,8 +58,8 @@ int main(int argc, char *argv[])
 
     QApplication app(argc, argv);
 
-    GradientWidget gradientWidget(0);
-    QStyle *arthurStyle = new ArthurStyle();
+    GradientWidget gradientWidget;
+    QStyle *arthurStyle = new ArthurStyle;
     gradientWidget.setStyle(arthurStyle);
     const QList<QWidget *> widgets = gradientWidget.findChildren<QWidget *>();
     for (QWidget *w : widgets) {
diff --git a/examples/widgets/painting/painterpaths/renderarea.h b/examples/widgets/painting/painterpaths/renderarea.h
index 5f0874b772..4b3ea5a397 100644
--- a/examples/widgets/painting/painterpaths/renderarea.h
+++ b/examples/widgets/painting/painterpaths/renderarea.h
@@ -60,7 +60,7 @@ class RenderArea : public QWidget
     Q_OBJECT
 
 public:
-    explicit RenderArea(const QPainterPath &path, QWidget *parent = 0);
+    explicit RenderArea(const QPainterPath &path, QWidget *parent = nullptr);
 
     QSize minimumSizeHint() const override;
     QSize sizeHint() const override;
diff --git a/examples/widgets/painting/pathstroke/pathstroke.cpp b/examples/widgets/painting/pathstroke/pathstroke.cpp
index e4009f0b1a..a850ce2672 100644
--- a/examples/widgets/painting/pathstroke/pathstroke.cpp
+++ b/examples/widgets/painting/pathstroke/pathstroke.cpp
@@ -48,11 +48,9 @@
 **
 ****************************************************************************/
 
+#include "pathstroke.h"
 #include "arthurstyle.h"
 #include "arthurwidgets.h"
-#include "pathstroke.h"
-
-#include <stdio.h>
 
 extern void draw_round_rect(QPainter *p, const QRect &bounds, int radius);
 
@@ -164,24 +162,39 @@ void PathStrokeControls::createCommonControls(QWidget* parent)
 
 
     // Connections
-    connect(flatCap, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setFlatCap);
-    connect(squareCap, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setSquareCap);
-    connect(roundCap, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setRoundCap);
-
-    connect(bevelJoin, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setBevelJoin);
-    connect(miterJoin, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setMiterJoin);
-    connect(svgMiterJoin, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setSvgMiterJoin);
-    connect(roundJoin, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setRoundJoin);
-
-    connect(curveMode, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setCurveMode);
-    connect(lineMode, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setLineMode);
-
-    connect(solidLine, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setSolidLine);
-    connect(dashLine, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setDashLine);
-    connect(dotLine, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setDotLine);
-    connect(dashDotLine, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setDashDotLine);
-    connect(dashDotDotLine, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setDashDotDotLine);
-    connect(customDashLine, &QAbstractButton::clicked, m_renderer, &PathStrokeRenderer::setCustomDashLine);
+    connect(flatCap, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setFlatCap);
+    connect(squareCap, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setSquareCap);
+    connect(roundCap, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setRoundCap);
+
+    connect(bevelJoin, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setBevelJoin);
+    connect(miterJoin, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setMiterJoin);
+    connect(svgMiterJoin, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setSvgMiterJoin);
+    connect(roundJoin, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setRoundJoin);
+
+    connect(curveMode, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setCurveMode);
+    connect(lineMode, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setLineMode);
+
+    connect(solidLine, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setSolidLine);
+    connect(dashLine, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setDashLine);
+    connect(dotLine, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setDotLine);
+    connect(dashDotLine, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setDashDotLine);
+    connect(dashDotDotLine, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setDashDotDotLine);
+    connect(customDashLine, &QAbstractButton::clicked,
+            m_renderer, &PathStrokeRenderer::setCustomDashLine);
 
     // Set the defaults:
     flatCap->setChecked(true);
@@ -247,15 +260,20 @@ void PathStrokeControls::layoutForDesktop()
 
 
     // Set up connections
-    connect(animated, &QAbstractButton::toggled, m_renderer, &PathStrokeRenderer::setAnimation);
+    connect(animated, &QAbstractButton::toggled,
+            m_renderer, &PathStrokeRenderer::setAnimation);
 
-    connect(penWidth, &QAbstractSlider::valueChanged, m_renderer, &PathStrokeRenderer::setPenWidth);
+    connect(penWidth, &QAbstractSlider::valueChanged,
+            m_renderer, &PathStrokeRenderer::setPenWidth);
 
-    connect(showSourceButton, &QAbstractButton::clicked, m_renderer, &ArthurFrame::showSource);
+    connect(showSourceButton, &QAbstractButton::clicked,
+            m_renderer, &ArthurFrame::showSource);
 #if QT_CONFIG(opengl)
-    connect(enableOpenGLButton, &QAbstractButton::clicked, m_renderer, &ArthurFrame::enableOpenGL);
+    connect(enableOpenGLButton, &QAbstractButton::clicked,
+            m_renderer, &ArthurFrame::enableOpenGL);
 #endif
-    connect(whatsThisButton, &QAbstractButton::clicked, m_renderer, &ArthurFrame::setDescriptionEnabled);
+    connect(whatsThisButton, &QAbstractButton::clicked,
+            m_renderer, &ArthurFrame::setDescriptionEnabled);
     connect(m_renderer, &ArthurFrame::descriptionEnabledChanged,
             whatsThisButton, &QAbstractButton::setChecked);
 
@@ -296,11 +314,11 @@ void PathStrokeControls::layoutForSmallScreens()
 #endif
 
     // Layouts:
-    QHBoxLayout *penWidthLayout = new QHBoxLayout(0);
+    QHBoxLayout *penWidthLayout = new QHBoxLayout;
     penWidthLayout->addWidget(penWidthLabel, 0, Qt::AlignRight);
     penWidthLayout->addWidget(penWidth);
 
-    QVBoxLayout *leftLayout = new QVBoxLayout(0);
+    QVBoxLayout *leftLayout = new QVBoxLayout;
     leftLayout->addWidget(m_capGroup);
     leftLayout->addWidget(m_joinGroup);
 #if QT_CONFIG(opengl)
@@ -308,7 +326,7 @@ void PathStrokeControls::layoutForSmallScreens()
 #endif
     leftLayout->addLayout(penWidthLayout);
 
-    QVBoxLayout *rightLayout = new QVBoxLayout(0);
+    QVBoxLayout *rightLayout = new QVBoxLayout;
     rightLayout->addWidget(m_styleGroup);
     rightLayout->addWidget(m_pathModeGroup);
 
@@ -356,7 +374,7 @@ PathStrokeWidget::PathStrokeWidget(bool smallScreen)
     // Widget construction and property setting
     m_renderer = new PathStrokeRenderer(this, smallScreen);
 
-    m_controls = new PathStrokeControls(0, m_renderer, smallScreen);
+    m_controls = new PathStrokeControls(nullptr, m_renderer, smallScreen);
 
     // Layouting
     QHBoxLayout *viewLayout = new QHBoxLayout(this);
@@ -383,10 +401,10 @@ void PathStrokeWidget::hideControls()
     m_controls->hide();
 }
 
-void PathStrokeWidget::setStyle( QStyle * style )
+void PathStrokeWidget::setStyle(QStyle *style)
 {
     QWidget::setStyle(style);
-    if (m_controls != 0)
+    if (m_controls != nullptr)
     {
         m_controls->setStyle(style);
 
@@ -516,7 +534,7 @@ void PathStrokeRenderer::updatePoints()
     qreal bottom = height() - pad;
 
     Q_ASSERT(m_points.size() == m_vectors.size());
-    for (int i=0; i<m_points.size(); ++i) {
+    for (int i = 0; i < m_points.size(); ++i) {
         QPointF pos = m_points.at(i);
         QPointF vec = m_vectors.at(i);
         pos += vec;
@@ -540,7 +558,7 @@ void PathStrokeRenderer::mousePressEvent(QMouseEvent *e)
     setDescriptionEnabled(false);
     m_activePoint = -1;
     qreal distance = -1;
-    for (int i=0; i<m_points.size(); ++i) {
+    for (int i = 0; i < m_points.size(); ++i) {
         qreal d = QLineF(e->pos(), m_points.at(i)).length();
         if ((distance < 0 && d < 8 * m_pointSize) || d < distance) {
             distance = d;
@@ -673,7 +691,6 @@ bool PathStrokeRenderer::event(QEvent *e)
         m_fingerPointMapping.clear();
         setAnimation(m_wasAnimated);
         return true;
-        break;
     default:
         break;
     }
diff --git a/examples/widgets/painting/pathstroke/pathstroke.h b/examples/widgets/painting/pathstroke/pathstroke.h
index 7bc7e09003..b559ed2ba0 100644
--- a/examples/widgets/painting/pathstroke/pathstroke.h
+++ b/examples/widgets/painting/pathstroke/pathstroke.h
@@ -169,7 +169,7 @@ class PathStrokeWidget : public QWidget
 
 public:
     PathStrokeWidget(bool smallScreen);
-    void setStyle ( QStyle * style );
+    void setStyle(QStyle *style);
 
 private:
     PathStrokeRenderer *m_renderer;
diff --git a/examples/widgets/painting/shared/arthurstyle.h b/examples/widgets/painting/shared/arthurstyle.h
index 8ea8354bab..64c888b636 100644
--- a/examples/widgets/painting/shared/arthurstyle.h
+++ b/examples/widgets/painting/shared/arthurstyle.h
@@ -63,7 +63,7 @@ public:
     void drawHoverRect(QPainter *painter, const QRect &rect) const;
 
     void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
-                       QPainter *painter, const QWidget *widget = 0) const override;
+                       QPainter *painter, const QWidget *widget = nullptr) const override;
     void drawControl(ControlElement element, const QStyleOption *option,
                      QPainter *painter, const QWidget *widget) const override;
     void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
diff --git a/examples/widgets/painting/shared/arthurwidgets.cpp b/examples/widgets/painting/shared/arthurwidgets.cpp
index 285be99d20..40d712c9e3 100644
--- a/examples/widgets/painting/shared/arthurwidgets.cpp
+++ b/examples/widgets/painting/shared/arthurwidgets.cpp
@@ -136,7 +136,7 @@ void ArthurFrame::createGlWindow()
 
 void ArthurFrame::paintEvent(QPaintEvent *e)
 {
-    static QImage *static_image = 0;
+    static QImage *static_image = nullptr;
 
     QPainter painter;
 
@@ -376,7 +376,7 @@ void ArthurFrame::showSource()
 
     const QString html = QStringLiteral("<html><pre>") + contents + QStringLiteral("</pre></html>");
 
-    QTextBrowser *sourceViewer = new QTextBrowser(0);
+    QTextBrowser *sourceViewer = new QTextBrowser;
     sourceViewer->setWindowTitle(tr("Source: %1").arg(m_sourceFileName.midRef(5)));
     sourceViewer->setParent(this, Qt::Dialog);
     sourceViewer->setAttribute(Qt::WA_DeleteOnClose);
diff --git a/examples/widgets/painting/shared/fbopaintdevice.cpp b/examples/widgets/painting/shared/fbopaintdevice.cpp
index 8207090cc8..9368293218 100644
--- a/examples/widgets/painting/shared/fbopaintdevice.cpp
+++ b/examples/widgets/painting/shared/fbopaintdevice.cpp
@@ -53,7 +53,7 @@
 #include <QOffscreenSurface>
 #include <QOpenGLFunctions>
 
-QFboPaintDevice::QFboPaintDevice(const QSize& size, bool flipped, bool clearOnInit,
+QFboPaintDevice::QFboPaintDevice(const QSize &size, bool flipped, bool clearOnInit,
                                  QOpenGLFramebufferObject::Attachment attachment)
         : QOpenGLPaintDevice(size)
 {
@@ -97,8 +97,8 @@ GLuint QFboPaintDevice::takeTexture()
 
 QImage QFboPaintDevice::toImage() const
 {
-    QOpenGLContext* currentContext = QOpenGLContext::currentContext();
-    QSurface* currentSurface = currentContext ? currentContext->surface() : 0;
+    QOpenGLContext *currentContext = QOpenGLContext::currentContext();
+    QSurface *currentSurface = currentContext ? currentContext->surface() : nullptr;
 
     context()->makeCurrent(m_surface);
 
diff --git a/examples/widgets/painting/shared/fbopaintdevice.h b/examples/widgets/painting/shared/fbopaintdevice.h
index 78451af895..a42bcc756d 100644
--- a/examples/widgets/painting/shared/fbopaintdevice.h
+++ b/examples/widgets/painting/shared/fbopaintdevice.h
@@ -60,7 +60,7 @@
 
 class QFboPaintDevice : public QOpenGLPaintDevice {
 public:
-    QFboPaintDevice(const QSize&, bool flipped = false, bool clearOnInit = true,
+    QFboPaintDevice(const QSize &size, bool flipped = false, bool clearOnInit = true,
         QOpenGLFramebufferObject::Attachment = QOpenGLFramebufferObject::CombinedDepthStencil);
     ~QFboPaintDevice();
 
@@ -83,7 +83,7 @@ public:
 
 private:
     QOpenGLFramebufferObject *m_framebufferObject;
-    QSurface* m_surface;
+    QSurface *m_surface;
 };
 
 #endif // QT_NO_OPENGL
diff --git a/examples/widgets/painting/shared/hoverpoints.cpp b/examples/widgets/painting/shared/hoverpoints.cpp
index 2032fb5a2c..2bf3963e9e 100644
--- a/examples/widgets/painting/shared/hoverpoints.cpp
+++ b/examples/widgets/painting/shared/hoverpoints.cpp
@@ -262,8 +262,8 @@ bool HoverPoints::eventFilter(QObject *object, QEvent *event)
         case QEvent::Paint:
         {
             QWidget *that_widget = m_widget;
-            m_widget = 0;
-            QApplication::sendEvent(object, event);
+            m_widget = nullptr;
+            QCoreApplication::sendEvent(object, event);
             m_widget = that_widget;
             paintPoints();
             return true;
diff --git a/examples/widgets/painting/transformations/renderarea.h b/examples/widgets/painting/transformations/renderarea.h
index 140be27b2b..d4be7cefa4 100644
--- a/examples/widgets/painting/transformations/renderarea.h
+++ b/examples/widgets/painting/transformations/renderarea.h
@@ -70,7 +70,7 @@ class RenderArea : public QWidget
     Q_OBJECT
 
 public:
-    RenderArea(QWidget *parent = 0);
+    RenderArea(QWidget *parent = nullptr);
 
     void setOperations(const QList<Operation> &operations);
     void setShape(const QPainterPath &shape);
diff --git a/examples/widgets/richtext/textedit/main.cpp b/examples/widgets/richtext/textedit/main.cpp
index aef186aa77..256d183811 100644
--- a/examples/widgets/richtext/textedit/main.cpp
+++ b/examples/widgets/richtext/textedit/main.cpp
@@ -51,9 +51,9 @@
 #include "textedit.h"
 
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QCommandLineParser>
 #include <QCommandLineOption>
+#include <QScreen>
 
 int main(int argc, char *argv[])
 {
@@ -72,7 +72,7 @@ int main(int argc, char *argv[])
 
     TextEdit mw;
 
-    const QRect availableGeometry = QApplication::desktop()->availableGeometry(&mw);
+    const QRect availableGeometry = mw.screen()->availableGeometry();
     mw.resize(availableGeometry.width() / 2, (availableGeometry.height() * 2) / 3);
     mw.move((availableGeometry.width() - mw.width()) / 2,
             (availableGeometry.height() - mw.height()) / 2);
diff --git a/examples/widgets/richtext/textedit/textedit.cpp b/examples/widgets/richtext/textedit/textedit.cpp
index 996bb8e0a4..85fb83ab89 100644
--- a/examples/widgets/richtext/textedit/textedit.cpp
+++ b/examples/widgets/richtext/textedit/textedit.cpp
@@ -640,7 +640,7 @@ void TextEdit::textStyle(int styleIndex)
 {
     QTextCursor cursor = textEdit->textCursor();
     QTextListFormat::Style style = QTextListFormat::ListStyleUndefined;
-    QTextBlockFormat::MarkerType marker = QTextBlockFormat::NoMarker;
+    QTextBlockFormat::MarkerType marker = QTextBlockFormat::MarkerType::NoMarker;
 
     switch (styleIndex) {
     case 1:
@@ -657,14 +657,14 @@ void TextEdit::textStyle(int styleIndex)
             style = cursor.currentList()->format().style();
         else
             style = QTextListFormat::ListDisc;
-        marker = QTextBlockFormat::Unchecked;
+        marker = QTextBlockFormat::MarkerType::Unchecked;
         break;
     case 5:
         if (cursor.currentList())
             style = cursor.currentList()->format().style();
         else
             style = QTextListFormat::ListDisc;
-        marker = QTextBlockFormat::Checked;
+        marker = QTextBlockFormat::MarkerType::Checked;
         break;
     case 6:
         style = QTextListFormat::ListDecimal;
@@ -823,14 +823,14 @@ void TextEdit::cursorPositionChanged()
             break;
         }
         switch (textEdit->textCursor().block().blockFormat().marker()) {
-        case QTextBlockFormat::NoMarker:
+        case QTextBlockFormat::MarkerType::NoMarker:
             actionToggleCheckState->setChecked(false);
             break;
-        case QTextBlockFormat::Unchecked:
+        case QTextBlockFormat::MarkerType::Unchecked:
             comboStyle->setCurrentIndex(4);
             actionToggleCheckState->setChecked(false);
             break;
-        case QTextBlockFormat::Checked:
+        case QTextBlockFormat::MarkerType::Checked:
             comboStyle->setCurrentIndex(5);
             actionToggleCheckState->setChecked(true);
             break;
diff --git a/examples/widgets/scroller/graphicsview/main.cpp b/examples/widgets/scroller/graphicsview/main.cpp
index d6b2956d50..178c431e6c 100644
--- a/examples/widgets/scroller/graphicsview/main.cpp
+++ b/examples/widgets/scroller/graphicsview/main.cpp
@@ -64,7 +64,7 @@ class RectObject : public QGraphicsObject
 
 public:
 
-    RectObject(const QString &text, qreal x, qreal y, qreal width, qreal height, QBrush brush, QGraphicsItem *parent = 0)
+    RectObject(const QString &text, qreal x, qreal y, qreal width, qreal height, QBrush brush, QGraphicsItem *parent = nullptr)
         : QGraphicsObject(parent)
         , m_text(text)
         , m_rect(x, y, width, height)
diff --git a/examples/widgets/statemachine/eventtransitions/main.cpp b/examples/widgets/statemachine/eventtransitions/main.cpp
index 2de8e5daa3..fe9518092f 100644
--- a/examples/widgets/statemachine/eventtransitions/main.cpp
+++ b/examples/widgets/statemachine/eventtransitions/main.cpp
@@ -48,13 +48,18 @@
 **
 ****************************************************************************/
 
-#include <QtWidgets>
+#include <QApplication>
+#include <QEventTransition>
+#include <QPushButton>
+#include <QStateMachine>
+#include <QVBoxLayout>
+#include <QWidget>
 
 //! [0]
 class Window : public QWidget
 {
 public:
-    Window(QWidget *parent = 0)
+    Window(QWidget *parent = nullptr)
         : QWidget(parent)
     {
         QPushButton *button = new QPushButton(this);
diff --git a/examples/widgets/statemachine/factorial/main.cpp b/examples/widgets/statemachine/factorial/main.cpp
index e9431596fe..e6cbdcae29 100644
--- a/examples/widgets/statemachine/factorial/main.cpp
+++ b/examples/widgets/statemachine/factorial/main.cpp
@@ -57,10 +57,7 @@ class Factorial : public QObject
     Q_PROPERTY(int x READ x WRITE setX)
     Q_PROPERTY(int fac READ fac WRITE setFac)
 public:
-    Factorial(QObject *parent = 0)
-        : QObject(parent), m_x(-1), m_fac(1)
-    {
-    }
+    using QObject::QObject;
 
     int x() const
     {
@@ -89,8 +86,8 @@ Q_SIGNALS:
     void xChanged(int value);
 
 private:
-    int m_x;
-    int m_fac;
+    int m_x = -1;
+    int m_fac = 1;
 };
 //! [0]
 
diff --git a/examples/widgets/statemachine/trafficlight/main.cpp b/examples/widgets/statemachine/trafficlight/main.cpp
index a12d2f10d1..dd8bddcb37 100644
--- a/examples/widgets/statemachine/trafficlight/main.cpp
+++ b/examples/widgets/statemachine/trafficlight/main.cpp
@@ -48,7 +48,13 @@
 **
 ****************************************************************************/
 
-#include <QtWidgets>
+#include <QApplication>
+#include <QFinalState>
+#include <QPainter>
+#include <QStateMachine>
+#include <QTimer>
+#include <QVBoxLayout>
+#include <QWidget>
 
 //! [0]
 class LightWidget : public QWidget
@@ -56,7 +62,7 @@ class LightWidget : public QWidget
     Q_OBJECT
     Q_PROPERTY(bool on READ isOn WRITE setOn)
 public:
-    LightWidget(const QColor &color, QWidget *parent = 0)
+    LightWidget(const QColor &color, QWidget *parent = nullptr)
         : QWidget(parent), m_color(color), m_on(false) {}
 
     bool isOn() const
@@ -94,7 +100,7 @@ private:
 class TrafficLightWidget : public QWidget
 {
 public:
-    TrafficLightWidget(QWidget *parent = 0)
+    TrafficLightWidget(QWidget *parent = nullptr)
         : QWidget(parent)
     {
         QVBoxLayout *vbox = new QVBoxLayout(this);
@@ -125,7 +131,7 @@ private:
 //! [1]
 
 //! [2]
-QState *createLightState(LightWidget *light, int duration, QState *parent = 0)
+QState *createLightState(LightWidget *light, int duration, QState *parent = nullptr)
 {
     QState *lightState = new QState(parent);
     QTimer *timer = new QTimer(lightState);
diff --git a/examples/widgets/tools/codecs/mainwindow.cpp b/examples/widgets/tools/codecs/mainwindow.cpp
index 6b601062b6..dc72fa73b7 100644
--- a/examples/widgets/tools/codecs/mainwindow.cpp
+++ b/examples/widgets/tools/codecs/mainwindow.cpp
@@ -54,12 +54,12 @@
 
 #include <QAction>
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QFileDialog>
 #include <QMenuBar>
 #include <QMessageBox>
 #include <QPlainTextEdit>
 #include <QRegularExpression>
+#include <QScreen>
 #include <QTextCodec>
 #include <QTextStream>
 
@@ -78,7 +78,7 @@ MainWindow::MainWindow()
 
     setWindowTitle(tr("Codecs"));
 
-    const QRect screenGeometry = QApplication::desktop()->screenGeometry(this);
+    const QRect screenGeometry = screen()->geometry();
     resize(screenGeometry.width() / 2, screenGeometry.height() * 2 / 3);
 }
 
@@ -216,7 +216,7 @@ void MainWindow::encodingDialog()
 {
     if (!m_encodingDialog) {
         m_encodingDialog = new EncodingDialog(this);
-        const QRect screenGeometry = QApplication::desktop()->screenGeometry(this);
+        const QRect screenGeometry = screen()->geometry();
         m_encodingDialog->setMinimumWidth(screenGeometry.width() / 4);
     }
     m_encodingDialog->show();
diff --git a/examples/widgets/tools/codecs/previewform.cpp b/examples/widgets/tools/codecs/previewform.cpp
index ec75ebb9fa..f48651335a 100644
--- a/examples/widgets/tools/codecs/previewform.cpp
+++ b/examples/widgets/tools/codecs/previewform.cpp
@@ -52,12 +52,12 @@
 
 #include <QApplication>
 #include <QComboBox>
-#include <QDesktopWidget>
 #include <QDialogButtonBox>
 #include <QGridLayout>
 #include <QLabel>
 #include <QPlainTextEdit>
 #include <QPushButton>
+#include <QScreen>
 #include <QTextCodec>
 #include <QTextStream>
 
@@ -183,7 +183,7 @@ PreviewForm::PreviewForm(QWidget *parent)
     mainLayout->addWidget(statusLabel, 2, 0, 1, 2);
     mainLayout->addWidget(buttonBox, 3, 0, 1, 2);
 
-    const QRect screenGeometry = QApplication::desktop()->screenGeometry(this);
+    const QRect screenGeometry = screen()->geometry();
     resize(screenGeometry.width() * 2 / 5, screenGeometry.height() / 2);
 }
 
diff --git a/examples/widgets/tools/settingseditor/mainwindow.cpp b/examples/widgets/tools/settingseditor/mainwindow.cpp
index b9c2193ccb..ccca16ffcd 100644
--- a/examples/widgets/tools/settingseditor/mainwindow.cpp
+++ b/examples/widgets/tools/settingseditor/mainwindow.cpp
@@ -54,12 +54,12 @@
 
 #include <QAction>
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QFileDialog>
 #include <QInputDialog>
 #include <QLineEdit>
 #include <QMenuBar>
 #include <QMessageBox>
+#include <QScreen>
 #include <QStandardPaths>
 #include <QStatusBar>
 
@@ -74,7 +74,7 @@ MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)
     fallbacksAct->setChecked(true);
 
     setWindowTitle(QCoreApplication::applicationName());
-    const QRect availableGeometry = QApplication::desktop()->availableGeometry(this);
+    const QRect availableGeometry = screen()->availableGeometry();
     adjustSize();
     move((availableGeometry.width() - width()) / 2, (availableGeometry.height() - height()) / 2);
 }
diff --git a/examples/widgets/tools/settingseditor/settingstree.cpp b/examples/widgets/tools/settingseditor/settingstree.cpp
index b263746847..49d299bf72 100644
--- a/examples/widgets/tools/settingseditor/settingstree.cpp
+++ b/examples/widgets/tools/settingseditor/settingstree.cpp
@@ -52,8 +52,8 @@
 #include "variantdelegate.h"
 
 #include <QApplication>
-#include <QDesktopWidget>
 #include <QHeaderView>
+#include <QScreen>
 #include <QSettings>
 
 SettingsTree::SettingsTree(QWidget *parent)
@@ -93,7 +93,7 @@ void SettingsTree::setSettingsObject(const SettingsPtr &newSettings)
 
 QSize SettingsTree::sizeHint() const
 {
-    const QRect availableGeometry = QApplication::desktop()->availableGeometry(this);
+    const QRect availableGeometry = screen()->availableGeometry();
     return QSize(availableGeometry.width() * 2 / 3, availableGeometry.height() * 2 / 3);
 }
 
diff --git a/examples/widgets/touch/fingerpaint/scribblearea.h b/examples/widgets/touch/fingerpaint/scribblearea.h
index 5138e3a1ab..fcdde53cc4 100644
--- a/examples/widgets/touch/fingerpaint/scribblearea.h
+++ b/examples/widgets/touch/fingerpaint/scribblearea.h
@@ -62,7 +62,7 @@ class ScribbleArea : public QWidget
     Q_OBJECT
 
 public:
-    ScribbleArea(QWidget *parent = 0);
+    ScribbleArea(QWidget *parent = nullptr);
 
     bool openImage(const QString &fileName);
     bool saveImage(const QString &fileName, const char *fileFormat);
diff --git a/examples/widgets/touch/pinchzoom/graphicsview.cpp b/examples/widgets/touch/pinchzoom/graphicsview.cpp
index 54e134aea2..6412f350a7 100644
--- a/examples/widgets/touch/pinchzoom/graphicsview.cpp
+++ b/examples/widgets/touch/pinchzoom/graphicsview.cpp
@@ -54,7 +54,7 @@
 #include <QTouchEvent>
 
 GraphicsView::GraphicsView(QGraphicsScene *scene, QWidget *parent)
-    : QGraphicsView(scene, parent), totalScaleFactor(1)
+    : QGraphicsView(scene, parent)
 {
     viewport()->setAttribute(Qt::WA_AcceptTouchEvents);
     setDragMode(ScrollHandDrag);
@@ -83,8 +83,8 @@ bool GraphicsView::viewportEvent(QEvent *event)
                 totalScaleFactor *= currentScaleFactor;
                 currentScaleFactor = 1;
             }
-            setTransform(QTransform().scale(totalScaleFactor * currentScaleFactor,
-                                            totalScaleFactor * currentScaleFactor));
+            setTransform(QTransform::fromScale(totalScaleFactor * currentScaleFactor,
+                                               totalScaleFactor * currentScaleFactor));
         }
         return true;
     }
diff --git a/examples/widgets/touch/pinchzoom/graphicsview.h b/examples/widgets/touch/pinchzoom/graphicsview.h
index d4e2e32d36..c0faeba444 100644
--- a/examples/widgets/touch/pinchzoom/graphicsview.h
+++ b/examples/widgets/touch/pinchzoom/graphicsview.h
@@ -56,10 +56,10 @@ class GraphicsView : public QGraphicsView
     Q_OBJECT
 
 public:
-    GraphicsView(QGraphicsScene *scene = 0, QWidget *parent = 0);
+    GraphicsView(QGraphicsScene *scene = nullptr, QWidget *parent = nullptr);
 
     bool viewportEvent(QEvent *event) override;
 
 private:
-    qreal totalScaleFactor;
+    qreal totalScaleFactor = 1;
 };
diff --git a/examples/widgets/touch/pinchzoom/main.cpp b/examples/widgets/touch/pinchzoom/main.cpp
index 938432600f..2c2ba39a26 100644
--- a/examples/widgets/touch/pinchzoom/main.cpp
+++ b/examples/widgets/touch/pinchzoom/main.cpp
@@ -51,11 +51,10 @@
 #include "graphicsview.h"
 #include "mouse.h"
 
-#include <QtWidgets>
+#include <QApplication>
+#include <cmath>
 
-#include <math.h>
-
-static const int MouseCount = 7;
+static constexpr int MouseCount = 7;
 
 //! [0]
 int main(int argc, char **argv)
diff --git a/examples/widgets/touch/pinchzoom/mouse.cpp b/examples/widgets/touch/pinchzoom/mouse.cpp
index 1dfd7d749c..8456a0214d 100644
--- a/examples/widgets/touch/pinchzoom/mouse.cpp
+++ b/examples/widgets/touch/pinchzoom/mouse.cpp
@@ -56,8 +56,8 @@
 #include <QStyleOption>
 #include <qmath.h>
 
-const qreal Pi = M_PI;
-const qreal TwoPi = 2 * M_PI;
+constexpr qreal Pi = M_PI;
+constexpr qreal TwoPi = 2 * M_PI;
 
 static qreal normalizeAngle(qreal angle)
 {
@@ -69,9 +69,9 @@ static qreal normalizeAngle(qreal angle)
 }
 
 //! [0]
-Mouse::Mouse()
-    : angle(0), speed(0), mouseEyeDirection(0),
-      color(QRandomGenerator::global()->bounded(256), QRandomGenerator::global()->bounded(256), QRandomGenerator::global()->bounded(256))
+Mouse::Mouse() : color(QRandomGenerator::global()->bounded(256),
+                       QRandomGenerator::global()->bounded(256),
+                       QRandomGenerator::global()->bounded(256))
 {
     setTransform(QTransform().rotate(QRandomGenerator::global()->bounded(360 * 16)), true);
     startTimer(1000 / 33);
diff --git a/examples/widgets/touch/pinchzoom/mouse.h b/examples/widgets/touch/pinchzoom/mouse.h
index 870bfcd6c0..8ac110821e 100644
--- a/examples/widgets/touch/pinchzoom/mouse.h
+++ b/examples/widgets/touch/pinchzoom/mouse.h
@@ -70,9 +70,9 @@ protected:
     void timerEvent(QTimerEvent *event) override;
 
 private:
-    qreal angle;
-    qreal speed;
-    qreal mouseEyeDirection;
+    qreal angle = 0;
+    qreal speed = 0;
+    qreal mouseEyeDirection = 0;
     QColor color;
 };
 //! [0]
diff --git a/examples/widgets/tutorials/addressbook/part1/addressbook.h b/examples/widgets/tutorials/addressbook/part1/addressbook.h
index 1d575e1260..4c2b456a41 100644
--- a/examples/widgets/tutorials/addressbook/part1/addressbook.h
+++ b/examples/widgets/tutorials/addressbook/part1/addressbook.h
@@ -65,7 +65,7 @@ class AddressBook : public QWidget
     Q_OBJECT
 
 public:
-    AddressBook(QWidget *parent = 0);
+    AddressBook(QWidget *parent = nullptr);
 
 private:
     QLineEdit *nameLine;
diff --git a/examples/widgets/tutorials/addressbook/part2/addressbook.h b/examples/widgets/tutorials/addressbook/part2/addressbook.h
index 7b1714b443..e690d14244 100644
--- a/examples/widgets/tutorials/addressbook/part2/addressbook.h
+++ b/examples/widgets/tutorials/addressbook/part2/addressbook.h
@@ -66,7 +66,7 @@ class AddressBook : public QWidget
     Q_OBJECT
 
 public:
-    AddressBook(QWidget *parent = 0);
+    AddressBook(QWidget *parent = nullptr);
 
 //! [slots]
 public slots:
diff --git a/examples/widgets/tutorials/addressbook/part3/addressbook.h b/examples/widgets/tutorials/addressbook/part3/addressbook.h
index 746a58a32a..f4a8aaa976 100644
--- a/examples/widgets/tutorials/addressbook/part3/addressbook.h
+++ b/examples/widgets/tutorials/addressbook/part3/addressbook.h
@@ -66,7 +66,7 @@ class AddressBook : public QWidget
     Q_OBJECT
 
 public:
-    AddressBook(QWidget *parent = 0);
+    AddressBook(QWidget *parent = nullptr);
 
 public slots:
     void addContact();
diff --git a/examples/widgets/tutorials/addressbook/part4/addressbook.h b/examples/widgets/tutorials/addressbook/part4/addressbook.h
index a8d4d9fe1d..307df1eb15 100644
--- a/examples/widgets/tutorials/addressbook/part4/addressbook.h
+++ b/examples/widgets/tutorials/addressbook/part4/addressbook.h
@@ -66,7 +66,7 @@ class AddressBook : public QWidget
     Q_OBJECT
 
 public:
-    AddressBook(QWidget *parent = 0);
+    AddressBook(QWidget *parent = nullptr);
 //! [Mode enum]
     enum Mode { NavigationMode, AddingMode, EditingMode };
 //! [Mode enum]
diff --git a/examples/widgets/tutorials/addressbook/part5/addressbook.h b/examples/widgets/tutorials/addressbook/part5/addressbook.h
index b60929a50c..9dd7ed1d89 100644
--- a/examples/widgets/tutorials/addressbook/part5/addressbook.h
+++ b/examples/widgets/tutorials/addressbook/part5/addressbook.h
@@ -69,7 +69,7 @@ class AddressBook : public QWidget
     Q_OBJECT
 
 public:
-    AddressBook(QWidget *parent = 0);
+    AddressBook(QWidget *parent = nullptr);
     enum Mode { NavigationMode, AddingMode, EditingMode };
 
 public slots:
diff --git a/examples/widgets/tutorials/addressbook/part5/finddialog.h b/examples/widgets/tutorials/addressbook/part5/finddialog.h
index 0fca6be81b..8e63eeee79 100644
--- a/examples/widgets/tutorials/addressbook/part5/finddialog.h
+++ b/examples/widgets/tutorials/addressbook/part5/finddialog.h
@@ -63,7 +63,7 @@ class FindDialog : public QDialog
     Q_OBJECT
 
 public:
-    FindDialog(QWidget *parent = 0);
+    FindDialog(QWidget *parent = nullptr);
     QString getFindText();
 
 public slots:
diff --git a/examples/widgets/tutorials/addressbook/part6/addressbook.h b/examples/widgets/tutorials/addressbook/part6/addressbook.h
index 8d328310f7..fca62c52b7 100644
--- a/examples/widgets/tutorials/addressbook/part6/addressbook.h
+++ b/examples/widgets/tutorials/addressbook/part6/addressbook.h
@@ -68,7 +68,7 @@ class AddressBook : public QWidget
     Q_OBJECT
 
 public:
-    AddressBook(QWidget *parent = 0);
+    AddressBook(QWidget *parent = nullptr);
     enum Mode { NavigationMode, AddingMode, EditingMode };
 
 public slots:
diff --git a/examples/widgets/tutorials/addressbook/part6/finddialog.h b/examples/widgets/tutorials/addressbook/part6/finddialog.h
index 527e0254e9..46f8047a56 100644
--- a/examples/widgets/tutorials/addressbook/part6/finddialog.h
+++ b/examples/widgets/tutorials/addressbook/part6/finddialog.h
@@ -63,7 +63,7 @@ class FindDialog : public QDialog
     Q_OBJECT
 
 public:
-    FindDialog(QWidget *parent = 0);
+    FindDialog(QWidget *parent = nullptr);
     QString getFindText();
 
 public slots:
diff --git a/examples/widgets/tutorials/addressbook/part7/addressbook.h b/examples/widgets/tutorials/addressbook/part7/addressbook.h
index 0f109b2ef1..47a0f3c062 100644
--- a/examples/widgets/tutorials/addressbook/part7/addressbook.h
+++ b/examples/widgets/tutorials/addressbook/part7/addressbook.h
@@ -68,7 +68,7 @@ class AddressBook : public QWidget
     Q_OBJECT
 
 public:
-    AddressBook(QWidget *parent = 0);
+    AddressBook(QWidget *parent = nullptr);
     enum Mode { NavigationMode, AddingMode, EditingMode };
 
 public slots:
diff --git a/examples/widgets/tutorials/addressbook/part7/finddialog.h b/examples/widgets/tutorials/addressbook/part7/finddialog.h
index 527e0254e9..46f8047a56 100644
--- a/examples/widgets/tutorials/addressbook/part7/finddialog.h
+++ b/examples/widgets/tutorials/addressbook/part7/finddialog.h
@@ -63,7 +63,7 @@ class FindDialog : public QDialog
     Q_OBJECT
 
 public:
-    FindDialog(QWidget *parent = 0);
+    FindDialog(QWidget *parent = nullptr);
     QString getFindText();
 
 public slots:
diff --git a/examples/widgets/tutorials/modelview/3_changingmodel/main.cpp b/examples/widgets/tutorials/modelview/3_changingmodel/main.cpp
index 2330019f93..90a8c6e894 100644
--- a/examples/widgets/tutorials/modelview/3_changingmodel/main.cpp
+++ b/examples/widgets/tutorials/modelview/3_changingmodel/main.cpp
@@ -56,7 +56,7 @@ int main(int argc, char *argv[])
 {
     QApplication a(argc, argv);
     QTableView tableView;
-    MyModel myModel(0);
+    MyModel myModel;
     tableView.setModel(&myModel);
     tableView.show();
     return a.exec();
diff --git a/examples/widgets/tutorials/modelview/7_selections/mainwindow.h b/examples/widgets/tutorials/modelview/7_selections/mainwindow.h
index c9761dd3d9..74906c831d 100644
--- a/examples/widgets/tutorials/modelview/7_selections/mainwindow.h
+++ b/examples/widgets/tutorials/modelview/7_selections/mainwindow.h
@@ -69,7 +69,7 @@ private:
 private slots:
     void selectionChangedSlot(const QItemSelection &newSelection, const QItemSelection &oldSelection);
 public:
-    MainWindow(QWidget *parent = 0);
+    MainWindow(QWidget *parent = nullptr);
 };
 
 #endif // MAINWINDOW_H
diff --git a/examples/widgets/tutorials/notepad/notepad.h b/examples/widgets/tutorials/notepad/notepad.h
index 9580ab8071..5e44dfeedc 100644
--- a/examples/widgets/tutorials/notepad/notepad.h
+++ b/examples/widgets/tutorials/notepad/notepad.h
@@ -72,7 +72,7 @@ class Notepad : public QMainWindow
 
 //! [4]
 public:
-    explicit Notepad(QWidget *parent = 0);
+    explicit Notepad(QWidget *parent = nullptr);
 //! [4]
 //! [5]
     ~Notepad();
diff --git a/examples/widgets/widgets/charactermap/mainwindow.cpp b/examples/widgets/widgets/charactermap/mainwindow.cpp
index 25c4503ddb..b0f9705c21 100644
--- a/examples/widgets/widgets/charactermap/mainwindow.cpp
+++ b/examples/widgets/widgets/charactermap/mainwindow.cpp
@@ -64,6 +64,7 @@
 #include <QMenuBar>
 #include <QPlainTextEdit>
 #include <QPushButton>
+#include <QScreen>
 #include <QScrollArea>
 #include <QStatusBar>
 #include <QTextStream>
@@ -302,7 +303,7 @@ QString FontInfoDialog::text() const
 
 void MainWindow::showInfo()
 {
-    const QRect screenGeometry = QApplication::desktop()->screenGeometry(this);
+    const QRect screenGeometry = screen()->geometry();
     FontInfoDialog *dialog = new FontInfoDialog(this);
     dialog->setWindowTitle(tr("Fonts"));
     dialog->setAttribute(Qt::WA_DeleteOnClose);
diff --git a/examples/widgets/widgets/icons/main.cpp b/examples/widgets/widgets/icons/main.cpp
index a045ea765a..632795c18c 100644
--- a/examples/widgets/widgets/icons/main.cpp
+++ b/examples/widgets/widgets/icons/main.cpp
@@ -50,7 +50,7 @@
 
 #include <QApplication>
 #include <QCommandLineParser>
-#include <QDesktopWidget>
+#include <QScreen>
 
 #include "mainwindow.h"
 
@@ -77,7 +77,7 @@ int main(int argc, char *argv[])
     if (!commandLineParser.positionalArguments().isEmpty())
         mainWin.loadImages(commandLineParser.positionalArguments());
 
-    const QRect availableGeometry = QApplication::desktop()->availableGeometry(&mainWin);
+    const QRect availableGeometry = mainWin.screen()->availableGeometry();
     mainWin.resize(availableGeometry.width() / 2, availableGeometry.height() * 2 / 3);
     mainWin.move((availableGeometry.width() - mainWin.width()) / 2, (availableGeometry.height() - mainWin.height()) / 2);
 
diff --git a/examples/widgets/widgets/tablet/tabletcanvas.cpp b/examples/widgets/widgets/tablet/tabletcanvas.cpp
index 9a8029486d..59ca608cef 100644
--- a/examples/widgets/widgets/tablet/tabletcanvas.cpp
+++ b/examples/widgets/widgets/tablet/tabletcanvas.cpp
@@ -53,6 +53,7 @@
 #include <QCoreApplication>
 #include <QPainter>
 #include <QtMath>
+#include <cstdlib>
 
 //! [0]
 TabletCanvas::TabletCanvas()
diff --git a/examples/widgets/windowcontainer/windowcontainer.cpp b/examples/widgets/windowcontainer/windowcontainer.cpp
index 9f2124c4e1..b920c85420 100644
--- a/examples/widgets/windowcontainer/windowcontainer.cpp
+++ b/examples/widgets/windowcontainer/windowcontainer.cpp
@@ -50,16 +50,14 @@
 
 #include "openglwindow.h"
 
-#include <QPainter>
-#include <QMouseEvent>
-#include <QKeyEvent>
-#include <QFocusEvent>
-
 #include <QApplication>
-#include <QWidget>
+#include <QFocusEvent>
 #include <QHBoxLayout>
+#include <QKeyEvent>
 #include <QLineEdit>
-
+#include <QMouseEvent>
+#include <QPainter>
+#include <QWidget>
 
 
 // Making use of the class from the opengl example in gui.
@@ -67,13 +65,10 @@ class Window : public OpenGLWindow
 {
     Q_OBJECT
 public:
-    Window()
-        : m_mouseDown(false)
-        , m_focus(false)
-    {
-    }
+    using OpenGLWindow::OpenGLWindow;
 
-    void render(QPainter *p) override {
+    void render(QPainter *p) override
+    {
         QLinearGradient g(0, 0, 0, height());
         g.setColorAt(0, QColor("lightsteelblue"));
         g.setColorAt(1, Qt::black);
@@ -93,15 +88,15 @@ public:
             p->restore();
         }
 
-        if (m_focus) {
+        if (m_focus)
             p->drawText(20, height() - 20, QLatin1String("Window has focus!"));
-        }
 
         p->setRenderHint(QPainter::Antialiasing);
         p->drawPolyline(m_polygon);
     }
 
-    void mousePressEvent(QMouseEvent *e) override {
+    void mousePressEvent(QMouseEvent *e) override
+    {
         if (!m_mouseDown) {
             m_mouseDown = true;
             m_polygon.clear();
@@ -110,14 +105,16 @@ public:
         }
     }
 
-    void mouseMoveEvent(QMouseEvent *e) override {
+    void mouseMoveEvent(QMouseEvent *e) override
+    {
         if (m_mouseDown) {
             m_polygon.append(e->pos());
             renderLater();
         }
     }
 
-    void mouseReleaseEvent(QMouseEvent *e) override {
+    void mouseReleaseEvent(QMouseEvent *e) override
+    {
         if (m_mouseDown) {
             m_mouseDown = false;
             m_polygon.append(e->pos());
@@ -125,33 +122,35 @@ public:
         }
     }
 
-    void focusInEvent(QFocusEvent *) override {
+    void focusInEvent(QFocusEvent *) override
+    {
         m_focus = true;
         renderLater();
     }
 
-    void focusOutEvent(QFocusEvent *) override {
+    void focusOutEvent(QFocusEvent *) override
+    {
         m_focus = false;
         m_polygon.clear();
         renderLater();
     }
 
-    void keyPressEvent(QKeyEvent *e) override {
+    void keyPressEvent(QKeyEvent *e) override
+    {
         m_key = e->text();
         renderLater();
     }
 
-    void keyReleaseEvent(QKeyEvent *) override {
+    void keyReleaseEvent(QKeyEvent *) override
+    {
         m_key = QString();
         renderLater();
     }
 private:
     QPolygon m_polygon;
-    bool m_mouseDown;
-
-    bool m_focus;
-
     QString m_key;
+    bool m_mouseDown = false;
+    bool m_focus = false;
 };
 
 
@@ -162,7 +161,7 @@ int main(int argc, char *argv[])
     QWidget *widget = new QWidget;
     QHBoxLayout *layout = new QHBoxLayout(widget);
 
-    Window *window = new Window();
+    Window *window = new Window;
 
     QWidget *container = QWidget::createWindowContainer(window);
     container->setMinimumSize(300, 300);
diff --git a/examples/xml/dombookmarks/mainwindow.cpp b/examples/xml/dombookmarks/mainwindow.cpp
index fade2dfc96..b8f2e12918 100644
--- a/examples/xml/dombookmarks/mainwindow.cpp
+++ b/examples/xml/dombookmarks/mainwindow.cpp
@@ -63,7 +63,7 @@ MainWindow::MainWindow()
     statusBar()->showMessage(tr("Ready"));
 
     setWindowTitle(tr("DOM Bookmarks"));
-    const QSize availableSize = QApplication::desktop()->availableGeometry(this).size();
+    const QSize availableSize = screen()->availableGeometry().size();
     resize(availableSize.width() / 2, availableSize.height() / 3);
 }
 
diff --git a/examples/xml/saxbookmarks/mainwindow.cpp b/examples/xml/saxbookmarks/mainwindow.cpp
index 0583cd82cf..8b7733081f 100644
--- a/examples/xml/saxbookmarks/mainwindow.cpp
+++ b/examples/xml/saxbookmarks/mainwindow.cpp
@@ -74,7 +74,7 @@ MainWindow::MainWindow()
     statusBar()->showMessage(tr("Ready"));
 
     setWindowTitle(tr("SAX Bookmarks"));
-    const QSize availableSize = QApplication::desktop()->availableGeometry(this).size();
+    const QSize availableSize = screen()->availableGeometry().size();
     resize(availableSize.width() / 2, availableSize.height() / 3);
 }
 
diff --git a/examples/xml/streambookmarks/mainwindow.cpp b/examples/xml/streambookmarks/mainwindow.cpp
index c9a18fa3c4..d0e7bf30c9 100644
--- a/examples/xml/streambookmarks/mainwindow.cpp
+++ b/examples/xml/streambookmarks/mainwindow.cpp
@@ -75,7 +75,7 @@ MainWindow::MainWindow()
     statusBar()->showMessage(tr("Ready"));
 
     setWindowTitle(tr("QXmlStream Bookmarks"));
-    const QSize availableSize = QApplication::desktop()->availableGeometry(this).size();
+    const QSize availableSize = screen()->availableGeometry().size();
     resize(availableSize.width() / 2, availableSize.height() / 3);
 }
 //! [0]
diff --git a/mkspecs/features/qt_configure.prf b/mkspecs/features/qt_configure.prf
index 52baca1fbb..adac835c26 100644
--- a/mkspecs/features/qt_configure.prf
+++ b/mkspecs/features/qt_configure.prf
@@ -758,9 +758,7 @@ defineTest(qtConfLibrary_pkgConfig) {
     !qtConfResolveLibs($${1}.libs, $$libs): \
         return(false)
     contains($${1}.libs, ".*\\.$${QMAKE_EXTENSION_STATICLIB}$") {
-        qtRunLoggedCommand("$$pkg_config --static --libs-only-L $$args", libpaths)|return(false)
-        qtRunLoggedCommand("$$pkg_config --static --libs-only-l $$args", libs)|return(false)
-        eval(libs = $$libpaths $$libs)
+        qtRunLoggedCommand("$$pkg_config --static --libs $$args", libs)|return(false)
         !qtConfResolveLibs($${1}.libs, $$libs): \
             return(false)
     }
diff --git a/mkspecs/features/qt_functions.prf b/mkspecs/features/qt_functions.prf
index ee6a4b352a..661b7dd961 100644
--- a/mkspecs/features/qt_functions.prf
+++ b/mkspecs/features/qt_functions.prf
@@ -159,8 +159,12 @@ defineTest(qtAddToolEnv) {
         !isEmpty(cmd): cmd = "$$cmd "
         equals(ds, /) {
             batch_name = $${batch_name}.sh
+            equals(QMAKE_HOST.os, Darwin):exists(/bin/bash): \
+                shell = /bin/bash
+            else: \
+                shell = /bin/sh
             batch_cont = \
-                "$$LITERAL_HASH!/bin/sh" \
+                "$$LITERAL_HASH!$$shell" \
                 $$batch_sets \
                 "exec $$cmd\"$@\""
             # It would be nicer to use the '.' command (without 'exec' above),
diff --git a/mkspecs/features/qt_tracepoints.prf b/mkspecs/features/qt_tracepoints.prf
index d1b45a47cb..56d315e1cd 100644
--- a/mkspecs/features/qt_tracepoints.prf
+++ b/mkspecs/features/qt_tracepoints.prf
@@ -16,7 +16,7 @@ PROVIDER_NAME = qt$$lower($$MODULE)
 INCLUDEPATH += $$absolute_path($$TRACEGEN_DIR, $$OUT_PWD)
 HEADER_PATH = $$OUT_PWD/$$TRACEGEN_DIR/$${PROVIDER_NAME}_tracepoints_p$${first(QMAKE_EXT_H)}
 
-!force_bootstrap:if(qtConfig(lttng)|qtConfig(etw)) {
+if(qtConfig(lttng)|qtConfig(etw)) {
     SOURCE_PATH = $$OUT_PWD/$$TRACEGEN_DIR/$${PROVIDER_NAME}_tracepoints$${first(QMAKE_EXT_CPP)}
 
     isEmpty(BUILDS)|build_pass {
diff --git a/mkspecs/features/uikit/xcodebuild.mk b/mkspecs/features/uikit/xcodebuild.mk
index 0c8d99f4b8..e1156d0e76 100644
--- a/mkspecs/features/uikit/xcodebuild.mk
+++ b/mkspecs/features/uikit/xcodebuild.mk
@@ -27,8 +27,8 @@ distclean: clean_all
 $(EXPORT_SUBTARGETS): % : %-build
 
 # Generic targets
-%_first: $(firstword $(call targets, %)) ;
-%_all: $(call targets, %) ;
+%_first: $(EXPORT_PRE_TARGETDEPS) $(firstword $(call targets, %)) ;
+%_all: $(EXPORT_PRE_TARGETDEPS) $(call targets, %) ;
 
 # Actions
 %-build: ACTION = build
diff --git a/mkspecs/features/uikit/xcodebuild.prf b/mkspecs/features/uikit/xcodebuild.prf
index 7a6b2acfc2..01022c7b99 100644
--- a/mkspecs/features/uikit/xcodebuild.prf
+++ b/mkspecs/features/uikit/xcodebuild.prf
@@ -29,6 +29,8 @@ cmd = "$$QMAKE_QMAKE $$system_quote($$_PRO_FILE_) -spec macx-xcode $$args"
 debug(1, "Generating Xcode project in $$OUT_PWD using '$$cmd'")
 system("$$QMAKE_CD $$system_quote($$OUT_PWD) && $$cmd")
 
+QMAKE_EXTRA_VARIABLES += PRE_TARGETDEPS
+
 # Subtargets
 
 for(build, BUILDS): \
diff --git a/mkspecs/macx-clang/Info.plist.app b/mkspecs/macx-clang/Info.plist.app
index 4d64a77704..fa592af089 100644
--- a/mkspecs/macx-clang/Info.plist.app
+++ b/mkspecs/macx-clang/Info.plist.app
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIconFile</key>
 	<string>${ASSETCATALOG_COMPILER_APPICON_NAME}</string>
 	<key>CFBundleIdentifier</key>
diff --git a/mkspecs/macx-clang/Info.plist.lib b/mkspecs/macx-clang/Info.plist.lib
index ce28365500..34752ec40d 100644
--- a/mkspecs/macx-clang/Info.plist.lib
+++ b/mkspecs/macx-clang/Info.plist.lib
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIdentifier</key>
 	<string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
 	<key>CFBundlePackageType</key>
diff --git a/mkspecs/macx-g++/Info.plist.app b/mkspecs/macx-g++/Info.plist.app
index 4d64a77704..fa592af089 100644
--- a/mkspecs/macx-g++/Info.plist.app
+++ b/mkspecs/macx-g++/Info.plist.app
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIconFile</key>
 	<string>${ASSETCATALOG_COMPILER_APPICON_NAME}</string>
 	<key>CFBundleIdentifier</key>
diff --git a/mkspecs/macx-g++/Info.plist.lib b/mkspecs/macx-g++/Info.plist.lib
index ce28365500..34752ec40d 100644
--- a/mkspecs/macx-g++/Info.plist.lib
+++ b/mkspecs/macx-g++/Info.plist.lib
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIdentifier</key>
 	<string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
 	<key>CFBundlePackageType</key>
diff --git a/mkspecs/macx-icc/Info.plist.app b/mkspecs/macx-icc/Info.plist.app
index 4d64a77704..fa592af089 100644
--- a/mkspecs/macx-icc/Info.plist.app
+++ b/mkspecs/macx-icc/Info.plist.app
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIconFile</key>
 	<string>${ASSETCATALOG_COMPILER_APPICON_NAME}</string>
 	<key>CFBundleIdentifier</key>
diff --git a/mkspecs/macx-icc/Info.plist.lib b/mkspecs/macx-icc/Info.plist.lib
index ce28365500..34752ec40d 100644
--- a/mkspecs/macx-icc/Info.plist.lib
+++ b/mkspecs/macx-icc/Info.plist.lib
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIdentifier</key>
 	<string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
 	<key>CFBundlePackageType</key>
diff --git a/mkspecs/macx-ios-clang/Info.plist.app b/mkspecs/macx-ios-clang/Info.plist.app
index 1acbf9d768..03ba3e82b4 100644
--- a/mkspecs/macx-ios-clang/Info.plist.app
+++ b/mkspecs/macx-ios-clang/Info.plist.app
@@ -6,8 +6,6 @@
 	<string>${PRODUCT_NAME}</string>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIconFile</key>
 	<string>${ASSETCATALOG_COMPILER_APPICON_NAME}</string>
 	<key>CFBundleIdentifier</key>
diff --git a/mkspecs/macx-ios-clang/Info.plist.lib b/mkspecs/macx-ios-clang/Info.plist.lib
index ce28365500..34752ec40d 100644
--- a/mkspecs/macx-ios-clang/Info.plist.lib
+++ b/mkspecs/macx-ios-clang/Info.plist.lib
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIdentifier</key>
 	<string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
 	<key>CFBundlePackageType</key>
diff --git a/mkspecs/macx-tvos-clang/Info.plist.app b/mkspecs/macx-tvos-clang/Info.plist.app
index 04aef816c2..b9b67fe41e 100644
--- a/mkspecs/macx-tvos-clang/Info.plist.app
+++ b/mkspecs/macx-tvos-clang/Info.plist.app
@@ -8,8 +8,6 @@
 	<string>${PRODUCT_NAME}</string>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIcons</key>
 	<dict>
 		<key>CFBundlePrimaryIcon</key>
diff --git a/mkspecs/macx-tvos-clang/Info.plist.lib b/mkspecs/macx-tvos-clang/Info.plist.lib
index ce28365500..34752ec40d 100644
--- a/mkspecs/macx-tvos-clang/Info.plist.lib
+++ b/mkspecs/macx-tvos-clang/Info.plist.lib
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIdentifier</key>
 	<string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
 	<key>CFBundlePackageType</key>
diff --git a/mkspecs/macx-watchos-clang/Info.plist.app b/mkspecs/macx-watchos-clang/Info.plist.app
index 47f5a58d5e..5ac0ef78a0 100644
--- a/mkspecs/macx-watchos-clang/Info.plist.app
+++ b/mkspecs/macx-watchos-clang/Info.plist.app
@@ -8,8 +8,6 @@
 	<string>${PRODUCT_NAME}</string>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIdentifier</key>
 	<string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
 	<key>CFBundleName</key>
diff --git a/mkspecs/macx-watchos-clang/Info.plist.lib b/mkspecs/macx-watchos-clang/Info.plist.lib
index ce28365500..34752ec40d 100644
--- a/mkspecs/macx-watchos-clang/Info.plist.lib
+++ b/mkspecs/macx-watchos-clang/Info.plist.lib
@@ -4,8 +4,6 @@
 <dict>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIdentifier</key>
 	<string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
 	<key>CFBundlePackageType</key>
diff --git a/qmake/Makefile.unix b/qmake/Makefile.unix
index e895feaef4..4d4f05e78a 100644
--- a/qmake/Makefile.unix
+++ b/qmake/Makefile.unix
@@ -27,7 +27,7 @@ QOBJS = \
 	qjsonarray.o qjson.o qjsondocument.o qjsonobject.o qjsonparser.o qjsonvalue.o \
 	qmetatype.o qsystemerror.o qvariant.o \
 	quuid.o \
-	qarraydata.o qbitarray.o qbytearray.o qbytearraymatcher.o \
+	qarraydata.o qbitarray.o qbytearray.o qbytearraylist.o qbytearraymatcher.o \
 	qcalendar.o qgregoriancalendar.o qromancalendar.o \
 	qcryptographichash.o qdatetime.o qhash.o qlist.o \
 	qlocale.o qlocale_tools.o qmap.o qregexp.o qringbuffer.o \
@@ -106,7 +106,8 @@ DEPEND_SRC = \
 	   $(SOURCE_PATH)/src/corelib/serialization/qtextstream.cpp \
 	   $(SOURCE_PATH)/src/corelib/serialization/qxmlstream.cpp \
 	   $(SOURCE_PATH)/src/corelib/serialization/qxmlutils.cpp \
-	   $(SOURCE_PATH)/src/corelib/text/qbytearray.cpp\
+	   $(SOURCE_PATH)/src/corelib/text/qbytearray.cpp \
+	   $(SOURCE_PATH)/src/corelib/text/qbytearraylist.cpp \
 	   $(SOURCE_PATH)/src/corelib/text/qbytearraymatcher.cpp \
 	   $(SOURCE_PATH)/src/corelib/text/qlocale.cpp \
 	   $(SOURCE_PATH)/src/corelib/text/qlocale_tools.cpp \
@@ -309,6 +310,9 @@ qarraydata.o: $(SOURCE_PATH)/src/corelib/tools/qarraydata.cpp
 qbytearray.o: $(SOURCE_PATH)/src/corelib/text/qbytearray.cpp
 	$(CXX) -c -o $@ $(CXXFLAGS) $<
 
+qbytearraylist.o: $(SOURCE_PATH)/src/corelib/text/qbytearraylist.cpp
+	$(CXX) -c -o $@ $(CXXFLAGS) $<
+
 qvsnprintf.o: $(SOURCE_PATH)/src/corelib/text/qvsnprintf.cpp
 	$(CXX) -c -o $@ $(CXXFLAGS) $<
 
diff --git a/qmake/Makefile.win32 b/qmake/Makefile.win32
index 672df47953..7324817af2 100644
--- a/qmake/Makefile.win32
+++ b/qmake/Makefile.win32
@@ -69,6 +69,7 @@ QTOBJS= \
 	qfsfileengine_iterator.obj \
 	qarraydata.obj \
 	qbytearray.obj \
+	qbytearraylist.obj \
 	qvsnprintf.obj \
 	qbytearraymatcher.obj \
 	qcalendar.obj \
diff --git a/qmake/generators/metamakefile.cpp b/qmake/generators/metamakefile.cpp
index 22a72100f7..7776d77008 100644
--- a/qmake/generators/metamakefile.cpp
+++ b/qmake/generators/metamakefile.cpp
@@ -141,7 +141,8 @@ bool
 BuildsMetaMakefileGenerator::write()
 {
     Build *glue = nullptr;
-    if(!makefiles.isEmpty() && !makefiles.first()->build.isNull()) {
+    if(!makefiles.isEmpty() && !makefiles.first()->build.isNull()
+        && Option::qmake_mode != Option::QMAKE_GENERATE_PRL) {
         glue = new Build;
         glue->name = name;
         glue->makefile = createMakefileGenerator(project, true);
@@ -252,6 +253,10 @@ void BuildsMetaMakefileGenerator::checkForConflictingTargets() const
         // and the last entry in makefiles is the "glue" Build.
         return;
     }
+    if (!project->isActiveConfig("build_all")) {
+        // Only complain if we're about to build all configurations.
+        return;
+    }
     using TargetInfo = std::pair<Build *, ProString>;
     QVector<TargetInfo> targets;
     const int last = makefiles.count() - 1;
diff --git a/qmake/generators/unix/unixmake.cpp b/qmake/generators/unix/unixmake.cpp
index 664c81296c..f4bc0e47ea 100644
--- a/qmake/generators/unix/unixmake.cpp
+++ b/qmake/generators/unix/unixmake.cpp
@@ -433,12 +433,9 @@ UnixMakefileGenerator::findLibraries(bool linkPrl, bool mergeLflags)
                     QMakeLocalFileName f(opt.mid(2));
                     if (!frameworkdirs.contains(f))
                         frameworkdirs.insert(fwidx++, f);
-                } else if (target_mode == TARG_MAC_MODE && opt.startsWith("-framework")) {
+                } else if (target_mode == TARG_MAC_MODE && opt == "-framework") {
                     if (linkPrl) {
-                        if (opt.length() == 10)
-                            opt = (*++it).toQString();
-                        else
-                            opt = opt.mid(10).trimmed();
+                        opt = (*++it).toQString();
                         static const QChar suffixMarker = ',';
                         const int suffixPosition = opt.indexOf(suffixMarker);
                         const bool hasSuffix = suffixPosition >= 0;
@@ -448,15 +445,21 @@ UnixMakefileGenerator::findLibraries(bool linkPrl, bool mergeLflags)
                             opt.remove(suffixMarker); // Apply suffix by removing marker
                         }
                         for (const QMakeLocalFileName &dir : qAsConst(frameworkdirs)) {
+                            auto processPrlIfFound = [&](QString directory) {
+                                QString suffixedPrl = directory + opt;
+                                if (processPrlFile(suffixedPrl, true))
+                                    return true;
+                                if (hasSuffix) {
+                                    QString unsuffixedPrl = directory + frameworkName;
+                                    if (processPrlFile(unsuffixedPrl, true))
+                                        return true;
+                                }
+                                return false;
+                            };
                             QString frameworkDirectory = dir.local() + "/" + frameworkName + + ".framework/";
-                            QString suffixedPrl = frameworkDirectory + opt;
-                            if (processPrlFile(suffixedPrl, true))
+                            if (processPrlIfFound(frameworkDirectory + "Resources/")
+                             || processPrlIfFound(frameworkDirectory))
                                 break;
-                            if (hasSuffix) {
-                                QString unsuffixedPrl = frameworkDirectory + frameworkName;
-                                if (processPrlFile(unsuffixedPrl, true))
-                                    break;
-                            }
                         }
                     } else {
                         if (opt.length() == 10)
diff --git a/qmake/generators/unix/unixmake2.cpp b/qmake/generators/unix/unixmake2.cpp
index ccb601d4b8..79d19cae8c 100644
--- a/qmake/generators/unix/unixmake2.cpp
+++ b/qmake/generators/unix/unixmake2.cpp
@@ -1230,8 +1230,9 @@ void UnixMakefileGenerator::init2()
         else
             ar_cmd.append("$(AR) $(TARGETA) $(OBJECTS)");
         if (!project->isEmpty("QMAKE_BUNDLE")) {
-            project->values("PRL_TARGET").prepend(
-                    project->first("QMAKE_BUNDLE") + Option::dir_sep + project->first("TARGET"));
+            project->values("PRL_TARGET").prepend(project->first("QMAKE_BUNDLE") +
+                "/Versions/" + project->first("QMAKE_FRAMEWORK_VERSION") +
+                "/Resources/" + project->first("TARGET"));
             ProString bundle_loc = project->first("QMAKE_BUNDLE_LOCATION");
             if(!bundle_loc.isEmpty() && !bundle_loc.startsWith("/"))
                 bundle_loc.prepend("/");
diff --git a/qmake/generators/win32/winmakefile.cpp b/qmake/generators/win32/winmakefile.cpp
index 27d2a7c0a5..86d10c213c 100644
--- a/qmake/generators/win32/winmakefile.cpp
+++ b/qmake/generators/win32/winmakefile.cpp
@@ -38,6 +38,8 @@
 #include <qdir.h>
 #include <stdlib.h>
 
+#include <algorithm>
+
 QT_BEGIN_NAMESPACE
 
 ProString Win32MakefileGenerator::fixLibFlag(const ProString &lib)
@@ -73,16 +75,37 @@ Win32MakefileGenerator::parseLibFlag(const ProString &flag, ProString *arg)
     return LibFlagFile;
 }
 
+class LibrarySearchPath : public QMakeLocalFileName
+{
+public:
+    LibrarySearchPath() = default;
+
+    LibrarySearchPath(const QString &s)
+        : QMakeLocalFileName(s)
+    {
+    }
+
+    LibrarySearchPath(QString &&s, bool isDefault = false)
+        : QMakeLocalFileName(std::move(s)), _default(isDefault)
+    {
+    }
+
+    bool isDefault() const { return _default; }
+
+private:
+    bool _default = false;
+};
+
 bool
 Win32MakefileGenerator::findLibraries(bool linkPrl, bool mergeLflags)
 {
     ProStringList impexts = project->values("QMAKE_LIB_EXTENSIONS");
     if (impexts.isEmpty())
         impexts = project->values("QMAKE_EXTENSION_STATICLIB");
-    QVector<QMakeLocalFileName> dirs;
+    QVector<LibrarySearchPath> dirs;
     int libidx = 0;
     for (const ProString &dlib : project->values("QMAKE_DEFAULT_LIBDIRS"))
-        dirs.append(QMakeLocalFileName(dlib.toQString()));
+        dirs.append(LibrarySearchPath(dlib.toQString(), true));
   static const char * const lflags[] = { "LIBS", "LIBS_PRIVATE",
                                          "QMAKE_LIBS", "QMAKE_LIBS_PRIVATE", nullptr };
   for (int i = 0; lflags[i]; i++) {
@@ -92,12 +115,20 @@ Win32MakefileGenerator::findLibraries(bool linkPrl, bool mergeLflags)
         ProString arg;
         LibFlagType type = parseLibFlag(opt, &arg);
         if (type == LibFlagPath) {
-            QMakeLocalFileName lp(arg.toQString());
-            int idx = dirs.indexOf(lp);
+            const QString argqstr = arg.toQString();
+            auto dit = std::find_if(dirs.cbegin(), dirs.cend(),
+                                 [&argqstr](const LibrarySearchPath &p)
+                                 {
+                                     return p.real() == argqstr;
+                                 });
+            int idx = dit == dirs.cend()
+                    ? -1
+                    : std::distance(dirs.cbegin(), dit);
             if (idx >= 0 && idx < libidx) {
                 it = l.erase(it);
                 continue;
             }
+            const LibrarySearchPath lp(argqstr);
             dirs.insert(libidx++, lp);
             (*it) = "-L" + lp.real();
         } else if (type == LibFlagLib) {
@@ -114,7 +145,8 @@ Win32MakefileGenerator::findLibraries(bool linkPrl, bool mergeLflags)
                 for (ProStringList::ConstIterator extit = impexts.cbegin();
                      extit != impexts.cend(); ++extit) {
                     if (exists(libBase + '.' + *extit)) {
-                        (*it) = cand + verovr + '.' + *extit;
+                        *it = (dir_it->isDefault() ? lib : cand)
+                                + verovr + '.' + *extit;
                         goto found;
                     }
                 }
diff --git a/src/android/jar/src/org/qtproject/qt5/android/QtNative.java b/src/android/jar/src/org/qtproject/qt5/android/QtNative.java
index c33d5016ce..7db16002ff 100644
--- a/src/android/jar/src/org/qtproject/qt5/android/QtNative.java
+++ b/src/android/jar/src/org/qtproject/qt5/android/QtNative.java
@@ -1013,6 +1013,25 @@ public class QtNative
         });
     }
 
+    private static String[] listAssetContent(android.content.res.AssetManager asset, String path) {
+        String [] list;
+        ArrayList<String> res = new ArrayList<String>();
+        try {
+            list = asset.list(path);
+            if (list.length > 0) {
+                for (String file : list) {
+                    try {
+                        String[] isDir = asset.list(path.length() > 0 ? path + "/" + file : file);
+                        if (isDir != null && isDir.length > 0)
+                            file += "/";
+                        res.add(file);
+                    } catch (Exception e) {}
+                }
+            }
+        } catch (Exception e) {}
+        return res.toArray(new String[res.size()]);
+    }
+
     // screen methods
     public static native void setDisplayMetrics(int screenWidthPixels,
                                                 int screenHeightPixels,
diff --git a/src/android/java/src/org/qtproject/qt5/android/bindings/QtLoader.java b/src/android/java/src/org/qtproject/qt5/android/bindings/QtLoader.java
index 45941e8ed8..1e72aa3841 100644
--- a/src/android/java/src/org/qtproject/qt5/android/bindings/QtLoader.java
+++ b/src/android/java/src/org/qtproject/qt5/android/bindings/QtLoader.java
@@ -44,8 +44,6 @@ import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.ComponentInfo;
-import android.content.pm.PackageInfo;
-import android.content.res.AssetManager;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.IBinder;
@@ -55,15 +53,8 @@ import android.util.Log;
 import org.kde.necessitas.ministro.IMinistro;
 import org.kde.necessitas.ministro.IMinistroCallback;
 
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -88,8 +79,6 @@ public abstract class QtLoader {
     public static final String ENVIRONMENT_VARIABLES_KEY = "environment.variables";
     public static final String APPLICATION_PARAMETERS_KEY = "application.parameters";
     public static final String BUNDLED_LIBRARIES_KEY = "bundled.libraries";
-    public static final String BUNDLED_IN_LIB_RESOURCE_ID_KEY = "android.app.bundled_in_lib_resource_id";
-    public static final String BUNDLED_IN_ASSETS_RESOURCE_ID_KEY = "android.app.bundled_in_assets_resource_id";
     public static final String MAIN_LIBRARY_KEY = "main.library";
     public static final String STATIC_INIT_CLASSES_KEY = "static.init.classes";
     public static final String NECESSITAS_API_LEVEL_KEY = "necessitas.api.level";
@@ -141,7 +130,6 @@ public abstract class QtLoader {
     public String QT_ANDROID_DEFAULT_THEME = null; // sets the default theme.
 
     public static final int INCOMPATIBLE_MINISTRO_VERSION = 1; // Incompatible Ministro version. Ministro needs to be upgraded.
-    public static final int BUFFER_SIZE = 1024;
 
     public String[] m_sources = {"https://download.qt-project.org/ministro/android/qt5/qt-5.7"}; // Make sure you are using ONLY secure locations
     public String m_repository = "default"; // Overwrites the default Ministro repository
@@ -368,263 +356,6 @@ public abstract class QtLoader {
         errorDialog.show();
     }
 
-    static private void copyFile(InputStream inputStream, OutputStream outputStream)
-            throws IOException
-    {
-        byte[] buffer = new byte[BUFFER_SIZE];
-
-        int count;
-        while ((count = inputStream.read(buffer)) > 0)
-            outputStream.write(buffer, 0, count);
-    }
-
-    private void copyAsset(String source, String destination)
-            throws IOException
-    {
-        // Already exists, we don't have to do anything
-        File destinationFile = new File(destination);
-        if (destinationFile.exists())
-            return;
-
-        File parentDirectory = destinationFile.getParentFile();
-        if (!parentDirectory.exists())
-            parentDirectory.mkdirs();
-
-        destinationFile.createNewFile();
-
-        AssetManager assetsManager = m_context.getAssets();
-        InputStream inputStream = null;
-        FileOutputStream outputStream = null;
-        try {
-            inputStream = assetsManager.open(source);
-            outputStream = new FileOutputStream(destinationFile);
-            copyFile(inputStream, outputStream);
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            if (inputStream != null)
-                inputStream.close();
-
-            if (outputStream != null)
-                // Ensure that the buffered data is flushed to the OS for writing.
-                outputStream.flush();
-        }
-        // Mark the output stream as still needing to be written to physical disk.
-        // The output stream will be closed after this sync completes.
-        m_fileOutputStreams.add(outputStream);
-    }
-
-    private static void createBundledBinary(String source, String destination)
-            throws IOException
-    {
-        // Already exists, we don't have to do anything
-        File destinationFile = new File(destination);
-        if (destinationFile.exists())
-            return;
-
-        File parentDirectory = destinationFile.getParentFile();
-        if (!parentDirectory.exists())
-            parentDirectory.mkdirs();
-
-        destinationFile.createNewFile();
-
-        InputStream inputStream = null;
-        FileOutputStream outputStream = null;
-        try {
-            inputStream = new FileInputStream(source);
-            outputStream = new FileOutputStream(destinationFile);
-            copyFile(inputStream, outputStream);
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            if (inputStream != null)
-                inputStream.close();
-
-            if (outputStream != null)
-                // Ensure that the buffered data is flushed to the OS for writing.
-                outputStream.flush();
-        }
-        // Mark the output stream as still needing to be written to physical disk.
-        // The output stream will be closed after this sync completes.
-        m_fileOutputStreams.add(outputStream);
-    }
-
-    private boolean cleanCacheIfNecessary(String pluginsPrefix, long packageVersion)
-    {
-        File versionFile = new File(pluginsPrefix + "cache.version");
-
-        long cacheVersion = 0;
-        if (versionFile.exists() && versionFile.canRead()) {
-            DataInputStream inputStream = null;
-            try {
-                inputStream = new DataInputStream(new FileInputStream(versionFile));
-                cacheVersion = inputStream.readLong();
-            } catch (Exception e) {
-                e.printStackTrace();
-            } finally {
-                if (inputStream != null) {
-                    try {
-                        inputStream.close();
-                    } catch (Exception e) {
-                        e.printStackTrace();
-                    }
-                }
-            }
-        }
-
-        if (cacheVersion != packageVersion) {
-            deleteRecursively(new File(pluginsPrefix));
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    private void extractBundledPluginsAndImports(String pluginsPrefix, String libsDir)
-            throws IOException
-    {
-        long packageVersion = -1;
-        try {
-            PackageInfo packageInfo = m_context.getPackageManager().getPackageInfo(m_context.getPackageName(), 0);
-            packageVersion = packageInfo.lastUpdateTime;
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-
-        if (!cleanCacheIfNecessary(pluginsPrefix, packageVersion))
-            return;
-
-        {
-            // why can't we load the plugins directly from libs ?!?!
-            String key = BUNDLED_IN_LIB_RESOURCE_ID_KEY;
-            if (m_contextInfo.metaData.containsKey(key)) {
-                int resourceId = m_contextInfo.metaData.getInt(key);
-                ArrayList<String> list = prefferedAbiLibs(m_context.getResources().getStringArray(resourceId));
-
-                for (String bundledImportBinary : list) {
-                    String[] split = bundledImportBinary.split(":");
-                    String sourceFileName = libsDir + split[0];
-                    String destinationFileName = pluginsPrefix + split[1];
-                    createBundledBinary(sourceFileName, destinationFileName);
-                }
-            }
-        }
-
-        {
-            String key = BUNDLED_IN_ASSETS_RESOURCE_ID_KEY;
-            if (m_contextInfo.metaData.containsKey(key)) {
-                String[] list = m_context.getResources().getStringArray(m_contextInfo.metaData.getInt(key));
-
-                for (String fileName : list) {
-                    String[] split = fileName.split(":");
-                    String sourceFileName = split[0];
-                    String destinationFileName = pluginsPrefix + split[1];
-                    copyAsset(sourceFileName, destinationFileName);
-                }
-            }
-
-        }
-
-        // The Java compiler must be assured that variables belonging to this parent thread will not
-        // go out of scope during the runtime of the spawned thread (since in general spawned
-        // threads can outlive their parent threads). Copy variables and declare as 'final' before
-        // passing into the spawned thread.
-        final String pluginsPrefixFinal = pluginsPrefix;
-        final long packageVersionFinal = packageVersion;
-
-        // Spawn a worker thread to write all installed files to physical disk and indicate
-        // successful installation by creating the 'cache.version' file.
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    finalizeInstallation(pluginsPrefixFinal, packageVersionFinal);
-                } catch (Exception e) {
-                    Log.e(QtApplication.QtTAG, e.getMessage());
-                    e.printStackTrace();
-                    return;
-                }
-            }
-        }).start();
-    }
-
-    private void finalizeInstallation(String pluginsPrefix, long packageVersion)
-            throws IOException
-    {
-        {
-            // Write all installed files to physical disk and close each output stream
-            for (FileOutputStream fileOutputStream : m_fileOutputStreams) {
-                fileOutputStream.getFD().sync();
-                fileOutputStream.close();
-            }
-
-            m_fileOutputStreams.clear();
-        }
-
-        {
-            // Create 'cache.version' file
-
-            File versionFile = new File(pluginsPrefix + "cache.version");
-
-            File parentDirectory = versionFile.getParentFile();
-            if (!parentDirectory.exists())
-                parentDirectory.mkdirs();
-
-            versionFile.createNewFile();
-
-            DataOutputStream outputStream = null;
-            try {
-                outputStream = new DataOutputStream(new FileOutputStream(versionFile));
-                outputStream.writeLong(packageVersion);
-            } catch (Exception e) {
-                e.printStackTrace();
-            } finally {
-                if (outputStream != null)
-                    outputStream.close();
-            }
-        }
-
-    }
-
-    private void deleteRecursively(File directory)
-    {
-        File[] files = directory.listFiles();
-        if (files != null) {
-            for (File file : files) {
-                if (file.isDirectory())
-                    deleteRecursively(file);
-                else
-                    file.delete();
-            }
-
-            directory.delete();
-        }
-    }
-
-    private void cleanOldCacheIfNecessary(String oldLocalPrefix, String localPrefix)
-    {
-        File newCache = new File(localPrefix);
-        if (!newCache.exists()) {
-            {
-                File oldPluginsCache = new File(oldLocalPrefix + "plugins/");
-                if (oldPluginsCache.exists() && oldPluginsCache.isDirectory())
-                    deleteRecursively(oldPluginsCache);
-            }
-
-            {
-                File oldImportsCache = new File(oldLocalPrefix + "imports/");
-                if (oldImportsCache.exists() && oldImportsCache.isDirectory())
-                    deleteRecursively(oldImportsCache);
-            }
-
-            {
-                File oldQmlCache = new File(oldLocalPrefix + "qml/");
-                if (oldQmlCache.exists() && oldQmlCache.isDirectory())
-                    deleteRecursively(oldQmlCache);
-            }
-        }
-    }
-
     public void startApp(final boolean firstStart)
     {
         try {
@@ -688,29 +419,13 @@ public abstract class QtLoader {
 
                 if (m_contextInfo.metaData.containsKey("android.app.bundle_local_qt_libs")
                         && m_contextInfo.metaData.getInt("android.app.bundle_local_qt_libs") == 1) {
-                    File dataDir = new File(m_context.getApplicationInfo().dataDir);
-                    String dataPath = dataDir.getCanonicalPath() + "/";
-                    String pluginsPrefix = dataPath + "qt-reserved-files/";
-
-                    if (libsDir == null)
-                        throw new Exception("Invalid libsDir");
-
-                    cleanOldCacheIfNecessary(dataPath, pluginsPrefix);
-                    extractBundledPluginsAndImports(pluginsPrefix, libsDir);
-
-                    if (m_contextInfo.metaData.containsKey(BUNDLED_IN_LIB_RESOURCE_ID_KEY)) {
-                        int resourceId = m_contextInfo.metaData.getInt("android.app.load_local_libs_resource_id");
-                        for (String libs : prefferedAbiLibs(m_context.getResources().getStringArray(resourceId))) {
-                            for (String lib : libs.split(":")) {
-                                if (!lib.isEmpty())
-                                    libraryList.add(libsDir + lib);
-                            }
+                    int resourceId = m_contextInfo.metaData.getInt("android.app.load_local_libs_resource_id");
+                    for (String libs : prefferedAbiLibs(m_context.getResources().getStringArray(resourceId))) {
+                        for (String lib : libs.split(":")) {
+                            if (!lib.isEmpty())
+                                libraryList.add(libsDir + lib);
                         }
                     }
-
-                    ENVIRONMENT_VARIABLES += "\tQML2_IMPORT_PATH=" + pluginsPrefix + "/qml"
-                            + "\tQML_IMPORT_PATH=" + pluginsPrefix + "/imports"
-                            + "\tQT_PLUGIN_PATH=" + pluginsPrefix + "/plugins";
                     if (bundledLibsDir != null)
                         ENVIRONMENT_VARIABLES += "\tQT_BUNDLED_LIBS_PATH=" + bundledLibsDir;
                 }
diff --git a/src/android/templates/AndroidManifest.xml b/src/android/templates/AndroidManifest.xml
index 75da314c2b..6d0f4e0d45 100644
--- a/src/android/templates/AndroidManifest.xml
+++ b/src/android/templates/AndroidManifest.xml
@@ -34,8 +34,6 @@
             <meta-data android:name="android.app.bundled_libs_resource_id" android:resource="@array/bundled_libs"/>
             <!-- Deploy Qt libs as part of package -->
             <meta-data android:name="android.app.bundle_local_qt_libs" android:value="-- %%BUNDLE_LOCAL_QT_LIBS%% --"/>
-            <meta-data android:name="android.app.bundled_in_lib_resource_id" android:resource="@array/bundled_in_lib"/>
-            <meta-data android:name="android.app.bundled_in_assets_resource_id" android:resource="@array/bundled_in_assets"/>
 
             <!-- Run with local libs -->
             <meta-data android:name="android.app.use_local_qt_libs" android:value="-- %%USE_LOCAL_QT_LIBS%% --"/>
diff --git a/src/android/templates/build.gradle b/src/android/templates/build.gradle
index d2da115936..3087d08c83 100644
--- a/src/android/templates/build.gradle
+++ b/src/android/templates/build.gradle
@@ -54,4 +54,9 @@ android {
     lintOptions {
         abortOnError false
     }
+
+    // Do not compress Qt binary resources file
+    aaptOptions {
+        noCompress 'rcc'
+    }
 }
diff --git a/src/android/templates/res/values/libs.xml b/src/android/templates/res/values/libs.xml
index db777bf433..6b1a4a2a02 100644
--- a/src/android/templates/res/values/libs.xml
+++ b/src/android/templates/res/values/libs.xml
@@ -11,20 +11,12 @@
         <!-- %%INSERT_EXTRA_LIBS%% -->
     </array>
 
-     <array name="qt_libs">
+    <array name="qt_libs">
         <!-- %%INSERT_QT_LIBS%% -->
-     </array>
-
-    <array name="bundled_in_lib">
-        <!-- %%INSERT_BUNDLED_IN_LIB%% -->
     </array>
 
     <array name="load_local_libs">
         <!-- %%INSERT_LOCAL_LIBS%% -->
     </array>
 
-    <array name="bundled_in_assets">
-        <!-- %%INSERT_BUNDLED_IN_ASSETS%% -->
-    </array>
-
 </resources>
diff --git a/src/concurrent/qtconcurrentmapkernel.h b/src/concurrent/qtconcurrentmapkernel.h
index 87fcf30cf9..7c9538a015 100644
--- a/src/concurrent/qtconcurrentmapkernel.h
+++ b/src/concurrent/qtconcurrentmapkernel.h
@@ -118,16 +118,16 @@ public:
         return false;
     }
 
-    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, ReducedResultType *) override
+    bool runIterations(Iterator sequenceBeginIterator, int beginIndex, int endIndex, ReducedResultType *) override
     {
         IntermediateResults<typename MapFunctor::result_type> results;
-        results.begin = begin;
-        results.end = end;
-        results.vector.reserve(end - begin);
+        results.begin = beginIndex;
+        results.end = endIndex;
+        results.vector.reserve(endIndex - beginIndex);
 
         Iterator it = sequenceBeginIterator;
-        std::advance(it, begin);
-        for (int i = begin; i < end; ++i) {
+        std::advance(it, beginIndex);
+        for (int i = beginIndex; i < endIndex; ++i) {
             results.vector.append(map(*(it)));
             std::advance(it, 1);
         }
@@ -176,13 +176,13 @@ public:
         return true;
     }
 
-    bool runIterations(Iterator sequenceBeginIterator, int begin, int end, T *results) override
+    bool runIterations(Iterator sequenceBeginIterator, int beginIndex, int endIndex, T *results) override
     {
 
         Iterator it = sequenceBeginIterator;
-        std::advance(it, begin);
-        for (int i = begin; i < end; ++i) {
-            runIteration(it, i, results + (i - begin));
+        std::advance(it, beginIndex);
+        for (int i = beginIndex; i < endIndex; ++i) {
+            runIteration(it, i, results + (i - beginIndex));
             std::advance(it, 1);
         }
 
diff --git a/src/corelib/Qt5CoreConfigExtras.cmake.in b/src/corelib/Qt5CoreConfigExtras.cmake.in
index e0652fdcf9..659faac6a5 100644
--- a/src/corelib/Qt5CoreConfigExtras.cmake.in
+++ b/src/corelib/Qt5CoreConfigExtras.cmake.in
@@ -46,6 +46,8 @@ if (NOT TARGET Qt5::rcc)
     )
 endif()
 
+set(CMAKE_AUTOMOC_MACRO_NAMES "Q_OBJECT" "Q_GADGET" "Q_NAMESPACE" "Q_NAMESPACE_EXPORT")
+
 set(Qt5Core_QMAKE_EXECUTABLE Qt5::qmake)
 set(Qt5Core_MOC_EXECUTABLE Qt5::moc)
 set(Qt5Core_RCC_EXECUTABLE Qt5::rcc)
diff --git a/src/corelib/codecs/qtextcodec.cpp b/src/corelib/codecs/qtextcodec.cpp
index 14f9abc28a..06fd88da90 100644
--- a/src/corelib/codecs/qtextcodec.cpp
+++ b/src/corelib/codecs/qtextcodec.cpp
@@ -103,10 +103,13 @@ typedef QList<QByteArray>::ConstIterator ByteArrayListConstIt;
 
 Q_GLOBAL_STATIC(QRecursiveMutex, textCodecsMutex);
 
-class TextCodecsMutexLocker {
+class TextCodecsMutexLocker
+{
     using Lock = decltype(qt_unique_lock(std::declval<QRecursiveMutex&>()));
     // ### FIXME: this is used when textCodecsMutex already == nullptr
     const Lock lock = qt_unique_lock(textCodecsMutex());
+public:
+    TextCodecsMutexLocker() {} // required d/t an ICC 19 bug
 };
 
 #if !QT_CONFIG(icu)
diff --git a/src/corelib/global/qfloat16.cpp b/src/corelib/global/qfloat16.cpp
index 2ba4c79374..6c21b7de5a 100644
--- a/src/corelib/global/qfloat16.cpp
+++ b/src/corelib/global/qfloat16.cpp
@@ -155,7 +155,7 @@ QT_BEGIN_NAMESPACE
 int qfloat16::fpClassify() const noexcept
 {
     return isInf() ? FP_INFINITE : isNaN() ? FP_NAN
-        : !b16 ? FP_ZERO : isNormal() ? FP_NORMAL : FP_SUBNORMAL;
+        : !(b16 & 0x7fff) ? FP_ZERO : isNormal() ? FP_NORMAL : FP_SUBNORMAL;
 }
 
 /*! \fn int qRound(qfloat16 value)
diff --git a/src/corelib/global/qfloat16.h b/src/corelib/global/qfloat16.h
index 4d1aa91349..9a4f1800a4 100644
--- a/src/corelib/global/qfloat16.h
+++ b/src/corelib/global/qfloat16.h
@@ -94,7 +94,7 @@ public:
     static constexpr qfloat16 _limit_quiet_NaN()  noexcept { return qfloat16(Wrap(0x7e00)); }
     // Signalling NaN is 0x7f00
     inline constexpr bool isNormal() const noexcept
-    { return b16 == 0 || ((b16 & 0x7c00) && (b16 & 0x7c00) != 0x7c00); }
+    { return (b16 & 0x7fff) == 0 || ((b16 & 0x7c00) && (b16 & 0x7c00) != 0x7c00); }
 private:
     quint16 b16;
     constexpr inline explicit qfloat16(Wrap nibble) noexcept : b16(nibble.b16) {}
@@ -296,7 +296,7 @@ class numeric_limits<QT_PREPEND_NAMESPACE(qfloat16)> : public numeric_limits<flo
 public:
     /*
       Treat quint16 b16 as if it were:
-      uint S: 1; // b16 >> 15 (sign)
+      uint S: 1; // b16 >> 15 (sign); can be set for zero
       uint E: 5; // (b16 >> 10) & 0x1f (offset exponent)
       uint M: 10; // b16 & 0x3ff (adjusted mantissa)
 
diff --git a/src/corelib/global/qglobal.cpp b/src/corelib/global/qglobal.cpp
index 123aeb1f7c..6ae5bf299a 100644
--- a/src/corelib/global/qglobal.cpp
+++ b/src/corelib/global/qglobal.cpp
@@ -47,12 +47,11 @@
 #include "qoperatingsystemversion.h"
 #include "qoperatingsystemversion_p.h"
 #if defined(Q_OS_WIN) || defined(Q_OS_CYGWIN) || defined(Q_OS_WINRT)
-#include "qoperatingsystemversion_win_p.h"
-#  if QT_CONFIG(settings)
-#    include "qsettings.h"
-#    include "qvariant.h"
+#  include "qoperatingsystemversion_win_p.h"
+#  ifndef Q_OS_WINRT
+#    include "private/qwinregistry_p.h"
 #  endif
-#endif
+#endif // Q_OS_WIN || Q_OS_CYGWIN
 #include <private/qlocale_tools_p.h>
 
 #include <qmutex.h>
@@ -2190,28 +2189,25 @@ const QSysInfo::WinVersion QSysInfo::WindowsVersion = QSysInfo::windowsVersion()
 QT_WARNING_POP
 #endif
 
-static QString readRegistryString(const QString &key, const QString &subKey)
+static QString readVersionRegistryString(const wchar_t *subKey)
 {
-#if QT_CONFIG(settings)
-    QSettings settings(key, QSettings::NativeFormat);
-    return settings.value(subKey).toString();
+#if !defined(QT_BUILD_QMAKE) && !defined(Q_OS_WINRT)
+     return QWinRegistryKey(HKEY_LOCAL_MACHINE, LR"(SOFTWARE\Microsoft\Windows NT\CurrentVersion)")
+            .stringValue(subKey);
 #else
-    Q_UNUSED(key);
-    Q_UNUSED(subKey);
-    return QString();
+     Q_UNUSED(subKey);
+     return QString();
 #endif
 }
 
-static inline QString windowsVersionKey() { return QStringLiteral(R"(HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion)"); }
-
 static inline QString windows10ReleaseId()
 {
-    return readRegistryString(windowsVersionKey(), QStringLiteral("ReleaseId"));
+    return readVersionRegistryString(L"ReleaseId");
 }
 
 static inline QString windows7Build()
 {
-    return readRegistryString(windowsVersionKey(), QStringLiteral("CurrentBuild"));
+    return readVersionRegistryString(L"CurrentBuild");
 }
 
 static QString winSp_helper()
@@ -2940,11 +2936,10 @@ QString QSysInfo::prettyProductName()
     if (!name)
         return result + versionString;
     result += QLatin1String(name);
-#    if !defined(Q_OS_WIN)
-        return result + QLatin1String(" (") + versionString + QLatin1Char(')');
-#    else
+#  if !defined(Q_OS_WIN) || defined(Q_OS_WINRT)
+    return result + QLatin1String(" (") + versionString + QLatin1Char(')');
+#  else
     // (resembling winver.exe): Windows 10 "Windows 10 Version 1809"
-    result += QLatin1String(" Version ");
     if (majorVersion >= 10) {
         const auto releaseId = windows10ReleaseId();
         if (!releaseId.isEmpty())
@@ -2952,7 +2947,7 @@ QString QSysInfo::prettyProductName()
         return result;
     }
     // Windows 7: "Windows 7 Version 6.1 (Build 7601: Service Pack 1)"
-    result += versionString + QLatin1String(" (");
+    result += QLatin1String(" Version ") + versionString + QLatin1String(" (");
     const auto build = windows7Build();
     if (!build.isEmpty())
         result += QLatin1String("Build ") + build;
@@ -2960,7 +2955,7 @@ QString QSysInfo::prettyProductName()
     if (!servicePack.isEmpty())
         result += QLatin1String(": ") + servicePack;
     return result + QLatin1Char(')');
-#    endif // Windows
+#  endif // Windows
 #elif defined(Q_OS_HAIKU)
     return QLatin1String("Haiku ") + productVersion();
 #elif defined(Q_OS_UNIX)
@@ -3079,6 +3074,7 @@ QByteArray QSysInfo::machineUniqueId()
     }
 #elif defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
     // Let's poke at the registry
+    // ### Qt 6: Use new helpers from qwinregistry.cpp (once bootstrap builds are obsolete)
     HKEY key = NULL;
     if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Cryptography", 0, KEY_READ | KEY_WOW64_64KEY, &key)
             == ERROR_SUCCESS) {
diff --git a/src/corelib/global/qlibraryinfo.cpp b/src/corelib/global/qlibraryinfo.cpp
index c7357f9d13..8bcf67e73d 100644
--- a/src/corelib/global/qlibraryinfo.cpp
+++ b/src/corelib/global/qlibraryinfo.cpp
@@ -495,6 +495,8 @@ static QString prefixFromAppDirHelper()
 #endif
 
 #if !defined(QT_BUILD_QMAKE) && QT_CONFIG(relocatable)
+#if !defined(QT_STATIC) && !(defined(Q_OS_DARWIN) && QT_CONFIG(framework)) \
+        && (QT_CONFIG(dlopen) || defined(Q_OS_WIN))
 static QString prefixFromQtCoreLibraryHelper(const QString &qtCoreLibraryPath)
 {
     const QString qtCoreLibrary = QDir::fromNativeSeparators(qtCoreLibraryPath);
@@ -503,6 +505,7 @@ static QString prefixFromQtCoreLibraryHelper(const QString &qtCoreLibraryPath)
             + QLatin1String(QT_CONFIGURE_LIBLOCATION_TO_PREFIX_PATH);
     return QDir::cleanPath(prefixDir);
 }
+#endif
 
 #if defined(Q_OS_WIN)
 #if defined(Q_OS_WINRT)
@@ -566,6 +569,23 @@ static QString getRelocatablePrefix()
 #error "The chosen platform / config does not support querying for a dynamic prefix."
 #endif
 
+#if defined(Q_OS_LINUX) && !defined(QT_STATIC) && defined(__GLIBC__)
+    // QTBUG-78948: libQt5Core.so may be located in subdirectories below libdir.
+    // See "Hardware capabilities" in the ld.so documentation and the Qt 5.3.0
+    // changelog regarding SSE2 support.
+    const QString libdir = QString::fromLatin1(
+        qt_configure_strs + qt_configure_str_offsets[QLibraryInfo::LibrariesPath - 1]);
+    QDir prefixDir(prefixPath);
+    while (!prefixDir.exists(libdir)) {
+        prefixDir.cdUp();
+        prefixPath = prefixDir.absolutePath();
+        if (prefixDir.isRoot()) {
+            prefixPath.clear();
+            break;
+        }
+    }
+#endif
+
     Q_ASSERT_X(!prefixPath.isEmpty(), "getRelocatablePrefix",
                                       "Failed to find the Qt prefix path.");
     return prefixPath;
@@ -851,10 +871,14 @@ QT_END_NAMESPACE
 
 #include "private/qcoreapplication_p.h"
 
+QT_WARNING_DISABLE_GCC("-Wattributes")
+QT_WARNING_DISABLE_CLANG("-Wattributes")
+QT_WARNING_DISABLE_INTEL(2621)
+
 extern const char qt_core_interpreter[] __attribute__((section(".interp")))
     = ELF_INTERPRETER;
 
-extern "C" void qt_core_boilerplate();
+extern "C" void qt_core_boilerplate() __attribute__((force_align_arg_pointer));
 void qt_core_boilerplate()
 {
     printf("This is the QtCore library version " QT_BUILD_STR "\n"
diff --git a/src/corelib/io/qsettings.cpp b/src/corelib/io/qsettings.cpp
index 4a119a1e2f..fc7122d904 100644
--- a/src/corelib/io/qsettings.cpp
+++ b/src/corelib/io/qsettings.cpp
@@ -746,7 +746,6 @@ bool QSettingsPrivate::iniUnescapedStringList(const QByteArray &str, int from, i
         { '\'', '\'' },
         { '\\', '\\' }
     };
-    static const int numEscapeCodes = sizeof(escapeCodes) / sizeof(escapeCodes[0]);
 
     bool isStringList = false;
     bool inQuotedString = false;
@@ -770,9 +769,9 @@ StNormal:
                 goto end;
 
             ch = str.at(i++);
-            for (int j = 0; j < numEscapeCodes; ++j) {
-                if (ch == escapeCodes[j][0]) {
-                    stringResult += QLatin1Char(escapeCodes[j][1]);
+            for (const auto &escapeCode : escapeCodes) {
+                if (ch == escapeCode[0]) {
+                    stringResult += QLatin1Char(escapeCode[1]);
                     goto StNormal;
                 }
             }
diff --git a/src/corelib/io/qsettings_win.cpp b/src/corelib/io/qsettings_win.cpp
index 679212ea21..6eb318006e 100644
--- a/src/corelib/io/qsettings_win.cpp
+++ b/src/corelib/io/qsettings_win.cpp
@@ -136,6 +136,8 @@ static void mergeKeySets(NameSet *dest, const QStringList &src)
 ** Wrappers for the insane windows registry API
 */
 
+// ### Qt 6: Use new helpers from qwinregistry.cpp (once bootstrap builds are obsolete)
+
 // Open a key with the specified "perms".
 // "access" is to explicitly use the 32- or 64-bit branch.
 static HKEY openKey(HKEY parentHandle, REGSAM perms, const QString &rSubKey, REGSAM access = 0)
diff --git a/src/corelib/io/qstandardpaths.cpp b/src/corelib/io/qstandardpaths.cpp
index f56fef7f8e..3b5f2f97da 100644
--- a/src/corelib/io/qstandardpaths.cpp
+++ b/src/corelib/io/qstandardpaths.cpp
@@ -232,7 +232,7 @@ QT_BEGIN_NAMESPACE
     \row \li DocumentsLocation
          \li "~/Documents"
     \row \li FontsLocation
-         \li "~/.fonts"
+         \li "~/.fonts", "~/.local/share/fonts", "/usr/local/share/fonts", "/usr/share/fonts"
     \row \li ApplicationsLocation
          \li "~/.local/share/applications", "/usr/local/share/applications", "/usr/share/applications"
     \row \li MusicLocation
diff --git a/src/corelib/io/qstandardpaths_unix.cpp b/src/corelib/io/qstandardpaths_unix.cpp
index 6425890e3f..c35d7adc9f 100644
--- a/src/corelib/io/qstandardpaths_unix.cpp
+++ b/src/corelib/io/qstandardpaths_unix.cpp
@@ -339,6 +339,9 @@ QStringList QStandardPaths::standardLocations(StandardLocation type)
         break;
     case FontsLocation:
         dirs += QDir::homePath() + QLatin1String("/.fonts");
+        dirs += xdgDataDirs();
+        for (int i = 1; i < dirs.count(); ++i)
+            dirs[i].append(QLatin1String("/fonts"));
         break;
     default:
         break;
diff --git a/src/corelib/itemmodels/qsortfilterproxymodel.cpp b/src/corelib/itemmodels/qsortfilterproxymodel.cpp
index 675bf4b8c3..978102035e 100644
--- a/src/corelib/itemmodels/qsortfilterproxymodel.cpp
+++ b/src/corelib/itemmodels/qsortfilterproxymodel.cpp
@@ -377,6 +377,7 @@ public:
 
     void sort();
     bool update_source_sort_column();
+    int find_source_sort_column() const;
     void sort_source_rows(QVector<int> &source_rows,
                           const QModelIndex &source_parent) const;
     QVector<QPair<int, QVector<int > > > proxy_intervals_for_source_items_to_add(
@@ -479,11 +480,8 @@ void QSortFilterProxyModelPrivate::_q_clearMapping()
 
     qDeleteAll(source_index_mapping);
     source_index_mapping.clear();
-    if (dynamic_sortfilter && update_source_sort_column()) {
-        //update_source_sort_column might have created wrong mapping so we have to clear it again
-        qDeleteAll(source_index_mapping);
-        source_index_mapping.clear();
-    }
+    if (dynamic_sortfilter)
+        source_sort_column = find_source_sort_column();
 
     // update the persistent indexes
     update_persistent_indexes(source_indexes);
@@ -640,6 +638,31 @@ bool QSortFilterProxyModelPrivate::update_source_sort_column()
     return old_source_sort_column != source_sort_column;
 }
 
+/*!
+  \internal
+
+  Find the source_sort_column without creating a full mapping and
+  without updating anything.
+*/
+int QSortFilterProxyModelPrivate::find_source_sort_column() const
+{
+    if (proxy_sort_column == -1)
+        return -1;
+
+    const QModelIndex rootIndex;
+    const int source_cols = model->columnCount();
+    int accepted_columns = -1;
+
+    Q_Q(const QSortFilterProxyModel);
+    for (int i = 0; i < source_cols; ++i) {
+        if (q->filterAcceptsColumn(i, rootIndex)) {
+            if (++accepted_columns == proxy_sort_column)
+                return i;
+        }
+    }
+
+    return -1;
+}
 
 /*!
   \internal
@@ -1591,11 +1614,8 @@ void QSortFilterProxyModelPrivate::_q_sourceLayoutChanged(const QList<QPersisten
     update_persistent_indexes(saved_persistent_indexes);
     saved_persistent_indexes.clear();
 
-    if (dynamic_sortfilter && update_source_sort_column()) {
-        //update_source_sort_column might have created wrong mapping so we have to clear it again
-        qDeleteAll(source_index_mapping);
-        source_index_mapping.clear();
-    }
+    if (dynamic_sortfilter)
+        source_sort_column = find_source_sort_column();
 
     emit q->layoutChanged(saved_layoutChange_parents);
     saved_layoutChange_parents.clear();
diff --git a/src/corelib/kernel/kernel.pri b/src/corelib/kernel/kernel.pri
index 789bcb7927..bd3cabc01a 100644
--- a/src/corelib/kernel/kernel.pri
+++ b/src/corelib/kernel/kernel.pri
@@ -88,8 +88,10 @@ win32 {
             SOURCES += kernel/qeventdispatcher_winrt.cpp
             HEADERS += kernel/qeventdispatcher_winrt_p.h
         } else {
-            SOURCES += kernel/qeventdispatcher_win.cpp
-            HEADERS += kernel/qeventdispatcher_win_p.h
+            SOURCES += kernel/qeventdispatcher_win.cpp \
+                       kernel/qwinregistry.cpp
+            HEADERS += kernel/qeventdispatcher_win_p.h \
+                       kernel/qwinregistry_p.h
         }
 
         !winrt: LIBS_PRIVATE += -lversion
diff --git a/src/corelib/kernel/qcore_mac_objc.mm b/src/corelib/kernel/qcore_mac_objc.mm
index 9e9e71c397..b1f3b74cd4 100644
--- a/src/corelib/kernel/qcore_mac_objc.mm
+++ b/src/corelib/kernel/qcore_mac_objc.mm
@@ -211,6 +211,12 @@ QDebug operator<<(QDebug debug, const QMacAutoReleasePool *pool)
     debug << "QMacAutoReleasePool(" << (const void *)pool << ')';
     return debug;
 }
+
+QDebug operator<<(QDebug debug, const QCFString &string)
+{
+    debug << static_cast<QString>(string);
+    return debug;
+}
 #endif // !QT_NO_DEBUG_STREAM
 
 #ifdef Q_OS_MACOS
diff --git a/src/corelib/kernel/qcore_mac_p.h b/src/corelib/kernel/qcore_mac_p.h
index 3266dc10a8..535d3579b2 100644
--- a/src/corelib/kernel/qcore_mac_p.h
+++ b/src/corelib/kernel/qcore_mac_p.h
@@ -137,8 +137,10 @@ private:
 template <typename T>
 class QCFType : public QAppleRefCounted<T, CFTypeRef, CFRetain, CFRelease>
 {
+    using Base = QAppleRefCounted<T, CFTypeRef, CFRetain, CFRelease>;
 public:
-    using QAppleRefCounted<T, CFTypeRef, CFRetain, CFRelease>::QAppleRefCounted;
+    using Base::Base;
+    explicit QCFType(CFTypeRef r) : Base(static_cast<T>(r)) {}
     template <typename X> X as() const { return reinterpret_cast<X>(this->value); }
     static QCFType constructFromGet(const T &t)
     {
@@ -151,6 +153,7 @@ public:
 class Q_CORE_EXPORT QCFString : public QCFType<CFStringRef>
 {
 public:
+    using QCFType<CFStringRef>::QCFType;
     inline QCFString(const QString &str) : QCFType<CFStringRef>(0), string(str) {}
     inline QCFString(const CFStringRef cfstr = 0) : QCFType<CFStringRef>(cfstr) {}
     inline QCFString(const QCFType<CFStringRef> &other) : QCFType<CFStringRef>(other) {}
@@ -168,7 +171,8 @@ Q_CORE_EXPORT bool qt_mac_applicationIsInDarkMode();
 #endif
 
 #ifndef QT_NO_DEBUG_STREAM
-QDebug operator<<(QDebug debug, const QMacAutoReleasePool *pool);
+Q_CORE_EXPORT QDebug operator<<(QDebug debug, const QMacAutoReleasePool *pool);
+Q_CORE_EXPORT QDebug operator<<(QDebug debug, const QCFString &string);
 #endif
 
 Q_CORE_EXPORT bool qt_apple_isApplicationExtension();
diff --git a/src/corelib/kernel/qeventdispatcher_cf.mm b/src/corelib/kernel/qeventdispatcher_cf.mm
index b9e334f1f4..177551467c 100644
--- a/src/corelib/kernel/qeventdispatcher_cf.mm
+++ b/src/corelib/kernel/qeventdispatcher_cf.mm
@@ -56,6 +56,14 @@
 #  include <UIKit/UIApplication.h>
 #endif
 
+QT_BEGIN_NAMESPACE
+namespace QtPrivate {
+Q_LOGGING_CATEGORY(lcEventDispatcher, "qt.eventdispatcher");
+Q_LOGGING_CATEGORY(lcEventDispatcherTimers, "qt.eventdispatcher.timers");
+}
+using namespace QtPrivate;
+QT_END_NAMESPACE
+
 QT_USE_NAMESPACE
 
 /*
@@ -148,9 +156,6 @@ static CFStringRef runLoopMode(NSDictionary *dictionary)
 
 QT_BEGIN_NAMESPACE
 
-Q_LOGGING_CATEGORY(lcEventDispatcher, "qt.eventdispatcher");
-Q_LOGGING_CATEGORY(lcEventDispatcherTimers, "qt.eventdispatcher.timers");
-
 class RunLoopDebugger : public QObject
 {
     Q_OBJECT
diff --git a/src/corelib/kernel/qeventdispatcher_cf_p.h b/src/corelib/kernel/qeventdispatcher_cf_p.h
index 26191d520c..a2cecd9a93 100644
--- a/src/corelib/kernel/qeventdispatcher_cf_p.h
+++ b/src/corelib/kernel/qeventdispatcher_cf_p.h
@@ -98,8 +98,10 @@ Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(RunLoopModeTracker));
 
 QT_BEGIN_NAMESPACE
 
-Q_DECLARE_LOGGING_CATEGORY(lcEventDispatcher);
-Q_DECLARE_LOGGING_CATEGORY(lcEventDispatcherTimers)
+namespace QtPrivate {
+Q_CORE_EXPORT Q_DECLARE_LOGGING_CATEGORY(lcEventDispatcher);
+Q_CORE_EXPORT Q_DECLARE_LOGGING_CATEGORY(lcEventDispatcherTimers)
+}
 
 class QEventDispatcherCoreFoundation;
 
diff --git a/src/corelib/kernel/qwinregistry.cpp b/src/corelib/kernel/qwinregistry.cpp
new file mode 100644
index 0000000000..6566dd3c76
--- /dev/null
+++ b/src/corelib/kernel/qwinregistry.cpp
@@ -0,0 +1,120 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qwinregistry_p.h"
+
+#include <QtCore/qvarlengtharray.h>
+
+#include <algorithm>
+
+QT_BEGIN_NAMESPACE
+
+QWinRegistryKey::QWinRegistryKey() :
+    m_key(nullptr)
+{
+}
+
+// Open a key with the specified permissions (KEY_READ/KEY_WRITE).
+// "access" is to explicitly use the 32- or 64-bit branch.
+QWinRegistryKey::QWinRegistryKey(HKEY parentHandle, QStringView subKey,
+                                 REGSAM permissions, REGSAM access)
+{
+    if (RegOpenKeyEx(parentHandle, reinterpret_cast<const wchar_t *>(subKey.utf16()),
+                     0, permissions | access, &m_key) != ERROR_SUCCESS) {
+        m_key = nullptr;
+    }
+}
+
+QWinRegistryKey::~QWinRegistryKey()
+{
+    close();
+}
+
+void QWinRegistryKey::close()
+{
+    if (isValid()) {
+        RegCloseKey(m_key);
+        m_key = nullptr;
+    }
+}
+
+QString QWinRegistryKey::stringValue(QStringView subKey) const
+{
+    QString result;
+    if (!isValid())
+        return result;
+    DWORD type;
+    DWORD size;
+    auto subKeyC = reinterpret_cast<const wchar_t *>(subKey.utf16());
+    if (RegQueryValueEx(m_key, subKeyC, nullptr, &type, nullptr, &size) != ERROR_SUCCESS
+        || (type != REG_SZ && type != REG_EXPAND_SZ) || size <= 2) {
+        return result;
+    }
+    // Reserve more for rare cases where trailing '\0' are missing in registry,
+    // otherwise chop off the '\0' received.
+    QString buffer(int(size / sizeof(wchar_t)), Qt::Uninitialized);
+    if (RegQueryValueEx(m_key, subKeyC, nullptr, &type,
+                        reinterpret_cast<LPBYTE>(buffer.data()), &size) == ERROR_SUCCESS) {
+        if (buffer.endsWith(QChar::Null))
+            buffer.chop(1);
+    } else {
+        buffer.clear();
+    }
+    return buffer;
+}
+
+QPair<DWORD, bool> QWinRegistryKey::dwordValue(QStringView subKey) const
+{
+    if (!isValid())
+        return qMakePair(0, false);
+    DWORD type;
+    auto subKeyC = reinterpret_cast<const wchar_t *>(subKey.utf16());
+    if (RegQueryValueEx(m_key, subKeyC, nullptr, &type, nullptr, nullptr) != ERROR_SUCCESS
+        || type != REG_DWORD) {
+        return qMakePair(0, false);
+    }
+    DWORD value = 0;
+    DWORD size = sizeof(value);
+    const bool ok =
+        RegQueryValueEx(m_key, subKeyC, nullptr, nullptr,
+                        reinterpret_cast<unsigned char *>(&value), &size) == ERROR_SUCCESS;
+    return qMakePair(value, ok);
+}
+
+QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qwinregistry_p.h b/src/corelib/kernel/qwinregistry_p.h
new file mode 100644
index 0000000000..d249a97988
--- /dev/null
+++ b/src/corelib/kernel/qwinregistry_p.h
@@ -0,0 +1,89 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QWINREGISTRY_H
+#define QWINREGISTRY_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qpair.h>
+#include <QtCore/qstring.h>
+#include <QtCore/qstringview.h>
+#include <QtCore/qt_windows.h>
+
+QT_BEGIN_NAMESPACE
+
+class Q_CORE_EXPORT QWinRegistryKey
+{
+public:
+    Q_DISABLE_COPY(QWinRegistryKey)
+
+    QWinRegistryKey();
+    explicit QWinRegistryKey(HKEY parentHandle, QStringView subKey,
+                             REGSAM permissions = KEY_READ, REGSAM access = 0);
+    ~QWinRegistryKey();
+
+    QWinRegistryKey(QWinRegistryKey &&other) noexcept { swap(other); }
+    QWinRegistryKey &operator=(QWinRegistryKey &&other) noexcept { swap(other); return *this; }
+
+    void swap(QWinRegistryKey &other) noexcept { qSwap(m_key, other.m_key); }
+
+    bool isValid() const { return m_key != nullptr; }
+    operator HKEY() const { return m_key; }
+    void close();
+
+    QString stringValue(QStringView subKey) const;
+    QPair<DWORD, bool> dwordValue(QStringView subKey) const;
+
+private:
+    HKEY m_key;
+};
+
+QT_END_NAMESPACE
+
+#endif // QWINREGISTRY_H
diff --git a/src/corelib/text/qchar.cpp b/src/corelib/text/qchar.cpp
index d959c55bb7..9b03a93278 100644
--- a/src/corelib/text/qchar.cpp
+++ b/src/corelib/text/qchar.cpp
@@ -61,6 +61,7 @@ QT_BEGIN_NAMESPACE
 /*!
     \class QLatin1Char
     \inmodule QtCore
+    \reentrant
     \brief The QLatin1Char class provides an 8-bit ASCII/Latin-1 character.
 
     \ingroup string-processing
diff --git a/src/corelib/text/qlocale.cpp b/src/corelib/text/qlocale.cpp
index 48d57e5e6e..75a5bc802e 100644
--- a/src/corelib/text/qlocale.cpp
+++ b/src/corelib/text/qlocale.cpp
@@ -345,6 +345,23 @@ QByteArray QLocalePrivate::bcp47Name(char separator) const
     return localeId.withLikelySubtagsRemoved().name(separator);
 }
 
+/*!
+  \internal
+ */
+QByteArray QLocalePrivate::rawName(char separator) const
+{
+    QByteArrayList parts;
+    if (m_data->m_language_id != QLocale::AnyLanguage)
+        parts.append(languageCode().latin1());
+    if (m_data->m_script_id != QLocale::AnyScript)
+        parts.append(scriptCode().latin1());
+    if (m_data->m_country_id != QLocale::AnyCountry)
+        parts.append(countryCode().latin1());
+
+    return parts.join(separator);
+}
+
+
 static const QLocaleData *findLocaleDataById(const QLocaleId &lid)
 {
     QLocaleId localeId = lid.withLikelySubtagsAdded();
@@ -4367,30 +4384,63 @@ QString QLocale::formattedDataSize(qint64 bytes, int precision, DataSizeFormats
 */
 QStringList QLocale::uiLanguages() const
 {
+    QStringList uiLanguages;
+    QVector<QLocale> locales;
 #ifndef QT_NO_SYSTEMLOCALE
     if (d->m_data == systemData()) {
         QVariant res = systemLocale()->query(QSystemLocale::UILanguages, QVariant());
         if (!res.isNull()) {
-            QStringList result = res.toStringList();
-            if (!result.isEmpty())
-                return result;
+            uiLanguages = res.toStringList();
+            // ... but we need to include likely-adjusted forms of each of those, too:
+            for (const auto entry : qAsConst(uiLanguages))
+                locales.append(QLocale(entry));
         }
-    }
+    } else
 #endif
-    QLocaleId id = QLocaleId::fromIds(d->m_data->m_language_id, d->m_data->m_script_id,
-                                      d->m_data->m_country_id);
-    const QLocaleId max = id.withLikelySubtagsAdded();
-    const QLocaleId min = max.withLikelySubtagsRemoved();
+    {
+        locales.append(*this);
+    }
+    for (int i = locales.size(); i-- > 0; ) {
+        const QLocale &locale = locales.at(i);
+        int j;
+        QByteArray prior;
+        if (i < uiLanguages.size()) {
+            // Adding likely-adjusted forms to system locale's list.
+            // Name the locale is derived from:
+            const QString &name = uiLanguages.at(i);
+            prior = name.toLatin1();
+            // Don't try to likely-adjust if construction's likely-adjustments
+            // were so drastic the result doesn't match the prior name:
+            if (locale.name() != name && locale.d->rawName() != prior)
+                continue;
+            // Insert just after prior:
+            j = i + 1;
+        } else {
+            // Plain locale, not system locale; just append.
+            j = uiLanguages.size();
+        }
+        const auto data = locale.d->m_data;
+
+        QLocaleId id
+            = QLocaleId::fromIds(data->m_language_id, data->m_script_id, data->m_country_id);
+        const QLocaleId max = id.withLikelySubtagsAdded();
+        const QLocaleId min = max.withLikelySubtagsRemoved();
+        id.script_id = 0; // For re-use as script-less variant.
+
+        // Include version with all likely sub-tags (last) if distinct from the rest:
+        if (max != min && max != id && max.name() != prior)
+            uiLanguages.insert(j, QString::fromLatin1(max.name()));
+
+        // Include scriptless version if likely-equivalent and distinct:
+        if (data->m_script_id && id != min && id.name() != prior
+            && id.withLikelySubtagsAdded() == max) {
+            uiLanguages.insert(j, QString::fromLatin1(id.name()));
+        }
 
-    QStringList uiLanguages;
-    uiLanguages.append(QString::fromLatin1(min.name()));
-    if (id.script_id) {
-        id.script_id = 0;
-        if (id != min && id.withLikelySubtagsAdded() == max)
-            uiLanguages.append(QString::fromLatin1(id.name()));
+        // Include minimal version (first) unless it's what our locale is derived from:
+        if (min.name() != prior)
+            uiLanguages.insert(j, QString::fromLatin1(min.name()));
     }
-    if (max != min && max != id)
-        uiLanguages.append(QString::fromLatin1(max.name()));
     return uiLanguages;
 }
 
diff --git a/src/corelib/text/qlocale_p.h b/src/corelib/text/qlocale_p.h
index 5ebed9b385..edee3a89c7 100644
--- a/src/corelib/text/qlocale_p.h
+++ b/src/corelib/text/qlocale_p.h
@@ -359,6 +359,7 @@ public:
     quint16 countryId() const { return m_data->m_country_id; }
 
     QByteArray bcp47Name(char separator = '-') const;
+    QByteArray rawName(char separator = '-') const;
 
     inline QLatin1String languageCode() const { return languageToCode(QLocale::Language(m_data->m_language_id)); }
     inline QLatin1String scriptCode() const { return scriptToCode(QLocale::Script(m_data->m_script_id)); }
diff --git a/src/corelib/time/qdatetime.cpp b/src/corelib/time/qdatetime.cpp
index 6ed0efe77d..95a7255a04 100644
--- a/src/corelib/time/qdatetime.cpp
+++ b/src/corelib/time/qdatetime.cpp
@@ -3861,6 +3861,9 @@ int QDateTime::offsetFromUtc() const
 
 QString QDateTime::timeZoneAbbreviation() const
 {
+    if (!isValid())
+        return QString();
+
     switch (getSpec(d)) {
     case Qt::UTC:
         return QLatin1String("UTC");
@@ -3895,6 +3898,9 @@ QString QDateTime::timeZoneAbbreviation() const
 
 bool QDateTime::isDaylightTime() const
 {
+    if (!isValid())
+        return false;
+
     switch (getSpec(d)) {
     case Qt::UTC:
     case Qt::OffsetFromUTC:
@@ -4761,17 +4767,24 @@ QDateTime QDateTime::toTimeZone(const QTimeZone &timeZone) const
     Returns \c true if this datetime is equal to the \a other datetime;
     otherwise returns \c false.
 
+    Since 5.14, all invalid datetimes are equal to one another and differ from
+    all other datetimes.
+
     \sa operator!=()
 */
 
 bool QDateTime::operator==(const QDateTime &other) const
 {
-    if (getSpec(d) == Qt::LocalTime
-        && getStatus(d) == getStatus(other.d)) {
+    if (!isValid())
+        return !other.isValid();
+    if (!other.isValid())
+        return false;
+
+    if (getSpec(d) == Qt::LocalTime && getStatus(d) == getStatus(other.d))
         return getMSecs(d) == getMSecs(other.d);
-    }
+
     // Convert to UTC and compare
-    return (toMSecsSinceEpoch() == other.toMSecsSinceEpoch());
+    return toMSecsSinceEpoch() == other.toMSecsSinceEpoch();
 }
 
 /*!
@@ -4780,8 +4793,9 @@ bool QDateTime::operator==(const QDateTime &other) const
     Returns \c true if this datetime is different from the \a other
     datetime; otherwise returns \c false.
 
-    Two datetimes are different if either the date, the time, or the
-    time zone components are different.
+    Two datetimes are different if either the date, the time, or the time zone
+    components are different. Since 5.14, any invalid datetime is less than all
+    valid datetimes.
 
     \sa operator==()
 */
@@ -4793,12 +4807,16 @@ bool QDateTime::operator==(const QDateTime &other) const
 
 bool QDateTime::operator<(const QDateTime &other) const
 {
-    if (getSpec(d) == Qt::LocalTime
-        && getStatus(d) == getStatus(other.d)) {
+    if (!isValid())
+        return other.isValid();
+    if (!other.isValid())
+        return false;
+
+    if (getSpec(d) == Qt::LocalTime && getStatus(d) == getStatus(other.d))
         return getMSecs(d) < getMSecs(other.d);
-    }
+
     // Convert to UTC and compare
-    return (toMSecsSinceEpoch() < other.toMSecsSinceEpoch());
+    return toMSecsSinceEpoch() < other.toMSecsSinceEpoch();
 }
 
 /*!
@@ -5849,7 +5867,7 @@ uint qHash(const QDateTime &key, uint seed)
     // QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
     // to the same timezone. If we don't, qHash would return different hashes for
     // two QDateTimes that are equivalent once converted to the same timezone.
-    return qHash(key.toMSecsSinceEpoch(), seed);
+    return key.isValid() ? qHash(key.toMSecsSinceEpoch(), seed) : seed;
 }
 
 /*! \fn uint qHash(const QDate &key, uint seed = 0)
diff --git a/src/corelib/time/qtimezoneprivate_win.cpp b/src/corelib/time/qtimezoneprivate_win.cpp
index 5a480222e0..0fec5355b2 100644
--- a/src/corelib/time/qtimezoneprivate_win.cpp
+++ b/src/corelib/time/qtimezoneprivate_win.cpp
@@ -46,13 +46,14 @@
 
 #include <algorithm>
 
-QT_BEGIN_NAMESPACE
-
 #ifndef Q_OS_WINRT
+#include <private/qwinregistry_p.h>
 // The registry-based timezone backend is not available on WinRT, which falls back to equivalent APIs.
 #define QT_USE_REGISTRY_TIMEZONE 1
 #endif
 
+QT_BEGIN_NAMESPACE
+
 /*
     Private
 
@@ -71,8 +72,8 @@ QT_BEGIN_NAMESPACE
 // Vista introduced support for historic data, see MSDN docs on DYNAMIC_TIME_ZONE_INFORMATION
 // http://msdn.microsoft.com/en-gb/library/windows/desktop/ms724253%28v=vs.85%29.aspx
 #ifdef QT_USE_REGISTRY_TIMEZONE
-static const char tzRegPath[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones";
-static const char currTzRegPath[] = "SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation";
+static const wchar_t tzRegPath[] = LR"(SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones)";
+static const wchar_t currTzRegPath[] = LR"(SYSTEM\CurrentControlSet\Control\TimeZoneInformation)";
 #endif
 
 enum {
@@ -138,27 +139,6 @@ bool equalTzi(const TIME_ZONE_INFORMATION &tzi1, const TIME_ZONE_INFORMATION &tz
 }
 
 #ifdef QT_USE_REGISTRY_TIMEZONE
-bool openRegistryKey(const QString &keyPath, HKEY *key)
-{
-    return RegOpenKeyEx(HKEY_LOCAL_MACHINE, reinterpret_cast<const wchar_t*>(keyPath.utf16()),
-                        0, KEY_READ, key) == ERROR_SUCCESS;
-}
-
-QString readRegistryString(const HKEY &key, const wchar_t *value)
-{
-    wchar_t buffer[MAX_PATH] = {0};
-    DWORD size = sizeof(wchar_t) * MAX_PATH;
-    RegQueryValueEx(key, value, nullptr, nullptr, reinterpret_cast<LPBYTE>(buffer), &size);
-    return QString::fromWCharArray(buffer);
-}
-
-int readRegistryValue(const HKEY &key, const wchar_t *value)
-{
-    DWORD buffer;
-    DWORD size = sizeof(buffer);
-    RegQueryValueEx(key, value, nullptr, nullptr, reinterpret_cast<LPBYTE>(&buffer), &size);
-    return buffer;
-}
 
 QWinTimeZonePrivate::QWinTransitionRule readRegistryRule(const HKEY &key,
                                                          const wchar_t *value, bool *ok)
@@ -185,12 +165,11 @@ TIME_ZONE_INFORMATION getRegistryTzi(const QByteArray &windowsId, bool *ok)
     TIME_ZONE_INFORMATION tzi;
     REG_TZI_FORMAT regTzi;
     DWORD regTziSize = sizeof(regTzi);
-    HKEY key = NULL;
-    const QString tziKeyPath = QString::fromUtf8(tzRegPath) + QLatin1Char('\\')
+    const QString tziKeyPath = QString::fromWCharArray(tzRegPath) + QLatin1Char('\\')
                                + QString::fromUtf8(windowsId);
 
-    if (openRegistryKey(tziKeyPath, &key)) {
-
+    QWinRegistryKey key(HKEY_LOCAL_MACHINE, tziKeyPath);
+    if (key.isValid()) {
         DWORD size = sizeof(tzi.DaylightName);
         RegQueryValueEx(key, L"Dlt", nullptr, nullptr, reinterpret_cast<LPBYTE>(tzi.DaylightName), &size);
 
@@ -206,8 +185,6 @@ TIME_ZONE_INFORMATION getRegistryTzi(const QByteArray &windowsId, bool *ok)
             tzi.DaylightDate = regTzi.DaylightDate;
             *ok = true;
         }
-
-        RegCloseKey(key);
     }
 
     return tzi;
@@ -299,8 +276,8 @@ QList<QByteArray> availableWindowsIds()
 #ifdef QT_USE_REGISTRY_TIMEZONE
     // TODO Consider caching results in a global static, very unlikely to change.
     QList<QByteArray> list;
-    HKEY key = NULL;
-    if (openRegistryKey(QString::fromUtf8(tzRegPath), &key)) {
+    QWinRegistryKey key(HKEY_LOCAL_MACHINE, tzRegPath);
+    if (key.isValid()) {
         DWORD idCount = 0;
         if (RegQueryInfoKey(key, 0, 0, 0, &idCount, 0, 0, 0, 0, 0, 0, 0) == ERROR_SUCCESS
             && idCount > 0) {
@@ -311,7 +288,6 @@ QList<QByteArray> availableWindowsIds()
                     list.append(QString::fromWCharArray(buffer).toUtf8());
             }
         }
-        RegCloseKey(key);
     }
     return list;
 #else // QT_USE_REGISTRY_TIMEZONE
@@ -325,15 +301,10 @@ QByteArray windowsSystemZoneId()
 {
 #ifdef QT_USE_REGISTRY_TIMEZONE
     // On Vista and later is held in the value TimeZoneKeyName in key currTzRegPath
-    QString id;
-    HKEY key = NULL;
-    QString tziKeyPath = QString::fromUtf8(currTzRegPath);
-    if (openRegistryKey(tziKeyPath, &key)) {
-        id = readRegistryString(key, L"TimeZoneKeyName");
-        RegCloseKey(key);
-        if (!id.isEmpty())
-            return std::move(id).toUtf8();
-    }
+    const QString id = QWinRegistryKey(HKEY_LOCAL_MACHINE, currTzRegPath)
+                       .stringValue(L"TimeZoneKeyName");
+    if (!id.isEmpty())
+        return id.toUtf8();
 
     // On XP we have to iterate over the zones until we find a match on
     // names/offsets with the current data
@@ -575,22 +546,22 @@ void QWinTimeZonePrivate::init(const QByteArray &ianaId)
     if (!m_windowsId.isEmpty()) {
 #ifdef QT_USE_REGISTRY_TIMEZONE
         // Open the base TZI for the time zone
-        HKEY baseKey = NULL;
-        const QString baseKeyPath = QString::fromUtf8(tzRegPath) + QLatin1Char('\\')
+        const QString baseKeyPath = QString::fromWCharArray(tzRegPath) + QLatin1Char('\\')
                                    + QString::fromUtf8(m_windowsId);
-        if (openRegistryKey(baseKeyPath, &baseKey)) {
+        QWinRegistryKey baseKey(HKEY_LOCAL_MACHINE, baseKeyPath);
+        if (baseKey.isValid()) {
             //  Load the localized names
-            m_displayName = readRegistryString(baseKey, L"Display");
-            m_standardName = readRegistryString(baseKey, L"Std");
-            m_daylightName = readRegistryString(baseKey, L"Dlt");
+            m_displayName = baseKey.stringValue(L"Display");
+            m_standardName = baseKey.stringValue(L"Std");
+            m_daylightName = baseKey.stringValue(L"Dlt");
             // On Vista and later the optional dynamic key holds historic data
             const QString dynamicKeyPath = baseKeyPath + QLatin1String("\\Dynamic DST");
-            HKEY dynamicKey = NULL;
-            if (openRegistryKey(dynamicKeyPath, &dynamicKey)) {
+            QWinRegistryKey dynamicKey(HKEY_LOCAL_MACHINE, dynamicKeyPath);
+            if (dynamicKey.isValid()) {
                 // Find out the start and end years stored, then iterate over them
-                int startYear = readRegistryValue(dynamicKey, L"FirstEntry");
-                int endYear = readRegistryValue(dynamicKey, L"LastEntry");
-                for (int year = startYear; year <= endYear; ++year) {
+                const auto startYear = dynamicKey.dwordValue(L"FirstEntry");
+                const auto endYear = dynamicKey.dwordValue(L"LastEntry");
+                for (int year = int(startYear.first); year <= int(endYear.first); ++year) {
                     bool ruleOk;
                     QWinTransitionRule rule = readRegistryRule(dynamicKey,
                                                                reinterpret_cast<LPCWSTR>(QString::number(year).utf16()),
@@ -611,7 +582,6 @@ void QWinTimeZonePrivate::init(const QByteArray &ianaId)
                         m_tranRules.append(rule);
                     }
                 }
-                RegCloseKey(dynamicKey);
             } else {
                 // No dynamic data so use the base data
                 bool ruleOk;
@@ -620,7 +590,6 @@ void QWinTimeZonePrivate::init(const QByteArray &ianaId)
                 if (ruleOk)
                     m_tranRules.append(rule);
             }
-            RegCloseKey(baseKey);
         }
 #else // QT_USE_REGISTRY_TIMEZONE
         if (gTimeZones->isEmpty())
diff --git a/src/corelib/tools/qeasingcurve.cpp b/src/corelib/tools/qeasingcurve.cpp
index 2ae63fe135..52c8d13fe3 100644
--- a/src/corelib/tools/qeasingcurve.cpp
+++ b/src/corelib/tools/qeasingcurve.cpp
@@ -583,6 +583,13 @@ struct BezierEase : public QEasingCurveFunction
             qWarning("QEasingCurve: Invalid bezier curve");
             return x;
         }
+
+        // The bezier computation is not always precise on the endpoints, so handle explicitly
+        if (!(x > 0))
+            return 0;
+        if (!(x < 1))
+            return 1;
+
         SingleCubicBezier *singleCubicBezier = 0;
         getBezierSegment(singleCubicBezier, x);
 
@@ -998,6 +1005,11 @@ struct BackEase : public QEasingCurveFunction
 
     qreal value(qreal t) override
     {
+        // The *Back() functions are not always precise on the endpoints, so handle explicitly
+        if (!(t > 0))
+            return 0;
+        if (!(t < 1))
+            return 1;
         qreal o = (_o < 0) ? qreal(1.70158) : _o;
         switch(_t) {
         case QEasingCurve::InBack:
diff --git a/src/corelib/tools/qlist.h b/src/corelib/tools/qlist.h
index be987c359b..425ffa42a5 100644
--- a/src/corelib/tools/qlist.h
+++ b/src/corelib/tools/qlist.h
@@ -1051,7 +1051,7 @@ int lastIndexOf(const QList<T> &list, const U &u, int from)
         Node *n = reinterpret_cast<Node *>(list.p.at(from + 1));
         while (n-- != b) {
             if (n->t() == u)
-                return typename QList<T>::difference_type(n - b);
+                return int(n - b);
         }
     }
     return -1;
diff --git a/src/corelib/tools/qpair.qdoc b/src/corelib/tools/qpair.qdoc
index 59e6931995..65576ef2e6 100644
--- a/src/corelib/tools/qpair.qdoc
+++ b/src/corelib/tools/qpair.qdoc
@@ -28,6 +28,7 @@
 /*!
     \class QPair
     \inmodule QtCore
+    \reentrant
     \brief The QPair class is a template class that stores a pair of items.
 
     \ingroup tools
diff --git a/src/dbus/qdbus_symbols.cpp b/src/dbus/qdbus_symbols.cpp
index 284ba999c2..1e2cbf6da6 100644
--- a/src/dbus/qdbus_symbols.cpp
+++ b/src/dbus/qdbus_symbols.cpp
@@ -100,15 +100,15 @@ bool qdbus_loadLibDBus()
     };
 
     lib->unload();
-    for (uint i = 0; i < sizeof(majorversions) / sizeof(majorversions[0]); ++i) {
-        for (uint j = 0; j < sizeof(baseNames) / sizeof(baseNames[0]); ++j) {
+    for (const int majorversion : majorversions) {
+        for (const QString &baseName : baseNames) {
 #ifdef Q_OS_WIN
             QString suffix;
-            if (majorversions[i] != -1)
-                suffix = QString::number(- majorversions[i]); // negative so it prepends the dash
-            lib->setFileName(baseNames[j] + suffix);
+            if (majorversion != -1)
+                suffix = QString::number(- majorversion); // negative so it prepends the dash
+            lib->setFileName(baseName + suffix);
 #else
-            lib->setFileNameAndVersion(baseNames[j], majorversions[i]);
+            lib->setFileNameAndVersion(baseName, majorversion);
 #endif
             if (lib->load() && lib->resolve("dbus_connection_open_private"))
                 return true;
diff --git a/src/dbus/qdbusconnection.cpp b/src/dbus/qdbusconnection.cpp
index 58b5af3615..d6f3230fd2 100644
--- a/src/dbus/qdbusconnection.cpp
+++ b/src/dbus/qdbusconnection.cpp
@@ -871,8 +871,12 @@ bool QDBusConnection::disconnect(const QString &service, const QString &path, co
     This function does not replace existing objects: if there is already an object registered at
     path \a path, this function will return false. Use unregisterObject() to unregister it first.
 
+    The ExportChildObjects flag exports child objects on D-Bus based on the
+    path of the registered objects and the QObject::objectName of the child.
+    Therefore, it is important for the child object to have an object name.
+
     You cannot register an object as a child object of an object that
-    was registered with QDBusConnection::ExportChildObjects.
+    was registered with ExportChildObjects.
 */
 bool QDBusConnection::registerObject(const QString &path, QObject *object, RegisterOptions options)
 {
@@ -891,8 +895,12 @@ bool QDBusConnection::registerObject(const QString &path, QObject *object, Regis
     This function does not replace existing objects: if there is already an object registered at
     path \a path, this function will return false. Use unregisterObject() to unregister it first.
 
+    The ExportChildObjects flag exports child objects on D-Bus based on the
+    path of the registered objects and the QObject::objectName of the child.
+    Therefore, it is important for the child object to have an object name.
+
     You cannot register an object as a child object of an object that
-    was registered with QDBusConnection::ExportChildObjects.
+    was registered with ExportChildObjects.
 */
 bool QDBusConnection::registerObject(const QString &path, const QString &interface, QObject *object, RegisterOptions options)
 {
diff --git a/src/gui/image/qmovie.cpp b/src/gui/image/qmovie.cpp
index 3e975115ab..25fce050a1 100644
--- a/src/gui/image/qmovie.cpp
+++ b/src/gui/image/qmovie.cpp
@@ -414,7 +414,7 @@ QFrameInfo QMoviePrivate::infoForFrame(int frameNumber)
             } else {
                 // We've read all frames now. Return an end marker
                 haveReadAll = true;
-                return QFrameInfo::endMarker();
+                return frameNumber == greatestFrameNumber + 1 ? QFrameInfo::endMarker() : QFrameInfo();
             }
         }
     }
diff --git a/src/gui/kernel/qevent.cpp b/src/gui/kernel/qevent.cpp
index d41e3e5e3c..2b28052dd5 100644
--- a/src/gui/kernel/qevent.cpp
+++ b/src/gui/kernel/qevent.cpp
@@ -791,37 +791,44 @@ QWheelEvent::QWheelEvent(const QPointF &pos, const QPointF& globalPos, int delta
     \obsolete
     This constructor has been deprecated.
 */
-
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
 QWheelEvent::QWheelEvent(const QPointF &pos, const QPointF& globalPos,
             QPoint pixelDelta, QPoint angleDelta, int qt4Delta, Qt::Orientation qt4Orientation,
             Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers)
     : QWheelEvent(pos, globalPos, pixelDelta, angleDelta, qt4Delta, qt4Orientation,
                   buttons, modifiers, Qt::NoScrollPhase)
 {}
+QT_WARNING_POP
 
 /*!
     \obsolete
     This constructor has been deprecated.
 */
-
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
 QWheelEvent::QWheelEvent(const QPointF &pos, const QPointF& globalPos,
             QPoint pixelDelta, QPoint angleDelta, int qt4Delta, Qt::Orientation qt4Orientation,
             Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::ScrollPhase phase)
     : QWheelEvent(pos, globalPos, pixelDelta, angleDelta, qt4Delta, qt4Orientation,
                   buttons, modifiers, phase, Qt::MouseEventNotSynthesized)
 {}
+QT_WARNING_POP
 
 /*!
     \obsolete
     This constructor has been deprecated.
 */
 
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
 QWheelEvent::QWheelEvent(const QPointF &pos, const QPointF& globalPos,
             QPoint pixelDelta, QPoint angleDelta, int qt4Delta, Qt::Orientation qt4Orientation,
             Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::ScrollPhase phase, Qt::MouseEventSource source)
     : QWheelEvent(pos, globalPos, pixelDelta, angleDelta, qt4Delta, qt4Orientation,
                   buttons, modifiers, phase, source, false)
 {}
+QT_WARNING_POP
 
 /*!
     \obsolete
@@ -3930,12 +3937,15 @@ QDebug operator<<(QDebug dbg, const QEvent *e)
     case QEvent::Wheel: {
         const QWheelEvent *we = static_cast<const QWheelEvent *>(e);
         dbg << "QWheelEvent(" << we->phase();
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED // delta() and orientation()
         if (!we->pixelDelta().isNull() || !we->angleDelta().isNull())
             dbg << ", pixelDelta=" << we->pixelDelta() << ", angleDelta=" << we->angleDelta();
 #if QT_DEPRECATED_SINCE(5, 14)
         else if (int qt4Delta = we->delta())
             dbg << ", delta=" << qt4Delta << ", orientation=" << we->orientation();
 #endif
+QT_WARNING_POP
         dbg << ')';
     }
         break;
diff --git a/src/gui/kernel/qguiapplication.cpp b/src/gui/kernel/qguiapplication.cpp
index 83ca337aaa..54f3996b6e 100644
--- a/src/gui/kernel/qguiapplication.cpp
+++ b/src/gui/kernel/qguiapplication.cpp
@@ -1863,7 +1863,20 @@ bool QGuiApplication::event(QEvent *e)
 {
     if(e->type() == QEvent::LanguageChange) {
         setLayoutDirection(qt_detectRTLLanguage()?Qt::RightToLeft:Qt::LeftToRight);
+    } else if (e->type() == QEvent::Quit) {
+        // Close open windows. This is done in order to deliver de-expose
+        // events while the event loop is still running.
+        for (QWindow *topLevelWindow : QGuiApplication::topLevelWindows()) {
+            // Already closed windows will not have a platform window, skip those
+            if (!topLevelWindow->handle())
+                continue;
+            if (!topLevelWindow->close()) {
+                e->ignore();
+                return true;
+            }
+        }
     }
+
     return QCoreApplication::event(e);
 }
 
@@ -1940,6 +1953,9 @@ void QGuiApplicationPrivate::processWindowSystemEvent(QWindowSystemInterfacePriv
         QWindowSystemInterfacePrivate::ApplicationStateChangedEvent * changeEvent = static_cast<QWindowSystemInterfacePrivate::ApplicationStateChangedEvent *>(e);
         QGuiApplicationPrivate::setApplicationState(changeEvent->newState, changeEvent->forcePropagate); }
         break;
+    case QWindowSystemInterfacePrivate::ApplicationTermination:
+        QGuiApplicationPrivate::processApplicationTermination(e);
+        break;
     case QWindowSystemInterfacePrivate::FlushEvents: {
         QWindowSystemInterfacePrivate::FlushEventsEvent *flushEventsEvent = static_cast<QWindowSystemInterfacePrivate::FlushEventsEvent *>(e);
         QWindowSystemInterface::deferredFlushWindowSystemEvents(flushEventsEvent->flags); }
@@ -2245,8 +2261,11 @@ void QGuiApplicationPrivate::processWheelEvent(QWindowSystemInterfacePrivate::Wh
     }
 
 #if QT_DEPRECATED_SINCE(5, 14)
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
      QWheelEvent ev(localPoint, globalPoint, e->pixelDelta, e->angleDelta, e->qt4Delta, e->qt4Orientation,
                     mouse_buttons, e->modifiers, e->phase, e->source, e->inverted);
+QT_WARNING_POP
 #else
     QWheelEvent ev(localPoint, globalPoint, e->pixelDelta, e->angleDelta,
                    mouse_buttons, e->modifiers, e->phase, e->inverted, e->source);
@@ -2524,9 +2543,8 @@ void QGuiApplicationPrivate::processCloseEvent(QWindowSystemInterfacePrivate::Cl
 
     QCloseEvent event;
     QGuiApplication::sendSpontaneousEvent(e->window.data(), &event);
-    if (e->accepted) {
-        *(e->accepted) = event.isAccepted();
-    }
+
+    e->eventAccepted = event.isAccepted();
 }
 
 void QGuiApplicationPrivate::processFileOpenEvent(QWindowSystemInterfacePrivate::FileOpenEvent *e)
@@ -3487,6 +3505,13 @@ bool QGuiApplicationPrivate::tryCloseRemainingWindows(QWindowList processedWindo
     return true;
 }
 
+void QGuiApplicationPrivate::processApplicationTermination(QWindowSystemInterfacePrivate::WindowSystemEvent *windowSystemEvent)
+{
+    QEvent event(QEvent::Quit);
+    QGuiApplication::sendSpontaneousEvent(QGuiApplication::instance(), &event);
+    windowSystemEvent->eventAccepted = event.isAccepted();
+}
+
 /*!
     \since 5.2
     \fn Qt::ApplicationState QGuiApplication::applicationState()
diff --git a/src/gui/kernel/qguiapplication_p.h b/src/gui/kernel/qguiapplication_p.h
index e28607bad6..26f65b2f16 100644
--- a/src/gui/kernel/qguiapplication_p.h
+++ b/src/gui/kernel/qguiapplication_p.h
@@ -141,6 +141,8 @@ public:
 
     static void processWindowSystemEvent(QWindowSystemInterfacePrivate::WindowSystemEvent *e);
 
+    static void processApplicationTermination(QWindowSystemInterfacePrivate::WindowSystemEvent *e);
+
     static void updateFilteredScreenOrientation(QScreen *screen);
     static void reportScreenOrientationChange(QScreen *screen);
     static void processScreenOrientationChange(QWindowSystemInterfacePrivate::ScreenOrientationEvent *e);
diff --git a/src/gui/kernel/qplatformwindow.cpp b/src/gui/kernel/qplatformwindow.cpp
index 4e95751397..2a0cb1094c 100644
--- a/src/gui/kernel/qplatformwindow.cpp
+++ b/src/gui/kernel/qplatformwindow.cpp
@@ -348,9 +348,7 @@ void QPlatformWindow::setWindowIcon(const QIcon &icon) { Q_UNUSED(icon); }
 */
 bool QPlatformWindow::close()
 {
-    bool accepted = false;
-    QWindowSystemInterface::handleCloseEvent<QWindowSystemInterface::SynchronousDelivery>(window(), &accepted);
-    return accepted;
+    return QWindowSystemInterface::handleCloseEvent<QWindowSystemInterface::SynchronousDelivery>(window());
 }
 
 /*!
diff --git a/src/gui/kernel/qwindowsysteminterface.cpp b/src/gui/kernel/qwindowsysteminterface.cpp
index 40a298226a..4f1056e906 100644
--- a/src/gui/kernel/qwindowsysteminterface.cpp
+++ b/src/gui/kernel/qwindowsysteminterface.cpp
@@ -285,6 +285,12 @@ QT_DEFINE_QPA_EVENT_HANDLER(void, handleApplicationStateChanged, Qt::Application
     QWindowSystemInterfacePrivate::handleWindowSystemEvent<Delivery>(e);
 }
 
+QT_DEFINE_QPA_EVENT_HANDLER(bool, handleApplicationTermination)
+{
+    auto *e = new QWindowSystemInterfacePrivate::WindowSystemEvent(QWindowSystemInterfacePrivate::ApplicationTermination);
+    return QWindowSystemInterfacePrivate::handleWindowSystemEvent<Delivery>(e);
+}
+
 QWindowSystemInterfacePrivate::GeometryChangeEvent::GeometryChangeEvent(QWindow *window, const QRect &newGeometry)
     : WindowSystemEvent(GeometryChange)
     , window(window)
@@ -340,13 +346,11 @@ QT_DEFINE_QPA_EVENT_HANDLER(void, handleExposeEvent, QWindow *window, const QReg
     QWindowSystemInterfacePrivate::handleWindowSystemEvent<Delivery>(e);
 }
 
-QT_DEFINE_QPA_EVENT_HANDLER(void, handleCloseEvent, QWindow *window, bool *accepted)
+QT_DEFINE_QPA_EVENT_HANDLER(bool, handleCloseEvent, QWindow *window)
 {
-    if (window) {
-        QWindowSystemInterfacePrivate::CloseEvent *e =
-                new QWindowSystemInterfacePrivate::CloseEvent(window, accepted);
-        QWindowSystemInterfacePrivate::handleWindowSystemEvent<Delivery>(e);
-    }
+    Q_ASSERT(window);
+    auto *event = new QWindowSystemInterfacePrivate::CloseEvent(window);
+    return QWindowSystemInterfacePrivate::handleWindowSystemEvent<Delivery>(event);
 }
 
 /*!
@@ -619,6 +623,7 @@ bool QWindowSystemInterface::isTouchDeviceRegistered(const QTouchDevice *device)
 static int g_nextPointId = 1;
 
 // map from device-independent point id (arbitrary) to "Qt point" ids
+QMutex QWindowSystemInterfacePrivate::pointIdMapMutex;
 typedef QMap<quint64, int> PointIdMap;
 Q_GLOBAL_STATIC(PointIdMap, g_pointIdMap)
 
@@ -636,6 +641,8 @@ Q_GLOBAL_STATIC(PointIdMap, g_pointIdMap)
 */
 static int acquireCombinedPointId(quint8 deviceId, int pointId)
 {
+    QMutexLocker locker(&QWindowSystemInterfacePrivate::pointIdMapMutex);
+
     quint64 combinedId64 = (quint64(deviceId) << 32) + pointId;
     auto it = g_pointIdMap->constFind(combinedId64);
     int uid;
@@ -695,6 +702,8 @@ QList<QTouchEvent::TouchPoint>
     }
 
     if (states == Qt::TouchPointReleased) {
+        QMutexLocker locker(&QWindowSystemInterfacePrivate::pointIdMapMutex);
+
         // All points on deviceId have been released.
         // Remove all points associated with that device from g_pointIdMap.
         // (On other devices, some touchpoints might still be pressed.
@@ -714,6 +723,7 @@ QList<QTouchEvent::TouchPoint>
 
 void QWindowSystemInterfacePrivate::clearPointIdMap()
 {
+    QMutexLocker locker(&QWindowSystemInterfacePrivate::pointIdMapMutex);
     g_pointIdMap->clear();
     g_nextPointId = 1;
 }
diff --git a/src/gui/kernel/qwindowsysteminterface.h b/src/gui/kernel/qwindowsysteminterface.h
index fd70eda9ff..d5a4ad30d8 100644
--- a/src/gui/kernel/qwindowsysteminterface.h
+++ b/src/gui/kernel/qwindowsysteminterface.h
@@ -194,7 +194,7 @@ public:
     static void handleExposeEvent(QWindow *window, const QRegion &region);
 
     template<typename Delivery = QWindowSystemInterface::DefaultDelivery>
-    static void handleCloseEvent(QWindow *window, bool *accepted = nullptr);
+    static bool handleCloseEvent(QWindow *window);
 
     template<typename Delivery = QWindowSystemInterface::DefaultDelivery>
     static void handleEnterEvent(QWindow *window, const QPointF &local = QPointF(), const QPointF& global = QPointF());
@@ -215,6 +215,9 @@ public:
     template<typename Delivery = QWindowSystemInterface::DefaultDelivery>
     static void handleApplicationStateChanged(Qt::ApplicationState newState, bool forcePropagate = false);
 
+    template<typename Delivery = QWindowSystemInterface::DefaultDelivery>
+    static bool handleApplicationTermination();
+
 #if QT_CONFIG(draganddrop)
 #if QT_DEPRECATED_SINCE(5, 11)
     QT_DEPRECATED static QPlatformDragQtResponse handleDrag(QWindow *window, const QMimeData *dropData,
diff --git a/src/gui/kernel/qwindowsysteminterface_p.h b/src/gui/kernel/qwindowsysteminterface_p.h
index d6513f1836..6e4bce607e 100644
--- a/src/gui/kernel/qwindowsysteminterface_p.h
+++ b/src/gui/kernel/qwindowsysteminterface_p.h
@@ -99,7 +99,8 @@ public:
         ApplicationStateChanged = 0x19,
         FlushEvents = 0x20,
         WindowScreenChanged = 0x21,
-        SafeAreaMarginsChanged = 0x22
+        SafeAreaMarginsChanged = 0x22,
+        ApplicationTermination = 0x23
     };
 
     class WindowSystemEvent {
@@ -123,11 +124,10 @@ public:
 
     class CloseEvent : public WindowSystemEvent {
     public:
-        explicit CloseEvent(QWindow *w, bool *a = nullptr)
-            : WindowSystemEvent(Close), window(w), accepted(a)
+        explicit CloseEvent(QWindow *w)
+            : WindowSystemEvent(Close), window(w)
             { }
         QPointer<QWindow> window;
-        bool *accepted;
     };
 
     class GeometryChangeEvent : public WindowSystemEvent {
@@ -529,6 +529,7 @@ public:
 
     static QWaitCondition eventsFlushed;
     static QMutex flushEventMutex;
+    static QMutex pointIdMapMutex;
     static QAtomicInt eventAccepted;
 
     static QList<QTouchEvent::TouchPoint>
diff --git a/src/gui/opengl/qopenglpaintengine.cpp b/src/gui/opengl/qopenglpaintengine.cpp
index c087326068..47394999c6 100644
--- a/src/gui/opengl/qopenglpaintengine.cpp
+++ b/src/gui/opengl/qopenglpaintengine.cpp
@@ -1474,6 +1474,8 @@ void QOpenGL2PaintEngineEx::renderHintsChanged()
 #ifndef QT_OPENGL_ES_2
     if (!QOpenGLContext::currentContext()->isOpenGLES()) {
         Q_D(QOpenGL2PaintEngineEx);
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
         if ((state()->renderHints & QPainter::Antialiasing)
 #if QT_DEPRECATED_SINCE(5, 14)
             || (state()->renderHints & QPainter::HighQualityAntialiasing)
@@ -1482,6 +1484,7 @@ void QOpenGL2PaintEngineEx::renderHintsChanged()
             d->funcs.glEnable(GL_MULTISAMPLE);
         else
             d->funcs.glDisable(GL_MULTISAMPLE);
+QT_WARNING_POP
     }
 #endif // QT_OPENGL_ES_2
 
diff --git a/src/gui/painting/qpagesize.cpp b/src/gui/painting/qpagesize.cpp
index a1c9f6e417..c98ca8a1fb 100644
--- a/src/gui/painting/qpagesize.cpp
+++ b/src/gui/painting/qpagesize.cpp
@@ -222,8 +222,6 @@ static const int qt_windowsConversion[][2] = {
     {DMPAPER_PENV_10_ROTATED,               DMPAPER_PENV_10}  // Is = DMPAPER_LAST, use as loop terminator
 };
 
-static const int windowsConversionCount = int(sizeof(qt_windowsConversion) / sizeof(qt_windowsConversion[0]));
-
 // Standard sizes data
 struct StandardPageSize {
     QPageSize::PageSizeId id;
@@ -423,9 +421,9 @@ static QPageSize::PageSizeId qt_idForWindowsID(int windowsId, QSize *match = 0)
     if (windowsId <= DMPAPER_NONE || windowsId > DMPAPER_LAST)
         return QPageSize::Custom;
     // Check if one of the unsupported values, convert to valid value if is
-    for (int i = 0; i < windowsConversionCount; ++i) {
-        if (qt_windowsConversion[i][0] == windowsId) {
-            windowsId = qt_windowsConversion[i][1];
+    for (const auto &it : qt_windowsConversion) {
+        if (it[0] == windowsId) {
+            windowsId = it[1];
             break;
         }
     }
diff --git a/src/gui/painting/qpaintengine_raster.cpp b/src/gui/painting/qpaintengine_raster.cpp
index 447ecb358a..40c822076b 100644
--- a/src/gui/painting/qpaintengine_raster.cpp
+++ b/src/gui/painting/qpaintengine_raster.cpp
@@ -906,8 +906,11 @@ void QRasterPaintEngine::renderHintsChanged()
 
     s->flags.antialiased = bool(s->renderHints & QPainter::Antialiasing);
 #if QT_DEPRECATED_SINCE(5, 14)
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
     if (s->renderHints & QPainter::HighQualityAntialiasing)
         s->flags.antialiased = true;
+QT_WARNING_POP
 #endif
     s->flags.bilinear = bool(s->renderHints & QPainter::SmoothPixmapTransform);
     s->flags.legacy_rounding = !bool(s->renderHints & QPainter::Antialiasing) && bool(s->renderHints & QPainter::Qt4CompatiblePainting);
@@ -1316,7 +1319,7 @@ void QRasterPaintEngine::clip(const QRect &rect, Qt::ClipOperation op)
         QPaintEngineEx::clip(rect, op);
         return;
 
-    } else if (!setClipRectInDeviceCoords(s->matrix.mapRect(rect), op)) {
+    } else if (!setClipRectInDeviceCoords(s->matrix.mapRect(QRectF(rect)).toRect(), op)) {
         QPaintEngineEx::clip(rect, op);
         return;
     }
diff --git a/src/gui/painting/qplatformbackingstore.cpp b/src/gui/painting/qplatformbackingstore.cpp
index 601dc97be1..45e90bd99b 100644
--- a/src/gui/painting/qplatformbackingstore.cpp
+++ b/src/gui/painting/qplatformbackingstore.cpp
@@ -338,7 +338,16 @@ void QPlatformBackingStore::composeAndFlush(QWindow *window, const QRegion &regi
         }
     }
 
-    if (!d_ptr->context->makeCurrent(window)) {
+    bool current = d_ptr->context->makeCurrent(window);
+
+    if (!current && !d_ptr->context->isValid()) {
+        delete d_ptr->blitter;
+        d_ptr->blitter = nullptr;
+        d_ptr->textureId = 0;
+        current = d_ptr->context->create() && d_ptr->context->makeCurrent(window);
+    }
+
+    if (!current) {
         qCWarning(lcQpaBackingStore, "composeAndFlush: makeCurrent() failed");
         return;
     }
diff --git a/src/gui/painting/qtransform.cpp b/src/gui/painting/qtransform.cpp
index 7696da7d45..d75b66c50b 100644
--- a/src/gui/painting/qtransform.cpp
+++ b/src/gui/painting/qtransform.cpp
@@ -1529,12 +1529,12 @@ QRegion QTransform::map(const QRegion &r) const
         QRegion res;
         if (m11() < 0 || m22() < 0) {
             for (const QRect &rect : r)
-                res += mapRect(rect);
+                res += mapRect(QRectF(rect)).toRect();
         } else {
             QVarLengthArray<QRect, 32> rects;
             rects.reserve(r.rectCount());
             for (const QRect &rect : r) {
-                QRect nr = mapRect(rect);
+                QRect nr = mapRect(QRectF(rect)).toRect();
                 if (!nr.isEmpty())
                     rects.append(nr);
             }
diff --git a/src/gui/rhi/qrhi.cpp b/src/gui/rhi/qrhi.cpp
index 08bafebdec..8ef98d2e42 100644
--- a/src/gui/rhi/qrhi.cpp
+++ b/src/gui/rhi/qrhi.cpp
@@ -563,6 +563,21 @@ Q_LOGGING_CATEGORY(QRHI_LOG_INFO, "qt.rhi.general")
     \value BaseInstance Indicates that instanced draw commands support the \c
     firstInstance argument. When reported as not supported, the firstInstance
     value is ignored and the instance ID starts from 0.
+
+    \value TriangleFanTopology Indicates that QRhiGraphicsPipeline::setTopology()
+    supports QRhiGraphicsPipeline::TriangleFan.
+
+    \value ReadBackNonUniformBuffer Indicates that
+    \l{QRhiResourceUpdateBatch::readBackBuffer()}{reading buffer contents} is
+    supported for QRhiBuffer instances with a usage different than
+    UniformBuffer. While this is supported in the majority of cases, it will be
+    unsupported with OpenGL ES older than 3.0.
+
+    \value ReadBackNonBaseMipLevel Indicates that specifying a mip level other
+    than 0 is supported when reading back texture contents. When not supported,
+    specifying a non-zero level in QRhiReadbackDescription leads to returning
+    an all-zero image. In practice this feature will be unsupported with OpenGL
+    ES 2.0, while it will likely be supported everywhere else.
  */
 
 /*!
@@ -1199,8 +1214,7 @@ QDebug operator<<(QDebug dbg, const QRhiVertexInputAttribute &a)
  */
 bool operator==(const QRhiVertexInputLayout &a, const QRhiVertexInputLayout &b) Q_DECL_NOTHROW
 {
-    return a.bindings() == b.bindings()
-            && a.attributes() == b.attributes();
+    return a.m_bindings == b.m_bindings && a.m_attributes == b.m_attributes;
 }
 
 /*!
@@ -1221,15 +1235,21 @@ bool operator!=(const QRhiVertexInputLayout &a, const QRhiVertexInputLayout &b)
  */
 uint qHash(const QRhiVertexInputLayout &v, uint seed) Q_DECL_NOTHROW
 {
-    return qHash(v.bindings(), seed) + qHash(v.attributes(), seed);
+    return qHash(v.m_bindings, seed) + qHash(v.m_attributes, seed);
 }
 
 #ifndef QT_NO_DEBUG_STREAM
+template<typename T, int N>
+QDebug operator<<(QDebug dbg, const QVarLengthArray<T, N> &vla)
+{
+    return QtPrivate::printSequentialContainer(dbg, "VLA", vla);
+}
+
 QDebug operator<<(QDebug dbg, const QRhiVertexInputLayout &v)
 {
     QDebugStateSaver saver(dbg);
-    dbg.nospace() << "QRhiVertexInputLayout(bindings=" << v.bindings()
-                  << " attributes=" << v.attributes()
+    dbg.nospace() << "QRhiVertexInputLayout(bindings=" << v.m_bindings
+                  << " attributes=" << v.m_attributes
                   << ')';
     return dbg;
 }
@@ -1630,27 +1650,19 @@ QRhiTextureUploadDescription::QRhiTextureUploadDescription(const QRhiTextureUplo
 }
 
 /*!
-    Constructs a texture upload description with the specified list of \a entries.
+    Constructs a texture upload description with the specified \a list of entries.
 
-    \note \a entries can also contain multiple QRhiTextureUploadEntry elements
+    \note \a list can also contain multiple QRhiTextureUploadEntry elements
     with the the same layer and level. This makes sense when those uploads are
     partial, meaning their subresource description has a source size or image
     smaller than the subresource dimensions, and can be more efficient than
     issuing separate uploadTexture()'s.
  */
-QRhiTextureUploadDescription::QRhiTextureUploadDescription(const QVector<QRhiTextureUploadEntry> &entries)
-    : m_entries(entries)
+QRhiTextureUploadDescription::QRhiTextureUploadDescription(std::initializer_list<QRhiTextureUploadEntry> list)
+    : m_entries(list)
 {
 }
 
-/*!
-    Adds \a entry to the list of subresource uploads.
- */
-void QRhiTextureUploadDescription::append(const QRhiTextureUploadEntry &entry)
-{
-    m_entries.append(entry);
-}
-
 /*!
     \class QRhiTextureCopyDescription
     \internal
@@ -3056,11 +3068,6 @@ QDebug operator<<(QDebug dbg, const QRhiShaderResourceBinding &b)
 #endif
 
 #ifndef QT_NO_DEBUG_STREAM
-QDebug operator<<(QDebug dbg, const QVarLengthArray<QRhiShaderResourceBinding, 8> &bindings)
-{
-    return QtPrivate::printSequentialContainer(dbg, "Bindings", bindings);
-}
-
 QDebug operator<<(QDebug dbg, const QRhiShaderResourceBindings &srb)
 {
     QDebugStateSaver saver(dbg);
@@ -3077,9 +3084,13 @@ QDebug operator<<(QDebug dbg, const QRhiShaderResourceBindings &srb)
     \inmodule QtGui
     \brief Graphics pipeline state resource.
 
+    \note Setting the shader stages is mandatory. There must be at least one
+    stage, and there must be a vertex stage.
+
     \note Setting the shader resource bindings is mandatory. The referenced
     QRhiShaderResourceBindings must already be built by the time build() is
-    called.
+    called. Associating with a QRhiShaderResourceBindings that has no bindings
+    is also valid, as long as no shader in any stage expects any resources.
 
     \note Setting the render pass descriptor is mandatory. To obtain a
     QRhiRenderPassDescriptor that can be passed to setRenderPassDescriptor(),
@@ -3088,8 +3099,6 @@ QDebug operator<<(QDebug dbg, const QRhiShaderResourceBindings &srb)
 
     \note Setting the vertex input layout is mandatory.
 
-    \note Setting the shader stages is mandatory.
-
     \note sampleCount() defaults to 1 and must match the sample count of the
     render target's color and depth stencil attachments.
 
@@ -3131,6 +3140,7 @@ QDebug operator<<(QDebug dbg, const QRhiShaderResourceBindings &srb)
 
     \value Triangles (default)
     \value TriangleStrip
+    \value TriangleFan (only available if QRhi::TriangleFanTopology is supported)
     \value Lines
     \value LineStrip
     \value Points
@@ -3508,14 +3518,36 @@ QRhiResource::Type QRhiSwapChain::resourceType() const
     \c{currentPixelSize() != surfacePixelSize()} then the swapchain needs to be
     resized.
 
+    \note Typical rendering logic will call this function to get the output
+    size when starting to prepare a new frame, and base dependent calculations
+    (such as, the viewport) on the size returned from this function.
+
+    While in many cases the value is the same as \c{QWindow::size() *
+    QWindow::devicePixelRatio()}, relying on the QWindow-reported size is not
+    guaranteed to be correct on all platforms and graphics API implementations.
+    Using this function is therefore strongly recommended whenever there is a
+    need to identify the dimensions, in pixels, of the output layer or surface.
+
+    This also has the added benefit of avoiding potential data races when QRhi
+    is used on a dedicated rendering thread, because the need to call QWindow
+    functions, that may then access data updated on the main thread, is
+    avoided.
+
     \sa surfacePixelSize()
   */
 
 /*!
     \fn QSize QRhiSwapChain::surfacePixelSize()
 
-    \return The size of the window's associated surface or layer. Do not assume
-    this is the same as QWindow::size() * QWindow::devicePixelRatio().
+    \return The size of the window's associated surface or layer.
+
+    \warning Do not assume this is the same as \c{QWindow::size() *
+    QWindow::devicePixelRatio()}. With some graphics APIs and windowing system
+    interfaces (for example, Vulkan) there is a theoretical possibility for a
+    surface to assume a size different from the associated window. To support
+    these cases, rendering logic must always base size-derived calculations
+    (such as, viewports) on the size reported from QRhiSwapChain, and never on
+    the size queried from QWindow.
 
     \note Can also be called before buildOrResize(), if at least window() is
     already set) This in combination with currentPixelSize() allows to detect
@@ -3904,6 +3936,46 @@ quint32 QRhiImplementation::approxByteSizeForTexture(QRhiTexture::Format format,
     return approxSize;
 }
 
+bool QRhiImplementation::sanityCheckGraphicsPipeline(QRhiGraphicsPipeline *ps)
+{
+    if (ps->cbeginShaderStages() == ps->cendShaderStages()) {
+        qWarning("Cannot build a graphics pipeline without any stages");
+        return false;
+    }
+
+    bool hasVertexStage = false;
+    for (auto it = ps->cbeginShaderStages(), itEnd = ps->cendShaderStages(); it != itEnd; ++it) {
+        if (!it->shader().isValid()) {
+            qWarning("Empty shader passed to graphics pipeline");
+            return false;
+        }
+        if (it->type() == QRhiShaderStage::Vertex) {
+            hasVertexStage = true;
+            const QRhiVertexInputLayout inputLayout = ps->vertexInputLayout();
+            if (inputLayout.cbeginAttributes() == inputLayout.cendAttributes()) {
+                qWarning("Vertex stage present without any vertex inputs");
+                return false;
+            }
+        }
+    }
+    if (!hasVertexStage) {
+        qWarning("Cannot build a graphics pipeline without a vertex stage");
+        return false;
+    }
+
+    if (!ps->renderPassDescriptor()) {
+        qWarning("Cannot build a graphics pipeline without a QRhiRenderPassDescriptor");
+        return false;
+    }
+
+    if (!ps->shaderResourceBindings()) {
+        qWarning("Cannot build a graphics pipeline without QRhiShaderResourceBindings");
+        return false;
+    }
+
+    return true;
+}
+
 /*!
     \internal
  */
@@ -4179,7 +4251,7 @@ void QRhiResourceUpdateBatch::merge(QRhiResourceUpdateBatch *other)
 void QRhiResourceUpdateBatch::updateDynamicBuffer(QRhiBuffer *buf, int offset, int size, const void *data)
 {
     if (size > 0)
-        d->dynamicBufferUpdates.append({ buf, offset, size, data });
+        d->bufferOps.append(QRhiResourceUpdateBatchPrivate::BufferOp::dynamicUpdate(buf, offset, size, data));
 }
 
 /*!
@@ -4193,7 +4265,7 @@ void QRhiResourceUpdateBatch::updateDynamicBuffer(QRhiBuffer *buf, int offset, i
 void QRhiResourceUpdateBatch::uploadStaticBuffer(QRhiBuffer *buf, int offset, int size, const void *data)
 {
     if (size > 0)
-        d->staticBufferUploads.append({ buf, offset, size, data });
+        d->bufferOps.append(QRhiResourceUpdateBatchPrivate::BufferOp::staticUpload(buf, offset, size, data));
 }
 
 /*!
@@ -4203,7 +4275,28 @@ void QRhiResourceUpdateBatch::uploadStaticBuffer(QRhiBuffer *buf, int offset, in
 void QRhiResourceUpdateBatch::uploadStaticBuffer(QRhiBuffer *buf, const void *data)
 {
     if (buf->size() > 0)
-        d->staticBufferUploads.append({ buf, 0, 0, data });
+        d->bufferOps.append(QRhiResourceUpdateBatchPrivate::BufferOp::staticUpload(buf, 0, 0, data));
+}
+
+/*!
+    Enqueues reading back a region of the QRhiBuffer \a buf. The size of the
+    region is specified by \a size in bytes, \a offset is the offset in bytes
+    to start reading from.
+
+    A readback is asynchronous. \a result contains a callback that is invoked
+    when the operation has completed. The data is provided in
+    QRhiBufferReadbackResult::data. Upon successful completion that QByteArray
+    will have a size equal to \a size. On failure the QByteArray will be empty.
+
+    \note Reading buffers with a usage different than QRhiBuffer::UniformBuffer
+    is supported only when the QRhi::ReadBackNonUniformBuffer feature is
+    reported as supported.
+
+    \a readBackTexture(), QRhi::isFeatureSupported()
+ */
+void QRhiResourceUpdateBatch::readBackBuffer(QRhiBuffer *buf, int offset, int size, QRhiBufferReadbackResult *result)
+{
+    d->bufferOps.append(QRhiResourceUpdateBatchPrivate::BufferOp::read(buf, offset, size, result));
 }
 
 /*!
@@ -4215,8 +4308,8 @@ void QRhiResourceUpdateBatch::uploadStaticBuffer(QRhiBuffer *buf, const void *da
  */
 void QRhiResourceUpdateBatch::uploadTexture(QRhiTexture *tex, const QRhiTextureUploadDescription &desc)
 {
-    if (!desc.entries().isEmpty())
-        d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::textureUpload(tex, desc));
+    if (desc.cbeginEntries() != desc.cendEntries())
+        d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::upload(tex, desc));
 }
 
 /*!
@@ -4241,7 +4334,7 @@ void QRhiResourceUpdateBatch::uploadTexture(QRhiTexture *tex, const QImage &imag
  */
 void QRhiResourceUpdateBatch::copyTexture(QRhiTexture *dst, QRhiTexture *src, const QRhiTextureCopyDescription &desc)
 {
-    d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::textureCopy(dst, src, desc));
+    d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::copy(dst, src, desc));
 }
 
 /*!
@@ -4293,7 +4386,7 @@ void QRhiResourceUpdateBatch::copyTexture(QRhiTexture *dst, QRhiTexture *src, co
  */
 void QRhiResourceUpdateBatch::readBackTexture(const QRhiReadbackDescription &rb, QRhiReadbackResult *result)
 {
-    d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::textureRead(rb, result));
+    d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::read(rb, result));
 }
 
 /*!
@@ -4305,7 +4398,7 @@ void QRhiResourceUpdateBatch::readBackTexture(const QRhiReadbackDescription &rb,
  */
 void QRhiResourceUpdateBatch::generateMips(QRhiTexture *tex, int layer)
 {
-    d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::textureMipGen(tex, layer));
+    d->textureOps.append(QRhiResourceUpdateBatchPrivate::TextureOp::genMips(tex, layer));
 }
 
 /*!
@@ -4354,8 +4447,7 @@ void QRhiResourceUpdateBatchPrivate::free()
 {
     Q_ASSERT(poolIndex >= 0 && rhi->resUpdPool[poolIndex] == q);
 
-    dynamicBufferUpdates.clear();
-    staticBufferUploads.clear();
+    bufferOps.clear();
     textureOps.clear();
 
     rhi->resUpdPoolMap.clearBit(poolIndex);
@@ -4364,9 +4456,13 @@ void QRhiResourceUpdateBatchPrivate::free()
 
 void QRhiResourceUpdateBatchPrivate::merge(QRhiResourceUpdateBatchPrivate *other)
 {
-    dynamicBufferUpdates += other->dynamicBufferUpdates;
-    staticBufferUploads += other->staticBufferUploads;
-    textureOps += other->textureOps;
+    bufferOps.reserve(bufferOps.size() + other->bufferOps.size());
+    for (const BufferOp &op : qAsConst(other->bufferOps))
+        bufferOps.append(op);
+
+    textureOps.reserve(textureOps.size() + other->textureOps.size());
+    for (const TextureOp &op : qAsConst(other->textureOps))
+        textureOps.append(op);
 }
 
 /*!
diff --git a/src/gui/rhi/qrhi_p.h b/src/gui/rhi/qrhi_p.h
index f8f922cfdb..907924c788 100644
--- a/src/gui/rhi/qrhi_p.h
+++ b/src/gui/rhi/qrhi_p.h
@@ -72,7 +72,6 @@ class QRhiCommandBuffer;
 class QRhiResourceUpdateBatch;
 class QRhiResourceUpdateBatchPrivate;
 class QRhiProfiler;
-class QRhiShaderResourceBindingPrivate;
 
 class Q_GUI_EXPORT QRhiDepthStencilClearValue
 {
@@ -240,15 +239,42 @@ class Q_GUI_EXPORT QRhiVertexInputLayout
 public:
     QRhiVertexInputLayout() = default;
 
-    QVector<QRhiVertexInputBinding> bindings() const { return m_bindings; }
-    void setBindings(const QVector<QRhiVertexInputBinding> &v) { m_bindings = v; }
+    void setBindings(std::initializer_list<QRhiVertexInputBinding> list) { m_bindings = list; }
+    template<typename InputIterator>
+    void setBindings(InputIterator first, InputIterator last)
+    {
+        m_bindings.clear();
+        std::copy(first, last, std::back_inserter(m_bindings));
+    }
+    void setBindings(const QVector<QRhiVertexInputBinding> &bindings) // compat., to be removed
+    {
+        setBindings(bindings.cbegin(), bindings.cend());
+    }
+    const QRhiVertexInputBinding *cbeginBindings() const { return m_bindings.cbegin(); }
+    const QRhiVertexInputBinding *cendBindings() const { return m_bindings.cend(); }
+    const QRhiVertexInputBinding *bindingAt(int index) const { return &m_bindings.at(index); }
 
-    QVector<QRhiVertexInputAttribute> attributes() const { return m_attributes; }
-    void setAttributes(const QVector<QRhiVertexInputAttribute> &v) { m_attributes = v; }
+    void setAttributes(std::initializer_list<QRhiVertexInputAttribute> list) { m_attributes = list; }
+    template<typename InputIterator>
+    void setAttributes(InputIterator first, InputIterator last)
+    {
+        m_attributes.clear();
+        std::copy(first, last, std::back_inserter(m_attributes));
+    }
+    void setAttributes(const QVector<QRhiVertexInputAttribute> &attributes) // compat., to be removed
+    {
+        setAttributes(attributes.cbegin(), attributes.cend());
+    }
+    const QRhiVertexInputAttribute *cbeginAttributes() const { return m_attributes.cbegin(); }
+    const QRhiVertexInputAttribute *cendAttributes() const { return m_attributes.cend(); }
 
 private:
-    QVector<QRhiVertexInputBinding> m_bindings;
-    QVector<QRhiVertexInputAttribute> m_attributes;
+    QVarLengthArray<QRhiVertexInputBinding, 8> m_bindings;
+    QVarLengthArray<QRhiVertexInputAttribute, 8> m_attributes;
+
+    friend Q_GUI_EXPORT bool operator==(const QRhiVertexInputLayout &a, const QRhiVertexInputLayout &b) Q_DECL_NOTHROW;
+    friend Q_GUI_EXPORT uint qHash(const QRhiVertexInputLayout &v, uint seed) Q_DECL_NOTHROW;
+    friend Q_GUI_EXPORT QDebug operator<<(QDebug, const QRhiVertexInputLayout &);
 };
 
 Q_DECLARE_TYPEINFO(QRhiVertexInputLayout, Q_MOVABLE_TYPE);
@@ -439,8 +465,16 @@ public:
     QRhiTextureRenderTargetDescription(const QRhiColorAttachment &colorAttachment, QRhiRenderBuffer *depthStencilBuffer);
     QRhiTextureRenderTargetDescription(const QRhiColorAttachment &colorAttachment, QRhiTexture *depthTexture);
 
-    QVector<QRhiColorAttachment> colorAttachments() const { return m_colorAttachments; }
-    void setColorAttachments(const QVector<QRhiColorAttachment> &att) { m_colorAttachments = att; }
+    void setColorAttachments(std::initializer_list<QRhiColorAttachment> list) { m_colorAttachments = list; }
+    template<typename InputIterator>
+    void setColorAttachments(InputIterator first, InputIterator last)
+    {
+        m_colorAttachments.clear();
+        std::copy(first, last, std::back_inserter(m_colorAttachments));
+    }
+    const QRhiColorAttachment *cbeginColorAttachments() const { return m_colorAttachments.cbegin(); }
+    const QRhiColorAttachment *cendColorAttachments() const { return m_colorAttachments.cend(); }
+    const QRhiColorAttachment *colorAttachmentAt(int index) const { return &m_colorAttachments.at(index); }
 
     QRhiRenderBuffer *depthStencilBuffer() const { return m_depthStencilBuffer; }
     void setDepthStencilBuffer(QRhiRenderBuffer *renderBuffer) { m_depthStencilBuffer = renderBuffer; }
@@ -449,7 +483,7 @@ public:
     void setDepthTexture(QRhiTexture *texture) { m_depthTexture = texture; }
 
 private:
-    QVector<QRhiColorAttachment> m_colorAttachments;
+    QVarLengthArray<QRhiColorAttachment, 8> m_colorAttachments;
     QRhiRenderBuffer *m_depthStencilBuffer = nullptr;
     QRhiTexture *m_depthTexture = nullptr;
 };
@@ -516,14 +550,23 @@ class Q_GUI_EXPORT QRhiTextureUploadDescription
 public:
     QRhiTextureUploadDescription() = default;
     QRhiTextureUploadDescription(const QRhiTextureUploadEntry &entry);
-    QRhiTextureUploadDescription(const QVector<QRhiTextureUploadEntry> &entries);
+    QRhiTextureUploadDescription(std::initializer_list<QRhiTextureUploadEntry> list);
+    QRhiTextureUploadDescription(const QVector<QRhiTextureUploadEntry> &entries) // compat., to be removed
+        : m_entries(entries.cbegin(), entries.cend())
+    { }
 
-    QVector<QRhiTextureUploadEntry> entries() const { return m_entries; }
-    void setEntries(const QVector<QRhiTextureUploadEntry> &entries) { m_entries = entries; }
-    void append(const QRhiTextureUploadEntry &entry);
+    void setEntries(std::initializer_list<QRhiTextureUploadEntry> list) { m_entries = list; }
+    template<typename InputIterator>
+    void setEntries(InputIterator first, InputIterator last)
+    {
+        m_entries.clear();
+        std::copy(first, last, std::back_inserter(m_entries));
+    }
+    const QRhiTextureUploadEntry *cbeginEntries() const { return m_entries.cbegin(); }
+    const QRhiTextureUploadEntry *cendEntries() const { return m_entries.cend(); }
 
 private:
-    QVector<QRhiTextureUploadEntry> m_entries;
+    QVarLengthArray<QRhiTextureUploadEntry, 16> m_entries;
 };
 
 Q_DECLARE_TYPEINFO(QRhiTextureUploadDescription, Q_MOVABLE_TYPE);
@@ -973,6 +1016,7 @@ public:
     enum Topology {
         Triangles,
         TriangleStrip,
+        TriangleFan,
         Lines,
         LineStrip,
         Points
@@ -1310,6 +1354,12 @@ struct Q_GUI_EXPORT QRhiReadbackResult
     QByteArray data;
 }; // non-movable due to the std::function
 
+struct Q_GUI_EXPORT QRhiBufferReadbackResult
+{
+    std::function<void()> completed = nullptr;
+    QByteArray data;
+};
+
 class Q_GUI_EXPORT QRhiResourceUpdateBatch
 {
 public:
@@ -1322,6 +1372,7 @@ public:
     void updateDynamicBuffer(QRhiBuffer *buf, int offset, int size, const void *data);
     void uploadStaticBuffer(QRhiBuffer *buf, int offset, int size, const void *data);
     void uploadStaticBuffer(QRhiBuffer *buf, const void *data);
+    void readBackBuffer(QRhiBuffer *buf, int offset, int size, QRhiBufferReadbackResult *result);
     void uploadTexture(QRhiTexture *tex, const QRhiTextureUploadDescription &desc);
     void uploadTexture(QRhiTexture *tex, const QImage &image);
     void copyTexture(QRhiTexture *dst, QRhiTexture *src, const QRhiTextureCopyDescription &desc = QRhiTextureCopyDescription());
@@ -1382,7 +1433,10 @@ public:
         WideLines,
         VertexShaderPointSize,
         BaseVertex,
-        BaseInstance
+        BaseInstance,
+        TriangleFanTopology,
+        ReadBackNonUniformBuffer,
+        ReadBackNonBaseMipLevel
     };
 
     enum BeginFrameFlag {
diff --git a/src/gui/rhi/qrhi_p_p.h b/src/gui/rhi/qrhi_p_p.h
index 822da528f1..baffe28202 100644
--- a/src/gui/rhi/qrhi_p_p.h
+++ b/src/gui/rhi/qrhi_p_p.h
@@ -205,6 +205,8 @@ public:
         cleanupCallbacks.append(callback);
     }
 
+    bool sanityCheckGraphicsPipeline(QRhiGraphicsPipeline *ps);
+
     QRhi *q;
 
     static const int MAX_SHADER_CACHE_ENTRIES = 128;
@@ -218,7 +220,7 @@ private:
     QRhi::Implementation implType;
     QThread *implThread;
     QRhiProfiler profiler;
-    QVector<QRhiResourceUpdateBatch *> resUpdPool;
+    QVarLengthArray<QRhiResourceUpdateBatch *, 4> resUpdPool;
     QBitArray resUpdPoolMap;
     QSet<QRhiResource *> resources;
     QSet<QRhiResource *> pendingReleaseAndDestroyResources;
@@ -271,26 +273,49 @@ bool qrhi_toTopLeftRenderTargetRect(const QSize &outputSize, const std::array<T,
 class QRhiResourceUpdateBatchPrivate
 {
 public:
-    struct DynamicBufferUpdate {
-        DynamicBufferUpdate() { }
-        DynamicBufferUpdate(QRhiBuffer *buf_, int offset_, int size_, const void *data_)
-            : buf(buf_), offset(offset_), data(reinterpret_cast<const char *>(data_), size_)
-        { }
-
-        QRhiBuffer *buf = nullptr;
-        int offset = 0;
+    struct BufferOp {
+        enum Type {
+            DynamicUpdate,
+            StaticUpload,
+            Read
+        };
+        Type type;
+        QRhiBuffer *buf;
+        int offset;
         QByteArray data;
-    };
+        int readSize;
+        QRhiBufferReadbackResult *result;
 
-    struct StaticBufferUpload {
-        StaticBufferUpload() { }
-        StaticBufferUpload(QRhiBuffer *buf_, int offset_, int size_, const void *data_)
-            : buf(buf_), offset(offset_), data(reinterpret_cast<const char *>(data_), size_ ? size_ : buf_->size())
-        { }
+        static BufferOp dynamicUpdate(QRhiBuffer *buf, int offset, int size, const void *data)
+        {
+            BufferOp op;
+            op.type = DynamicUpdate;
+            op.buf = buf;
+            op.offset = offset;
+            op.data = QByteArray(reinterpret_cast<const char *>(data), size ? size : buf->size());
+            return op;
+        }
 
-        QRhiBuffer *buf = nullptr;
-        int offset = 0;
-        QByteArray data;
+        static BufferOp staticUpload(QRhiBuffer *buf, int offset, int size, const void *data)
+        {
+            BufferOp op;
+            op.type = StaticUpload;
+            op.buf = buf;
+            op.offset = offset;
+            op.data = QByteArray(reinterpret_cast<const char *>(data), size ? size : buf->size());
+            return op;
+        }
+
+        static BufferOp read(QRhiBuffer *buf, int offset, int size, QRhiBufferReadbackResult *result)
+        {
+            BufferOp op;
+            op.type = Read;
+            op.buf = buf;
+            op.offset = offset;
+            op.readSize = size;
+            op.result = result;
+            return op;
+        }
     };
 
     struct TextureOp {
@@ -298,74 +323,62 @@ public:
             Upload,
             Copy,
             Read,
-            MipGen
+            GenMips
         };
         Type type;
-        struct SUpload {
-            QRhiTexture *tex = nullptr;
-            // Specifying multiple uploads for a subresource must be supported.
-            // In the backend this can then end up, where applicable, as a
-            // single, batched copy operation with only one set of barriers.
-            // This helps when doing for example glyph cache fills.
-            QVector<QRhiTextureSubresourceUploadDescription> subresDesc[QRhi::MAX_LAYERS][QRhi::MAX_LEVELS];
-        } upload;
-        struct SCopy {
-            QRhiTexture *dst = nullptr;
-            QRhiTexture *src = nullptr;
-            QRhiTextureCopyDescription desc;
-        } copy;
-        struct SRead {
-            QRhiReadbackDescription rb;
-            QRhiReadbackResult *result;
-        } read;
-        struct SMipGen {
-            QRhiTexture *tex = nullptr;
-            int layer = 0;
-        } mipgen;
-
-        static TextureOp textureUpload(QRhiTexture *tex, const QRhiTextureUploadDescription &desc)
+        QRhiTexture *dst;
+        // Specifying multiple uploads for a subresource must be supported.
+        // In the backend this can then end up, where applicable, as a
+        // single, batched copy operation with only one set of barriers.
+        // This helps when doing for example glyph cache fills.
+        QVector<QRhiTextureSubresourceUploadDescription> subresDesc[QRhi::MAX_LAYERS][QRhi::MAX_LEVELS];
+        QRhiTexture *src;
+        QRhiTextureCopyDescription desc;
+        QRhiReadbackDescription rb;
+        QRhiReadbackResult *result;
+        int layer;
+
+        static TextureOp upload(QRhiTexture *tex, const QRhiTextureUploadDescription &desc)
         {
             TextureOp op;
             op.type = Upload;
-            op.upload.tex = tex;
-            const QVector<QRhiTextureUploadEntry> &entries(desc.entries());
-            for (const QRhiTextureUploadEntry &entry : entries)
-                op.upload.subresDesc[entry.layer()][entry.level()].append(entry.description());
+            op.dst = tex;
+            for (auto it = desc.cbeginEntries(), itEnd = desc.cendEntries(); it != itEnd; ++it)
+                op.subresDesc[it->layer()][it->level()].append(it->description());
             return op;
         }
 
-        static TextureOp textureCopy(QRhiTexture *dst, QRhiTexture *src, const QRhiTextureCopyDescription &desc)
+        static TextureOp copy(QRhiTexture *dst, QRhiTexture *src, const QRhiTextureCopyDescription &desc)
         {
             TextureOp op;
             op.type = Copy;
-            op.copy.dst = dst;
-            op.copy.src = src;
-            op.copy.desc = desc;
+            op.dst = dst;
+            op.src = src;
+            op.desc = desc;
             return op;
         }
 
-        static TextureOp textureRead(const QRhiReadbackDescription &rb, QRhiReadbackResult *result)
+        static TextureOp read(const QRhiReadbackDescription &rb, QRhiReadbackResult *result)
         {
             TextureOp op;
             op.type = Read;
-            op.read.rb = rb;
-            op.read.result = result;
+            op.rb = rb;
+            op.result = result;
             return op;
         }
 
-        static TextureOp textureMipGen(QRhiTexture *tex, int layer)
+        static TextureOp genMips(QRhiTexture *tex, int layer)
         {
             TextureOp op;
-            op.type = MipGen;
-            op.mipgen.tex = tex;
-            op.mipgen.layer = layer;
+            op.type = GenMips;
+            op.dst = tex;
+            op.layer = layer;
             return op;
         }
     };
 
-    QVector<DynamicBufferUpdate> dynamicBufferUpdates;
-    QVector<StaticBufferUpload> staticBufferUploads;
-    QVector<TextureOp> textureOps;
+    QVarLengthArray<BufferOp, 1024> bufferOps;
+    QVarLengthArray<TextureOp, 256> textureOps;
 
     QRhiResourceUpdateBatch *q = nullptr;
     QRhiImplementation *rhi = nullptr;
@@ -377,8 +390,7 @@ public:
     static QRhiResourceUpdateBatchPrivate *get(QRhiResourceUpdateBatch *b) { return b->d; }
 };
 
-Q_DECLARE_TYPEINFO(QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate, Q_MOVABLE_TYPE);
-Q_DECLARE_TYPEINFO(QRhiResourceUpdateBatchPrivate::StaticBufferUpload, Q_MOVABLE_TYPE);
+Q_DECLARE_TYPEINFO(QRhiResourceUpdateBatchPrivate::BufferOp, Q_MOVABLE_TYPE);
 Q_DECLARE_TYPEINFO(QRhiResourceUpdateBatchPrivate::TextureOp, Q_MOVABLE_TYPE);
 
 template<typename T>
diff --git a/src/gui/rhi/qrhid3d11.cpp b/src/gui/rhi/qrhid3d11.cpp
index b82a68f3dd..717f3e6d6c 100644
--- a/src/gui/rhi/qrhid3d11.cpp
+++ b/src/gui/rhi/qrhid3d11.cpp
@@ -469,6 +469,12 @@ bool QRhiD3D11::isFeatureSupported(QRhi::Feature feature) const
         return true;
     case QRhi::BaseInstance:
         return true;
+    case QRhi::TriangleFanTopology:
+        return false;
+    case QRhi::ReadBackNonUniformBuffer:
+        return true;
+    case QRhi::ReadBackNonBaseMipLevel:
+        return true;
     default:
         Q_UNREACHABLE();
         return false;
@@ -742,13 +748,14 @@ void QRhiD3D11::setVertexInput(QRhiCommandBuffer *cb,
         cmd.cmd = QD3D11CommandBuffer::Command::BindVertexBuffers;
         cmd.args.bindVertexBuffers.startSlot = startBinding;
         cmd.args.bindVertexBuffers.slotCount = bindingCount;
-        const QVector<QRhiVertexInputBinding> inputBindings =
-                QRHI_RES(QD3D11GraphicsPipeline, cbD->currentGraphicsPipeline)->m_vertexInputLayout.bindings();
-        for (int i = 0, ie = qMin(bindingCount, inputBindings.count()); i != ie; ++i) {
+        QD3D11GraphicsPipeline *psD = QRHI_RES(QD3D11GraphicsPipeline, cbD->currentGraphicsPipeline);
+        const QRhiVertexInputLayout &inputLayout(psD->m_vertexInputLayout);
+        const int inputBindingCount = inputLayout.cendBindings() - inputLayout.cbeginBindings();
+        for (int i = 0, ie = qMin(bindingCount, inputBindingCount); i != ie; ++i) {
             QD3D11Buffer *bufD = QRHI_RES(QD3D11Buffer, bindings[i].first);
             cmd.args.bindVertexBuffers.buffers[i] = bufD->buffer;
             cmd.args.bindVertexBuffers.offsets[i] = bindings[i].second;
-            cmd.args.bindVertexBuffers.strides[i] = inputBindings[i].stride();
+            cmd.args.bindVertexBuffers.strides[i] = inputLayout.bindingAt(i)->stride();
         }
         cbD->commands.append(cmd);
     }
@@ -1320,61 +1327,105 @@ void QRhiD3D11::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
     QRhiResourceUpdateBatchPrivate *ud = QRhiResourceUpdateBatchPrivate::get(resourceUpdates);
     QRhiProfilerPrivate *rhiP = profilerPrivateOrNull();
 
-    for (const QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate &u : ud->dynamicBufferUpdates) {
-        QD3D11Buffer *bufD = QRHI_RES(QD3D11Buffer, u.buf);
-        Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
-        memcpy(bufD->dynBuf.data() + u.offset, u.data.constData(), size_t(u.data.size()));
-        bufD->hasPendingDynamicUpdates = true;
-    }
-
-    for (const QRhiResourceUpdateBatchPrivate::StaticBufferUpload &u : ud->staticBufferUploads) {
-        QD3D11Buffer *bufD = QRHI_RES(QD3D11Buffer, u.buf);
-        Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
-        Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
-        QD3D11CommandBuffer::Command cmd;
-        cmd.cmd = QD3D11CommandBuffer::Command::UpdateSubRes;
-        cmd.args.updateSubRes.dst = bufD->buffer;
-        cmd.args.updateSubRes.dstSubRes = 0;
-        cmd.args.updateSubRes.src = cbD->retainData(u.data);
-        cmd.args.updateSubRes.srcRowPitch = 0;
-        // Specify the region (even when offset is 0 and all data is provided)
-        // since the ID3D11Buffer's size is rounded up to be a multiple of 256
-        // while the data we have has the original size.
-        D3D11_BOX box;
-        box.left = UINT(u.offset);
-        box.top = box.front = 0;
-        box.back = box.bottom = 1;
-        box.right = UINT(u.offset + u.data.size()); // no -1: right, bottom, back are exclusive, see D3D11_BOX doc
-        cmd.args.updateSubRes.hasDstBox = true;
-        cmd.args.updateSubRes.dstBox = box;
-        cbD->commands.append(cmd);
+    for (const QRhiResourceUpdateBatchPrivate::BufferOp &u : ud->bufferOps) {
+        if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::DynamicUpdate) {
+            QD3D11Buffer *bufD = QRHI_RES(QD3D11Buffer, u.buf);
+            Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
+            memcpy(bufD->dynBuf.data() + u.offset, u.data.constData(), size_t(u.data.size()));
+            bufD->hasPendingDynamicUpdates = true;
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::StaticUpload) {
+            QD3D11Buffer *bufD = QRHI_RES(QD3D11Buffer, u.buf);
+            Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
+            Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
+            QD3D11CommandBuffer::Command cmd;
+            cmd.cmd = QD3D11CommandBuffer::Command::UpdateSubRes;
+            cmd.args.updateSubRes.dst = bufD->buffer;
+            cmd.args.updateSubRes.dstSubRes = 0;
+            cmd.args.updateSubRes.src = cbD->retainData(u.data);
+            cmd.args.updateSubRes.srcRowPitch = 0;
+            // Specify the region (even when offset is 0 and all data is provided)
+            // since the ID3D11Buffer's size is rounded up to be a multiple of 256
+            // while the data we have has the original size.
+            D3D11_BOX box;
+            box.left = UINT(u.offset);
+            box.top = box.front = 0;
+            box.back = box.bottom = 1;
+            box.right = UINT(u.offset + u.data.size()); // no -1: right, bottom, back are exclusive, see D3D11_BOX doc
+            cmd.args.updateSubRes.hasDstBox = true;
+            cmd.args.updateSubRes.dstBox = box;
+            cbD->commands.append(cmd);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::Read) {
+            QD3D11Buffer *bufD = QRHI_RES(QD3D11Buffer, u.buf);
+            if (bufD->m_type == QRhiBuffer::Dynamic) {
+                u.result->data.resize(u.readSize);
+                memcpy(u.result->data.data(), bufD->dynBuf.constData() + u.offset, size_t(u.readSize));
+            } else {
+                BufferReadback readback;
+                readback.result = u.result;
+                readback.byteSize = u.readSize;
+
+                D3D11_BUFFER_DESC desc;
+                memset(&desc, 0, sizeof(desc));
+                desc.ByteWidth = readback.byteSize;
+                desc.Usage = D3D11_USAGE_STAGING;
+                desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
+                HRESULT hr = dev->CreateBuffer(&desc, nullptr, &readback.stagingBuf);
+                if (FAILED(hr)) {
+                    qWarning("Failed to create buffer: %s", qPrintable(comErrorMessage(hr)));
+                    continue;
+                }
+                QRHI_PROF_F(newReadbackBuffer(qint64(qintptr(readback.stagingBuf)), bufD, readback.byteSize));
+
+                QD3D11CommandBuffer::Command cmd;
+                cmd.cmd = QD3D11CommandBuffer::Command::CopySubRes;
+                cmd.args.copySubRes.dst = readback.stagingBuf;
+                cmd.args.copySubRes.dstSubRes = 0;
+                cmd.args.copySubRes.dstX = 0;
+                cmd.args.copySubRes.dstY = 0;
+                cmd.args.copySubRes.src = bufD->buffer;
+                cmd.args.copySubRes.srcSubRes = 0;
+                cmd.args.copySubRes.hasSrcBox = true;
+                D3D11_BOX box;
+                box.left = UINT(u.offset);
+                box.top = box.front = 0;
+                box.back = box.bottom = 1;
+                box.right = UINT(u.offset + u.readSize);
+                cmd.args.copySubRes.srcBox = box;
+                cbD->commands.append(cmd);
+
+                activeBufferReadbacks.append(readback);
+            }
+            if (u.result->completed)
+                u.result->completed();
+        }
     }
 
     for (const QRhiResourceUpdateBatchPrivate::TextureOp &u : ud->textureOps) {
         if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Upload) {
-            QD3D11Texture *texD = QRHI_RES(QD3D11Texture, u.upload.tex);
+            QD3D11Texture *texD = QRHI_RES(QD3D11Texture, u.dst);
             for (int layer = 0; layer < QRhi::MAX_LAYERS; ++layer) {
                 for (int level = 0; level < QRhi::MAX_LEVELS; ++level) {
-                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.upload.subresDesc[layer][level]))
+                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.subresDesc[layer][level]))
                         enqueueSubresUpload(texD, cbD, layer, level, subresDesc);
                 }
             }
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Copy) {
-            Q_ASSERT(u.copy.src && u.copy.dst);
-            QD3D11Texture *srcD = QRHI_RES(QD3D11Texture, u.copy.src);
-            QD3D11Texture *dstD = QRHI_RES(QD3D11Texture, u.copy.dst);
-            UINT srcSubRes = D3D11CalcSubresource(UINT(u.copy.desc.sourceLevel()), UINT(u.copy.desc.sourceLayer()), srcD->mipLevelCount);
-            UINT dstSubRes = D3D11CalcSubresource(UINT(u.copy.desc.destinationLevel()), UINT(u.copy.desc.destinationLayer()), dstD->mipLevelCount);
-            const QPoint dp = u.copy.desc.destinationTopLeft();
-            const QSize size = u.copy.desc.pixelSize().isEmpty() ? srcD->m_pixelSize : u.copy.desc.pixelSize();
-            const QPoint sp = u.copy.desc.sourceTopLeft();
+            Q_ASSERT(u.src && u.dst);
+            QD3D11Texture *srcD = QRHI_RES(QD3D11Texture, u.src);
+            QD3D11Texture *dstD = QRHI_RES(QD3D11Texture, u.dst);
+            UINT srcSubRes = D3D11CalcSubresource(UINT(u.desc.sourceLevel()), UINT(u.desc.sourceLayer()), srcD->mipLevelCount);
+            UINT dstSubRes = D3D11CalcSubresource(UINT(u.desc.destinationLevel()), UINT(u.desc.destinationLayer()), dstD->mipLevelCount);
+            const QPoint dp = u.desc.destinationTopLeft();
+            const QSize mipSize = q->sizeForMipLevel(u.desc.sourceLevel(), srcD->m_pixelSize);
+            const QSize copySize = u.desc.pixelSize().isEmpty() ? mipSize : u.desc.pixelSize();
+            const QPoint sp = u.desc.sourceTopLeft();
             D3D11_BOX srcBox;
             srcBox.left = UINT(sp.x());
             srcBox.top = UINT(sp.y());
             srcBox.front = 0;
             // back, right, bottom are exclusive
-            srcBox.right = srcBox.left + UINT(size.width());
-            srcBox.bottom = srcBox.top + UINT(size.height());
+            srcBox.right = srcBox.left + UINT(copySize.width());
+            srcBox.bottom = srcBox.top + UINT(copySize.height());
             srcBox.back = 1;
             QD3D11CommandBuffer::Command cmd;
             cmd.cmd = QD3D11CommandBuffer::Command::CopySubRes;
@@ -1388,16 +1439,16 @@ void QRhiD3D11::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
             cmd.args.copySubRes.srcBox = srcBox;
             cbD->commands.append(cmd);
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Read) {
-            ActiveReadback aRb;
-            aRb.desc = u.read.rb;
-            aRb.result = u.read.result;
+            TextureReadback readback;
+            readback.desc = u.rb;
+            readback.result = u.result;
 
             ID3D11Resource *src;
             DXGI_FORMAT dxgiFormat;
             QSize pixelSize;
             QRhiTexture::Format format;
             UINT subres = 0;
-            QD3D11Texture *texD = QRHI_RES(QD3D11Texture, u.read.rb.texture());
+            QD3D11Texture *texD = QRHI_RES(QD3D11Texture, u.rb.texture());
             QD3D11SwapChain *swapChainD = nullptr;
 
             if (texD) {
@@ -1407,9 +1458,9 @@ void QRhiD3D11::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
                 }
                 src = texD->tex;
                 dxgiFormat = texD->dxgiFormat;
-                pixelSize = u.read.rb.level() > 0 ? q->sizeForMipLevel(u.read.rb.level(), texD->m_pixelSize) : texD->m_pixelSize;
+                pixelSize = q->sizeForMipLevel(u.rb.level(), texD->m_pixelSize);
                 format = texD->m_format;
-                subres = D3D11CalcSubresource(UINT(u.read.rb.level()), UINT(u.read.rb.layer()), texD->mipLevelCount);
+                subres = D3D11CalcSubresource(UINT(u.rb.level()), UINT(u.rb.layer()), texD->mipLevelCount);
             } else {
                 Q_ASSERT(contextState.currentSwapChain);
                 swapChainD = QRHI_RES(QD3D11SwapChain, contextState.currentSwapChain);
@@ -1432,9 +1483,9 @@ void QRhiD3D11::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
                 if (format == QRhiTexture::UnknownFormat)
                     continue;
             }
-            quint32 bufSize = 0;
+            quint32 byteSize = 0;
             quint32 bpl = 0;
-            textureFormatInfo(format, pixelSize, &bpl, &bufSize);
+            textureFormatInfo(format, pixelSize, &bpl, &byteSize);
 
             D3D11_TEXTURE2D_DESC desc;
             memset(&desc, 0, sizeof(desc));
@@ -1454,7 +1505,7 @@ void QRhiD3D11::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
             }
             QRHI_PROF_F(newReadbackBuffer(qint64(qintptr(stagingTex)),
                                           texD ? static_cast<QRhiResource *>(texD) : static_cast<QRhiResource *>(swapChainD),
-                                          bufSize));
+                                          byteSize));
 
             QD3D11CommandBuffer::Command cmd;
             cmd.cmd = QD3D11CommandBuffer::Command::CopySubRes;
@@ -1467,18 +1518,18 @@ void QRhiD3D11::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
             cmd.args.copySubRes.hasSrcBox = false;
             cbD->commands.append(cmd);
 
-            aRb.stagingTex = stagingTex;
-            aRb.bufSize = bufSize;
-            aRb.bpl = bpl;
-            aRb.pixelSize = pixelSize;
-            aRb.format = format;
+            readback.stagingTex = stagingTex;
+            readback.byteSize = byteSize;
+            readback.bpl = bpl;
+            readback.pixelSize = pixelSize;
+            readback.format = format;
 
-            activeReadbacks.append(aRb);
-        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::MipGen) {
-            Q_ASSERT(u.mipgen.tex->flags().testFlag(QRhiTexture::UsedWithGenerateMips));
+            activeTextureReadbacks.append(readback);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::GenMips) {
+            Q_ASSERT(u.dst->flags().testFlag(QRhiTexture::UsedWithGenerateMips));
             QD3D11CommandBuffer::Command cmd;
             cmd.cmd = QD3D11CommandBuffer::Command::GenMip;
-            cmd.args.genMip.srv = QRHI_RES(QD3D11Texture, u.mipgen.tex)->srv;
+            cmd.args.genMip.srv = QRHI_RES(QD3D11Texture, u.dst)->srv;
             cbD->commands.append(cmd);
         }
     }
@@ -1491,37 +1542,58 @@ void QRhiD3D11::finishActiveReadbacks()
     QVarLengthArray<std::function<void()>, 4> completedCallbacks;
     QRhiProfilerPrivate *rhiP = profilerPrivateOrNull();
 
-    for (int i = activeReadbacks.count() - 1; i >= 0; --i) {
-        const QRhiD3D11::ActiveReadback &aRb(activeReadbacks[i]);
-        aRb.result->format = aRb.format;
-        aRb.result->pixelSize = aRb.pixelSize;
-        aRb.result->data.resize(int(aRb.bufSize));
+    for (int i = activeTextureReadbacks.count() - 1; i >= 0; --i) {
+        const QRhiD3D11::TextureReadback &readback(activeTextureReadbacks[i]);
+        readback.result->format = readback.format;
+        readback.result->pixelSize = readback.pixelSize;
 
         D3D11_MAPPED_SUBRESOURCE mp;
-        HRESULT hr = context->Map(aRb.stagingTex, 0, D3D11_MAP_READ, 0, &mp);
-        if (FAILED(hr)) {
+        HRESULT hr = context->Map(readback.stagingTex, 0, D3D11_MAP_READ, 0, &mp);
+        if (SUCCEEDED(hr)) {
+            readback.result->data.resize(int(readback.byteSize));
+            // nothing says the rows are tightly packed in the texture, must take
+            // the stride into account
+            char *dst = readback.result->data.data();
+            char *src = static_cast<char *>(mp.pData);
+            for (int y = 0, h = readback.pixelSize.height(); y != h; ++y) {
+                memcpy(dst, src, readback.bpl);
+                dst += readback.bpl;
+                src += mp.RowPitch;
+            }
+            context->Unmap(readback.stagingTex, 0);
+        } else {
             qWarning("Failed to map readback staging texture: %s", qPrintable(comErrorMessage(hr)));
-            aRb.stagingTex->Release();
-            continue;
         }
-        // nothing says the rows are tightly packed in the texture, must take
-        // the stride into account
-        char *dst = aRb.result->data.data();
-        char *src = static_cast<char *>(mp.pData);
-        for (int y = 0, h = aRb.pixelSize.height(); y != h; ++y) {
-            memcpy(dst, src, aRb.bpl);
-            dst += aRb.bpl;
-            src += mp.RowPitch;
+
+        readback.stagingTex->Release();
+        QRHI_PROF_F(releaseReadbackBuffer(qint64(qintptr(readback.stagingTex))));
+
+        if (readback.result->completed)
+            completedCallbacks.append(readback.result->completed);
+
+        activeTextureReadbacks.removeAt(i);
+    }
+
+    for (int i = activeBufferReadbacks.count() - 1; i >= 0; --i) {
+        const QRhiD3D11::BufferReadback &readback(activeBufferReadbacks[i]);
+
+        D3D11_MAPPED_SUBRESOURCE mp;
+        HRESULT hr = context->Map(readback.stagingBuf, 0, D3D11_MAP_READ, 0, &mp);
+        if (SUCCEEDED(hr)) {
+            readback.result->data.resize(int(readback.byteSize));
+            memcpy(readback.result->data.data(), mp.pData, readback.byteSize);
+            context->Unmap(readback.stagingBuf, 0);
+        } else {
+            qWarning("Failed to map readback staging texture: %s", qPrintable(comErrorMessage(hr)));
         }
-        context->Unmap(aRb.stagingTex, 0);
 
-        aRb.stagingTex->Release();
-        QRHI_PROF_F(releaseReadbackBuffer(qint64(qintptr(aRb.stagingTex))));
+        readback.stagingBuf->Release();
+        QRHI_PROF_F(releaseReadbackBuffer(qint64(qintptr(readback.stagingBuf))));
 
-        if (aRb.result->completed)
-            completedCallbacks.append(aRb.result->completed);
+        if (readback.result->completed)
+            completedCallbacks.append(readback.result->completed);
 
-        activeReadbacks.removeAt(i);
+        activeBufferReadbacks.removeAt(i);
     }
 
     for (auto f : completedCallbacks)
@@ -1606,9 +1678,10 @@ void QRhiD3D11::endPass(QRhiCommandBuffer *cb, QRhiResourceUpdateBatch *resource
 
     if (cbD->currentTarget->resourceType() == QRhiResource::TextureRenderTarget) {
         QD3D11TextureRenderTarget *rtTex = QRHI_RES(QD3D11TextureRenderTarget, cbD->currentTarget);
-        const QVector<QRhiColorAttachment> colorAttachments = rtTex->m_desc.colorAttachments();
-        for (int att = 0, attCount = colorAttachments.count(); att != attCount; ++att) {
-            const QRhiColorAttachment &colorAtt(colorAttachments[att]);
+        for (auto it = rtTex->m_desc.cbeginColorAttachments(), itEnd = rtTex->m_desc.cendColorAttachments();
+             it != itEnd; ++it)
+        {
+            const QRhiColorAttachment &colorAtt(*it);
             if (!colorAtt.resolveTexture())
                 continue;
 
@@ -2953,17 +3026,20 @@ bool QD3D11TextureRenderTarget::build()
     if (rtv[0] || dsv)
         release();
 
-    const QVector<QRhiColorAttachment> colorAttachments = m_desc.colorAttachments();
-    Q_ASSERT(!colorAttachments.isEmpty() || m_desc.depthTexture());
+    const bool hasColorAttachments = m_desc.cbeginColorAttachments() != m_desc.cendColorAttachments();
+    Q_ASSERT(hasColorAttachments || m_desc.depthTexture());
     Q_ASSERT(!m_desc.depthStencilBuffer() || !m_desc.depthTexture());
     const bool hasDepthStencil = m_desc.depthStencilBuffer() || m_desc.depthTexture();
 
     QRHI_RES_RHI(QRhiD3D11);
 
-    d.colorAttCount = colorAttachments.count();
-    for (int i = 0; i < d.colorAttCount; ++i) {
-        QRhiTexture *texture = colorAttachments[i].texture();
-        QRhiRenderBuffer *rb = colorAttachments[i].renderBuffer();
+    d.colorAttCount = 0;
+    int attIndex = 0;
+    for (auto it = m_desc.cbeginColorAttachments(), itEnd = m_desc.cendColorAttachments(); it != itEnd; ++it, ++attIndex) {
+        d.colorAttCount += 1;
+        const QRhiColorAttachment &colorAtt(*it);
+        QRhiTexture *texture = colorAtt.texture();
+        QRhiRenderBuffer *rb = colorAtt.renderBuffer();
         Q_ASSERT(texture || rb);
         if (texture) {
             QD3D11Texture *texD = QRHI_RES(QD3D11Texture, texture);
@@ -2972,32 +3048,32 @@ bool QD3D11TextureRenderTarget::build()
             rtvDesc.Format = toD3DTextureFormat(texD->format(), texD->flags());
             if (texD->flags().testFlag(QRhiTexture::CubeMap)) {
                 rtvDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DARRAY;
-                rtvDesc.Texture2DArray.MipSlice = UINT(colorAttachments[i].level());
-                rtvDesc.Texture2DArray.FirstArraySlice = UINT(colorAttachments[i].layer());
+                rtvDesc.Texture2DArray.MipSlice = UINT(colorAtt.level());
+                rtvDesc.Texture2DArray.FirstArraySlice = UINT(colorAtt.layer());
                 rtvDesc.Texture2DArray.ArraySize = 1;
             } else {
                 if (texD->sampleDesc.Count > 1) {
                     rtvDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DMS;
                 } else {
                     rtvDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
-                    rtvDesc.Texture2D.MipSlice = UINT(colorAttachments[i].level());
+                    rtvDesc.Texture2D.MipSlice = UINT(colorAtt.level());
                 }
             }
-            HRESULT hr = rhiD->dev->CreateRenderTargetView(texD->tex, &rtvDesc, &rtv[i]);
+            HRESULT hr = rhiD->dev->CreateRenderTargetView(texD->tex, &rtvDesc, &rtv[attIndex]);
             if (FAILED(hr)) {
                 qWarning("Failed to create rtv: %s", qPrintable(comErrorMessage(hr)));
                 return false;
             }
-            ownsRtv[i] = true;
-            if (i == 0) {
+            ownsRtv[attIndex] = true;
+            if (attIndex == 0) {
                 d.pixelSize = texD->pixelSize();
                 d.sampleCount = int(texD->sampleDesc.Count);
             }
         } else if (rb) {
             QD3D11RenderBuffer *rbD = QRHI_RES(QD3D11RenderBuffer, rb);
-            ownsRtv[i] = false;
-            rtv[i] = rbD->rtv;
-            if (i == 0) {
+            ownsRtv[attIndex] = false;
+            rtv[attIndex] = rbD->rtv;
+            if (attIndex == 0) {
                 d.pixelSize = rbD->pixelSize();
                 d.sampleCount = int(rbD->sampleDesc.Count);
             }
@@ -3416,6 +3492,8 @@ bool QD3D11GraphicsPipeline::build()
         release();
 
     QRHI_RES_RHI(QRhiD3D11);
+    if (!rhiD->sanityCheckGraphicsPipeline(this))
+        return false;
 
     D3D11_RASTERIZER_DESC rastDesc;
     memset(&rastDesc, 0, sizeof(rastDesc));
@@ -3542,22 +3620,22 @@ bool QD3D11GraphicsPipeline::build()
     d3dTopology = toD3DTopology(m_topology);
 
     if (!vsByteCode.isEmpty()) {
-        const QVector<QRhiVertexInputBinding> bindings = m_vertexInputLayout.bindings();
-        const QVector<QRhiVertexInputAttribute> attributes = m_vertexInputLayout.attributes();
         QVarLengthArray<D3D11_INPUT_ELEMENT_DESC, 4> inputDescs;
-        for (const QRhiVertexInputAttribute &attribute : attributes) {
+        for (auto it = m_vertexInputLayout.cbeginAttributes(), itEnd = m_vertexInputLayout.cendAttributes();
+             it != itEnd; ++it)
+        {
             D3D11_INPUT_ELEMENT_DESC desc;
             memset(&desc, 0, sizeof(desc));
             // the output from SPIRV-Cross uses TEXCOORD<location> as the semantic
             desc.SemanticName = "TEXCOORD";
-            desc.SemanticIndex = UINT(attribute.location());
-            desc.Format = toD3DAttributeFormat(attribute.format());
-            desc.InputSlot = UINT(attribute.binding());
-            desc.AlignedByteOffset = attribute.offset();
-            const QRhiVertexInputBinding &binding(bindings[attribute.binding()]);
-            if (binding.classification() == QRhiVertexInputBinding::PerInstance) {
+            desc.SemanticIndex = UINT(it->location());
+            desc.Format = toD3DAttributeFormat(it->format());
+            desc.InputSlot = UINT(it->binding());
+            desc.AlignedByteOffset = it->offset();
+            const QRhiVertexInputBinding *inputBinding = m_vertexInputLayout.bindingAt(it->binding());
+            if (inputBinding->classification() == QRhiVertexInputBinding::PerInstance) {
                 desc.InputSlotClass = D3D11_INPUT_PER_INSTANCE_DATA;
-                desc.InstanceDataStepRate = UINT(binding.instanceStepRate());
+                desc.InstanceDataStepRate = UINT(inputBinding->instanceStepRate());
             } else {
                 desc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
             }
diff --git a/src/gui/rhi/qrhid3d11_p_p.h b/src/gui/rhi/qrhid3d11_p_p.h
index 6699e7ad64..26de34ae0a 100644
--- a/src/gui/rhi/qrhid3d11_p_p.h
+++ b/src/gui/rhi/qrhid3d11_p_p.h
@@ -678,16 +678,22 @@ public:
         QD3D11CommandBuffer cbWrapper;
     } ofr;
 
-    struct ActiveReadback {
+    struct TextureReadback {
         QRhiReadbackDescription desc;
         QRhiReadbackResult *result;
         ID3D11Texture2D *stagingTex;
-        quint32 bufSize;
+        quint32 byteSize;
         quint32 bpl;
         QSize pixelSize;
         QRhiTexture::Format format;
     };
-    QVector<ActiveReadback> activeReadbacks;
+    QVector<TextureReadback> activeTextureReadbacks;
+    struct BufferReadback {
+        QRhiBufferReadbackResult *result;
+        quint32 byteSize;
+        ID3D11Buffer *stagingBuf;
+    };
+    QVector<BufferReadback> activeBufferReadbacks;
 
     struct Shader {
         Shader() = default;
@@ -711,7 +717,8 @@ public:
     } deviceCurse;
 };
 
-Q_DECLARE_TYPEINFO(QRhiD3D11::ActiveReadback, Q_MOVABLE_TYPE);
+Q_DECLARE_TYPEINFO(QRhiD3D11::TextureReadback, Q_MOVABLE_TYPE);
+Q_DECLARE_TYPEINFO(QRhiD3D11::BufferReadback, Q_MOVABLE_TYPE);
 
 QT_END_NAMESPACE
 
diff --git a/src/gui/rhi/qrhigles2.cpp b/src/gui/rhi/qrhigles2.cpp
index 190385d5de..dec28cac9b 100644
--- a/src/gui/rhi/qrhigles2.cpp
+++ b/src/gui/rhi/qrhigles2.cpp
@@ -276,6 +276,10 @@ QT_BEGIN_NAMESPACE
 #define GL_POINT_SPRITE                   0x8861
 #endif
 
+#ifndef GL_MAP_READ_BIT
+#define GL_MAP_READ_BIT                   0x0001
+#endif
+
 Q_DECLARE_LOGGING_CATEGORY(lcOpenGLProgramDiskCache)
 
 /*!
@@ -492,6 +496,15 @@ bool QRhiGles2::create(QRhi::Flags flags)
     else
         caps.textureCompareMode = true;
 
+    // proper as in ES 3.0 (glMapBufferRange), not the old glMapBuffer
+    // extension(s) (which is not in ES 3.0...messy)
+    caps.properMapBuffer = f->hasOpenGLExtension(QOpenGLExtensions::MapBufferRange);
+
+    if (caps.gles)
+        caps.nonBaseLevelFramebufferTexture = caps.ctxMajor >= 3; // ES 3.0
+    else
+        caps.nonBaseLevelFramebufferTexture = true;
+
     if (!caps.gles) {
         f->glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
         f->glEnable(GL_POINT_SPRITE);
@@ -512,6 +525,11 @@ void QRhiGles2::destroy()
     ensureContext();
     executeDeferredReleases();
 
+    if (vao) {
+        f->glDeleteVertexArrays(1, &vao);
+        vao = 0;
+    }
+
     for (uint shader : m_shaderCache)
         f->glDeleteShader(shader);
     m_shaderCache.clear();
@@ -732,6 +750,12 @@ bool QRhiGles2::isFeatureSupported(QRhi::Feature feature) const
         return caps.baseVertex;
     case QRhi::BaseInstance:
         return false; // not in ES 3.2, so won't bother
+    case QRhi::TriangleFanTopology:
+        return true;
+    case QRhi::ReadBackNonUniformBuffer:
+        return !caps.gles || caps.properMapBuffer;
+    case QRhi::ReadBackNonBaseMipLevel:
+        return caps.nonBaseLevelFramebufferTexture;
     default:
         Q_UNREACHABLE();
         return false;
@@ -1132,6 +1156,13 @@ const QRhiNativeHandles *QRhiGles2::nativeHandles(QRhiCommandBuffer *cb)
     return nullptr;
 }
 
+static void addBoundaryCommand(QGles2CommandBuffer *cbD, QGles2CommandBuffer::Command::Cmd type)
+{
+    QGles2CommandBuffer::Command cmd;
+    cmd.cmd = type;
+    cbD->commands.append(cmd);
+}
+
 void QRhiGles2::beginExternal(QRhiCommandBuffer *cb)
 {
     if (ofr.active) {
@@ -1147,6 +1178,9 @@ void QRhiGles2::beginExternal(QRhiCommandBuffer *cb)
     QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
     executeCommandBuffer(cbD);
     cbD->resetCommands();
+
+    if (vao)
+        f->glBindVertexArray(0);
 }
 
 void QRhiGles2::endExternal(QRhiCommandBuffer *cb)
@@ -1164,17 +1198,12 @@ void QRhiGles2::endExternal(QRhiCommandBuffer *cb)
         enqueueBarriersForPass(cbD);
     }
 
+    addBoundaryCommand(cbD, QGles2CommandBuffer::Command::ResetFrame);
+
     if (cbD->currentTarget)
         enqueueBindFramebuffer(cbD->currentTarget, cbD);
 }
 
-static void addBoundaryCommand(QGles2CommandBuffer *cb, QGles2CommandBuffer::Command::Cmd type)
-{
-    QGles2CommandBuffer::Command cmd;
-    cmd.cmd = type;
-    cb->commands.append(cmd);
-}
-
 QRhi::FrameOpResult QRhiGles2::beginFrame(QRhiSwapChain *swapChain, QRhi::BeginFrameFlags flags)
 {
     Q_UNUSED(flags);
@@ -1415,65 +1444,83 @@ void QRhiGles2::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
     QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
     QRhiResourceUpdateBatchPrivate *ud = QRhiResourceUpdateBatchPrivate::get(resourceUpdates);
 
-    for (const QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate &u : ud->dynamicBufferUpdates) {
-        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
-        Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
-        if (bufD->m_usage.testFlag(QRhiBuffer::UniformBuffer)) {
-            memcpy(bufD->ubuf.data() + u.offset, u.data.constData(), size_t(u.data.size()));
-        } else {
-            trackedBufferBarrier(cbD, bufD, QGles2Buffer::AccessUpdate);
-            QGles2CommandBuffer::Command cmd;
-            cmd.cmd = QGles2CommandBuffer::Command::BufferSubData;
-            cmd.args.bufferSubData.target = bufD->targetForDataOps;
-            cmd.args.bufferSubData.buffer = bufD->buffer;
-            cmd.args.bufferSubData.offset = u.offset;
-            cmd.args.bufferSubData.size = u.data.size();
-            cmd.args.bufferSubData.data = cbD->retainData(u.data);
-            cbD->commands.append(cmd);
-        }
-    }
-
-    for (const QRhiResourceUpdateBatchPrivate::StaticBufferUpload &u : ud->staticBufferUploads) {
-        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
-        Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
-        Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
-        if (bufD->m_usage.testFlag(QRhiBuffer::UniformBuffer)) {
-            memcpy(bufD->ubuf.data() + u.offset, u.data.constData(), size_t(u.data.size()));
-        } else {
-            trackedBufferBarrier(cbD, bufD, QGles2Buffer::AccessUpdate);
-            QGles2CommandBuffer::Command cmd;
-            cmd.cmd = QGles2CommandBuffer::Command::BufferSubData;
-            cmd.args.bufferSubData.target = bufD->targetForDataOps;
-            cmd.args.bufferSubData.buffer = bufD->buffer;
-            cmd.args.bufferSubData.offset = u.offset;
-            cmd.args.bufferSubData.size = u.data.size();
-            cmd.args.bufferSubData.data = cbD->retainData(u.data);
-            cbD->commands.append(cmd);
+    for (const QRhiResourceUpdateBatchPrivate::BufferOp &u : ud->bufferOps) {
+        if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::DynamicUpdate) {
+            QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
+            Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
+            if (bufD->m_usage.testFlag(QRhiBuffer::UniformBuffer)) {
+                memcpy(bufD->ubuf.data() + u.offset, u.data.constData(), size_t(u.data.size()));
+            } else {
+                trackedBufferBarrier(cbD, bufD, QGles2Buffer::AccessUpdate);
+                QGles2CommandBuffer::Command cmd;
+                cmd.cmd = QGles2CommandBuffer::Command::BufferSubData;
+                cmd.args.bufferSubData.target = bufD->targetForDataOps;
+                cmd.args.bufferSubData.buffer = bufD->buffer;
+                cmd.args.bufferSubData.offset = u.offset;
+                cmd.args.bufferSubData.size = u.data.size();
+                cmd.args.bufferSubData.data = cbD->retainData(u.data);
+                cbD->commands.append(cmd);
+            }
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::StaticUpload) {
+            QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
+            Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
+            Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
+            if (bufD->m_usage.testFlag(QRhiBuffer::UniformBuffer)) {
+                memcpy(bufD->ubuf.data() + u.offset, u.data.constData(), size_t(u.data.size()));
+            } else {
+                trackedBufferBarrier(cbD, bufD, QGles2Buffer::AccessUpdate);
+                QGles2CommandBuffer::Command cmd;
+                cmd.cmd = QGles2CommandBuffer::Command::BufferSubData;
+                cmd.args.bufferSubData.target = bufD->targetForDataOps;
+                cmd.args.bufferSubData.buffer = bufD->buffer;
+                cmd.args.bufferSubData.offset = u.offset;
+                cmd.args.bufferSubData.size = u.data.size();
+                cmd.args.bufferSubData.data = cbD->retainData(u.data);
+                cbD->commands.append(cmd);
+            }
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::Read) {
+            QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
+            if (bufD->m_usage.testFlag(QRhiBuffer::UniformBuffer)) {
+                u.result->data.resize(u.readSize);
+                memcpy(u.result->data.data(), bufD->ubuf.constData() + u.offset, size_t(u.readSize));
+                if (u.result->completed)
+                    u.result->completed();
+            } else {
+                QGles2CommandBuffer::Command cmd;
+                cmd.cmd = QGles2CommandBuffer::Command::GetBufferSubData;
+                cmd.args.getBufferSubData.result = u.result;
+                cmd.args.getBufferSubData.target = bufD->targetForDataOps;
+                cmd.args.getBufferSubData.buffer = bufD->buffer;
+                cmd.args.getBufferSubData.offset = u.offset;
+                cmd.args.getBufferSubData.size = u.readSize;
+                cbD->commands.append(cmd);
+            }
         }
     }
 
     for (const QRhiResourceUpdateBatchPrivate::TextureOp &u : ud->textureOps) {
         if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Upload) {
-            QGles2Texture *texD = QRHI_RES(QGles2Texture, u.upload.tex);
+            QGles2Texture *texD = QRHI_RES(QGles2Texture, u.dst);
             for (int layer = 0; layer < QRhi::MAX_LAYERS; ++layer) {
                 for (int level = 0; level < QRhi::MAX_LEVELS; ++level) {
-                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.upload.subresDesc[layer][level]))
+                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.subresDesc[layer][level]))
                         enqueueSubresUpload(texD, cbD, layer, level, subresDesc);
                 }
             }
             texD->specified = true;
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Copy) {
-            Q_ASSERT(u.copy.src && u.copy.dst);
-            QGles2Texture *srcD = QRHI_RES(QGles2Texture, u.copy.src);
-            QGles2Texture *dstD = QRHI_RES(QGles2Texture, u.copy.dst);
+            Q_ASSERT(u.src && u.dst);
+            QGles2Texture *srcD = QRHI_RES(QGles2Texture, u.src);
+            QGles2Texture *dstD = QRHI_RES(QGles2Texture, u.dst);
 
             trackedImageBarrier(cbD, srcD, QGles2Texture::AccessRead);
             trackedImageBarrier(cbD, dstD, QGles2Texture::AccessUpdate);
 
-            const QSize size = u.copy.desc.pixelSize().isEmpty() ? srcD->m_pixelSize : u.copy.desc.pixelSize();
+            const QSize mipSize = q->sizeForMipLevel(u.desc.sourceLevel(), srcD->m_pixelSize);
+            const QSize copySize = u.desc.pixelSize().isEmpty() ? mipSize : u.desc.pixelSize();
             // do not translate coordinates, even if sp is bottom-left from gl's pov
-            const QPoint sp = u.copy.desc.sourceTopLeft();
-            const QPoint dp = u.copy.desc.destinationTopLeft();
+            const QPoint sp = u.desc.sourceTopLeft();
+            const QPoint dp = u.desc.destinationTopLeft();
 
             const GLenum srcFaceTargetBase = srcD->m_flags.testFlag(QRhiTexture::CubeMap)
                     ? GL_TEXTURE_CUBE_MAP_POSITIVE_X : srcD->target;
@@ -1483,43 +1530,44 @@ void QRhiGles2::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
             QGles2CommandBuffer::Command cmd;
             cmd.cmd = QGles2CommandBuffer::Command::CopyTex;
 
-            cmd.args.copyTex.srcFaceTarget = srcFaceTargetBase + uint(u.copy.desc.sourceLayer());
+            cmd.args.copyTex.srcFaceTarget = srcFaceTargetBase + uint(u.desc.sourceLayer());
             cmd.args.copyTex.srcTexture = srcD->texture;
-            cmd.args.copyTex.srcLevel = u.copy.desc.sourceLevel();
+            cmd.args.copyTex.srcLevel = u.desc.sourceLevel();
             cmd.args.copyTex.srcX = sp.x();
             cmd.args.copyTex.srcY = sp.y();
 
             cmd.args.copyTex.dstTarget = dstD->target;
             cmd.args.copyTex.dstTexture = dstD->texture;
-            cmd.args.copyTex.dstFaceTarget = dstFaceTargetBase + uint(u.copy.desc.destinationLayer());
-            cmd.args.copyTex.dstLevel = u.copy.desc.destinationLevel();
+            cmd.args.copyTex.dstFaceTarget = dstFaceTargetBase + uint(u.desc.destinationLayer());
+            cmd.args.copyTex.dstLevel = u.desc.destinationLevel();
             cmd.args.copyTex.dstX = dp.x();
             cmd.args.copyTex.dstY = dp.y();
 
-            cmd.args.copyTex.w = size.width();
-            cmd.args.copyTex.h = size.height();
+            cmd.args.copyTex.w = copySize.width();
+            cmd.args.copyTex.h = copySize.height();
 
             cbD->commands.append(cmd);
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Read) {
             QGles2CommandBuffer::Command cmd;
             cmd.cmd = QGles2CommandBuffer::Command::ReadPixels;
-            cmd.args.readPixels.result = u.read.result;
-            QGles2Texture *texD = QRHI_RES(QGles2Texture, u.read.rb.texture());
+            cmd.args.readPixels.result = u.result;
+            QGles2Texture *texD = QRHI_RES(QGles2Texture, u.rb.texture());
             if (texD)
                 trackedImageBarrier(cbD, texD, QGles2Texture::AccessRead);
             cmd.args.readPixels.texture = texD ? texD->texture : 0;
             if (texD) {
-                cmd.args.readPixels.w = texD->m_pixelSize.width();
-                cmd.args.readPixels.h = texD->m_pixelSize.height();
+                const QSize readImageSize = q->sizeForMipLevel(u.rb.level(), texD->m_pixelSize);
+                cmd.args.readPixels.w = readImageSize.width();
+                cmd.args.readPixels.h = readImageSize.height();
                 cmd.args.readPixels.format = texD->m_format;
                 const GLenum faceTargetBase = texD->m_flags.testFlag(QRhiTexture::CubeMap)
                         ? GL_TEXTURE_CUBE_MAP_POSITIVE_X : texD->target;
-                cmd.args.readPixels.readTarget = faceTargetBase + uint(u.read.rb.layer());
-                cmd.args.readPixels.level = u.read.rb.level();
+                cmd.args.readPixels.readTarget = faceTargetBase + uint(u.rb.layer());
+                cmd.args.readPixels.level = u.rb.level();
             }
             cbD->commands.append(cmd);
-        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::MipGen) {
-            QGles2Texture *texD = QRHI_RES(QGles2Texture, u.mipgen.tex);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::GenMips) {
+            QGles2Texture *texD = QRHI_RES(QGles2Texture, u.dst);
             trackedImageBarrier(cbD, texD, QGles2Texture::AccessFramebuffer);
             QGles2CommandBuffer::Command cmd;
             cmd.cmd = QGles2CommandBuffer::Command::GenMip;
@@ -1539,6 +1587,8 @@ static inline GLenum toGlTopology(QRhiGraphicsPipeline::Topology t)
         return GL_TRIANGLES;
     case QRhiGraphicsPipeline::TriangleStrip:
         return GL_TRIANGLE_STRIP;
+    case QRhiGraphicsPipeline::TriangleFan:
+        return GL_TRIANGLE_FAN;
     case QRhiGraphicsPipeline::Lines:
         return GL_LINES;
     case QRhiGraphicsPipeline::LineStrip:
@@ -1873,6 +1923,10 @@ void QRhiGles2::executeCommandBuffer(QRhiCommandBuffer *cb)
             if (vao)
                 f->glBindVertexArray(0);
             break;
+        case QGles2CommandBuffer::Command::ResetFrame:
+            if (vao)
+                f->glBindVertexArray(vao);
+            break;
         case QGles2CommandBuffer::Command::Viewport:
             f->glViewport(GLint(cmd.args.viewport.x), GLint(cmd.args.viewport.y), GLsizei(cmd.args.viewport.w), GLsizei(cmd.args.viewport.h));
             f->glDepthRangef(cmd.args.viewport.d0, cmd.args.viewport.d1);
@@ -1898,21 +1952,22 @@ void QRhiGles2::executeCommandBuffer(QRhiCommandBuffer *cb)
         {
             QGles2GraphicsPipeline *psD = QRHI_RES(QGles2GraphicsPipeline, cmd.args.bindVertexBuffer.ps);
             if (psD) {
-                const QVector<QRhiVertexInputBinding> bindings = psD->m_vertexInputLayout.bindings();
-                const QVector<QRhiVertexInputAttribute> attributes = psD->m_vertexInputLayout.attributes();
-                for (const QRhiVertexInputAttribute &a : attributes) {
-                    const int bindingIdx = a.binding();
+                for (auto it = psD->m_vertexInputLayout.cbeginAttributes(), itEnd = psD->m_vertexInputLayout.cendAttributes();
+                     it != itEnd; ++it)
+                {
+                    const int bindingIdx = it->binding();
                     if (bindingIdx != cmd.args.bindVertexBuffer.binding)
                         continue;
 
                     // we do not support more than one vertex buffer
                     f->glBindBuffer(GL_ARRAY_BUFFER, cmd.args.bindVertexBuffer.buffer);
 
-                    const int stride = int(bindings[bindingIdx].stride());
+                    const QRhiVertexInputBinding *inputBinding = psD->m_vertexInputLayout.bindingAt(bindingIdx);
+                    const int stride = int(inputBinding->stride());
                     int size = 1;
                     GLenum type = GL_FLOAT;
                     bool normalize = false;
-                    switch (a.format()) {
+                    switch (it->format()) {
                     case QRhiVertexInputAttribute::Float4:
                         type = GL_FLOAT;
                         size = 4;
@@ -1948,16 +2003,13 @@ void QRhiGles2::executeCommandBuffer(QRhiCommandBuffer *cb)
                         break;
                     }
 
-                    const int locationIdx = a.location();
-                    quint32 ofs = a.offset() + cmd.args.bindVertexBuffer.offset;
+                    const int locationIdx = it->location();
+                    quint32 ofs = it->offset() + cmd.args.bindVertexBuffer.offset;
                     f->glVertexAttribPointer(GLuint(locationIdx), size, type, normalize, stride,
                                              reinterpret_cast<const GLvoid *>(quintptr(ofs)));
                     f->glEnableVertexAttribArray(GLuint(locationIdx));
-                    if (bindings[bindingIdx].classification() == QRhiVertexInputBinding::PerInstance
-                            && caps.instancing)
-                    {
-                        f->glVertexAttribDivisor(GLuint(locationIdx), GLuint(bindings[bindingIdx].instanceStepRate()));
-                    }
+                    if (inputBinding->classification() == QRhiVertexInputBinding::PerInstance && caps.instancing)
+                        f->glVertexAttribDivisor(GLuint(locationIdx), GLuint(inputBinding->instanceStepRate()));
                 }
             } else {
                 qWarning("No graphics pipeline active for setVertexInput; ignored");
@@ -2078,6 +2130,33 @@ void QRhiGles2::executeCommandBuffer(QRhiCommandBuffer *cb)
             f->glBufferSubData(cmd.args.bufferSubData.target, cmd.args.bufferSubData.offset, cmd.args.bufferSubData.size,
                                cmd.args.bufferSubData.data);
             break;
+        case QGles2CommandBuffer::Command::GetBufferSubData:
+        {
+            QRhiBufferReadbackResult *result = cmd.args.getBufferSubData.result;
+            f->glBindBuffer(cmd.args.getBufferSubData.target, cmd.args.getBufferSubData.buffer);
+            if (caps.gles) {
+                if (caps.properMapBuffer) {
+                    void *p = f->glMapBufferRange(cmd.args.getBufferSubData.target,
+                                                  cmd.args.getBufferSubData.offset,
+                                                  cmd.args.getBufferSubData.size,
+                                                  GL_MAP_READ_BIT);
+                    if (p) {
+                        result->data.resize(cmd.args.getBufferSubData.size);
+                        memcpy(result->data.data(), p, size_t(cmd.args.getBufferSubData.size));
+                        f->glUnmapBuffer(cmd.args.getBufferSubData.target);
+                    }
+                }
+            } else {
+                result->data.resize(cmd.args.getBufferSubData.size);
+                f->glGetBufferSubData(cmd.args.getBufferSubData.target,
+                                      cmd.args.getBufferSubData.offset,
+                                      cmd.args.getBufferSubData.size,
+                                      result->data.data());
+            }
+            if (result->completed)
+                result->completed();
+        }
+            break;
         case QGles2CommandBuffer::Command::CopyTex:
         {
             GLuint fbo;
@@ -2099,23 +2178,31 @@ void QRhiGles2::executeCommandBuffer(QRhiCommandBuffer *cb)
             QRhiReadbackResult *result = cmd.args.readPixels.result;
             GLuint tex = cmd.args.readPixels.texture;
             GLuint fbo = 0;
+            int mipLevel = 0;
             if (tex) {
                 result->pixelSize = QSize(cmd.args.readPixels.w, cmd.args.readPixels.h);
                 result->format = cmd.args.readPixels.format;
-                f->glGenFramebuffers(1, &fbo);
-                f->glBindFramebuffer(GL_FRAMEBUFFER, fbo);
-                f->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                                          cmd.args.readPixels.readTarget, cmd.args.readPixels.texture, cmd.args.readPixels.level);
+                mipLevel = cmd.args.readPixels.level;
+                if (mipLevel == 0 || caps.nonBaseLevelFramebufferTexture) {
+                    f->glGenFramebuffers(1, &fbo);
+                    f->glBindFramebuffer(GL_FRAMEBUFFER, fbo);
+                    f->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                                              cmd.args.readPixels.readTarget, cmd.args.readPixels.texture, mipLevel);
+                }
             } else {
                 result->pixelSize = currentSwapChain->pixelSize;
                 result->format = QRhiTexture::RGBA8;
                 // readPixels handles multisample resolving implicitly
             }
             result->data.resize(result->pixelSize.width() * result->pixelSize.height() * 4);
-            // With GLES (2.0?) GL_RGBA is the only mandated readback format, so stick with it.
-            f->glReadPixels(0, 0, result->pixelSize.width(), result->pixelSize.height(),
-                            GL_RGBA, GL_UNSIGNED_BYTE,
-                            result->data.data());
+            if (mipLevel == 0 || caps.nonBaseLevelFramebufferTexture) {
+                // With GLES (2.0?) GL_RGBA is the only mandated readback format, so stick with it.
+                f->glReadPixels(0, 0, result->pixelSize.width(), result->pixelSize.height(),
+                                GL_RGBA, GL_UNSIGNED_BYTE,
+                                result->data.data());
+            } else {
+                result->data.fill('\0');
+            }
             if (fbo) {
                 f->glBindFramebuffer(GL_FRAMEBUFFER, ctx->defaultFramebufferObject());
                 f->glDeleteFramebuffers(1, &fbo);
@@ -2510,10 +2597,12 @@ QGles2RenderTargetData *QRhiGles2::enqueueBindFramebuffer(QRhiRenderTarget *rt,
         fbCmd.args.bindFramebuffer.fbo = rtTex->framebuffer;
         fbCmd.args.bindFramebuffer.colorAttCount = rtD->colorAttCount;
 
-        const QVector<QRhiColorAttachment> colorAttachments = rtTex->m_desc.colorAttachments();
-        for (const QRhiColorAttachment &colorAttachment : colorAttachments) {
-            QGles2Texture *texD = QRHI_RES(QGles2Texture, colorAttachment.texture());
-            QGles2Texture *resolveTexD = QRHI_RES(QGles2Texture, colorAttachment.resolveTexture());
+        for (auto it = rtTex->m_desc.cbeginColorAttachments(), itEnd = rtTex->m_desc.cendColorAttachments();
+             it != itEnd; ++it)
+        {
+            const QRhiColorAttachment &colorAtt(*it);
+            QGles2Texture *texD = QRHI_RES(QGles2Texture, colorAtt.texture());
+            QGles2Texture *resolveTexD = QRHI_RES(QGles2Texture, colorAtt.resolveTexture());
             if (texD) {
                 trackedRegisterTexture(&passResTracker, texD,
                                        QRhiPassResourceTracker::TexColorOutput,
@@ -2602,10 +2691,9 @@ void QRhiGles2::endPass(QRhiCommandBuffer *cb, QRhiResourceUpdateBatch *resource
 
     if (cbD->currentTarget->resourceType() == QRhiResource::TextureRenderTarget) {
         QGles2TextureRenderTarget *rtTex = QRHI_RES(QGles2TextureRenderTarget, cbD->currentTarget);
-        const QVector<QRhiColorAttachment> colorAttachments = rtTex->m_desc.colorAttachments();
-        if (!colorAttachments.isEmpty()) {
+        if (rtTex->m_desc.cbeginColorAttachments() != rtTex->m_desc.cendColorAttachments()) {
             // handle only 1 color attachment and only (msaa) renderbuffer
-            const QRhiColorAttachment &colorAtt(colorAttachments[0]);
+            const QRhiColorAttachment &colorAtt(*rtTex->m_desc.cbeginColorAttachments());
             if (colorAtt.resolveTexture()) {
                 Q_ASSERT(colorAtt.renderBuffer());
                 QGles2RenderBuffer *rbD = QRHI_RES(QGles2RenderBuffer, colorAtt.renderBuffer());
@@ -3446,14 +3534,18 @@ bool QGles2TextureRenderTarget::build()
     if (framebuffer)
         release();
 
-    const QVector<QRhiColorAttachment> colorAttachments = m_desc.colorAttachments();
-    Q_ASSERT(!colorAttachments.isEmpty() || m_desc.depthTexture());
+    const bool hasColorAttachments = m_desc.cbeginColorAttachments() != m_desc.cendColorAttachments();
+    Q_ASSERT(hasColorAttachments || m_desc.depthTexture());
     Q_ASSERT(!m_desc.depthStencilBuffer() || !m_desc.depthTexture());
     const bool hasDepthStencil = m_desc.depthStencilBuffer() || m_desc.depthTexture();
 
-    if (colorAttachments.count() > rhiD->caps.maxDrawBuffers)
-        qWarning("QGles2TextureRenderTarget: Too many color attachments (%d, max is %d)",
-                 colorAttachments.count(), rhiD->caps.maxDrawBuffers);
+    if (hasColorAttachments) {
+        const int count = m_desc.cendColorAttachments() - m_desc.cbeginColorAttachments();
+        if (count > rhiD->caps.maxDrawBuffers) {
+            qWarning("QGles2TextureRenderTarget: Too many color attachments (%d, max is %d)",
+                     count, rhiD->caps.maxDrawBuffers);
+        }
+    }
     if (m_desc.depthTexture() && !rhiD->caps.depthTexture)
         qWarning("QGles2TextureRenderTarget: Depth texture is not supported and will be ignored");
 
@@ -3463,9 +3555,11 @@ bool QGles2TextureRenderTarget::build()
     rhiD->f->glGenFramebuffers(1, &framebuffer);
     rhiD->f->glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
 
-    d.colorAttCount = colorAttachments.count();
-    for (int i = 0; i < d.colorAttCount; ++i) {
-        const QRhiColorAttachment &colorAtt(colorAttachments[i]);
+    d.colorAttCount = 0;
+    int attIndex = 0;
+    for (auto it = m_desc.cbeginColorAttachments(), itEnd = m_desc.cendColorAttachments(); it != itEnd; ++it, ++attIndex) {
+        d.colorAttCount += 1;
+        const QRhiColorAttachment &colorAtt(*it);
         QRhiTexture *texture = colorAtt.texture();
         QRhiRenderBuffer *renderBuffer = colorAtt.renderBuffer();
         Q_ASSERT(texture || renderBuffer);
@@ -3473,16 +3567,16 @@ bool QGles2TextureRenderTarget::build()
             QGles2Texture *texD = QRHI_RES(QGles2Texture, texture);
             Q_ASSERT(texD->texture && texD->specified);
             const GLenum faceTargetBase = texD->flags().testFlag(QRhiTexture::CubeMap) ? GL_TEXTURE_CUBE_MAP_POSITIVE_X : texD->target;
-            rhiD->f->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + uint(i), faceTargetBase + uint(colorAtt.layer()),
+            rhiD->f->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + uint(attIndex), faceTargetBase + uint(colorAtt.layer()),
                                             texD->texture, colorAtt.level());
-            if (i == 0) {
+            if (attIndex == 0) {
                 d.pixelSize = texD->pixelSize();
                 d.sampleCount = 1;
             }
         } else if (renderBuffer) {
             QGles2RenderBuffer *rbD = QRHI_RES(QGles2RenderBuffer, renderBuffer);
-            rhiD->f->glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + uint(i), GL_RENDERBUFFER, rbD->renderbuffer);
-            if (i == 0) {
+            rhiD->f->glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + uint(attIndex), GL_RENDERBUFFER, rbD->renderbuffer);
+            if (attIndex == 0) {
                 d.pixelSize = rbD->pixelSize();
                 d.sampleCount = rbD->samples;
             }
@@ -3611,6 +3705,9 @@ bool QGles2GraphicsPipeline::build()
     if (!rhiD->ensureContext())
         return false;
 
+    if (!rhiD->sanityCheckGraphicsPipeline(this))
+        return false;
+
     drawMode = toGlTopology(m_topology);
 
     program = rhiD->f->glCreateProgram();
diff --git a/src/gui/rhi/qrhigles2_p_p.h b/src/gui/rhi/qrhigles2_p_p.h
index 646836a699..cc945876e6 100644
--- a/src/gui/rhi/qrhigles2_p_p.h
+++ b/src/gui/rhi/qrhigles2_p_p.h
@@ -300,6 +300,7 @@ struct QGles2CommandBuffer : public QRhiCommandBuffer
         enum Cmd {
             BeginFrame,
             EndFrame,
+            ResetFrame,
             Viewport,
             Scissor,
             BlendConstants,
@@ -312,8 +313,8 @@ struct QGles2CommandBuffer : public QRhiCommandBuffer
             BindShaderResources,
             BindFramebuffer,
             Clear,
-            BufferData,
             BufferSubData,
+            GetBufferSubData,
             CopyTex,
             ReadPixels,
             SubImage,
@@ -401,6 +402,13 @@ struct QGles2CommandBuffer : public QRhiCommandBuffer
                 int size;
                 const void *data; // must come from retainData()
             } bufferSubData;
+            struct {
+                QRhiBufferReadbackResult *result;
+                GLenum target;
+                GLuint buffer;
+                int offset;
+                int size;
+            } getBufferSubData;
             struct {
                 GLenum srcFaceTarget;
                 GLuint srcTexture;
@@ -744,7 +752,10 @@ public:
               rgba8Format(false),
               instancing(false),
               baseVertex(false),
-              compute(false)
+              compute(false),
+              textureCompareMode(false),
+              properMapBuffer(false),
+              nonBaseLevelFramebufferTexture(false)
         { }
         int ctxMajor;
         int ctxMinor;
@@ -775,6 +786,8 @@ public:
         uint baseVertex : 1;
         uint compute : 1;
         uint textureCompareMode : 1;
+        uint properMapBuffer : 1;
+        uint nonBaseLevelFramebufferTexture : 1;
     } caps;
     QGles2SwapChain *currentSwapChain = nullptr;
     QVector<GLint> supportedCompressedFormats;
diff --git a/src/gui/rhi/qrhimetal.mm b/src/gui/rhi/qrhimetal.mm
index 4dc12f0691..5f14d917b8 100644
--- a/src/gui/rhi/qrhimetal.mm
+++ b/src/gui/rhi/qrhimetal.mm
@@ -205,7 +205,7 @@ struct QRhiMetalData
         QMetalCommandBuffer cbWrapper;
     } ofr;
 
-    struct ActiveReadback {
+    struct TextureReadback {
         int activeFrameSlot = -1;
         QRhiReadbackDescription desc;
         QRhiReadbackResult *result;
@@ -214,7 +214,7 @@ struct QRhiMetalData
         QSize pixelSize;
         QRhiTexture::Format format;
     };
-    QVector<ActiveReadback> activeReadbacks;
+    QVector<TextureReadback> activeTextureReadbacks;
 
     API_AVAILABLE(macos(10.13), ios(11.0)) MTLCaptureManager *captureMgr;
     API_AVAILABLE(macos(10.13), ios(11.0)) id<MTLCaptureScope> captureScope = nil;
@@ -225,14 +225,14 @@ struct QRhiMetalData
 };
 
 Q_DECLARE_TYPEINFO(QRhiMetalData::DeferredReleaseEntry, Q_MOVABLE_TYPE);
-Q_DECLARE_TYPEINFO(QRhiMetalData::ActiveReadback, Q_MOVABLE_TYPE);
+Q_DECLARE_TYPEINFO(QRhiMetalData::TextureReadback, Q_MOVABLE_TYPE);
 
 struct QMetalBufferData
 {
     bool managed;
     bool slotted;
     id<MTLBuffer> buf[QMTL_FRAMES_IN_FLIGHT];
-    QVector<QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate> pendingUpdates[QMTL_FRAMES_IN_FLIGHT];
+    QVarLengthArray<QRhiResourceUpdateBatchPrivate::BufferOp, 16> pendingUpdates[QMTL_FRAMES_IN_FLIGHT];
 };
 
 struct QMetalRenderBufferData
@@ -367,6 +367,11 @@ bool QRhiMetal::create(QRhi::Flags flags)
     else
         d->dev = MTLCreateSystemDefaultDevice();
 
+    if (!d->dev) {
+        qWarning("No MTLDevice");
+        return false;
+    }
+
     qCDebug(QRHI_LOG_INFO, "Metal device: %s", qPrintable(QString::fromNSString([d->dev name])));
 
     if (importedCmdQueue)
@@ -550,6 +555,12 @@ bool QRhiMetal::isFeatureSupported(QRhi::Feature feature) const
         return true;
     case QRhi::BaseInstance:
         return true;
+    case QRhi::TriangleFanTopology:
+        return false;
+    case QRhi::ReadBackNonUniformBuffer:
+        return true;
+    case QRhi::ReadBackNonBaseMipLevel:
+        return true;
     default:
         Q_UNREACHABLE();
         return false;
@@ -1539,21 +1550,33 @@ void QRhiMetal::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
     QRhiResourceUpdateBatchPrivate *ud = QRhiResourceUpdateBatchPrivate::get(resourceUpdates);
     QRhiProfilerPrivate *rhiP = profilerPrivateOrNull();
 
-    for (const QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate &u : ud->dynamicBufferUpdates) {
-        QMetalBuffer *bufD = QRHI_RES(QMetalBuffer, u.buf);
-        Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
-        for (int i = 0; i < QMTL_FRAMES_IN_FLIGHT; ++i)
-            bufD->d->pendingUpdates[i].append(u);
-    }
-
-    // Due to the Metal API the handling of static and dynamic buffers is
-    // basically the same. So go through the same pendingUpdates machinery.
-    for (const QRhiResourceUpdateBatchPrivate::StaticBufferUpload &u : ud->staticBufferUploads) {
-        QMetalBuffer *bufD = QRHI_RES(QMetalBuffer, u.buf);
-        Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
-        Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
-        for (int i = 0, ie = bufD->d->slotted ? QMTL_FRAMES_IN_FLIGHT : 1; i != ie; ++i)
-            bufD->d->pendingUpdates[i].append({ u.buf, u.offset, u.data.size(), u.data.constData() });
+    for (const QRhiResourceUpdateBatchPrivate::BufferOp &u : ud->bufferOps) {
+        if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::DynamicUpdate) {
+            QMetalBuffer *bufD = QRHI_RES(QMetalBuffer, u.buf);
+            Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
+            for (int i = 0; i < QMTL_FRAMES_IN_FLIGHT; ++i)
+                bufD->d->pendingUpdates[i].append(u);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::StaticUpload) {
+            // Due to the Metal API the handling of static and dynamic buffers is
+            // basically the same. So go through the same pendingUpdates machinery.
+            QMetalBuffer *bufD = QRHI_RES(QMetalBuffer, u.buf);
+            Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
+            Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
+            for (int i = 0, ie = bufD->d->slotted ? QMTL_FRAMES_IN_FLIGHT : 1; i != ie; ++i)
+                bufD->d->pendingUpdates[i].append(
+                            QRhiResourceUpdateBatchPrivate::BufferOp::dynamicUpdate(u.buf, u.offset, u.data.size(), u.data.constData()));
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::Read) {
+            QMetalBuffer *bufD = QRHI_RES(QMetalBuffer, u.buf);
+            executeBufferHostWritesForCurrentFrame(bufD);
+            const int idx = bufD->d->slotted ? currentFrameSlot : 0;
+            char *p = reinterpret_cast<char *>([bufD->d->buf[idx] contents]);
+            if (p) {
+                u.result->data.resize(u.readSize);
+                memcpy(u.result->data.data(), p + u.offset, size_t(u.readSize));
+            }
+            if (u.result->completed)
+                u.result->completed();
+        }
     }
 
     id<MTLBlitCommandEncoder> blitEnc = nil;
@@ -1567,11 +1590,11 @@ void QRhiMetal::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
 
     for (const QRhiResourceUpdateBatchPrivate::TextureOp &u : ud->textureOps) {
         if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Upload) {
-            QMetalTexture *utexD = QRHI_RES(QMetalTexture, u.upload.tex);
+            QMetalTexture *utexD = QRHI_RES(QMetalTexture, u.dst);
             qsizetype stagingSize = 0;
             for (int layer = 0; layer < QRhi::MAX_LAYERS; ++layer) {
                 for (int level = 0; level < QRhi::MAX_LEVELS; ++level) {
-                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.upload.subresDesc[layer][level]))
+                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.subresDesc[layer][level]))
                         stagingSize += subresUploadByteSize(subresDesc);
                 }
             }
@@ -1586,7 +1609,7 @@ void QRhiMetal::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
             qsizetype curOfs = 0;
             for (int layer = 0; layer < QRhi::MAX_LAYERS; ++layer) {
                 for (int level = 0; level < QRhi::MAX_LEVELS; ++level) {
-                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.upload.subresDesc[layer][level]))
+                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.subresDesc[layer][level]))
                         enqueueSubresUpload(utexD, mp, blitEnc, layer, level, subresDesc, &curOfs);
                 }
             }
@@ -1601,32 +1624,33 @@ void QRhiMetal::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
             d->releaseQueue.append(e);
             QRHI_PROF_F(releaseTextureStagingArea(utexD, currentFrameSlot));
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Copy) {
-            Q_ASSERT(u.copy.src && u.copy.dst);
-            QMetalTexture *srcD = QRHI_RES(QMetalTexture, u.copy.src);
-            QMetalTexture *dstD = QRHI_RES(QMetalTexture, u.copy.dst);
-            const QPoint dp = u.copy.desc.destinationTopLeft();
-            const QSize size = u.copy.desc.pixelSize().isEmpty() ? srcD->m_pixelSize : u.copy.desc.pixelSize();
-            const QPoint sp = u.copy.desc.sourceTopLeft();
+            Q_ASSERT(u.src && u.dst);
+            QMetalTexture *srcD = QRHI_RES(QMetalTexture, u.src);
+            QMetalTexture *dstD = QRHI_RES(QMetalTexture, u.dst);
+            const QPoint dp = u.desc.destinationTopLeft();
+            const QSize mipSize = q->sizeForMipLevel(u.desc.sourceLevel(), srcD->m_pixelSize);
+            const QSize copySize = u.desc.pixelSize().isEmpty() ? mipSize : u.desc.pixelSize();
+            const QPoint sp = u.desc.sourceTopLeft();
 
             ensureBlit();
             [blitEnc copyFromTexture: srcD->d->tex
-                                      sourceSlice: NSUInteger(u.copy.desc.sourceLayer())
-                                      sourceLevel: NSUInteger(u.copy.desc.sourceLevel())
+                                      sourceSlice: NSUInteger(u.desc.sourceLayer())
+                                      sourceLevel: NSUInteger(u.desc.sourceLevel())
                                       sourceOrigin: MTLOriginMake(NSUInteger(sp.x()), NSUInteger(sp.y()), 0)
-                                      sourceSize: MTLSizeMake(NSUInteger(size.width()), NSUInteger(size.height()), 1)
+                                      sourceSize: MTLSizeMake(NSUInteger(copySize.width()), NSUInteger(copySize.height()), 1)
                                       toTexture: dstD->d->tex
-                                      destinationSlice: NSUInteger(u.copy.desc.destinationLayer())
-                                      destinationLevel: NSUInteger(u.copy.desc.destinationLevel())
+                                      destinationSlice: NSUInteger(u.desc.destinationLayer())
+                                      destinationLevel: NSUInteger(u.desc.destinationLevel())
                                       destinationOrigin: MTLOriginMake(NSUInteger(dp.x()), NSUInteger(dp.y()), 0)];
 
             srcD->lastActiveFrameSlot = dstD->lastActiveFrameSlot = currentFrameSlot;
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Read) {
-            QRhiMetalData::ActiveReadback aRb;
-            aRb.activeFrameSlot = currentFrameSlot;
-            aRb.desc = u.read.rb;
-            aRb.result = u.read.result;
+            QRhiMetalData::TextureReadback readback;
+            readback.activeFrameSlot = currentFrameSlot;
+            readback.desc = u.rb;
+            readback.result = u.result;
 
-            QMetalTexture *texD = QRHI_RES(QMetalTexture, u.read.rb.texture());
+            QMetalTexture *texD = QRHI_RES(QMetalTexture, u.rb.texture());
             QMetalSwapChain *swapChainD = nullptr;
             id<MTLTexture> src;
             QSize srcSize;
@@ -1635,17 +1659,16 @@ void QRhiMetal::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
                     qWarning("Multisample texture cannot be read back");
                     continue;
                 }
-                aRb.pixelSize = u.read.rb.level() > 0 ? q->sizeForMipLevel(u.read.rb.level(), texD->m_pixelSize)
-                                                      : texD->m_pixelSize;
-                aRb.format = texD->m_format;
+                readback.pixelSize = q->sizeForMipLevel(u.rb.level(), texD->m_pixelSize);
+                readback.format = texD->m_format;
                 src = texD->d->tex;
-                srcSize = texD->m_pixelSize;
+                srcSize = readback.pixelSize;
                 texD->lastActiveFrameSlot = currentFrameSlot;
             } else {
                 Q_ASSERT(currentSwapChain);
                 swapChainD = QRHI_RES(QMetalSwapChain, currentSwapChain);
-                aRb.pixelSize = swapChainD->pixelSize;
-                aRb.format = swapChainD->d->rhiColorFormat;
+                readback.pixelSize = swapChainD->pixelSize;
+                readback.format = swapChainD->d->rhiColorFormat;
                 // Multisample swapchains need nothing special since resolving
                 // happens when ending a renderpass.
                 const QMetalRenderTargetData::ColorAtt &colorAtt(swapChainD->rtWrapper.d->fb.colorAtt[0]);
@@ -1654,28 +1677,28 @@ void QRhiMetal::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
             }
 
             quint32 bpl = 0;
-            textureFormatInfo(aRb.format, aRb.pixelSize, &bpl, &aRb.bufSize);
-            aRb.buf = [d->dev newBufferWithLength: aRb.bufSize options: MTLResourceStorageModeShared];
+            textureFormatInfo(readback.format, readback.pixelSize, &bpl, &readback.bufSize);
+            readback.buf = [d->dev newBufferWithLength: readback.bufSize options: MTLResourceStorageModeShared];
 
-            QRHI_PROF_F(newReadbackBuffer(qint64(qintptr(aRb.buf)),
+            QRHI_PROF_F(newReadbackBuffer(qint64(qintptr(readback.buf)),
                                           texD ? static_cast<QRhiResource *>(texD) : static_cast<QRhiResource *>(swapChainD),
-                                          aRb.bufSize));
+                                          readback.bufSize));
 
             ensureBlit();
             [blitEnc copyFromTexture: src
-                                      sourceSlice: NSUInteger(u.read.rb.layer())
-                                      sourceLevel: NSUInteger(u.read.rb.level())
+                                      sourceSlice: NSUInteger(u.rb.layer())
+                                      sourceLevel: NSUInteger(u.rb.level())
                                       sourceOrigin: MTLOriginMake(0, 0, 0)
                                       sourceSize: MTLSizeMake(NSUInteger(srcSize.width()), NSUInteger(srcSize.height()), 1)
-                                      toBuffer: aRb.buf
+                                      toBuffer: readback.buf
                                       destinationOffset: 0
                                       destinationBytesPerRow: bpl
                                       destinationBytesPerImage: 0
                                       options: MTLBlitOptionNone];
 
-            d->activeReadbacks.append(aRb);
-        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::MipGen) {
-            QMetalTexture *utexD = QRHI_RES(QMetalTexture, u.mipgen.tex);
+            d->activeTextureReadbacks.append(readback);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::GenMips) {
+            QMetalTexture *utexD = QRHI_RES(QMetalTexture, u.dst);
             ensureBlit();
             [blitEnc generateMipmapsForTexture: utexD->d->tex];
             utexD->lastActiveFrameSlot = currentFrameSlot;
@@ -1695,14 +1718,13 @@ void QRhiMetal::enqueueResourceUpdates(QRhiCommandBuffer *cb, QRhiResourceUpdate
 void QRhiMetal::executeBufferHostWritesForCurrentFrame(QMetalBuffer *bufD)
 {
     const int idx = bufD->d->slotted ? currentFrameSlot : 0;
-    QVector<QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate> &updates(bufD->d->pendingUpdates[idx]);
-    if (updates.isEmpty())
+    if (bufD->d->pendingUpdates[idx].isEmpty())
         return;
 
     void *p = [bufD->d->buf[idx] contents];
     int changeBegin = -1;
     int changeEnd = -1;
-    for (const QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate &u : updates) {
+    for (const QRhiResourceUpdateBatchPrivate::BufferOp &u : qAsConst(bufD->d->pendingUpdates[idx])) {
         Q_ASSERT(bufD == QRHI_RES(QMetalBuffer, u.buf));
         memcpy(static_cast<char *>(p) + u.offset, u.data.constData(), size_t(u.data.size()));
         if (changeBegin == -1 || u.offset < changeBegin)
@@ -1713,7 +1735,7 @@ void QRhiMetal::executeBufferHostWritesForCurrentFrame(QMetalBuffer *bufD)
     if (changeBegin >= 0 && bufD->d->managed)
         [bufD->d->buf[idx] didModifyRange: NSMakeRange(NSUInteger(changeBegin), NSUInteger(changeEnd - changeBegin))];
 
-    updates.clear();
+    bufD->d->pendingUpdates[idx].clear();
 }
 
 void QRhiMetal::resourceUpdate(QRhiCommandBuffer *cb, QRhiResourceUpdateBatch *resourceUpdates)
@@ -1775,14 +1797,15 @@ void QRhiMetal::beginPass(QRhiCommandBuffer *cb,
             cbD->d->currentPassRpDesc.depthAttachment.loadAction = MTLLoadActionLoad;
             cbD->d->currentPassRpDesc.stencilAttachment.loadAction = MTLLoadActionLoad;
         }
-        const QVector<QRhiColorAttachment> colorAttachments = rtTex->m_desc.colorAttachments();
-        for (const QRhiColorAttachment &colorAttachment : colorAttachments) {
-            if (colorAttachment.texture())
-                QRHI_RES(QMetalTexture, colorAttachment.texture())->lastActiveFrameSlot = currentFrameSlot;
-            else if (colorAttachment.renderBuffer())
-                QRHI_RES(QMetalRenderBuffer, colorAttachment.renderBuffer())->lastActiveFrameSlot = currentFrameSlot;
-            if (colorAttachment.resolveTexture())
-                QRHI_RES(QMetalTexture, colorAttachment.resolveTexture())->lastActiveFrameSlot = currentFrameSlot;
+        for (auto it = rtTex->m_desc.cbeginColorAttachments(), itEnd = rtTex->m_desc.cendColorAttachments();
+             it != itEnd; ++it)
+        {
+            if (it->texture())
+                QRHI_RES(QMetalTexture, it->texture())->lastActiveFrameSlot = currentFrameSlot;
+            else if (it->renderBuffer())
+                QRHI_RES(QMetalRenderBuffer, it->renderBuffer())->lastActiveFrameSlot = currentFrameSlot;
+            if (it->resolveTexture())
+                QRHI_RES(QMetalTexture, it->resolveTexture())->lastActiveFrameSlot = currentFrameSlot;
         }
         if (rtTex->m_desc.depthStencilBuffer())
             QRHI_RES(QMetalRenderBuffer, rtTex->m_desc.depthStencilBuffer())->lastActiveFrameSlot = currentFrameSlot;
@@ -1948,22 +1971,22 @@ void QRhiMetal::finishActiveReadbacks(bool forced)
     QVarLengthArray<std::function<void()>, 4> completedCallbacks;
     QRhiProfilerPrivate *rhiP = profilerPrivateOrNull();
 
-    for (int i = d->activeReadbacks.count() - 1; i >= 0; --i) {
-        const QRhiMetalData::ActiveReadback &aRb(d->activeReadbacks[i]);
-        if (forced || currentFrameSlot == aRb.activeFrameSlot || aRb.activeFrameSlot < 0) {
-            aRb.result->format = aRb.format;
-            aRb.result->pixelSize = aRb.pixelSize;
-            aRb.result->data.resize(int(aRb.bufSize));
-            void *p = [aRb.buf contents];
-            memcpy(aRb.result->data.data(), p, aRb.bufSize);
-            [aRb.buf release];
+    for (int i = d->activeTextureReadbacks.count() - 1; i >= 0; --i) {
+        const QRhiMetalData::TextureReadback &readback(d->activeTextureReadbacks[i]);
+        if (forced || currentFrameSlot == readback.activeFrameSlot || readback.activeFrameSlot < 0) {
+            readback.result->format = readback.format;
+            readback.result->pixelSize = readback.pixelSize;
+            readback.result->data.resize(int(readback.bufSize));
+            void *p = [readback.buf contents];
+            memcpy(readback.result->data.data(), p, readback.bufSize);
+            [readback.buf release];
 
-            QRHI_PROF_F(releaseReadbackBuffer(qint64(qintptr(aRb.buf))));
+            QRHI_PROF_F(releaseReadbackBuffer(qint64(qintptr(readback.buf))));
 
-            if (aRb.result->completed)
-                completedCallbacks.append(aRb.result->completed);
+            if (readback.result->completed)
+                completedCallbacks.append(readback.result->completed);
 
-            d->activeReadbacks.removeAt(i);
+            d->activeTextureReadbacks.removeAt(i);
         }
     }
 
@@ -2039,7 +2062,6 @@ bool QMetalBuffer::build()
     for (int i = 0; i < QMTL_FRAMES_IN_FLIGHT; ++i) {
         if (i == 0 || d->slotted) {
             d->buf[i] = [rhiD->d->dev newBufferWithLength: roundedSize options: opts];
-            d->pendingUpdates[i].reserve(16);
             if (!m_objectName.isEmpty()) {
                 if (!d->slotted) {
                     d->buf[i].label = [NSString stringWithUTF8String: m_objectName.constData()];
@@ -2647,14 +2669,15 @@ void QMetalTextureRenderTarget::release()
 
 QRhiRenderPassDescriptor *QMetalTextureRenderTarget::newCompatibleRenderPassDescriptor()
 {
-    const QVector<QRhiColorAttachment> colorAttachments = m_desc.colorAttachments();
+    const int colorAttachmentCount = m_desc.cendColorAttachments() - m_desc.cbeginColorAttachments();
     QMetalRenderPassDescriptor *rpD = new QMetalRenderPassDescriptor(m_rhi);
-    rpD->colorAttachmentCount = colorAttachments.count();
+    rpD->colorAttachmentCount = colorAttachmentCount;
     rpD->hasDepthStencil = m_desc.depthStencilBuffer() || m_desc.depthTexture();
 
-    for (int i = 0, ie = colorAttachments.count(); i != ie; ++i) {
-        QMetalTexture *texD = QRHI_RES(QMetalTexture, colorAttachments[i].texture());
-        QMetalRenderBuffer *rbD = QRHI_RES(QMetalRenderBuffer, colorAttachments[i].renderBuffer());
+    for (int i = 0; i < colorAttachmentCount; ++i) {
+        const QRhiColorAttachment *colorAtt = m_desc.colorAttachmentAt(i);
+        QMetalTexture *texD = QRHI_RES(QMetalTexture, colorAtt->texture());
+        QMetalRenderBuffer *rbD = QRHI_RES(QMetalRenderBuffer, colorAtt->renderBuffer());
         rpD->colorFormat[i] = int(texD ? texD->d->format : rbD->d->format);
     }
 
@@ -2668,39 +2691,41 @@ QRhiRenderPassDescriptor *QMetalTextureRenderTarget::newCompatibleRenderPassDesc
 
 bool QMetalTextureRenderTarget::build()
 {
-    const QVector<QRhiColorAttachment> colorAttachments = m_desc.colorAttachments();
-    Q_ASSERT(!colorAttachments.isEmpty() || m_desc.depthTexture());
+    const bool hasColorAttachments = m_desc.cbeginColorAttachments() != m_desc.cendColorAttachments();
+    Q_ASSERT(hasColorAttachments || m_desc.depthTexture());
     Q_ASSERT(!m_desc.depthStencilBuffer() || !m_desc.depthTexture());
     const bool hasDepthStencil = m_desc.depthStencilBuffer() || m_desc.depthTexture();
 
-    d->colorAttCount = colorAttachments.count();
-    for (int i = 0; i < d->colorAttCount; ++i) {
-        QMetalTexture *texD = QRHI_RES(QMetalTexture, colorAttachments[i].texture());
-        QMetalRenderBuffer *rbD = QRHI_RES(QMetalRenderBuffer, colorAttachments[i].renderBuffer());
+    d->colorAttCount = 0;
+    int attIndex = 0;
+    for (auto it = m_desc.cbeginColorAttachments(), itEnd = m_desc.cendColorAttachments(); it != itEnd; ++it, ++attIndex) {
+        d->colorAttCount += 1;
+        QMetalTexture *texD = QRHI_RES(QMetalTexture, it->texture());
+        QMetalRenderBuffer *rbD = QRHI_RES(QMetalRenderBuffer, it->renderBuffer());
         Q_ASSERT(texD || rbD);
         id<MTLTexture> dst = nil;
         if (texD) {
             dst = texD->d->tex;
-            if (i == 0) {
+            if (attIndex == 0) {
                 d->pixelSize = texD->pixelSize();
                 d->sampleCount = texD->samples;
             }
         } else if (rbD) {
             dst = rbD->d->tex;
-            if (i == 0) {
+            if (attIndex == 0) {
                 d->pixelSize = rbD->pixelSize();
                 d->sampleCount = rbD->samples;
             }
         }
         QMetalRenderTargetData::ColorAtt colorAtt;
         colorAtt.tex = dst;
-        colorAtt.layer = colorAttachments[i].layer();
-        colorAtt.level = colorAttachments[i].level();
-        QMetalTexture *resTexD = QRHI_RES(QMetalTexture, colorAttachments[i].resolveTexture());
+        colorAtt.layer = it->layer();
+        colorAtt.level = it->level();
+        QMetalTexture *resTexD = QRHI_RES(QMetalTexture, it->resolveTexture());
         colorAtt.resolveTex = resTexD ? resTexD->d->tex : nil;
-        colorAtt.resolveLayer = colorAttachments[i].resolveLayer();
-        colorAtt.resolveLevel = colorAttachments[i].resolveLevel();
-        d->fb.colorAtt[i] = colorAtt;
+        colorAtt.resolveLayer = it->resolveLayer();
+        colorAtt.resolveLevel = it->resolveLevel();
+        d->fb.colorAtt[attIndex] = colorAtt;
     }
     d->dpr = 1;
 
@@ -3114,27 +3139,31 @@ bool QMetalGraphicsPipeline::build()
         release();
 
     QRHI_RES_RHI(QRhiMetal);
+    if (!rhiD->sanityCheckGraphicsPipeline(this))
+        return false;
 
     // same binding space for vertex and constant buffers - work it around
     const int firstVertexBinding = QRHI_RES(QMetalShaderResourceBindings, m_shaderResourceBindings)->maxBinding + 1;
 
     MTLVertexDescriptor *inputLayout = [MTLVertexDescriptor vertexDescriptor];
-    const QVector<QRhiVertexInputAttribute> attributes = m_vertexInputLayout.attributes();
-    for (const QRhiVertexInputAttribute &attribute : attributes) {
-        const uint loc = uint(attribute.location());
-        inputLayout.attributes[loc].format = toMetalAttributeFormat(attribute.format());
-        inputLayout.attributes[loc].offset = NSUInteger(attribute.offset());
-        inputLayout.attributes[loc].bufferIndex = NSUInteger(firstVertexBinding + attribute.binding());
-    }
-    const QVector<QRhiVertexInputBinding> bindings = m_vertexInputLayout.bindings();
-    for (int i = 0, ie = bindings.count(); i != ie; ++i) {
-        const QRhiVertexInputBinding &binding(bindings[i]);
-        const uint layoutIdx = uint(firstVertexBinding + i);
+    for (auto it = m_vertexInputLayout.cbeginAttributes(), itEnd = m_vertexInputLayout.cendAttributes();
+         it != itEnd; ++it)
+    {
+        const uint loc = uint(it->location());
+        inputLayout.attributes[loc].format = toMetalAttributeFormat(it->format());
+        inputLayout.attributes[loc].offset = NSUInteger(it->offset());
+        inputLayout.attributes[loc].bufferIndex = NSUInteger(firstVertexBinding + it->binding());
+    }
+    int bindingIndex = 0;
+    for (auto it = m_vertexInputLayout.cbeginBindings(), itEnd = m_vertexInputLayout.cendBindings();
+         it != itEnd; ++it, ++bindingIndex)
+    {
+        const uint layoutIdx = uint(firstVertexBinding + bindingIndex);
         inputLayout.layouts[layoutIdx].stepFunction =
-                binding.classification() == QRhiVertexInputBinding::PerInstance
+                it->classification() == QRhiVertexInputBinding::PerInstance
                 ? MTLVertexStepFunctionPerInstance : MTLVertexStepFunctionPerVertex;
-        inputLayout.layouts[layoutIdx].stepRate = NSUInteger(binding.instanceStepRate());
-        inputLayout.layouts[layoutIdx].stride = binding.stride();
+        inputLayout.layouts[layoutIdx].stepRate = NSUInteger(it->instanceStepRate());
+        inputLayout.layouts[layoutIdx].stride = it->stride();
     }
 
     MTLRenderPipelineDescriptor *rpDesc = [[MTLRenderPipelineDescriptor alloc] init];
diff --git a/src/gui/rhi/qrhinull.cpp b/src/gui/rhi/qrhinull.cpp
index 60d620813b..fe606f971f 100644
--- a/src/gui/rhi/qrhinull.cpp
+++ b/src/gui/rhi/qrhinull.cpp
@@ -36,6 +36,7 @@
 
 #include "qrhinull_p_p.h"
 #include <qmath.h>
+#include <QPainter>
 
 QT_BEGIN_NAMESPACE
 
@@ -385,27 +386,125 @@ QRhi::FrameOpResult QRhiNull::finish()
     return QRhi::FrameOpSuccess;
 }
 
+void QRhiNull::simulateTextureUpload(const QRhiResourceUpdateBatchPrivate::TextureOp &u)
+{
+    QNullTexture *texD = QRHI_RES(QNullTexture, u.dst);
+    for (int layer = 0; layer < QRhi::MAX_LAYERS; ++layer) {
+        for (int level = 0; level < QRhi::MAX_LEVELS; ++level) {
+            for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.subresDesc[layer][level])) {
+                if (!subresDesc.image().isNull()) {
+                    const QImage src = subresDesc.image();
+                    QPainter painter(&texD->image[layer][level]);
+                    const QSize srcSize = subresDesc.sourceSize().isEmpty()
+                            ? src.size() : subresDesc.sourceSize();
+                    painter.setCompositionMode(QPainter::CompositionMode_Source);
+                    painter.drawImage(subresDesc.destinationTopLeft(), src,
+                                      QRect(subresDesc.sourceTopLeft(), srcSize));
+                } else if (!subresDesc.data().isEmpty()) {
+                    const QSize subresSize = q->sizeForMipLevel(level, texD->pixelSize());
+                    int w = subresSize.width();
+                    int h = subresSize.height();
+                    if (!subresDesc.sourceSize().isEmpty()) {
+                        w = subresDesc.sourceSize().width();
+                        h = subresDesc.sourceSize().height();
+                    }
+                    // sourceTopLeft is not supported on this path as per QRhi docs
+                    const char *src = subresDesc.data().constData();
+                    const int srcBpl = w * 4;
+                    const QPoint dstOffset = subresDesc.destinationTopLeft();
+                    uchar *dst = texD->image[layer][level].bits();
+                    const int dstBpl = texD->image[layer][level].bytesPerLine();
+                    for (int y = 0; y < h; ++y) {
+                        memcpy(dst + dstOffset.x() * 4 + (y + dstOffset.y()) * dstBpl,
+                               src + y * srcBpl,
+                               size_t(srcBpl));
+                    }
+                }
+            }
+        }
+    }
+}
+
+void QRhiNull::simulateTextureCopy(const QRhiResourceUpdateBatchPrivate::TextureOp &u)
+{
+    QNullTexture *srcD = QRHI_RES(QNullTexture, u.src);
+    QNullTexture *dstD = QRHI_RES(QNullTexture, u.dst);
+    const QImage &srcImage(srcD->image[u.desc.sourceLayer()][u.desc.sourceLevel()]);
+    QImage &dstImage(dstD->image[u.desc.destinationLayer()][u.desc.destinationLevel()]);
+    const QPoint dstPos = u.desc.destinationTopLeft();
+    const QSize size = u.desc.pixelSize().isEmpty() ? srcD->pixelSize() : u.desc.pixelSize();
+    const QPoint srcPos = u.desc.sourceTopLeft();
+
+    QPainter painter(&dstImage);
+    painter.setCompositionMode(QPainter::CompositionMode_Source);
+    painter.drawImage(QRect(dstPos, size), srcImage, QRect(srcPos, size));
+}
+
+void QRhiNull::simulateTextureGenMips(const QRhiResourceUpdateBatchPrivate::TextureOp &u)
+{
+    QNullTexture *texD = QRHI_RES(QNullTexture, u.dst);
+    const QSize baseSize = texD->pixelSize();
+    const int levelCount = q->mipLevelsForSize(baseSize);
+    for (int level = 1; level < levelCount; ++level)
+        texD->image[0][level] = texD->image[0][0].scaled(q->sizeForMipLevel(level, baseSize));
+}
+
 void QRhiNull::resourceUpdate(QRhiCommandBuffer *cb, QRhiResourceUpdateBatch *resourceUpdates)
 {
     Q_UNUSED(cb);
     QRhiResourceUpdateBatchPrivate *ud = QRhiResourceUpdateBatchPrivate::get(resourceUpdates);
+    for (const QRhiResourceUpdateBatchPrivate::BufferOp &u : ud->bufferOps) {
+        if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::DynamicUpdate
+                || u.type == QRhiResourceUpdateBatchPrivate::BufferOp::StaticUpload)
+        {
+            QNullBuffer *bufD = QRHI_RES(QNullBuffer, u.buf);
+            memcpy(bufD->data.data() + u.offset, u.data.constData(), size_t(u.data.size()));
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::Read) {
+            QRhiBufferReadbackResult *result = u.result;
+            result->data.resize(u.readSize);
+            QNullBuffer *bufD = QRHI_RES(QNullBuffer, u.buf);
+            memcpy(result->data.data(), bufD->data.constData() + u.offset, size_t(u.readSize));
+            if (result->completed)
+                result->completed();
+        }
+    }
     for (const QRhiResourceUpdateBatchPrivate::TextureOp &u : ud->textureOps) {
-        if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Read) {
-            QRhiReadbackResult *result = u.read.result;
-            QRhiTexture *tex = u.read.rb.texture();
-            if (tex) {
-                result->format = tex->format();
-                result->pixelSize = q->sizeForMipLevel(u.read.rb.level(), tex->pixelSize());
+        if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Upload) {
+            if (u.dst->format() == QRhiTexture::RGBA8)
+                simulateTextureUpload(u);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Copy) {
+            if (u.src->format() == QRhiTexture::RGBA8 && u.dst->format() == QRhiTexture::RGBA8)
+                simulateTextureCopy(u);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Read) {
+            QRhiReadbackResult *result = u.result;
+            QNullTexture *texD = QRHI_RES(QNullTexture, u.rb.texture());
+            if (texD) {
+                result->format = texD->format();
+                result->pixelSize = q->sizeForMipLevel(u.rb.level(), texD->pixelSize());
             } else {
                 Q_ASSERT(currentSwapChain);
                 result->format = QRhiTexture::RGBA8;
                 result->pixelSize = currentSwapChain->currentPixelSize();
             }
+            quint32 bytesPerLine = 0;
             quint32 byteSize = 0;
-            textureFormatInfo(result->format, result->pixelSize, nullptr, &byteSize);
-            result->data.fill(0, byteSize);
+            textureFormatInfo(result->format, result->pixelSize, &bytesPerLine, &byteSize);
+            if (texD && texD->format() == QRhiTexture::RGBA8) {
+                result->data.resize(int(byteSize));
+                const QImage &src(texD->image[u.rb.layer()][u.rb.level()]);
+                char *dst = result->data.data();
+                for (int y = 0, h = src.height(); y < h; ++y) {
+                    memcpy(dst, src.constScanLine(y), bytesPerLine);
+                    dst += bytesPerLine;
+                }
+            } else {
+                result->data.fill(0, int(byteSize));
+            }
             if (result->completed)
                 result->completed();
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::GenMips) {
+            if (u.dst->format() == QRhiTexture::RGBA8)
+                simulateTextureGenMips(u);
         }
     }
     ud->free();
@@ -454,14 +553,18 @@ QNullBuffer::~QNullBuffer()
 
 void QNullBuffer::release()
 {
+    data.clear();
+
     QRHI_PROF;
     QRHI_PROF_F(releaseBuffer(this));
 }
 
 bool QNullBuffer::build()
 {
+    data.fill('\0', m_size);
+
     QRHI_PROF;
-    QRHI_PROF_F(newBuffer(this, m_size, 1, 0));
+    QRHI_PROF_F(newBuffer(this, uint(m_size), 1, 0));
     return true;
 }
 
@@ -513,22 +616,36 @@ void QNullTexture::release()
 
 bool QNullTexture::build()
 {
+    QRHI_RES_RHI(QRhiNull);
     const bool isCube = m_flags.testFlag(CubeMap);
     const bool hasMipMaps = m_flags.testFlag(MipMapped);
     QSize size = m_pixelSize.isEmpty() ? QSize(1, 1) : m_pixelSize;
-    const int mipLevelCount = hasMipMaps ? qCeil(log2(qMax(size.width(), size.height()))) + 1 : 1;
+    const int mipLevelCount = hasMipMaps ? rhiD->q->mipLevelsForSize(size) : 1;
+    const int layerCount = isCube ? 6 : 1;
+
+    if (m_format == RGBA8) {
+        for (int layer = 0; layer < layerCount; ++layer) {
+            for (int level = 0; level < mipLevelCount; ++level) {
+                image[layer][level] = QImage(rhiD->q->sizeForMipLevel(level, size),
+                                             QImage::Format_RGBA8888_Premultiplied);
+                image[layer][level].fill(Qt::yellow);
+            }
+        }
+    }
+
     QRHI_PROF;
-    QRHI_PROF_F(newTexture(this, true, mipLevelCount, isCube ? 6 : 1, 1));
+    QRHI_PROF_F(newTexture(this, true, mipLevelCount, layerCount, 1));
     return true;
 }
 
 bool QNullTexture::buildFrom(const QRhiNativeHandles *src)
 {
     Q_UNUSED(src);
+    QRHI_RES_RHI(QRhiNull);
     const bool isCube = m_flags.testFlag(CubeMap);
     const bool hasMipMaps = m_flags.testFlag(MipMapped);
     QSize size = m_pixelSize.isEmpty() ? QSize(1, 1) : m_pixelSize;
-    const int mipLevelCount = hasMipMaps ? qCeil(log2(qMax(size.width(), size.height()))) + 1 : 1;
+    const int mipLevelCount = hasMipMaps ? rhiD->q->mipLevelsForSize(size) : 1;
     QRHI_PROF;
     QRHI_PROF_F(newTexture(this, false, mipLevelCount, isCube ? 6 : 1, 1));
     return true;
@@ -628,10 +745,9 @@ QRhiRenderPassDescriptor *QNullTextureRenderTarget::newCompatibleRenderPassDescr
 bool QNullTextureRenderTarget::build()
 {
     d.rp = QRHI_RES(QNullRenderPassDescriptor, m_renderPassDesc);
-    const QVector<QRhiColorAttachment> colorAttachments = m_desc.colorAttachments();
-    if (!colorAttachments.isEmpty()) {
-        QRhiTexture *tex = colorAttachments.first().texture();
-        QRhiRenderBuffer *rb = colorAttachments.first().renderBuffer();
+    if (m_desc.cbeginColorAttachments() != m_desc.cendColorAttachments()) {
+        QRhiTexture *tex = m_desc.cbeginColorAttachments()->texture();
+        QRhiRenderBuffer *rb = m_desc.cbeginColorAttachments()->renderBuffer();
         d.pixelSize = tex ? tex->pixelSize() : rb->pixelSize();
     } else if (m_desc.depthStencilBuffer()) {
         d.pixelSize = m_desc.depthStencilBuffer()->pixelSize();
@@ -691,6 +807,10 @@ void QNullGraphicsPipeline::release()
 
 bool QNullGraphicsPipeline::build()
 {
+    QRHI_RES_RHI(QRhiNull);
+    if (!rhiD->sanityCheckGraphicsPipeline(this))
+        return false;
+
     return true;
 }
 
diff --git a/src/gui/rhi/qrhinull_p_p.h b/src/gui/rhi/qrhinull_p_p.h
index ee301d247b..ce517bfa63 100644
--- a/src/gui/rhi/qrhinull_p_p.h
+++ b/src/gui/rhi/qrhinull_p_p.h
@@ -59,6 +59,8 @@ struct QNullBuffer : public QRhiBuffer
     ~QNullBuffer();
     void release() override;
     bool build() override;
+
+    QByteArray data;
 };
 
 struct QNullRenderBuffer : public QRhiRenderBuffer
@@ -82,6 +84,7 @@ struct QNullTexture : public QRhiTexture
     const QRhiNativeHandles *nativeHandles() override;
 
     QRhiNullTextureNativeHandles nativeHandlesStruct;
+    QImage image[QRhi::MAX_LAYERS][QRhi::MAX_LEVELS];
 };
 
 struct QNullSampler : public QRhiSampler
@@ -286,6 +289,10 @@ public:
     void releaseCachedResources() override;
     bool isDeviceLost() const override;
 
+    void simulateTextureUpload(const QRhiResourceUpdateBatchPrivate::TextureOp &u);
+    void simulateTextureCopy(const QRhiResourceUpdateBatchPrivate::TextureOp &u);
+    void simulateTextureGenMips(const QRhiResourceUpdateBatchPrivate::TextureOp &u);
+
     QRhiNullNativeHandles nativeHandlesStruct;
     QRhiSwapChain *currentSwapChain = nullptr;
     QNullCommandBuffer offscreenCommandBuffer;
diff --git a/src/gui/rhi/qrhivulkan.cpp b/src/gui/rhi/qrhivulkan.cpp
index 7e2e914af3..103fea627a 100644
--- a/src/gui/rhi/qrhivulkan.cpp
+++ b/src/gui/rhi/qrhivulkan.cpp
@@ -363,6 +363,11 @@ bool QRhiVulkan::create(QRhi::Flags flags)
     Q_UNUSED(flags);
     Q_ASSERT(inst);
 
+    if (!inst->isValid()) {
+        qWarning("Vulkan instance is not valid");
+        return false;
+    }
+
     globalVulkanInstance = inst; // assume this will not change during the lifetime of the entire application
 
     f = inst->functions();
@@ -568,6 +573,9 @@ bool QRhiVulkan::create(QRhi::Flags flags)
 
         VmaAllocatorCreateInfo allocatorInfo;
         memset(&allocatorInfo, 0, sizeof(allocatorInfo));
+        // A QRhi is supposed to be used from one single thread only. Disable
+        // the allocator's own mutexes. This gives a performance boost.
+        allocatorInfo.flags = VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT;
         allocatorInfo.physicalDevice = physDev;
         allocatorInfo.device = dev;
         allocatorInfo.pVulkanFunctions = &afuncs;
@@ -1111,7 +1119,8 @@ bool QRhiVulkan::createDefaultRenderPass(VkRenderPass *rp, bool hasDepthStencil,
 }
 
 bool QRhiVulkan::createOffscreenRenderPass(VkRenderPass *rp,
-                                           const QVector<QRhiColorAttachment> &colorAttachments,
+                                           const QRhiColorAttachment *firstColorAttachment,
+                                           const QRhiColorAttachment *lastColorAttachment,
                                            bool preserveColor,
                                            bool preserveDs,
                                            QRhiRenderBuffer *depthStencilBuffer,
@@ -1120,13 +1129,12 @@ bool QRhiVulkan::createOffscreenRenderPass(VkRenderPass *rp,
     QVarLengthArray<VkAttachmentDescription, 8> attDescs;
     QVarLengthArray<VkAttachmentReference, 8> colorRefs;
     QVarLengthArray<VkAttachmentReference, 8> resolveRefs;
-    const int colorAttCount = colorAttachments.count();
 
     // attachment list layout is color (0-8), ds (0-1), resolve (0-8)
 
-    for (int i = 0; i < colorAttCount; ++i) {
-        QVkTexture *texD = QRHI_RES(QVkTexture, colorAttachments[i].texture());
-        QVkRenderBuffer *rbD = QRHI_RES(QVkRenderBuffer, colorAttachments[i].renderBuffer());
+    for (auto it = firstColorAttachment; it != lastColorAttachment; ++it) {
+        QVkTexture *texD = QRHI_RES(QVkTexture, it->texture());
+        QVkRenderBuffer *rbD = QRHI_RES(QVkRenderBuffer, it->renderBuffer());
         Q_ASSERT(texD || rbD);
         const VkFormat vkformat = texD ? texD->vkformat : rbD->vkformat;
         const VkSampleCountFlagBits samples = texD ? texD->samples : rbD->samples;
@@ -1136,7 +1144,7 @@ bool QRhiVulkan::createOffscreenRenderPass(VkRenderPass *rp,
         attDesc.format = vkformat;
         attDesc.samples = samples;
         attDesc.loadOp = preserveColor ? VK_ATTACHMENT_LOAD_OP_LOAD : VK_ATTACHMENT_LOAD_OP_CLEAR;
-        attDesc.storeOp = colorAttachments[i].resolveTexture() ? VK_ATTACHMENT_STORE_OP_DONT_CARE : VK_ATTACHMENT_STORE_OP_STORE;
+        attDesc.storeOp = it->resolveTexture() ? VK_ATTACHMENT_STORE_OP_DONT_CARE : VK_ATTACHMENT_STORE_OP_STORE;
         attDesc.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
         attDesc.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
         // this has to interact correctly with activateTextureRenderTarget(), hence leaving in COLOR_ATT
@@ -1170,9 +1178,9 @@ bool QRhiVulkan::createOffscreenRenderPass(VkRenderPass *rp,
     }
     VkAttachmentReference dsRef = { uint32_t(attDescs.count() - 1), VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL };
 
-    for (int i = 0; i < colorAttCount; ++i) {
-        if (colorAttachments[i].resolveTexture()) {
-            QVkTexture *rtexD = QRHI_RES(QVkTexture, colorAttachments[i].resolveTexture());
+    for (auto it = firstColorAttachment; it != lastColorAttachment; ++it) {
+        if (it->resolveTexture()) {
+            QVkTexture *rtexD = QRHI_RES(QVkTexture, it->resolveTexture());
             if (rtexD->samples > VK_SAMPLE_COUNT_1_BIT)
                 qWarning("Resolving into a multisample texture is not supported");
 
@@ -1979,11 +1987,10 @@ void QRhiVulkan::activateTextureRenderTarget(QVkCommandBuffer *cbD, QVkTextureRe
     rtD->lastActiveFrameSlot = currentFrameSlot;
     rtD->d.rp->lastActiveFrameSlot = currentFrameSlot;
     QRhiPassResourceTracker &passResTracker(cbD->passResTrackers[cbD->currentPassResTrackerIndex]);
-    const QVector<QRhiColorAttachment> colorAttachments = rtD->m_desc.colorAttachments();
-    for (const QRhiColorAttachment &colorAttachment : colorAttachments) {
-        QVkTexture *texD = QRHI_RES(QVkTexture, colorAttachment.texture());
-        QVkTexture *resolveTexD = QRHI_RES(QVkTexture, colorAttachment.resolveTexture());
-        QVkRenderBuffer *rbD = QRHI_RES(QVkRenderBuffer, colorAttachment.renderBuffer());
+    for (auto it = rtD->m_desc.cbeginColorAttachments(), itEnd = rtD->m_desc.cendColorAttachments(); it != itEnd; ++it) {
+        QVkTexture *texD = QRHI_RES(QVkTexture, it->texture());
+        QVkTexture *resolveTexD = QRHI_RES(QVkTexture, it->resolveTexture());
+        QVkRenderBuffer *rbD = QRHI_RES(QVkRenderBuffer, it->renderBuffer());
         if (texD) {
             trackedRegisterTexture(&passResTracker, texD,
                                    QRhiPassResourceTracker::TexColorOutput,
@@ -2643,100 +2650,164 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
     QRhiResourceUpdateBatchPrivate *ud = QRhiResourceUpdateBatchPrivate::get(resourceUpdates);
     QRhiProfilerPrivate *rhiP = profilerPrivateOrNull();
 
-    for (const QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate &u : ud->dynamicBufferUpdates) {
-        QVkBuffer *bufD = QRHI_RES(QVkBuffer, u.buf);
-        Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
-        for (int i = 0; i < QVK_FRAMES_IN_FLIGHT; ++i)
-            bufD->pendingDynamicUpdates[i].append(u);
-    }
+    for (const QRhiResourceUpdateBatchPrivate::BufferOp &u : ud->bufferOps) {
+        if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::DynamicUpdate) {
+            QVkBuffer *bufD = QRHI_RES(QVkBuffer, u.buf);
+            Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
+            for (int i = 0; i < QVK_FRAMES_IN_FLIGHT; ++i)
+                bufD->pendingDynamicUpdates[i].append(u);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::StaticUpload) {
+            QVkBuffer *bufD = QRHI_RES(QVkBuffer, u.buf);
+            Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
+            Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
+
+            if (!bufD->stagingBuffers[currentFrameSlot]) {
+                VkBufferCreateInfo bufferInfo;
+                memset(&bufferInfo, 0, sizeof(bufferInfo));
+                bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
+                // must cover the entire buffer - this way multiple, partial updates per frame
+                // are supported even when the staging buffer is reused (Static)
+                bufferInfo.size = VkDeviceSize(bufD->m_size);
+                bufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
+
+                VmaAllocationCreateInfo allocInfo;
+                memset(&allocInfo, 0, sizeof(allocInfo));
+                allocInfo.usage = VMA_MEMORY_USAGE_CPU_ONLY;
+
+                VmaAllocation allocation;
+                VkResult err = vmaCreateBuffer(toVmaAllocator(allocator), &bufferInfo, &allocInfo,
+                                               &bufD->stagingBuffers[currentFrameSlot], &allocation, nullptr);
+                if (err == VK_SUCCESS) {
+                    bufD->stagingAllocations[currentFrameSlot] = allocation;
+                    QRHI_PROF_F(newBufferStagingArea(bufD, currentFrameSlot, quint32(bufD->m_size)));
+                } else {
+                    qWarning("Failed to create staging buffer of size %d: %d", bufD->m_size, err);
+                    continue;
+                }
+            }
 
-    for (const QRhiResourceUpdateBatchPrivate::StaticBufferUpload &u : ud->staticBufferUploads) {
-        QVkBuffer *bufD = QRHI_RES(QVkBuffer, u.buf);
-        Q_ASSERT(bufD->m_type != QRhiBuffer::Dynamic);
-        Q_ASSERT(u.offset + u.data.size() <= bufD->m_size);
+            void *p = nullptr;
+            VmaAllocation a = toVmaAllocation(bufD->stagingAllocations[currentFrameSlot]);
+            VkResult err = vmaMapMemory(toVmaAllocator(allocator), a, &p);
+            if (err != VK_SUCCESS) {
+                qWarning("Failed to map buffer: %d", err);
+                continue;
+            }
+            memcpy(static_cast<uchar *>(p) + u.offset, u.data.constData(), size_t(u.data.size()));
+            vmaUnmapMemory(toVmaAllocator(allocator), a);
+            vmaFlushAllocation(toVmaAllocator(allocator), a, VkDeviceSize(u.offset), VkDeviceSize(u.data.size()));
 
-        if (!bufD->stagingBuffers[currentFrameSlot]) {
-            VkBufferCreateInfo bufferInfo;
-            memset(&bufferInfo, 0, sizeof(bufferInfo));
-            bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
-            // must cover the entire buffer - this way multiple, partial updates per frame
-            // are supported even when the staging buffer is reused (Static)
-            bufferInfo.size = VkDeviceSize(bufD->m_size);
-            bufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
+            trackedBufferBarrier(cbD, bufD, 0,
+                                 VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT);
 
-            VmaAllocationCreateInfo allocInfo;
-            memset(&allocInfo, 0, sizeof(allocInfo));
-            allocInfo.usage = VMA_MEMORY_USAGE_CPU_ONLY;
+            VkBufferCopy copyInfo;
+            memset(&copyInfo, 0, sizeof(copyInfo));
+            copyInfo.srcOffset = VkDeviceSize(u.offset);
+            copyInfo.dstOffset = VkDeviceSize(u.offset);
+            copyInfo.size = VkDeviceSize(u.data.size());
 
-            VmaAllocation allocation;
-            VkResult err = vmaCreateBuffer(toVmaAllocator(allocator), &bufferInfo, &allocInfo,
-                                           &bufD->stagingBuffers[currentFrameSlot], &allocation, nullptr);
-            if (err == VK_SUCCESS) {
-                bufD->stagingAllocations[currentFrameSlot] = allocation;
-                QRHI_PROF_F(newBufferStagingArea(bufD, currentFrameSlot, quint32(bufD->m_size)));
-            } else {
-                qWarning("Failed to create staging buffer of size %d: %d", bufD->m_size, err);
-                continue;
-            }
-        }
+            QVkCommandBuffer::Command cmd;
+            cmd.cmd = QVkCommandBuffer::Command::CopyBuffer;
+            cmd.args.copyBuffer.src = bufD->stagingBuffers[currentFrameSlot];
+            cmd.args.copyBuffer.dst = bufD->buffers[0];
+            cmd.args.copyBuffer.desc = copyInfo;
+            cbD->commands.append(cmd);
 
-        void *p = nullptr;
-        VmaAllocation a = toVmaAllocation(bufD->stagingAllocations[currentFrameSlot]);
-        VkResult err = vmaMapMemory(toVmaAllocator(allocator), a, &p);
-        if (err != VK_SUCCESS) {
-            qWarning("Failed to map buffer: %d", err);
-            continue;
-        }
-        memcpy(static_cast<uchar *>(p) + u.offset, u.data.constData(), size_t(u.data.size()));
-        vmaUnmapMemory(toVmaAllocator(allocator), a);
-        vmaFlushAllocation(toVmaAllocator(allocator), a, VkDeviceSize(u.offset), VkDeviceSize(u.data.size()));
+            // Where's the barrier for read-after-write? (assuming the common case
+            // of binding this buffer as vertex/index, or, less likely, as uniform
+            // buffer, in a renderpass later on) That is handled by the pass
+            // resource tracking: the appropriate pipeline barrier will be
+            // generated and recorded right before the renderpass, that binds this
+            // buffer in one of its commands, gets its BeginRenderPass recorded.
 
-        trackedBufferBarrier(cbD, bufD, 0,
-                             VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT);
+            bufD->lastActiveFrameSlot = currentFrameSlot;
 
-        VkBufferCopy copyInfo;
-        memset(&copyInfo, 0, sizeof(copyInfo));
-        copyInfo.srcOffset = VkDeviceSize(u.offset);
-        copyInfo.dstOffset = VkDeviceSize(u.offset);
-        copyInfo.size = VkDeviceSize(u.data.size());
+            if (bufD->m_type == QRhiBuffer::Immutable) {
+                QRhiVulkan::DeferredReleaseEntry e;
+                e.type = QRhiVulkan::DeferredReleaseEntry::StagingBuffer;
+                e.lastActiveFrameSlot = currentFrameSlot;
+                e.stagingBuffer.stagingBuffer = bufD->stagingBuffers[currentFrameSlot];
+                e.stagingBuffer.stagingAllocation = bufD->stagingAllocations[currentFrameSlot];
+                bufD->stagingBuffers[currentFrameSlot] = VK_NULL_HANDLE;
+                bufD->stagingAllocations[currentFrameSlot] = nullptr;
+                releaseQueue.append(e);
+                QRHI_PROF_F(releaseBufferStagingArea(bufD, currentFrameSlot));
+            }
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::BufferOp::Read) {
+            QVkBuffer *bufD = QRHI_RES(QVkBuffer, u.buf);
+            if (bufD->m_type == QRhiBuffer::Dynamic) {
+                executeBufferHostWritesForCurrentFrame(bufD);
+                void *p = nullptr;
+                VmaAllocation a = toVmaAllocation(bufD->allocations[currentFrameSlot]);
+                VkResult err = vmaMapMemory(toVmaAllocator(allocator), a, &p);
+                if (err == VK_SUCCESS) {
+                    u.result->data.resize(u.readSize);
+                    memcpy(u.result->data.data(), reinterpret_cast<char *>(p) + u.offset, size_t(u.readSize));
+                    vmaUnmapMemory(toVmaAllocator(allocator), a);
+                }
+                if (u.result->completed)
+                    u.result->completed();
+            } else {
+                // Non-Dynamic buffers may not be host visible, so have to
+                // create a readback buffer, enqueue a copy from
+                // bufD->buffers[0] to this buffer, and then once the command
+                // buffer completes, copy the data out of the host visible
+                // readback buffer. Quite similar to what we do for texture
+                // readbacks.
+                BufferReadback readback;
+                readback.activeFrameSlot = currentFrameSlot;
+                readback.result = u.result;
+                readback.byteSize = u.readSize;
+
+                VkBufferCreateInfo bufferInfo;
+                memset(&bufferInfo, 0, sizeof(bufferInfo));
+                bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
+                bufferInfo.size = VkDeviceSize(readback.byteSize);
+                bufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+
+                VmaAllocationCreateInfo allocInfo;
+                memset(&allocInfo, 0, sizeof(allocInfo));
+                allocInfo.usage = VMA_MEMORY_USAGE_GPU_TO_CPU;
+
+                VmaAllocation allocation;
+                VkResult err = vmaCreateBuffer(toVmaAllocator(allocator), &bufferInfo, &allocInfo, &readback.stagingBuf, &allocation, nullptr);
+                if (err == VK_SUCCESS) {
+                    readback.stagingAlloc = allocation;
+                    QRHI_PROF_F(newReadbackBuffer(qint64(readback.stagingBuf), bufD, uint(readback.byteSize)));
+                } else {
+                    qWarning("Failed to create readback buffer of size %u: %d", readback.byteSize, err);
+                    continue;
+                }
 
-        QVkCommandBuffer::Command cmd;
-        cmd.cmd = QVkCommandBuffer::Command::CopyBuffer;
-        cmd.args.copyBuffer.src = bufD->stagingBuffers[currentFrameSlot];
-        cmd.args.copyBuffer.dst = bufD->buffers[0];
-        cmd.args.copyBuffer.desc = copyInfo;
-        cbD->commands.append(cmd);
+                trackedBufferBarrier(cbD, bufD, 0, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT);
 
-        // Where's the barrier for read-after-write? (assuming the common case
-        // of binding this buffer as vertex/index, or, less likely, as uniform
-        // buffer, in a renderpass later on) That is handled by the pass
-        // resource tracking: the appropriate pipeline barrier will be
-        // generated and recorded right before the renderpass, that binds this
-        // buffer in one of its commands, gets its BeginRenderPass recorded.
+                VkBufferCopy copyInfo;
+                memset(&copyInfo, 0, sizeof(copyInfo));
+                copyInfo.srcOffset = VkDeviceSize(u.offset);
+                copyInfo.size = VkDeviceSize(u.readSize);
 
-        bufD->lastActiveFrameSlot = currentFrameSlot;
+                QVkCommandBuffer::Command cmd;
+                cmd.cmd = QVkCommandBuffer::Command::CopyBuffer;
+                cmd.args.copyBuffer.src = bufD->buffers[0];
+                cmd.args.copyBuffer.dst = readback.stagingBuf;
+                cmd.args.copyBuffer.desc = copyInfo;
+                cbD->commands.append(cmd);
 
-        if (bufD->m_type == QRhiBuffer::Immutable) {
-            QRhiVulkan::DeferredReleaseEntry e;
-            e.type = QRhiVulkan::DeferredReleaseEntry::StagingBuffer;
-            e.lastActiveFrameSlot = currentFrameSlot;
-            e.stagingBuffer.stagingBuffer = bufD->stagingBuffers[currentFrameSlot];
-            e.stagingBuffer.stagingAllocation = bufD->stagingAllocations[currentFrameSlot];
-            bufD->stagingBuffers[currentFrameSlot] = VK_NULL_HANDLE;
-            bufD->stagingAllocations[currentFrameSlot] = nullptr;
-            releaseQueue.append(e);
-            QRHI_PROF_F(releaseBufferStagingArea(bufD, currentFrameSlot));
+                bufD->lastActiveFrameSlot = currentFrameSlot;
+
+                activeBufferReadbacks.append(readback);
+            }
         }
     }
 
     for (const QRhiResourceUpdateBatchPrivate::TextureOp &u : ud->textureOps) {
         if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Upload) {
-            QVkTexture *utexD = QRHI_RES(QVkTexture, u.upload.tex);
+            QVkTexture *utexD = QRHI_RES(QVkTexture, u.dst);
             // batch into a single staging buffer and a single CopyBufferToImage with multiple copyInfos
             VkDeviceSize stagingSize = 0;
             for (int layer = 0; layer < QRhi::MAX_LAYERS; ++layer) {
                 for (int level = 0; level < QRhi::MAX_LEVELS; ++level) {
-                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.upload.subresDesc[layer][level]))
+                    for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(u.subresDesc[layer][level]))
                         stagingSize += subresUploadByteSize(subresDesc);
                 }
             }
@@ -2774,7 +2845,7 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
 
             for (int layer = 0; layer < QRhi::MAX_LAYERS; ++layer) {
                 for (int level = 0; level < QRhi::MAX_LEVELS; ++level) {
-                    const QVector<QRhiTextureSubresourceUploadDescription> &srd(u.upload.subresDesc[layer][level]);
+                    const QVector<QRhiTextureSubresourceUploadDescription> &srd(u.subresDesc[layer][level]);
                     if (srd.isEmpty())
                         continue;
                     for (const QRhiTextureSubresourceUploadDescription &subresDesc : qAsConst(srd)) {
@@ -2815,36 +2886,37 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
 
             utexD->lastActiveFrameSlot = currentFrameSlot;
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Copy) {
-            Q_ASSERT(u.copy.src && u.copy.dst);
-            if (u.copy.src == u.copy.dst) {
+            Q_ASSERT(u.src && u.dst);
+            if (u.src == u.dst) {
                 qWarning("Texture copy with matching source and destination is not supported");
                 continue;
             }
-            QVkTexture *srcD = QRHI_RES(QVkTexture, u.copy.src);
-            QVkTexture *dstD = QRHI_RES(QVkTexture, u.copy.dst);
+            QVkTexture *srcD = QRHI_RES(QVkTexture, u.src);
+            QVkTexture *dstD = QRHI_RES(QVkTexture, u.dst);
 
             VkImageCopy region;
             memset(&region, 0, sizeof(region));
 
             region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
-            region.srcSubresource.mipLevel = uint32_t(u.copy.desc.sourceLevel());
-            region.srcSubresource.baseArrayLayer = uint32_t(u.copy.desc.sourceLayer());
+            region.srcSubresource.mipLevel = uint32_t(u.desc.sourceLevel());
+            region.srcSubresource.baseArrayLayer = uint32_t(u.desc.sourceLayer());
             region.srcSubresource.layerCount = 1;
 
-            region.srcOffset.x = u.copy.desc.sourceTopLeft().x();
-            region.srcOffset.y = u.copy.desc.sourceTopLeft().y();
+            region.srcOffset.x = u.desc.sourceTopLeft().x();
+            region.srcOffset.y = u.desc.sourceTopLeft().y();
 
             region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
-            region.dstSubresource.mipLevel = uint32_t(u.copy.desc.destinationLevel());
-            region.dstSubresource.baseArrayLayer = uint32_t(u.copy.desc.destinationLayer());
+            region.dstSubresource.mipLevel = uint32_t(u.desc.destinationLevel());
+            region.dstSubresource.baseArrayLayer = uint32_t(u.desc.destinationLayer());
             region.dstSubresource.layerCount = 1;
 
-            region.dstOffset.x = u.copy.desc.destinationTopLeft().x();
-            region.dstOffset.y = u.copy.desc.destinationTopLeft().y();
+            region.dstOffset.x = u.desc.destinationTopLeft().x();
+            region.dstOffset.y = u.desc.destinationTopLeft().y();
 
-            const QSize size = u.copy.desc.pixelSize().isEmpty() ? srcD->m_pixelSize : u.copy.desc.pixelSize();
-            region.extent.width = uint32_t(size.width());
-            region.extent.height = uint32_t(size.height());
+            const QSize mipSize = q->sizeForMipLevel(u.desc.sourceLevel(), srcD->m_pixelSize);
+            const QSize copySize = u.desc.pixelSize().isEmpty() ? mipSize : u.desc.pixelSize();
+            region.extent.width = uint32_t(copySize.width());
+            region.extent.height = uint32_t(copySize.height());
             region.extent.depth = 1;
 
             trackedImageBarrier(cbD, srcD, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
@@ -2863,21 +2935,20 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
 
             srcD->lastActiveFrameSlot = dstD->lastActiveFrameSlot = currentFrameSlot;
         } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::Read) {
-            ActiveReadback aRb;
-            aRb.activeFrameSlot = currentFrameSlot;
-            aRb.desc = u.read.rb;
-            aRb.result = u.read.result;
+            TextureReadback readback;
+            readback.activeFrameSlot = currentFrameSlot;
+            readback.desc = u.rb;
+            readback.result = u.result;
 
-            QVkTexture *texD = QRHI_RES(QVkTexture, u.read.rb.texture());
+            QVkTexture *texD = QRHI_RES(QVkTexture, u.rb.texture());
             QVkSwapChain *swapChainD = nullptr;
             if (texD) {
                 if (texD->samples > VK_SAMPLE_COUNT_1_BIT) {
                     qWarning("Multisample texture cannot be read back");
                     continue;
                 }
-                aRb.pixelSize = u.read.rb.level() > 0 ? q->sizeForMipLevel(u.read.rb.level(), texD->m_pixelSize)
-                                                 : texD->m_pixelSize;
-                aRb.format = texD->m_format;
+                readback.pixelSize = q->sizeForMipLevel(u.rb.level(), texD->m_pixelSize);
+                readback.format = texD->m_format;
                 texD->lastActiveFrameSlot = currentFrameSlot;
             } else {
                 Q_ASSERT(currentSwapChain);
@@ -2886,21 +2957,21 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
                     qWarning("Swapchain does not support readback");
                     continue;
                 }
-                aRb.pixelSize = swapChainD->pixelSize;
-                aRb.format = colorTextureFormatFromVkFormat(swapChainD->colorFormat, nullptr);
-                if (aRb.format == QRhiTexture::UnknownFormat)
+                readback.pixelSize = swapChainD->pixelSize;
+                readback.format = colorTextureFormatFromVkFormat(swapChainD->colorFormat, nullptr);
+                if (readback.format == QRhiTexture::UnknownFormat)
                     continue;
 
                 // Multisample swapchains need nothing special since resolving
                 // happens when ending a renderpass.
             }
-            textureFormatInfo(aRb.format, aRb.pixelSize, nullptr, &aRb.bufSize);
+            textureFormatInfo(readback.format, readback.pixelSize, nullptr, &readback.byteSize);
 
-            // Create a host visible buffer.
+            // Create a host visible readback buffer.
             VkBufferCreateInfo bufferInfo;
             memset(&bufferInfo, 0, sizeof(bufferInfo));
             bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
-            bufferInfo.size = aRb.bufSize;
+            bufferInfo.size = readback.byteSize;
             bufferInfo.usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT;
 
             VmaAllocationCreateInfo allocInfo;
@@ -2908,14 +2979,14 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
             allocInfo.usage = VMA_MEMORY_USAGE_GPU_TO_CPU;
 
             VmaAllocation allocation;
-            VkResult err = vmaCreateBuffer(toVmaAllocator(allocator), &bufferInfo, &allocInfo, &aRb.buf, &allocation, nullptr);
+            VkResult err = vmaCreateBuffer(toVmaAllocator(allocator), &bufferInfo, &allocInfo, &readback.stagingBuf, &allocation, nullptr);
             if (err == VK_SUCCESS) {
-                aRb.bufAlloc = allocation;
-                QRHI_PROF_F(newReadbackBuffer(qint64(aRb.buf),
+                readback.stagingAlloc = allocation;
+                QRHI_PROF_F(newReadbackBuffer(qint64(readback.stagingBuf),
                                               texD ? static_cast<QRhiResource *>(texD) : static_cast<QRhiResource *>(swapChainD),
-                                              aRb.bufSize));
+                                              readback.byteSize));
             } else {
-                qWarning("Failed to create readback buffer of size %u: %d", aRb.bufSize, err);
+                qWarning("Failed to create readback buffer of size %u: %d", readback.byteSize, err);
                 continue;
             }
 
@@ -2924,11 +2995,11 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
             memset(&copyDesc, 0, sizeof(copyDesc));
             copyDesc.bufferOffset = 0;
             copyDesc.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
-            copyDesc.imageSubresource.mipLevel = uint32_t(u.read.rb.level());
-            copyDesc.imageSubresource.baseArrayLayer = uint32_t(u.read.rb.layer());
+            copyDesc.imageSubresource.mipLevel = uint32_t(u.rb.level());
+            copyDesc.imageSubresource.baseArrayLayer = uint32_t(u.rb.layer());
             copyDesc.imageSubresource.layerCount = 1;
-            copyDesc.imageExtent.width = uint32_t(aRb.pixelSize.width());
-            copyDesc.imageExtent.height = uint32_t(aRb.pixelSize.height());
+            copyDesc.imageExtent.width = uint32_t(readback.pixelSize.width());
+            copyDesc.imageExtent.height = uint32_t(readback.pixelSize.height());
             copyDesc.imageExtent.depth = 1;
 
             if (texD) {
@@ -2938,7 +3009,7 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
                 cmd.cmd = QVkCommandBuffer::Command::CopyImageToBuffer;
                 cmd.args.copyImageToBuffer.src = texD->image;
                 cmd.args.copyImageToBuffer.srcLayout = texD->usageState.layout;
-                cmd.args.copyImageToBuffer.dst = aRb.buf;
+                cmd.args.copyImageToBuffer.dst = readback.stagingBuf;
                 cmd.args.copyImageToBuffer.desc = copyDesc;
                 cbD->commands.append(cmd);
             } else {
@@ -2963,14 +3034,14 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
                 cmd.cmd = QVkCommandBuffer::Command::CopyImageToBuffer;
                 cmd.args.copyImageToBuffer.src = image;
                 cmd.args.copyImageToBuffer.srcLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
-                cmd.args.copyImageToBuffer.dst = aRb.buf;
+                cmd.args.copyImageToBuffer.dst = readback.stagingBuf;
                 cmd.args.copyImageToBuffer.desc = copyDesc;
                 cbD->commands.append(cmd);
             }
 
-            activeReadbacks.append(aRb);
-        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::MipGen) {
-            QVkTexture *utexD = QRHI_RES(QVkTexture, u.mipgen.tex);
+            activeTextureReadbacks.append(readback);
+        } else if (u.type == QRhiResourceUpdateBatchPrivate::TextureOp::GenMips) {
+            QVkTexture *utexD = QRHI_RES(QVkTexture, u.dst);
             Q_ASSERT(utexD->m_flags.testFlag(QRhiTexture::UsedWithGenerateMips));
             int w = utexD->m_pixelSize.width();
             int h = utexD->m_pixelSize.height();
@@ -2987,14 +3058,14 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
                                        origLayout, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                        origAccess, VK_ACCESS_TRANSFER_READ_BIT,
                                        origStage, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                                       u.mipgen.layer, 1,
+                                       u.layer, 1,
                                        level - 1, 1);
                 } else {
                     subresourceBarrier(cbD, utexD->image,
                                        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                        VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_TRANSFER_READ_BIT,
                                        VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                                       u.mipgen.layer, 1,
+                                       u.layer, 1,
                                        level - 1, 1);
                 }
 
@@ -3002,7 +3073,7 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
                                    origLayout, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                    origAccess, VK_ACCESS_TRANSFER_WRITE_BIT,
                                    origStage, VK_PIPELINE_STAGE_TRANSFER_BIT,
-                                   u.mipgen.layer, 1,
+                                   u.layer, 1,
                                    level, 1);
 
                 VkImageBlit region;
@@ -3010,7 +3081,7 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
 
                 region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
                 region.srcSubresource.mipLevel = uint32_t(level) - 1;
-                region.srcSubresource.baseArrayLayer = uint32_t(u.mipgen.layer);
+                region.srcSubresource.baseArrayLayer = uint32_t(u.layer);
                 region.srcSubresource.layerCount = 1;
 
                 region.srcOffsets[1].x = qMax(1, w);
@@ -3019,7 +3090,7 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
 
                 region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
                 region.dstSubresource.mipLevel = uint32_t(level);
-                region.dstSubresource.baseArrayLayer = uint32_t(u.mipgen.layer);
+                region.dstSubresource.baseArrayLayer = uint32_t(u.layer);
                 region.dstSubresource.layerCount = 1;
 
                 region.dstOffsets[1].x = qMax(1, w >> 1);
@@ -3045,13 +3116,13 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
                                    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, origLayout,
                                    VK_ACCESS_TRANSFER_READ_BIT, origAccess,
                                    VK_PIPELINE_STAGE_TRANSFER_BIT, origStage,
-                                   u.mipgen.layer, 1,
+                                   u.layer, 1,
                                    0, int(utexD->mipLevelCount) - 1);
                 subresourceBarrier(cbD, utexD->image,
                                    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, origLayout,
                                    VK_ACCESS_TRANSFER_WRITE_BIT, origAccess,
                                    VK_PIPELINE_STAGE_TRANSFER_BIT, origStage,
-                                   u.mipgen.layer, 1,
+                                   u.layer, 1,
                                    int(utexD->mipLevelCount) - 1, 1);
             }
 
@@ -3064,8 +3135,7 @@ void QRhiVulkan::enqueueResourceUpdates(QVkCommandBuffer *cbD, QRhiResourceUpdat
 
 void QRhiVulkan::executeBufferHostWritesForCurrentFrame(QVkBuffer *bufD)
 {
-    QVector<QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate> &updates(bufD->pendingDynamicUpdates[currentFrameSlot]);
-    if (updates.isEmpty())
+    if (bufD->pendingDynamicUpdates[currentFrameSlot].isEmpty())
         return;
 
     Q_ASSERT(bufD->m_type == QRhiBuffer::Dynamic);
@@ -3081,7 +3151,7 @@ void QRhiVulkan::executeBufferHostWritesForCurrentFrame(QVkBuffer *bufD)
     }
     int changeBegin = -1;
     int changeEnd = -1;
-    for (const QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate &u : updates) {
+    for (const QRhiResourceUpdateBatchPrivate::BufferOp &u : qAsConst(bufD->pendingDynamicUpdates[currentFrameSlot])) {
         Q_ASSERT(bufD == QRHI_RES(QVkBuffer, u.buf));
         memcpy(static_cast<char *>(p) + u.offset, u.data.constData(), size_t(u.data.size()));
         if (changeBegin == -1 || u.offset < changeBegin)
@@ -3093,7 +3163,7 @@ void QRhiVulkan::executeBufferHostWritesForCurrentFrame(QVkBuffer *bufD)
     if (changeBegin >= 0)
         vmaFlushAllocation(toVmaAllocator(allocator), a, VkDeviceSize(changeBegin), VkDeviceSize(changeEnd - changeBegin));
 
-    updates.clear();
+    bufD->pendingDynamicUpdates[currentFrameSlot].clear();
 }
 
 static void qrhivk_releaseBuffer(const QRhiVulkan::DeferredReleaseEntry &e, void *allocator)
@@ -3187,29 +3257,53 @@ void QRhiVulkan::finishActiveReadbacks(bool forced)
     QVarLengthArray<std::function<void()>, 4> completedCallbacks;
     QRhiProfilerPrivate *rhiP = profilerPrivateOrNull();
 
-    for (int i = activeReadbacks.count() - 1; i >= 0; --i) {
-        const QRhiVulkan::ActiveReadback &aRb(activeReadbacks[i]);
-        if (forced || currentFrameSlot == aRb.activeFrameSlot || aRb.activeFrameSlot < 0) {
-            aRb.result->format = aRb.format;
-            aRb.result->pixelSize = aRb.pixelSize;
-            aRb.result->data.resize(int(aRb.bufSize));
+    for (int i = activeTextureReadbacks.count() - 1; i >= 0; --i) {
+        const QRhiVulkan::TextureReadback &readback(activeTextureReadbacks[i]);
+        if (forced || currentFrameSlot == readback.activeFrameSlot || readback.activeFrameSlot < 0) {
+            readback.result->format = readback.format;
+            readback.result->pixelSize = readback.pixelSize;
+            VmaAllocation a = toVmaAllocation(readback.stagingAlloc);
             void *p = nullptr;
-            VmaAllocation a = toVmaAllocation(aRb.bufAlloc);
             VkResult err = vmaMapMemory(toVmaAllocator(allocator), a, &p);
-            if (err != VK_SUCCESS) {
-                qWarning("Failed to map readback buffer: %d", err);
-                continue;
+            if (err == VK_SUCCESS && p) {
+                readback.result->data.resize(int(readback.byteSize));
+                memcpy(readback.result->data.data(), p, readback.byteSize);
+                vmaUnmapMemory(toVmaAllocator(allocator), a);
+            } else {
+                qWarning("Failed to map texture readback buffer of size %u: %d", readback.byteSize, err);
             }
-            memcpy(aRb.result->data.data(), p, aRb.bufSize);
-            vmaUnmapMemory(toVmaAllocator(allocator), a);
 
-            vmaDestroyBuffer(toVmaAllocator(allocator), aRb.buf, a);
-            QRHI_PROF_F(releaseReadbackBuffer(qint64(aRb.buf)));
+            vmaDestroyBuffer(toVmaAllocator(allocator), readback.stagingBuf, a);
+            QRHI_PROF_F(releaseReadbackBuffer(qint64(readback.stagingBuf)));
 
-            if (aRb.result->completed)
-                completedCallbacks.append(aRb.result->completed);
+            if (readback.result->completed)
+                completedCallbacks.append(readback.result->completed);
 
-            activeReadbacks.removeAt(i);
+            activeTextureReadbacks.removeAt(i);
+        }
+    }
+
+    for (int i = activeBufferReadbacks.count() - 1; i >= 0; --i) {
+        const QRhiVulkan::BufferReadback &readback(activeBufferReadbacks[i]);
+        if (forced || currentFrameSlot == readback.activeFrameSlot || readback.activeFrameSlot < 0) {
+            VmaAllocation a = toVmaAllocation(readback.stagingAlloc);
+            void *p = nullptr;
+            VkResult err = vmaMapMemory(toVmaAllocator(allocator), a, &p);
+            if (err == VK_SUCCESS && p) {
+                readback.result->data.resize(readback.byteSize);
+                memcpy(readback.result->data.data(), p, size_t(readback.byteSize));
+                vmaUnmapMemory(toVmaAllocator(allocator), a);
+            } else {
+                qWarning("Failed to map buffer readback buffer of size %d: %d", readback.byteSize, err);
+            }
+
+            vmaDestroyBuffer(toVmaAllocator(allocator), readback.stagingBuf, a);
+            QRHI_PROF_F(releaseReadbackBuffer(qint64(readback.stagingBuf)));
+
+            if (readback.result->completed)
+                completedCallbacks.append(readback.result->completed);
+
+            activeBufferReadbacks.removeAt(i);
         }
     }
 
@@ -3239,12 +3333,12 @@ QVector<int> QRhiVulkan::supportedSampleCounts() const
     VkSampleCountFlags stencil = limits->framebufferStencilSampleCounts;
     QVector<int> result;
 
-    for (size_t i = 0; i < sizeof(qvk_sampleCounts) / sizeof(qvk_sampleCounts[0]); ++i) {
-        if ((color & qvk_sampleCounts[i].mask)
-                && (depth & qvk_sampleCounts[i].mask)
-                && (stencil & qvk_sampleCounts[i].mask))
+    for (const auto &qvk_sampleCount : qvk_sampleCounts) {
+        if ((color & qvk_sampleCount.mask)
+                && (depth & qvk_sampleCount.mask)
+                && (stencil & qvk_sampleCount.mask))
         {
-            result.append(qvk_sampleCounts[i].count);
+            result.append(qvk_sampleCount.count);
         }
     }
 
@@ -3261,9 +3355,9 @@ VkSampleCountFlagBits QRhiVulkan::effectiveSampleCount(int sampleCount)
         return VK_SAMPLE_COUNT_1_BIT;
     }
 
-    for (size_t i = 0; i < sizeof(qvk_sampleCounts) / sizeof(qvk_sampleCounts[0]); ++i) {
-        if (qvk_sampleCounts[i].count == sampleCount)
-            return qvk_sampleCounts[i].mask;
+    for (const auto &qvk_sampleCount : qvk_sampleCounts) {
+        if (qvk_sampleCount.count == sampleCount)
+            return qvk_sampleCount.mask;
     }
 
     Q_UNREACHABLE();
@@ -3725,6 +3819,12 @@ bool QRhiVulkan::isFeatureSupported(QRhi::Feature feature) const
         return true;
     case QRhi::BaseInstance:
         return true;
+    case QRhi::TriangleFanTopology:
+        return true;
+    case QRhi::ReadBackNonUniformBuffer:
+        return true;
+    case QRhi::ReadBackNonBaseMipLevel:
+        return true;
     default:
         Q_UNREACHABLE();
         return false;
@@ -4570,6 +4670,8 @@ static inline VkPrimitiveTopology toVkTopology(QRhiGraphicsPipeline::Topology t)
         return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
     case QRhiGraphicsPipeline::TriangleStrip:
         return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
+    case QRhiGraphicsPipeline::TriangleFan:
+        return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN;
     case QRhiGraphicsPipeline::Lines:
         return VK_PRIMITIVE_TOPOLOGY_LINE_LIST;
     case QRhiGraphicsPipeline::LineStrip:
@@ -4892,7 +4994,7 @@ bool QVkBuffer::build()
         allocInfo.usage = VMA_MEMORY_USAGE_CPU_TO_GPU;
     } else {
         allocInfo.usage = VMA_MEMORY_USAGE_GPU_ONLY;
-        bufferInfo.usage |= VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+        bufferInfo.usage |= VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
     }
 
     QRHI_RES_RHI(QRhiVulkan);
@@ -4906,11 +5008,7 @@ bool QVkBuffer::build()
             err = vmaCreateBuffer(toVmaAllocator(rhiD->allocator), &bufferInfo, &allocInfo, &buffers[i], &allocation, nullptr);
             if (err != VK_SUCCESS)
                 break;
-
             allocations[i] = allocation;
-            if (m_type == Dynamic)
-                pendingDynamicUpdates[i].reserve(16);
-
             rhiD->setObjectName(uint64_t(buffers[i]), VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT, m_objectName,
                                 m_type == Dynamic ? i : -1);
         }
@@ -5487,7 +5585,8 @@ QRhiRenderPassDescriptor *QVkTextureRenderTarget::newCompatibleRenderPassDescrip
     QRHI_RES_RHI(QRhiVulkan);
     QVkRenderPassDescriptor *rp = new QVkRenderPassDescriptor(m_rhi);
     if (!rhiD->createOffscreenRenderPass(&rp->rp,
-                                         m_desc.colorAttachments(),
+                                         m_desc.cbeginColorAttachments(),
+                                         m_desc.cendColorAttachments(),
                                          m_flags.testFlag(QRhiTextureRenderTarget::PreserveColorContents),
                                          m_flags.testFlag(QRhiTextureRenderTarget::PreserveDepthStencilContents),
                                          m_desc.depthStencilBuffer(),
@@ -5507,18 +5606,20 @@ bool QVkTextureRenderTarget::build()
     if (d.fb)
         release();
 
-    const QVector<QRhiColorAttachment> colorAttachments = m_desc.colorAttachments();
-    Q_ASSERT(!colorAttachments.isEmpty() || m_desc.depthTexture());
+    const bool hasColorAttachments = m_desc.cbeginColorAttachments() != m_desc.cendColorAttachments();
+    Q_ASSERT(hasColorAttachments || m_desc.depthTexture());
     Q_ASSERT(!m_desc.depthStencilBuffer() || !m_desc.depthTexture());
     const bool hasDepthStencil = m_desc.depthStencilBuffer() || m_desc.depthTexture();
 
     QRHI_RES_RHI(QRhiVulkan);
     QVarLengthArray<VkImageView, 8> views;
 
-    d.colorAttCount = colorAttachments.count();
-    for (int i = 0; i < d.colorAttCount; ++i) {
-        QVkTexture *texD = QRHI_RES(QVkTexture, colorAttachments[i].texture());
-        QVkRenderBuffer *rbD = QRHI_RES(QVkRenderBuffer, colorAttachments[i].renderBuffer());
+    d.colorAttCount = 0;
+    int attIndex = 0;
+    for (auto it = m_desc.cbeginColorAttachments(), itEnd = m_desc.cendColorAttachments(); it != itEnd; ++it, ++attIndex) {
+        d.colorAttCount += 1;
+        QVkTexture *texD = QRHI_RES(QVkTexture, it->texture());
+        QVkRenderBuffer *rbD = QRHI_RES(QVkRenderBuffer, it->renderBuffer());
         Q_ASSERT(texD || rbD);
         if (texD) {
             Q_ASSERT(texD->flags().testFlag(QRhiTexture::RenderTarget));
@@ -5533,24 +5634,24 @@ bool QVkTextureRenderTarget::build()
             viewInfo.components.b = VK_COMPONENT_SWIZZLE_B;
             viewInfo.components.a = VK_COMPONENT_SWIZZLE_A;
             viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
-            viewInfo.subresourceRange.baseMipLevel = uint32_t(colorAttachments[i].level());
+            viewInfo.subresourceRange.baseMipLevel = uint32_t(it->level());
             viewInfo.subresourceRange.levelCount = 1;
-            viewInfo.subresourceRange.baseArrayLayer = uint32_t(colorAttachments[i].layer());
+            viewInfo.subresourceRange.baseArrayLayer = uint32_t(it->layer());
             viewInfo.subresourceRange.layerCount = 1;
-            VkResult err = rhiD->df->vkCreateImageView(rhiD->dev, &viewInfo, nullptr, &rtv[i]);
+            VkResult err = rhiD->df->vkCreateImageView(rhiD->dev, &viewInfo, nullptr, &rtv[attIndex]);
             if (err != VK_SUCCESS) {
                 qWarning("Failed to create render target image view: %d", err);
                 return false;
             }
-            views.append(rtv[i]);
-            if (i == 0) {
+            views.append(rtv[attIndex]);
+            if (attIndex == 0) {
                 d.pixelSize = texD->pixelSize();
                 d.sampleCount = texD->samples;
             }
         } else if (rbD) {
             Q_ASSERT(rbD->backingTexture);
             views.append(rbD->backingTexture->imageView);
-            if (i == 0) {
+            if (attIndex == 0) {
                 d.pixelSize = rbD->pixelSize();
                 d.sampleCount = rbD->samples;
             }
@@ -5580,9 +5681,10 @@ bool QVkTextureRenderTarget::build()
     }
 
     d.resolveAttCount = 0;
-    for (int i = 0; i < d.colorAttCount; ++i) {
-        if (colorAttachments[i].resolveTexture()) {
-            QVkTexture *resTexD = QRHI_RES(QVkTexture, colorAttachments[i].resolveTexture());
+    attIndex = 0;
+    for (auto it = m_desc.cbeginColorAttachments(), itEnd = m_desc.cendColorAttachments(); it != itEnd; ++it, ++attIndex) {
+        if (it->resolveTexture()) {
+            QVkTexture *resTexD = QRHI_RES(QVkTexture, it->resolveTexture());
             Q_ASSERT(resTexD->flags().testFlag(QRhiTexture::RenderTarget));
             d.resolveAttCount += 1;
 
@@ -5597,16 +5699,16 @@ bool QVkTextureRenderTarget::build()
             viewInfo.components.b = VK_COMPONENT_SWIZZLE_B;
             viewInfo.components.a = VK_COMPONENT_SWIZZLE_A;
             viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
-            viewInfo.subresourceRange.baseMipLevel = uint32_t(colorAttachments[i].resolveLevel());
+            viewInfo.subresourceRange.baseMipLevel = uint32_t(it->resolveLevel());
             viewInfo.subresourceRange.levelCount = 1;
-            viewInfo.subresourceRange.baseArrayLayer = uint32_t(colorAttachments[i].resolveLayer());
+            viewInfo.subresourceRange.baseArrayLayer = uint32_t(it->resolveLayer());
             viewInfo.subresourceRange.layerCount = 1;
-            VkResult err = rhiD->df->vkCreateImageView(rhiD->dev, &viewInfo, nullptr, &resrtv[i]);
+            VkResult err = rhiD->df->vkCreateImageView(rhiD->dev, &viewInfo, nullptr, &resrtv[attIndex]);
             if (err != VK_SUCCESS) {
                 qWarning("Failed to create render target resolve image view: %d", err);
                 return false;
             }
-            views.append(resrtv[i]);
+            views.append(resrtv[attIndex]);
         }
     }
 
@@ -5784,6 +5886,9 @@ bool QVkGraphicsPipeline::build()
         release();
 
     QRHI_RES_RHI(QRhiVulkan);
+    if (!rhiD->sanityCheckGraphicsPipeline(this))
+        return false;
+
     if (!rhiD->ensurePipelineCache())
         return false;
 
@@ -5828,22 +5933,21 @@ bool QVkGraphicsPipeline::build()
     pipelineInfo.stageCount = uint32_t(shaderStageCreateInfos.count());
     pipelineInfo.pStages = shaderStageCreateInfos.constData();
 
-    const QVector<QRhiVertexInputBinding> bindings = m_vertexInputLayout.bindings();
     QVarLengthArray<VkVertexInputBindingDescription, 4> vertexBindings;
     QVarLengthArray<VkVertexInputBindingDivisorDescriptionEXT> nonOneStepRates;
-    for (int i = 0, ie = bindings.count(); i != ie; ++i) {
-        const QRhiVertexInputBinding &binding(bindings[i]);
+    int bindingIndex = 0;
+    for (auto it = m_vertexInputLayout.cbeginBindings(), itEnd = m_vertexInputLayout.cendBindings();
+         it != itEnd; ++it, ++bindingIndex)
+    {
         VkVertexInputBindingDescription bindingInfo = {
-            uint32_t(i),
-            binding.stride(),
-            binding.classification() == QRhiVertexInputBinding::PerVertex
+            uint32_t(bindingIndex),
+            it->stride(),
+            it->classification() == QRhiVertexInputBinding::PerVertex
                 ? VK_VERTEX_INPUT_RATE_VERTEX : VK_VERTEX_INPUT_RATE_INSTANCE
         };
-        if (binding.classification() == QRhiVertexInputBinding::PerInstance
-                && binding.instanceStepRate() != 1)
-        {
+        if (it->classification() == QRhiVertexInputBinding::PerInstance && it->instanceStepRate() != 1) {
             if (rhiD->vertexAttribDivisorAvailable) {
-                nonOneStepRates.append({ uint32_t(i), uint32_t(binding.instanceStepRate()) });
+                nonOneStepRates.append({ uint32_t(bindingIndex), uint32_t(it->instanceStepRate()) });
             } else {
                 qWarning("QRhiVulkan: Instance step rates other than 1 not supported without "
                          "VK_EXT_vertex_attribute_divisor on the device and "
@@ -5852,14 +5956,15 @@ bool QVkGraphicsPipeline::build()
         }
         vertexBindings.append(bindingInfo);
     }
-    const QVector<QRhiVertexInputAttribute> attributes = m_vertexInputLayout.attributes();
     QVarLengthArray<VkVertexInputAttributeDescription, 4> vertexAttributes;
-    for (const QRhiVertexInputAttribute &attribute : attributes) {
+    for (auto it = m_vertexInputLayout.cbeginAttributes(), itEnd = m_vertexInputLayout.cendAttributes();
+         it != itEnd; ++it)
+    {
         VkVertexInputAttributeDescription attributeInfo = {
-            uint32_t(attribute.location()),
-            uint32_t(attribute.binding()),
-            toVkAttributeFormat(attribute.format()),
-            attribute.offset()
+            uint32_t(it->location()),
+            uint32_t(it->binding()),
+            toVkAttributeFormat(it->format()),
+            it->offset()
         };
         vertexAttributes.append(attributeInfo);
     }
diff --git a/src/gui/rhi/qrhivulkan_p_p.h b/src/gui/rhi/qrhivulkan_p_p.h
index d83a338acd..d0e1e6758b 100644
--- a/src/gui/rhi/qrhivulkan_p_p.h
+++ b/src/gui/rhi/qrhivulkan_p_p.h
@@ -79,7 +79,7 @@ struct QVkBuffer : public QRhiBuffer
 
     VkBuffer buffers[QVK_FRAMES_IN_FLIGHT];
     QVkAlloc allocations[QVK_FRAMES_IN_FLIGHT];
-    QVector<QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate> pendingDynamicUpdates[QVK_FRAMES_IN_FLIGHT];
+    QVarLengthArray<QRhiResourceUpdateBatchPrivate::BufferOp, 16> pendingDynamicUpdates[QVK_FRAMES_IN_FLIGHT];
     VkBuffer stagingBuffers[QVK_FRAMES_IN_FLIGHT];
     QVkAlloc stagingAllocations[QVK_FRAMES_IN_FLIGHT];
     struct UsageState {
@@ -732,7 +732,8 @@ public:
                                  VkSampleCountFlagBits samples,
                                  VkFormat colorFormat);
     bool createOffscreenRenderPass(VkRenderPass *rp,
-                                   const QVector<QRhiColorAttachment> &colorAttachments,
+                                   const QRhiColorAttachment *firstColorAttachment,
+                                   const QRhiColorAttachment *lastColorAttachment,
                                    bool preserveColor,
                                    bool preserveDs,
                                    QRhiRenderBuffer *depthStencilBuffer,
@@ -852,17 +853,25 @@ public:
         VkFence cmdFence = VK_NULL_HANDLE;
     } ofr;
 
-    struct ActiveReadback {
+    struct TextureReadback {
         int activeFrameSlot = -1;
         QRhiReadbackDescription desc;
         QRhiReadbackResult *result;
-        VkBuffer buf;
-        QVkAlloc bufAlloc;
-        quint32 bufSize;
+        VkBuffer stagingBuf;
+        QVkAlloc stagingAlloc;
+        quint32 byteSize;
         QSize pixelSize;
         QRhiTexture::Format format;
     };
-    QVector<ActiveReadback> activeReadbacks;
+    QVector<TextureReadback> activeTextureReadbacks;
+    struct BufferReadback {
+        int activeFrameSlot = -1;
+        QRhiBufferReadbackResult *result;
+        int byteSize;
+        VkBuffer stagingBuf;
+        QVkAlloc stagingAlloc;
+    };
+    QVector<BufferReadback> activeBufferReadbacks;
 
     struct DeferredReleaseEntry {
         enum Type {
@@ -932,7 +941,8 @@ public:
 
 Q_DECLARE_TYPEINFO(QRhiVulkan::DescriptorPoolData, Q_MOVABLE_TYPE);
 Q_DECLARE_TYPEINFO(QRhiVulkan::DeferredReleaseEntry, Q_MOVABLE_TYPE);
-Q_DECLARE_TYPEINFO(QRhiVulkan::ActiveReadback, Q_MOVABLE_TYPE);
+Q_DECLARE_TYPEINFO(QRhiVulkan::TextureReadback, Q_MOVABLE_TYPE);
+Q_DECLARE_TYPEINFO(QRhiVulkan::BufferReadback, Q_MOVABLE_TYPE);
 
 QT_END_NAMESPACE
 
diff --git a/src/gui/text/qabstracttextdocumentlayout.cpp b/src/gui/text/qabstracttextdocumentlayout.cpp
index 5263ece87c..8b8f3e28ac 100644
--- a/src/gui/text/qabstracttextdocumentlayout.cpp
+++ b/src/gui/text/qabstracttextdocumentlayout.cpp
@@ -660,7 +660,7 @@ QTextBlock QAbstractTextDocumentLayout::blockWithMarkerAt(const QPointF &pos) co
 {
     QTextBlock block = document()->firstBlock();
     while (block.isValid()) {
-        if (block.blockFormat().marker() != QTextBlockFormat::NoMarker) {
+        if (block.blockFormat().marker() != QTextBlockFormat::MarkerType::NoMarker) {
             QRectF blockBr = blockBoundingRect(block);
             QTextBlockFormat blockFmt = block.blockFormat();
             QFontMetrics fm(block.charFormat().font());
diff --git a/src/gui/text/qfont.cpp b/src/gui/text/qfont.cpp
index efc79a1783..76fde5388c 100644
--- a/src/gui/text/qfont.cpp
+++ b/src/gui/text/qfont.cpp
@@ -3176,8 +3176,7 @@ QDebug operator<<(QDebug stream, const QFont &font)
     QDebug debug(&fontDescription);
     debug.nospace();
 
-    QFontPrivate priv;
-    const QFont defaultFont(&priv);
+    const QFont defaultFont(new QFontPrivate);
 
     for (int property = QFont::FamilyResolved; property < QFont::AllPropertiesResolved; property <<= 1) {
         const bool resolved = (font.resolve_mask & property) != 0;
diff --git a/src/gui/text/qfontdatabase.cpp b/src/gui/text/qfontdatabase.cpp
index ce6bb0c347..261e1d831b 100644
--- a/src/gui/text/qfontdatabase.cpp
+++ b/src/gui/text/qfontdatabase.cpp
@@ -2684,7 +2684,7 @@ QFontEngine *QFontDatabase::findFont(const QFontDef &request, int script)
     QtFontDesc desc;
     QList<int> blackListed;
     int index = match(multi ? QChar::Script_Common : script, request, family_name, foundry_name, &desc, blackListed);
-    if (index < 0 && QGuiApplicationPrivate::platformIntegration()->fontDatabase()->populateFamilyAliases()) {
+    if (index < 0 && QGuiApplicationPrivate::platformIntegration()->fontDatabase()->populateFamilyAliases(family_name)) {
         // We populated familiy aliases (e.g. localized families), so try again
         index = match(multi ? QChar::Script_Common : script, request, family_name, foundry_name, &desc, blackListed);
     }
diff --git a/src/gui/text/qplatformfontdatabase.h b/src/gui/text/qplatformfontdatabase.h
index 38ba7f10b2..f79c5db625 100644
--- a/src/gui/text/qplatformfontdatabase.h
+++ b/src/gui/text/qplatformfontdatabase.h
@@ -104,7 +104,7 @@ class Q_GUI_EXPORT QPlatformFontDatabase
 public:
     virtual ~QPlatformFontDatabase();
     virtual void populateFontDatabase();
-    virtual bool populateFamilyAliases() { return false; }
+    virtual bool populateFamilyAliases(const QString &missingFamily) { Q_UNUSED(missingFamily); return false; }
     virtual void populateFamily(const QString &familyName);
     virtual void invalidate();
 
diff --git a/src/gui/text/qtextdocumentfragment.cpp b/src/gui/text/qtextdocumentfragment.cpp
index 723e5c907c..742c56382d 100644
--- a/src/gui/text/qtextdocumentfragment.cpp
+++ b/src/gui/text/qtextdocumentfragment.cpp
@@ -1062,6 +1062,7 @@ QTextHtmlImporter::ProcessNodeResult QTextHtmlImporter::processBlockNode()
                     fmt.setLeftPadding(leftPadding(currentNodeIdx));
                 if (rightPadding(currentNodeIdx) >= 0)
                     fmt.setRightPadding(rightPadding(currentNodeIdx));
+#ifndef QT_NO_CSSPARSER
                 if (tableCellBorder(currentNodeIdx, QCss::TopEdge) > 0)
                     fmt.setTopBorder(tableCellBorder(currentNodeIdx, QCss::TopEdge));
                 if (tableCellBorder(currentNodeIdx, QCss::RightEdge) > 0)
@@ -1086,6 +1087,7 @@ QTextHtmlImporter::ProcessNodeResult QTextHtmlImporter::processBlockNode()
                     fmt.setBottomBorderBrush(tableCellBorderBrush(currentNodeIdx, QCss::BottomEdge));
                 if (tableCellBorderBrush(currentNodeIdx, QCss::LeftEdge) != Qt::NoBrush)
                     fmt.setLeftBorderBrush(tableCellBorderBrush(currentNodeIdx, QCss::LeftEdge));
+#endif
 
                 cell.setFormat(fmt);
 
diff --git a/src/gui/text/qtextdocumentlayout.cpp b/src/gui/text/qtextdocumentlayout.cpp
index a9a177da8b..7be114adf9 100644
--- a/src/gui/text/qtextdocumentlayout.cpp
+++ b/src/gui/text/qtextdocumentlayout.cpp
@@ -265,6 +265,9 @@ public:
 
     inline QFixed topPadding(QTextTable *table, const QTextTableCell &cell) const
     {
+#ifdef QT_NO_CSSPARSER
+        Q_UNUSED(table);
+#endif
         return paddingProperty(cell.format(), QTextFormat::TableCellTopPadding)
 #ifndef QT_NO_CSSPARSER
                 + cellBorderWidth(table, cell, QCss::TopEdge)
@@ -274,6 +277,9 @@ public:
 
     inline QFixed bottomPadding(QTextTable *table, const QTextTableCell &cell) const
     {
+#ifdef QT_NO_CSSPARSER
+        Q_UNUSED(table);
+#endif
         return paddingProperty(cell.format(), QTextFormat::TableCellBottomPadding)
 #ifndef QT_NO_CSSPARSER
                 + cellBorderWidth(table, cell, QCss::BottomEdge)
@@ -283,6 +289,9 @@ public:
 
     inline QFixed leftPadding(QTextTable *table, const QTextTableCell &cell) const
     {
+#ifdef QT_NO_CSSPARSER
+        Q_UNUSED(table);
+#endif
         return paddingProperty(cell.format(), QTextFormat::TableCellLeftPadding)
 #ifndef QT_NO_CSSPARSER
                 + cellBorderWidth(table, cell, QCss::LeftEdge)
@@ -292,6 +301,9 @@ public:
 
     inline QFixed rightPadding(QTextTable *table, const QTextTableCell &cell) const
     {
+#ifdef QT_NO_CSSPARSER
+        Q_UNUSED(table);
+#endif
         return paddingProperty(cell.format(), QTextFormat::TableCellRightPadding)
 #ifndef QT_NO_CSSPARSER
                 + cellBorderWidth(table, cell, QCss::RightEdge)
@@ -1034,15 +1046,22 @@ static bool cellClipTest(QTextTable *table, QTextTableData *td,
                          const QTextTableCell &cell,
                          QRectF cellRect)
 {
+#ifdef QT_NO_CSSPARSER
+    Q_UNUSED(table);
+    Q_UNUSED(cell);
+#endif
+
     if (!cell_context.clip.isValid())
         return false;
 
     if (td->borderCollapse) {
         // we need to account for the cell borders in the clipping test
+#ifndef QT_NO_CSSPARSER
         cellRect.adjust(-axisEdgeData(table, td, cell, QCss::LeftEdge).width / 2,
                         -axisEdgeData(table, td, cell, QCss::TopEdge).width / 2,
                         axisEdgeData(table, td, cell, QCss::RightEdge).width / 2,
                         axisEdgeData(table, td, cell, QCss::BottomEdge).width / 2);
+#endif
     } else {
         qreal border = td->border.toReal();
         cellRect.adjust(-border, -border, border, border);
@@ -1798,6 +1817,13 @@ void QTextDocumentLayoutPrivate::drawTableCellBorder(const QRectF &cellRect, QPa
 
     if (turn_off_antialiasing)
         painter->setRenderHint(QPainter::Antialiasing, false);
+#else
+    Q_UNUSED(cell);
+    Q_UNUSED(cellRect);
+    Q_UNUSED(painter);
+    Q_UNUSED(table);
+    Q_UNUSED(td);
+    Q_UNUSED(cell);
 #endif
 }
 
@@ -2168,11 +2194,11 @@ void QTextDocumentLayoutPrivate::drawListItem(const QPointF &offset, QPainter *p
 
     QBrush brush = context.palette.brush(QPalette::Text);
 
-    bool marker = bl.blockFormat().marker() != QTextBlockFormat::NoMarker;
+    bool marker = bl.blockFormat().marker() != QTextBlockFormat::MarkerType::NoMarker;
     if (marker) {
         int adj = fontMetrics.lineSpacing() / 6;
         r.adjust(-adj, 0, -adj, 0);
-        if (bl.blockFormat().marker() == QTextBlockFormat::Checked) {
+        if (bl.blockFormat().marker() == QTextBlockFormat::MarkerType::Checked) {
             // ### Qt6: render with QStyle / PE_IndicatorCheckBox. We don't currently
             // have access to that here, because it would be a widget dependency.
             painter->setPen(QPen(painter->pen().color(), 2));
@@ -2285,12 +2311,14 @@ QTextLayoutStruct QTextDocumentLayoutPrivate::layoutCell(QTextTable *t, const QT
             + td->border
             + td->paddingProperty(cell.format(), QTextFormat::TableCellTopPadding); // top cell-border is not repeated
 
+#ifndef QT_NO_CSSPARSER
     const int headerRowCount = t->format().headerRowCount();
     if (td->borderCollapse && headerRowCount > 0) {
         // consider the header row's bottom edge width
         qreal headerRowBottomBorderWidth = axisEdgeData(t, td, t->cellAt(headerRowCount - 1, cell.column()), QCss::BottomEdge).width;
         layoutStruct.pageTopMargin += QFixed::fromReal(scaleToDevice(headerRowBottomBorderWidth) / 2);
     }
+#endif
 
     layoutStruct.pageBottomMargin = td->effectiveBottomMargin + td->cellSpacing + td->effectiveBottomBorder + td->bottomPadding(t, cell);
     layoutStruct.pageBottom = (currentPage + 1) * layoutStruct.pageHeight - layoutStruct.pageBottomMargin;
diff --git a/src/gui/text/qtextengine.cpp b/src/gui/text/qtextengine.cpp
index b37353bf2c..209433dac5 100644
--- a/src/gui/text/qtextengine.cpp
+++ b/src/gui/text/qtextengine.cpp
@@ -2125,22 +2125,7 @@ void QTextEngine::itemize() const
     }
 #if QT_CONFIG(harfbuzz)
     analysis = scriptAnalysis.data();
-    if (qt_useHarfbuzzNG()) {
-        // ### pretend HB-old behavior for now
-        for (int i = 0; i < length; ++i) {
-            switch (analysis[i].script) {
-            case QChar::Script_Latin:
-            case QChar::Script_Hiragana:
-            case QChar::Script_Katakana:
-            case QChar::Script_Bopomofo:
-            case QChar::Script_Han:
-                analysis[i].script = QChar::Script_Common;
-                break;
-            default:
-                break;
-            }
-        }
-    } else {
+    if (!qt_useHarfbuzzNG()) {
         for (int i = 0; i < length; ++i)
             analysis[i].script = hbscript_to_script(script_to_hbscript(analysis[i].script));
     }
@@ -3619,7 +3604,12 @@ int QTextEngine::positionInLigature(const QScriptItem *si, int end,
     int clusterLength = 0;
 
     if (si->analysis.script != QChar::Script_Common &&
-        si->analysis.script != QChar::Script_Greek) {
+        si->analysis.script != QChar::Script_Greek &&
+        si->analysis.script != QChar::Script_Latin &&
+        si->analysis.script != QChar::Script_Hiragana &&
+        si->analysis.script != QChar::Script_Katakana &&
+        si->analysis.script != QChar::Script_Bopomofo &&
+        si->analysis.script != QChar::Script_Han) {
         if (glyph_pos == -1)
             return si->position + end;
         else {
diff --git a/src/gui/text/qtextformat.h b/src/gui/text/qtextformat.h
index 12f14a1555..28da0fe344 100644
--- a/src/gui/text/qtextformat.h
+++ b/src/gui/text/qtextformat.h
@@ -627,7 +627,7 @@ public:
         LineDistanceHeight = 4
     };
 
-    enum MarkerType {
+    enum class MarkerType {
         NoMarker = 0,
         Unchecked = 1,
         Checked = 2
diff --git a/src/gui/text/qtextmarkdownimporter.cpp b/src/gui/text/qtextmarkdownimporter.cpp
index b96263f5fc..fe7e422923 100644
--- a/src/gui/text/qtextmarkdownimporter.cpp
+++ b/src/gui/text/qtextmarkdownimporter.cpp
@@ -190,8 +190,8 @@ int QTextMarkdownImporter::cbEnterBlock(int blockType, void *det)
         m_listItem = true;
         MD_BLOCK_LI_DETAIL *detail = static_cast<MD_BLOCK_LI_DETAIL *>(det);
         m_markerType = detail->is_task ?
-                    (detail->task_mark == ' ' ? QTextBlockFormat::Unchecked : QTextBlockFormat::Checked) :
-                    QTextBlockFormat::NoMarker;
+                    (detail->task_mark == ' ' ? QTextBlockFormat::MarkerType::Unchecked : QTextBlockFormat::MarkerType::Checked) :
+                    QTextBlockFormat::MarkerType::NoMarker;
         qCDebug(lcMD) << "LI";
     } break;
     case MD_BLOCK_UL: {
@@ -549,7 +549,7 @@ void QTextMarkdownImporter::insertBlock()
         blockFormat.setTopMargin(m_paragraphMargin);
         blockFormat.setBottomMargin(m_paragraphMargin);
     }
-    if (m_markerType == QTextBlockFormat::NoMarker)
+    if (m_markerType == QTextBlockFormat::MarkerType::NoMarker)
         blockFormat.clearProperty(QTextFormat::BlockMarker);
     else
         blockFormat.setMarker(m_markerType);
diff --git a/src/gui/text/qtextmarkdownimporter_p.h b/src/gui/text/qtextmarkdownimporter_p.h
index 1b8c2ca354..35655aff8a 100644
--- a/src/gui/text/qtextmarkdownimporter_p.h
+++ b/src/gui/text/qtextmarkdownimporter_p.h
@@ -128,7 +128,7 @@ private:
     Features m_features;
     QTextImageFormat m_imageFormat;
     QTextListFormat m_listFormat;
-    QTextBlockFormat::MarkerType m_markerType = QTextBlockFormat::NoMarker;
+    QTextBlockFormat::MarkerType m_markerType = QTextBlockFormat::MarkerType::NoMarker;
     bool m_needsInsertBlock = false;
     bool m_needsInsertList = false;
     bool m_listItem = false; // true from the beginning of LI to the end of the first P
diff --git a/src/gui/text/qtextmarkdownwriter.cpp b/src/gui/text/qtextmarkdownwriter.cpp
index cbfb092485..764c64aead 100644
--- a/src/gui/text/qtextmarkdownwriter.cpp
+++ b/src/gui/text/qtextmarkdownwriter.cpp
@@ -327,10 +327,10 @@ int QTextMarkdownWriter::writeBlock(const QTextBlock &block, bool wrap, bool ign
             break;
         }
         switch (blockFmt.marker()) {
-        case QTextBlockFormat::Checked:
+        case QTextBlockFormat::MarkerType::Checked:
             bullet += " [x]";
             break;
-        case QTextBlockFormat::Unchecked:
+        case QTextBlockFormat::MarkerType::Unchecked:
             bullet += " [ ]";
             break;
         default:
diff --git a/src/gui/text/qtextodfwriter.cpp b/src/gui/text/qtextodfwriter.cpp
index 3561c185a6..0e8666565f 100644
--- a/src/gui/text/qtextodfwriter.cpp
+++ b/src/gui/text/qtextodfwriter.cpp
@@ -358,7 +358,7 @@ void QTextOdfWriter::writeBlock(QXmlStreamWriter &writer, const QTextBlock &bloc
         int precedingSpaces = 0;
         int exportedIndex = 0;
         for (int i=0; i <= fragmentText.count(); ++i) {
-            QChar character = fragmentText[i];
+            QChar character = (i == fragmentText.count() ? QChar() : fragmentText.at(i));
             bool isSpace = character.unicode() == ' ';
 
             // find more than one space. -> <text:s text:c="2" />
diff --git a/src/gui/vulkan/qvulkanwindow.cpp b/src/gui/vulkan/qvulkanwindow.cpp
index 6d12377a60..4b5c2b56ee 100644
--- a/src/gui/vulkan/qvulkanwindow.cpp
+++ b/src/gui/vulkan/qvulkanwindow.cpp
@@ -498,12 +498,12 @@ QVector<int> QVulkanWindow::supportedSampleCounts()
     VkSampleCountFlags depth = limits->framebufferDepthSampleCounts;
     VkSampleCountFlags stencil = limits->framebufferStencilSampleCounts;
 
-    for (size_t i = 0; i < sizeof(qvk_sampleCounts) / sizeof(qvk_sampleCounts[0]); ++i) {
-        if ((color & qvk_sampleCounts[i].mask)
-                && (depth & qvk_sampleCounts[i].mask)
-                && (stencil & qvk_sampleCounts[i].mask))
+    for (const auto &qvk_sampleCount : qvk_sampleCounts) {
+        if ((color & qvk_sampleCount.mask)
+                && (depth & qvk_sampleCount.mask)
+                && (stencil & qvk_sampleCount.mask))
         {
-            result.append(qvk_sampleCounts[i].count);
+            result.append(qvk_sampleCount.count);
         }
     }
 
@@ -547,9 +547,9 @@ void QVulkanWindow::setSampleCount(int sampleCount)
         return;
     }
 
-    for (size_t i = 0; i < sizeof(qvk_sampleCounts) / sizeof(qvk_sampleCounts[0]); ++i) {
-        if (qvk_sampleCounts[i].count == sampleCount) {
-            d->sampleCount = qvk_sampleCounts[i].mask;
+    for (const auto &qvk_sampleCount : qvk_sampleCounts) {
+        if (qvk_sampleCount.count == sampleCount) {
+            d->sampleCount = qvk_sampleCount.mask;
             return;
         }
     }
diff --git a/src/network/access/qhttp2protocolhandler.cpp b/src/network/access/qhttp2protocolhandler.cpp
index 9bf5547f15..dce51d4fd5 100644
--- a/src/network/access/qhttp2protocolhandler.cpp
+++ b/src/network/access/qhttp2protocolhandler.cpp
@@ -1339,14 +1339,13 @@ void QHttp2ProtocolHandler::markAsReset(quint32 streamID)
 quint32 QHttp2ProtocolHandler::popStreamToResume()
 {
     quint32 streamID = connectionStreamID;
-    const int nQ = sizeof suspendedStreams / sizeof suspendedStreams[0];
     using QNR = QHttpNetworkRequest;
-    const QNR::Priority ranks[nQ] = {QNR::HighPriority,
-                                     QNR::NormalPriority,
-                                     QNR::LowPriority};
+    const QNR::Priority ranks[] = {QNR::HighPriority,
+                                   QNR::NormalPriority,
+                                   QNR::LowPriority};
 
-    for (int i = 0; i < nQ; ++i) {
-        auto &queue = suspendedStreams[ranks[i]];
+    for (const QNR::Priority rank : ranks) {
+        auto &queue = suspendedStreams[rank];
         auto it = queue.begin();
         for (; it != queue.end(); ++it) {
             if (!activeStreams.contains(*it))
@@ -1367,9 +1366,7 @@ quint32 QHttp2ProtocolHandler::popStreamToResume()
 
 void QHttp2ProtocolHandler::removeFromSuspended(quint32 streamID)
 {
-    const int nQ = sizeof suspendedStreams / sizeof suspendedStreams[0];
-    for (int i = 0; i < nQ; ++i) {
-        auto &q = suspendedStreams[i];
+    for (auto &q : suspendedStreams) {
         q.erase(std::remove(q.begin(), q.end(), streamID), q.end());
     }
 }
diff --git a/src/network/configure.json b/src/network/configure.json
index bebe592088..f501465c91 100644
--- a/src/network/configure.json
+++ b/src/network/configure.json
@@ -98,6 +98,30 @@
                     "condition": "!config.msvc"
                 }
             ]
+        },
+        "gssapi": {
+            "label": "KRB5 GSSAPI Support",
+            "test": {
+                "head": [
+                    "#if defined(__APPLE__) && (defined(__GNUC__) || defined(__xlC__) || defined(__xlc__))",
+                    "#  include <TargetConditionals.h>",
+                    "#  if defined(TARGET_OS_MAC) && TARGET_OS_MAC",
+                    "#    include <GSS/GSS.h>",
+                    "#  endif",
+                    "#else",
+                    "#  include <gssapi/gssapi.h>",
+                    "#endif"
+                ],
+                "main": [
+                  "gss_ctx_id_t ctx;",
+                  "gss_context_time(nullptr, ctx, nullptr);"
+                ]
+            },
+            "sources": [
+                { "libs": "-framework GSS", "condition": "config.darwin" },
+                { "type": "pkgConfig", "args": "krb5-gssapi" },
+                "-lgssapi_krb5"
+            ]
         }
     },
 
@@ -200,15 +224,6 @@
             },
             "use": "openssl"
         },
-        "gssapi": {
-            "label": "KRB5 GSSAPI support",
-            "type": "compile",
-            "test": {
-                "include": [ "gssapi/gssapi.h" ],
-                "main": ["gss_ctx_id_t ctx;"],
-                "qmake": "LIBS += -lgssapi_krb5"
-            }
-        },
         "netlistmgr": {
             "label": "Network List Manager",
             "type": "compile",
@@ -408,7 +423,7 @@
             "label": "GSSAPI",
             "purpose": "Enable SPNEGO authentication through GSSAPI",
             "section": "Networking",
-            "condition": "!config.win32 && tests.gssapi",
+            "condition": "!config.win32 && libs.gssapi",
             "output": [ "publicFeature", "feature" ]
         },
         "sspi": {
diff --git a/src/network/kernel/kernel.pri b/src/network/kernel/kernel.pri
index a55648dbc7..110d9f56bf 100644
--- a/src/network/kernel/kernel.pri
+++ b/src/network/kernel/kernel.pri
@@ -83,7 +83,7 @@ macos | ios {
     SOURCES += kernel/qnetconmonitor_stub.cpp
 }
 
-qtConfig(gssapi): LIBS_PRIVATE += -lgssapi_krb5
+qtConfig(gssapi): QMAKE_USE_PRIVATE += gssapi
 
 uikit:HEADERS += kernel/qnetworkinterface_uikit_p.h
 osx:SOURCES += kernel/qnetworkproxy_mac.cpp
diff --git a/src/network/kernel/qauthenticator.cpp b/src/network/kernel/qauthenticator.cpp
index 4100dfd784..33a30eb1cd 100644
--- a/src/network/kernel/qauthenticator.cpp
+++ b/src/network/kernel/qauthenticator.cpp
@@ -59,8 +59,12 @@
 #define SECURITY_WIN32 1
 #include <security.h>
 #elif QT_CONFIG(gssapi) // GSSAPI
+#if defined(Q_OS_DARWIN)
+#include <GSS/GSS.h>
+#else
 #include <gssapi/gssapi.h>
-#endif
+#endif // Q_OS_DARWIN
+#endif // Q_CONFIG(sspi)
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/network/ssl/qsslerror.h b/src/network/ssl/qsslerror.h
index c4a0d52193..28eb1a9ea8 100644
--- a/src/network/ssl/qsslerror.h
+++ b/src/network/ssl/qsslerror.h
@@ -53,6 +53,7 @@ QT_BEGIN_NAMESPACE
 class QSslErrorPrivate;
 class Q_NETWORK_EXPORT QSslError
 {
+    Q_GADGET
 public:
     enum SslError {
         NoError,
@@ -94,6 +95,7 @@ public:
         OcspStatusUnknown,
         UnspecifiedError = -1
     };
+    Q_ENUM(SslError)
 
     // RVCT compiler in debug build does not like about default values in const-
     // So as an workaround we define all constructor overloads here explicitly
diff --git a/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp b/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp
index e8ff40304e..2546f6dc13 100644
--- a/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp
+++ b/src/opengl/gl2paintengineex/qpaintengineex_opengl2.cpp
@@ -1391,6 +1391,8 @@ void QGL2PaintEngineEx::renderHintsChanged()
     state()->renderHintsChanged = true;
 
 #if !defined(QT_OPENGL_ES_2)
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
     if (!d->ctx->contextHandle()->isOpenGLES()) {
         if ((state()->renderHints & QPainter::Antialiasing)
 #if QT_DEPRECATED_SINCE(5, 14)
@@ -1401,6 +1403,7 @@ void QGL2PaintEngineEx::renderHintsChanged()
         else
             d->glDisable(GL_MULTISAMPLE);
     }
+QT_WARNING_POP
 #endif
 
     d->lastTextureUsed = GLuint(-1);
diff --git a/src/platformsupport/edid/qedidparser.cpp b/src/platformsupport/edid/qedidparser.cpp
index 06c8852825..6bf1f1db96 100644
--- a/src/platformsupport/edid/qedidparser.cpp
+++ b/src/platformsupport/edid/qedidparser.cpp
@@ -42,8 +42,6 @@
 #include "qedidparser_p.h"
 #include "qedidvendortable_p.h"
 
-#define ARRAY_LENGTH(a) (sizeof (a) / sizeof (a)[0])
-
 #define EDID_DESCRIPTOR_ALPHANUMERIC_STRING 0xfe
 #define EDID_DESCRIPTOR_PRODUCT_NAME 0xfc
 #define EDID_DESCRIPTOR_SERIAL_NUMBER 0xff
@@ -139,9 +137,9 @@ bool QEdidParser::parse(const QByteArray &blob)
     manufacturer = m_vendorCache.value(pnpIdString);
     if (manufacturer.isEmpty()) {
         // Find the manufacturer from the vendor lookup table
-        for (size_t i = 0; i < ARRAY_LENGTH(q_edidVendorTable); i++) {
-            if (strncmp(q_edidVendorTable[i].id, pnpId, 3) == 0) {
-                manufacturer = QString::fromUtf8(q_edidVendorTable[i].name);
+        for (const auto &vendor : q_edidVendorTable) {
+            if (strncmp(vendor.id, pnpId, 3) == 0) {
+                manufacturer = QString::fromUtf8(vendor.name);
                 break;
             }
         }
diff --git a/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm b/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
index ac4a8f35f8..daa3dc94ea 100644
--- a/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
+++ b/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
@@ -48,6 +48,8 @@
 #import <UIKit/UIFont.h>
 #endif
 
+#include <QtCore/qelapsedtimer.h>
+
 #include "qcoretextfontdatabase_p.h"
 #include "qfontengine_coretext_p.h"
 #if QT_CONFIG(settings)
@@ -113,39 +115,77 @@ QCoreTextFontDatabase::~QCoreTextFontDatabase()
 
 void QCoreTextFontDatabase::populateFontDatabase()
 {
+    qCDebug(lcQpaFonts) << "Populating font database...";
+    QElapsedTimer elapsed;
+    if (lcQpaFonts().isDebugEnabled())
+        elapsed.start();
+
     QCFType<CFArrayRef> familyNames = CTFontManagerCopyAvailableFontFamilyNames();
     for (NSString *familyName in familyNames.as<const NSArray *>())
         QPlatformFontDatabase::registerFontFamily(QString::fromNSString(familyName));
 
+    qCDebug(lcQpaFonts) << "Populating available families took" << elapsed.restart() << "ms";
+
     // Force creating the theme fonts to get the descriptors in m_systemFontDescriptors
     if (m_themeFonts.isEmpty())
         (void)themeFonts();
 
+    qCDebug(lcQpaFonts) << "Resolving theme fonts took" << elapsed.restart() << "ms";
+
     Q_FOREACH (CTFontDescriptorRef fontDesc, m_systemFontDescriptors)
         populateFromDescriptor(fontDesc);
 
+    qCDebug(lcQpaFonts) << "Populating system descriptors took" << elapsed.restart() << "ms";
+
     Q_ASSERT(!m_hasPopulatedAliases);
 }
 
-bool QCoreTextFontDatabase::populateFamilyAliases()
+bool QCoreTextFontDatabase::populateFamilyAliases(const QString &missingFamily)
 {
 #if defined(Q_OS_MACOS)
     if (m_hasPopulatedAliases)
         return false;
 
+    // There's no API to go from a localized family name to its non-localized
+    // name, so we have to resort to enumerating all the available fonts and
+    // doing a reverse lookup.
+
+    qCDebug(lcQpaFonts) << "Populating family aliases...";
+    QElapsedTimer elapsed;
+    elapsed.start();
+
+    QString nonLocalizedMatch;
     QCFType<CFArrayRef> familyNames = CTFontManagerCopyAvailableFontFamilyNames();
+    NSFontManager *fontManager = NSFontManager.sharedFontManager;
     for (NSString *familyName in familyNames.as<const NSArray *>()) {
-        NSFontManager *fontManager = [NSFontManager sharedFontManager];
         NSString *localizedFamilyName = [fontManager localizedNameForFamily:familyName face:nil];
         if (![localizedFamilyName isEqual:familyName]) {
-            QPlatformFontDatabase::registerAliasToFontFamily(
-                QString::fromNSString(familyName),
-                QString::fromNSString(localizedFamilyName));
+            QString nonLocalizedFamily = QString::fromNSString(familyName);
+            QString localizedFamily = QString::fromNSString(localizedFamilyName);
+            QPlatformFontDatabase::registerAliasToFontFamily(nonLocalizedFamily, localizedFamily);
+            if (localizedFamily == missingFamily)
+                nonLocalizedMatch = nonLocalizedFamily;
         }
     }
     m_hasPopulatedAliases = true;
+
+    if (lcQpaFonts().isWarningEnabled()) {
+        QString warningMessage;
+        QDebug msg(&warningMessage);
+
+        msg << "Populating font family aliases took" << elapsed.restart() << "ms.";
+        if (!nonLocalizedMatch.isNull())
+            msg << "Replace uses of" << missingFamily << "with its non-localized name" << nonLocalizedMatch;
+        else
+            msg << "Replace uses of missing font family" << missingFamily << "with one that exists";
+        msg << "to avoid this cost.";
+
+        qCWarning(lcQpaFonts) << qPrintable(warningMessage);
+    }
+
     return true;
 #else
+    Q_UNUSED(missingFamily);
     return false;
 #endif
 }
@@ -159,7 +199,7 @@ void QCoreTextFontDatabase::populateFamily(const QString &familyName)
     // A single family might match several different fonts with different styles eg.
     QCFType<CFArrayRef> matchingFonts = (CFArrayRef) CTFontDescriptorCreateMatchingFontDescriptors(nameOnlyDescriptor, 0);
     if (!matchingFonts) {
-        qWarning() << "QCoreTextFontDatabase: Found no matching fonts for family" << familyName;
+        qCWarning(lcQpaFonts) << "QCoreTextFontDatabase: Found no matching fonts for family" << familyName;
         return;
     }
 
@@ -392,88 +432,142 @@ template class QCoreTextFontDatabaseEngineFactory<QCoreTextFontEngine>;
 template class QCoreTextFontDatabaseEngineFactory<QFontEngineFT>;
 #endif
 
-QStringList QCoreTextFontDatabase::fallbacksForFamily(const QString &family)
+CTFontDescriptorRef descriptorForFamily(const QString &familyName)
 {
-    if (family.isEmpty())
-        return QStringList();
+    return CTFontDescriptorCreateWithAttributes(CFDictionaryRef(@{
+        (id)kCTFontFamilyNameAttribute: familyName.toNSString()
+    }));
+}
 
-    auto attributes = @{ id(kCTFontFamilyNameAttribute): family.toNSString() };
-    QCFType<CTFontDescriptorRef> fontDescriptor = CTFontDescriptorCreateWithAttributes(CFDictionaryRef(attributes));
-    if (!fontDescriptor) {
-        qWarning() << "Failed to create fallback font descriptor for" << family;
-        return QStringList();
-    }
+CTFontDescriptorRef descriptorForFamily(const char *familyName)
+{
+    return descriptorForFamily(QString::fromLatin1(familyName));
+}
 
-    QCFType<CTFontRef> font = CTFontCreateWithFontDescriptor(fontDescriptor, 12.0, 0);
+CFArrayRef fallbacksForDescriptor(CTFontDescriptorRef descriptor)
+{
+    QCFType<CTFontRef> font = CTFontCreateWithFontDescriptor(descriptor, 0.0, nullptr);
     if (!font) {
-        qWarning() << "Failed to create fallback font for" << family;
-        return QStringList();
+        qCWarning(lcQpaFonts) << "Failed to create fallback font for" << descriptor;
+        return nullptr;
     }
 
-    QCFType<CFArrayRef> cascadeList = CFArrayRef(CTFontCopyDefaultCascadeListForLanguages(font,
+    CFArrayRef cascadeList = CFArrayRef(CTFontCopyDefaultCascadeListForLanguages(font,
         (CFArrayRef)[NSUserDefaults.standardUserDefaults stringArrayForKey:@"AppleLanguages"]));
+
     if (!cascadeList) {
-        qWarning() << "Failed to create fallback cascade list for" << family;
-        return QStringList();
+        qCWarning(lcQpaFonts) << "Failed to create fallback cascade list for" << descriptor;
+        return nullptr;
     }
 
-    QStringList fallbackList;
-    const int numCascades = CFArrayGetCount(cascadeList);
-    for (int i = 0; i < numCascades; ++i) {
-        CTFontDescriptorRef fontFallback = CTFontDescriptorRef(CFArrayGetValueAtIndex(cascadeList, i));
-        QCFString fallbackFamilyName = CFStringRef(CTFontDescriptorCopyAttribute(fontFallback, kCTFontFamilyNameAttribute));
-        fallbackList.append(QString::fromCFString(fallbackFamilyName));
+    return cascadeList;
+}
+
+CFArrayRef QCoreTextFontDatabase::fallbacksForFamily(const QString &family)
+{
+    if (family.isEmpty())
+        return nullptr;
+
+    QCFType<CTFontDescriptorRef> fontDescriptor = descriptorForFamily(family);
+    if (!fontDescriptor) {
+        qCWarning(lcQpaFonts) << "Failed to create fallback font descriptor for" << family;
+        return nullptr;
     }
 
-    return fallbackList;
+    // If the font is not available we want to fall back to the style hint.
+    // By creating a matching font descriptor we can verify whether the font
+    // is available or not, and avoid CTFontCreateWithFontDescriptor picking
+    // a default font for us based on incomplete information.
+    fontDescriptor = CTFontDescriptorCreateMatchingFontDescriptor(fontDescriptor, 0);
+    if (!fontDescriptor)
+        return nullptr;
+
+    return fallbacksForDescriptor(fontDescriptor);
+}
+
+CTFontDescriptorRef descriptorForFontType(CTFontUIFontType uiType)
+{
+    static const CGFloat kDefaultSizeForRequestedUIType = 0.0;
+    QCFType<CTFontRef> ctFont = CTFontCreateUIFontForLanguage(
+        uiType, kDefaultSizeForRequestedUIType, nullptr);
+    return CTFontCopyFontDescriptor(ctFont);
+}
+
+CTFontDescriptorRef descriptorForStyle(QFont::StyleHint styleHint)
+{
+    switch (styleHint) {
+        case QFont::SansSerif: return descriptorForFamily("Helvetica");
+        case QFont::Serif: return descriptorForFamily("Times New Roman");
+        case QFont::Monospace: return descriptorForFamily("Menlo");
+#ifdef Q_OS_MACOS
+        case QFont::Cursive: return descriptorForFamily("Apple Chancery");
+#endif
+        case QFont::Fantasy: return descriptorForFamily("Zapfino");
+        case QFont::TypeWriter: return descriptorForFamily("American Typewriter");
+        case QFont::AnyStyle: Q_FALLTHROUGH();
+        case QFont::System: return descriptorForFontType(kCTFontUIFontSystem);
+        default: return nullptr; // No matching font on this platform
+    }
 }
 
 QStringList QCoreTextFontDatabase::fallbacksForFamily(const QString &family, QFont::Style style, QFont::StyleHint styleHint, QChar::Script script) const
 {
     Q_UNUSED(style);
 
+    qCDebug(lcQpaFonts).nospace() << "Resolving fallbacks families for"
+        << (!family.isEmpty() ? qPrintable(QLatin1String(" family '%1' with").arg(family)) : "")
+        << " style hint " << styleHint;
+
     QMacAutoReleasePool pool;
 
-    QStringList fallbackList = fallbacksForFamily(family);
+    QStringList fallbackList;
 
-    if (fallbackList.isEmpty()) {
+    QCFType<CFArrayRef> fallbackFonts = fallbacksForFamily(family);
+    if (!fallbackFonts || !CFArrayGetCount(fallbackFonts)) {
         // We were not able to find a fallback for the specific family,
         // or the family was empty, so we fall back to the style hint.
-        QString styleFamily = [styleHint]{
-            switch (styleHint) {
-                case QFont::SansSerif: return QStringLiteral("Helvetica");
-                case QFont::Serif: return QStringLiteral("Times New Roman");
-                case QFont::Monospace: return QStringLiteral("Menlo");
-#ifdef Q_OS_MACOS
-                case QFont::Cursive: return QStringLiteral("Apple Chancery");
-#endif
-                case QFont::Fantasy: return QStringLiteral("Zapfino");
-                case QFont::TypeWriter: return QStringLiteral("American Typewriter");
-                case QFont::AnyStyle: Q_FALLTHROUGH();
-                case QFont::System: {
-                    QCFType<CTFontRef> font = CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, 12.0, NULL);
-                    return static_cast<QString>(QCFString(CTFontCopyFullName(font)));
-                }
-                default: return QString(); // No matching font on this platform
-            }
-        }();
-        if (!styleFamily.isEmpty()) {
-            fallbackList = fallbacksForFamily(styleFamily);
-            if (!fallbackList.contains(styleFamily))
-                fallbackList.prepend(styleFamily);
+        if (!family.isEmpty())
+            qCDebug(lcQpaFonts) << "No fallbacks found. Using style hint instead";
+
+        if (QCFType<CTFontDescriptorRef> styleDescriptor = descriptorForStyle(styleHint)) {
+            CFMutableArrayRef tmp = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
+            CFArrayAppendValue(tmp, styleDescriptor);
+            QCFType<CFArrayRef> styleFallbacks = fallbacksForDescriptor(styleDescriptor);
+            CFArrayAppendArray(tmp, styleFallbacks, CFRangeMake(0, CFArrayGetCount(styleFallbacks)));
+            fallbackFonts = tmp;
         }
     }
 
-    if (fallbackList.isEmpty())
+    if (!fallbackFonts)
         return fallbackList;
 
-    // .Apple Symbols Fallback will be at the beginning of the list and we will
-    // detect that this has glyphs for Arabic and other writing systems.
-    // Since it is a symbol font, it should be the last resort, so that
-    // the proper fonts for these writing systems are preferred.
-    int symbolIndex = fallbackList.indexOf(QLatin1String(".Apple Symbols Fallback"));
-    if (symbolIndex >= 0)
-        fallbackList.move(symbolIndex, fallbackList.size() - 1);
+    const int numberOfFallbacks = CFArrayGetCount(fallbackFonts);
+    for (int i = 0; i < numberOfFallbacks; ++i) {
+        auto fallbackDescriptor = CTFontDescriptorRef(CFArrayGetValueAtIndex(fallbackFonts, i));
+        auto fallbackFamilyName = QCFString(CTFontDescriptorCopyAttribute(fallbackDescriptor, kCTFontFamilyNameAttribute));
+
+        if (!isFamilyPopulated(fallbackFamilyName)) {
+            // We need to populate, or at least register the fallback fonts,
+            // otherwise the Qt font database may not know they exist.
+            if (isPrivateFontFamily(fallbackFamilyName))
+                const_cast<QCoreTextFontDatabase *>(this)->populateFromDescriptor(fallbackDescriptor);
+            else
+                registerFontFamily(fallbackFamilyName);
+        }
+
+        fallbackList.append(fallbackFamilyName);
+    }
+
+    // Some fallback fonts will have have an order in the list returned
+    // by Core Text that would indicate they should be preferred for e.g.
+    // Arabic, or Emoji, while in reality only supporting a tiny subset
+    // of the required glyphs, or representing them by question marks.
+    // Move these to the end, so that the proper fonts are preferred.
+    for (const char *family : { ".Apple Symbols Fallback", ".Noto Sans Universal" }) {
+        int index = fallbackList.indexOf(QLatin1String(family));
+        if (index >= 0)
+            fallbackList.move(index, fallbackList.size() - 1);
+    }
 
 #if defined(Q_OS_MACOS)
     // Since we are only returning a list of default fonts for the current language, we do not
@@ -489,18 +583,11 @@ QStringList QCoreTextFontDatabase::fallbacksForFamily(const QString &family, QFo
         fallbackList.append(QStringLiteral("Apple Symbols"));
 #endif
 
-    // Since iOS 13, the cascade list may contain meta-fonts which have not been
-    // populated to the database, such as ".AppleJapaneseFont". It is important that we
-    // include this in the fallback list, in order to get fallback support for all
-    // languages
-    for (const QString &fallback : fallbackList) {
-        if (!QPlatformFontDatabase::isFamilyPopulated(fallback))
-            const_cast<QCoreTextFontDatabase *>(this)->populateFamily(fallback);
-    }
-
     extern QStringList qt_sort_families_by_writing_system(QChar::Script, const QStringList &);
     fallbackList = qt_sort_families_by_writing_system(script, fallbackList);
 
+    qCDebug(lcQpaFonts).nospace() << "Fallback families ordered by script " << script << ": " << fallbackList;
+
     return fallbackList;
 }
 
@@ -660,10 +747,8 @@ static CTFontDescriptorRef fontDescriptorFromTheme(QPlatformTheme::Font f)
     }
 #endif // Q_OS_IOS, Q_OS_TVOS, Q_OS_WATCHOS
 
-    // OSX default case and iOS fallback case
-    CTFontUIFontType fontType = fontTypeFromTheme(f);
-    QCFType<CTFontRef> ctFont = CTFontCreateUIFontForLanguage(fontType, 0.0, NULL);
-    return CTFontCopyFontDescriptor(ctFont);
+    // macOS default case and iOS fallback case
+    return descriptorForFontType(fontTypeFromTheme(f));
 }
 
 const QHash<QPlatformTheme::Font, QFont *> &QCoreTextFontDatabase::themeFonts() const
@@ -696,8 +781,8 @@ QFont *QCoreTextFontDatabase::themeFont(QPlatformTheme::Font f) const
 QFont QCoreTextFontDatabase::defaultFont() const
 {
     if (defaultFontName.isEmpty()) {
-        QCFType<CTFontRef> font = CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, 12.0, NULL);
-        defaultFontName = (QString) QCFString(CTFontCopyFullName(font));
+        QCFType<CTFontDescriptorRef> systemFont = descriptorForFontType(kCTFontUIFontSystem);
+        defaultFontName = QCFString(CTFontDescriptorCopyAttribute(systemFont, kCTFontFamilyNameAttribute));
     }
 
     return QFont(defaultFontName);
diff --git a/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase_p.h b/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase_p.h
index 45e74b99be..eebb3eb964 100644
--- a/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase_p.h
+++ b/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase_p.h
@@ -71,7 +71,7 @@ public:
     QCoreTextFontDatabase();
     ~QCoreTextFontDatabase();
     void populateFontDatabase() override;
-    bool populateFamilyAliases() override;
+    bool populateFamilyAliases(const QString &missingFamily) override;
     void populateFamily(const QString &familyName) override;
     void invalidate() override;
 
@@ -92,7 +92,7 @@ protected:
 
 private:
     void populateFromDescriptor(CTFontDescriptorRef font, const QString &familyName = QString());
-    static QStringList fallbacksForFamily(const QString &family);
+    static CFArrayRef fallbacksForFamily(const QString &family);
 
     mutable QString defaultFontName;
 
diff --git a/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase.cpp b/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase.cpp
index 79f7eb3d43..011476cf13 100644
--- a/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase.cpp
+++ b/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase.cpp
@@ -53,6 +53,7 @@
 #include <QtCore/QtEndian>
 #include <QtCore/QThreadStorage>
 #include <QtCore/private/qsystemlibrary_p.h>
+#include <QtCore/private/qwinregistry_p.h>
 
 #include <wchar.h>
 
@@ -1210,33 +1211,8 @@ static int QT_WIN_CALLBACK populateFontFamilies(const LOGFONT *logFont, const TE
 
 void QWindowsFontDatabase::addDefaultEUDCFont()
 {
-    QString path;
-    {
-        HKEY key;
-        if (RegOpenKeyEx(HKEY_CURRENT_USER,
-                         L"EUDC\\1252",
-                         0,
-                         KEY_READ,
-                         &key) != ERROR_SUCCESS) {
-            return;
-        }
-
-        WCHAR value[MAX_PATH];
-        DWORD bufferSize = sizeof(value);
-        ZeroMemory(value, bufferSize);
-
-        if (RegQueryValueEx(key,
-                            L"SystemDefaultEUDCFont",
-                            nullptr,
-                            nullptr,
-                            reinterpret_cast<LPBYTE>(value),
-                            &bufferSize) == ERROR_SUCCESS) {
-            path = QString::fromWCharArray(value);
-        }
-
-        RegCloseKey(key);
-    }
-
+    const QString path = QWinRegistryKey(HKEY_CURRENT_USER, LR"(EUDC\1252)")
+                         .stringValue(L"SystemDefaultEUDCFont");
     if (!path.isEmpty()) {
         QFile file(path);
         if (!file.open(QIODevice::ReadOnly)) {
@@ -2105,28 +2081,6 @@ int QWindowsFontDatabase::defaultVerticalDPI()
     return vDPI;
 }
 
-QString QWindowsFontDatabase::readRegistryString(HKEY parentHandle, const wchar_t *keyPath, const wchar_t *keyName)
-{
-    QString result;
-    HKEY handle = 0;
-    if (RegOpenKeyEx(parentHandle, keyPath, 0, KEY_READ, &handle) == ERROR_SUCCESS) {
-        // get the size and type of the value
-        DWORD dataType;
-        DWORD dataSize;
-        if (RegQueryValueEx(handle, keyName, 0, &dataType, 0, &dataSize) == ERROR_SUCCESS) {
-            if (dataType == REG_SZ || dataType == REG_EXPAND_SZ) {
-                dataSize += 2; // '\0' missing?
-                QVarLengthArray<unsigned char> data(dataSize);
-                data[dataSize - 2] = data[dataSize - 1] = '\0';
-                if (RegQueryValueEx(handle, keyName, 0, 0, data.data(), &dataSize) == ERROR_SUCCESS)
-                    result = QString::fromWCharArray(reinterpret_cast<const wchar_t *>(data.data()));
-            }
-        }
-        RegCloseKey(handle);
-    }
-    return result;
-}
-
 bool QWindowsFontDatabase::isPrivateFontFamily(const QString &family) const
 {
     return m_eudcFonts.contains(family) || QPlatformFontDatabase::isPrivateFontFamily(family);
diff --git a/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase_p.h b/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase_p.h
index a1cab17a87..f132e69d4d 100644
--- a/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase_p.h
+++ b/src/platformsupport/fontdatabases/windows/qwindowsfontdatabase_p.h
@@ -133,8 +133,6 @@ public:
     static void setFontOptions(unsigned options);
     static unsigned fontOptions();
 
-    static QString readRegistryString(HKEY parentHandle, const wchar_t *keyPath, const wchar_t *keyName);
-
 private:
     void removeApplicationFonts();
     void addDefaultEUDCFont();
diff --git a/src/platformsupport/fontdatabases/windows/qwindowsfontenginedirectwrite.cpp b/src/platformsupport/fontdatabases/windows/qwindowsfontenginedirectwrite.cpp
index a4490a6664..e796c18e79 100644
--- a/src/platformsupport/fontdatabases/windows/qwindowsfontenginedirectwrite.cpp
+++ b/src/platformsupport/fontdatabases/windows/qwindowsfontenginedirectwrite.cpp
@@ -47,6 +47,7 @@
 #include <QtCore/QFile>
 #include <private/qstringiterator_p.h>
 #include <QtCore/private/qsystemlibrary_p.h>
+#include <QtCore/private/qwinregistry_p.h>
 #include <QtGui/private/qguiapplication_p.h>
 #include <qpa/qplatformintegration.h>
 #include <QtGui/private/qhighdpiscaling_p.h>
@@ -945,10 +946,10 @@ void QWindowsFontEngineDirectWrite::initFontInfo(const QFontDef &request,
 
 QString QWindowsFontEngineDirectWrite::fontNameSubstitute(const QString &familyName)
 {
-    const wchar_t key[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes";
     const QString substitute =
-        QWindowsFontDatabase::readRegistryString(HKEY_LOCAL_MACHINE, key,
-                                                 reinterpret_cast<const wchar_t *>(familyName.utf16()));
+        QWinRegistryKey(HKEY_LOCAL_MACHINE,
+                        LR"(Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes)")
+        .stringValue(familyName);
     return substitute.isEmpty() ? familyName : substitute;
 }
 
diff --git a/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp b/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp
index bf044229ff..c51db59e1f 100644
--- a/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp
+++ b/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp
@@ -69,6 +69,7 @@ extern "C" {
 QT_BEGIN_NAMESPACE
 
 Q_LOGGING_CATEGORY(qLcEvdevTouch, "qt.qpa.input")
+Q_LOGGING_CATEGORY(qLcEvents, "qt.qpa.input.events")
 
 /* android (and perhaps some other linux-derived stuff) don't define everything
  * in linux/input.h, so we'll need to do that ourselves.
@@ -539,6 +540,9 @@ void QEvdevTouchScreenData::processInputEvent(input_event *data)
             if (m_typeB)
                 m_contacts[m_currentSlot].maj = m_currentData.maj;
         } else if (data->code == ABS_PRESSURE || data->code == ABS_MT_PRESSURE) {
+            if (Q_UNLIKELY(qLcEvents().isDebugEnabled()))
+                qCDebug(qLcEvents, "EV_ABS code 0x%x: pressure %d; bounding to [%d,%d]",
+                        data->code, data->value, hw_pressure_min, hw_pressure_max);
             m_currentData.pressure = qBound(hw_pressure_min, data->value, hw_pressure_max);
             if (m_typeB || m_singleTouch)
                 m_contacts[m_currentSlot].pressure = m_currentData.pressure;
@@ -577,6 +581,7 @@ void QEvdevTouchScreenData::processInputEvent(input_event *data)
         m_lastTouchPoints = m_touchPoints;
         m_touchPoints.clear();
         Qt::TouchPointStates combinedStates;
+        bool hasPressure = false;
 
         for (auto i = m_contacts.begin(), end = m_contacts.end(); i != end; /*erasing*/) {
             auto it = i++;
@@ -607,6 +612,9 @@ void QEvdevTouchScreenData::processInputEvent(input_event *data)
                 continue;
             }
 
+            if (contact.pressure)
+                hasPressure = true;
+
             addTouchPoint(contact, &combinedStates);
         }
 
@@ -651,7 +659,7 @@ void QEvdevTouchScreenData::processInputEvent(input_event *data)
             m_contacts.clear();
 
 
-        if (!m_touchPoints.isEmpty() && combinedStates != Qt::TouchPointStationary)
+        if (!m_touchPoints.isEmpty() && (hasPressure || combinedStates != Qt::TouchPointStationary))
             reportPoints();
     }
 
@@ -777,6 +785,9 @@ void QEvdevTouchScreenData::reportPoints()
             tp.pressure = tp.state == Qt::TouchPointReleased ? 0 : 1;
         else
             tp.pressure = (tp.pressure - hw_pressure_min) / qreal(hw_pressure_max - hw_pressure_min);
+
+        if (Q_UNLIKELY(qLcEvents().isDebugEnabled()))
+            qCDebug(qLcEvents) << "reporting" << tp;
     }
 
     // Let qguiapp pick the target window.
diff --git a/src/platformsupport/input/evdevtouch/qevdevtouchmanager.cpp b/src/platformsupport/input/evdevtouch/qevdevtouchmanager.cpp
index b280f27fac..bf2df93d11 100644
--- a/src/platformsupport/input/evdevtouch/qevdevtouchmanager.cpp
+++ b/src/platformsupport/input/evdevtouch/qevdevtouchmanager.cpp
@@ -98,8 +98,8 @@ void QEvdevTouchManager::addDevice(const QString &deviceNode)
     qCDebug(qLcEvdevTouch, "evdevtouch: Adding device at %ls", qUtf16Printable(deviceNode));
     auto handler = qt_make_unique<QEvdevTouchScreenHandlerThread>(deviceNode, m_spec);
     if (handler) {
-        m_activeDevices.add(deviceNode, std::move(handler));
         connect(handler.get(), &QEvdevTouchScreenHandlerThread::touchDeviceRegistered, this, &QEvdevTouchManager::updateInputDeviceCount);
+        m_activeDevices.add(deviceNode, std::move(handler));
     } else {
         qWarning("evdevtouch: Failed to open touch device %ls", qUtf16Printable(deviceNode));
     }
diff --git a/src/plugins/bearer/corewlan/qcorewlanengine.mm b/src/plugins/bearer/corewlan/qcorewlanengine.mm
index 4644b5af9f..66f2ed017b 100644
--- a/src/plugins/bearer/corewlan/qcorewlanengine.mm
+++ b/src/plugins/bearer/corewlan/qcorewlanengine.mm
@@ -62,12 +62,11 @@ extern "C" { // Otherwise it won't find CWKeychain* symbols at link time
 #include <ifaddrs.h>
 
 @interface QT_MANGLE_NAMESPACE(QNSListener) : NSObject <CWEventDelegate>
-
 @property (assign) QCoreWlanEngine* engine;
-
 @end
+QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSListener);
 
-@implementation QT_MANGLE_NAMESPACE(QNSListener) {
+@implementation QNSListener {
     NSNotificationCenter *notificationCenter;
     CWWiFiClient *client;
     QCoreWlanEngine *engine;
@@ -88,7 +87,7 @@ extern "C" { // Otherwise it won't find CWKeychain* symbols at link time
     return self;
 }
 
-static QT_MANGLE_NAMESPACE(QNSListener) *listener = 0;
+static QNSListener *listener = 0;
 
 -(void)dealloc
 {
@@ -415,7 +414,7 @@ void QCoreWlanEngine::initialize()
     QMacAutoReleasePool pool;
 
     if ([[CWWiFiClient interfaceNames] count] > 0 && !listener) {
-        listener = [[QT_MANGLE_NAMESPACE(QNSListener) alloc] init];
+        listener = [QNSListener alloc] init];
         listener.engine = this;
         hasWifi = true;
     } else {
diff --git a/src/plugins/platforms/android/androidjnimain.cpp b/src/plugins/platforms/android/androidjnimain.cpp
index 27eb337aaa..fd2644717e 100644
--- a/src/plugins/platforms/android/androidjnimain.cpp
+++ b/src/plugins/platforms/android/androidjnimain.cpp
@@ -60,6 +60,7 @@
 #include "qandroideventdispatcher.h"
 #include <android/api-level.h>
 
+#include <QtCore/qresource.h>
 #include <QtCore/qthread.h>
 #include <QtCore/private/qjnihelpers_p.h>
 #include <QtCore/private/qjni_p.h>
@@ -75,6 +76,7 @@ static jclass m_applicationClass  = nullptr;
 static jobject m_classLoaderObject = nullptr;
 static jmethodID m_loadClassMethodID = nullptr;
 static AAssetManager *m_assetManager = nullptr;
+static jobject m_assets = nullptr;
 static jobject m_resourcesObj = nullptr;
 static jobject m_activityObject = nullptr;
 static jmethodID m_createSurfaceMethodID = nullptr;
@@ -439,6 +441,11 @@ namespace QtAndroid
         return block;
     }
 
+    jobject assets()
+    {
+        return m_assets;
+    }
+
 } // namespace QtAndroid
 
 static jboolean startQtAndroidPlugin(JNIEnv *env, jobject /*object*/, jstring paramsString, jstring environmentString)
@@ -519,6 +526,10 @@ static jboolean startQtApplication(JNIEnv */*env*/, jclass /*clazz*/)
             vm->AttachCurrentThread(&env, &args);
     }
 
+    // Register resources if they are available
+    if (QFile{QStringLiteral("assets:/android_rcc_bundle.rcc")}.exists())
+        QResource::registerResource(QStringLiteral("assets:/android_rcc_bundle.rcc"));
+
     QVarLengthArray<const char *> params(m_applicationParams.size());
     for (int i = 0; i < m_applicationParams.size(); i++)
         params[i] = static_cast<const char *>(m_applicationParams[i].constData());
@@ -588,6 +599,8 @@ static void terminateQt(JNIEnv *env, jclass /*clazz*/)
         env->DeleteGlobalRef(m_RGB_565_BitmapConfigValue);
     if (m_bitmapDrawableClass)
         env->DeleteGlobalRef(m_bitmapDrawableClass);
+    if (m_assets)
+        env->DeleteGlobalRef(m_assets);
     m_androidPlatformIntegration = nullptr;
     delete m_androidAssetsFileEngineHandler;
     m_androidAssetsFileEngineHandler = nullptr;
@@ -840,7 +853,8 @@ static int registerNatives(JNIEnv *env)
     if (object) {
         FIND_AND_CHECK_CLASS("android/content/ContextWrapper");
         GET_AND_CHECK_METHOD(methodID, clazz, "getAssets", "()Landroid/content/res/AssetManager;");
-        m_assetManager = AAssetManager_fromJava(env, env->CallObjectMethod(object, methodID));
+        m_assets = env->NewGlobalRef(env->CallObjectMethod(object, methodID));
+        m_assetManager = AAssetManager_fromJava(env, m_assets);
 
         GET_AND_CHECK_METHOD(methodID, clazz, "getResources", "()Landroid/content/res/Resources;");
         m_resourcesObj = env->NewGlobalRef(env->CallObjectMethod(object, methodID));
diff --git a/src/plugins/platforms/android/androidjnimain.h b/src/plugins/platforms/android/androidjnimain.h
index 08f1d50fe3..17ae30a1be 100644
--- a/src/plugins/platforms/android/androidjnimain.h
+++ b/src/plugins/platforms/android/androidjnimain.h
@@ -82,6 +82,7 @@ namespace QtAndroid
     double scaledDensity();
     double pixelDensity();
     JavaVM *javaVM();
+    jobject assets();
     AAssetManager *assetManager();
     jclass applicationClass();
     jobject activity();
diff --git a/src/plugins/platforms/android/qandroidassetsfileenginehandler.cpp b/src/plugins/platforms/android/qandroidassetsfileenginehandler.cpp
index e1dcebfa4c..26e72a480f 100644
--- a/src/plugins/platforms/android/qandroidassetsfileenginehandler.cpp
+++ b/src/plugins/platforms/android/qandroidassetsfileenginehandler.cpp
@@ -39,40 +39,139 @@
 
 #include "qandroidassetsfileenginehandler.h"
 #include "androidjnimain.h"
+#include <optional>
 
 #include <QCoreApplication>
 #include <QVector>
+#include <QtCore/private/qjni_p.h>
 
 QT_BEGIN_NAMESPACE
 
-typedef QVector<QString> FilesList;
+static const QLatin1String assetsPrefix("assets:");
+const static int prefixSize = 7;
 
-struct AndroidAssetDir
+static inline QString cleanedAssetPath(QString file)
 {
-    AndroidAssetDir(AAssetDir* ad)
+    if (file.startsWith(assetsPrefix))
+        file.remove(0, prefixSize);
+    file.replace(QLatin1String("//"), QLatin1String("/"));
+    if (file.startsWith(QLatin1Char('/')))
+        file.remove(0, 1);
+    if (file.endsWith(QLatin1Char('/')))
+        file.chop(1);
+    return file;
+}
+
+static inline QString prefixedPath(QString path)
+{
+    path = assetsPrefix + QLatin1Char('/') + path;
+    path.replace(QLatin1String("//"), QLatin1String("/"));
+    return path;
+}
+
+struct AssetItem {
+    enum class Type {
+        File,
+        Folder
+    };
+
+    AssetItem (const QString &rawName)
+        : name(rawName)
+    {
+        if (name.endsWith(QLatin1Char('/'))) {
+            type = Type::Folder;
+            name.chop(1);
+        }
+    }
+    Type type = Type::File;
+    QString name;
+};
+
+using AssetItemList = QVector<AssetItem>;
+
+class FolderIterator : public AssetItemList
+{
+public:
+    static QSharedPointer<FolderIterator> fromCache(const QString &path)
     {
-        if (ad) {
-            const char *fileName;
-            while ((fileName = AAssetDir_getNextFileName(ad)))
-                m_items.push_back(QString::fromUtf8(fileName));
-            AAssetDir_close(ad);
+        QMutexLocker lock(&m_assetsCacheMutex);
+        QSharedPointer<FolderIterator> *folder = m_assetsCache.object(path);
+        if (!folder) {
+            folder = new QSharedPointer<FolderIterator>{new FolderIterator{path}};
+            if (!m_assetsCache.insert(path, folder)) {
+                QSharedPointer<FolderIterator> res = *folder;
+                delete folder;
+                return res;
+            }
         }
+        return *folder;
+    }
+
+    FolderIterator(const QString &path)
+        : m_path(path)
+    {
+        QJNIObjectPrivate files = QJNIObjectPrivate::callStaticObjectMethod(QtAndroid::applicationClass(),
+                                                                            "listAssetContent",
+                                                                            "(Landroid/content/res/AssetManager;Ljava/lang/String;)[Ljava/lang/String;",
+                                                                            QtAndroid::assets(), QJNIObjectPrivate::fromString(path).object());
+        if (files.isValid()) {
+            QJNIEnvironmentPrivate env;
+            jobjectArray jFiles = static_cast<jobjectArray>(files.object());
+            const jint nFiles = env->GetArrayLength(jFiles);
+            for (int i = 0; i < nFiles; ++i)
+                push_back({QJNIObjectPrivate(env->GetObjectArrayElement(jFiles, i)).toString()});
+        }
+        m_path = assetsPrefix + QLatin1Char('/') + m_path + QLatin1Char('/');
+        m_path.replace(QLatin1String("//"), QLatin1String("/"));
+    }
+
+    QString currentFileName() const
+    {
+        if (m_index < 0 || m_index >= size())
+            return {};
+        return at(m_index).name;
+    }
+    QString currentFilePath() const
+    {
+        if (m_index < 0 || m_index >= size())
+            return {};
+        return m_path + at(m_index).name;
+    }
+
+    bool hasNext() const
+    {
+        return !empty() && m_index + 1 < size();
+    }
+
+    std::optional<std::pair<QString, AssetItem>> next()
+    {
+        if (!hasNext())
+            return {};
+        ++m_index;
+        return std::pair<QString, AssetItem>(currentFileName(), at(m_index));
     }
-    FilesList m_items;
+
+private:
+    int m_index = -1;
+    QString m_path;
+    static QCache<QString, QSharedPointer<FolderIterator>> m_assetsCache;
+    static QMutex m_assetsCacheMutex;
 };
 
+QCache<QString, QSharedPointer<FolderIterator>> FolderIterator::m_assetsCache(std::max(50, qEnvironmentVariableIntValue("QT_ANDROID_MAX_ASSETS_CACHE_SIZE")));
+QMutex FolderIterator::m_assetsCacheMutex;
+
 class AndroidAbstractFileEngineIterator: public QAbstractFileEngineIterator
 {
 public:
     AndroidAbstractFileEngineIterator(QDir::Filters filters,
                                       const QStringList &nameFilters,
-                                      QSharedPointer<AndroidAssetDir> asset,
                                       const QString &path)
         : QAbstractFileEngineIterator(filters, nameFilters)
     {
-        m_items = asset->m_items;
-        m_index = -1;
-        m_path = path;
+        m_stack.push_back(FolderIterator::fromCache(cleanedAssetPath(path)));
+        if (m_stack.last()->empty())
+            m_stack.pop_back();
     }
 
     QFileInfo currentFileInfo() const override
@@ -82,54 +181,59 @@ public:
 
     QString currentFileName() const override
     {
-        if (m_index < 0 || m_index >= m_items.size())
-            return QString();
-        QString fileName = m_items[m_index];
-        if (fileName.endsWith(QLatin1Char('/')))
-            fileName.chop(1);
-        return fileName;
+        if (!m_currentIterator)
+            return {};
+        return m_currentIterator->currentFileName();
     }
 
     virtual QString currentFilePath() const
     {
-        return m_path + currentFileName();
+        if (!m_currentIterator)
+            return {};
+        return m_currentIterator->currentFilePath();
     }
 
     bool hasNext() const override
     {
-        return m_items.size() && (m_index < m_items.size() - 1);
+        if (m_stack.empty())
+            return false;
+        if (!m_stack.last()->hasNext()) {
+            m_stack.pop_back();
+            return hasNext();
+        }
+        return true;
     }
 
     QString next() override
     {
-        if (!hasNext())
-            return QString();
-        m_index++;
-        return currentFileName();
+        if (m_stack.empty()) {
+            m_currentIterator.reset();
+            return {};
+        }
+        m_currentIterator = m_stack.last();
+        auto res = m_currentIterator->next();
+        if (!res)
+            return {};
+        if (res->second.type == AssetItem::Type::Folder) {
+            m_stack.push_back(FolderIterator::fromCache(cleanedAssetPath(currentFilePath())));
+            if (m_stack.last()->empty())
+                m_stack.pop_back();
+        }
+        return res->first;
     }
 
 private:
-    QString     m_path;
-    FilesList   m_items;
-    int         m_index;
+    mutable QSharedPointer<FolderIterator> m_currentIterator;
+    mutable QVector<QSharedPointer<FolderIterator>> m_stack;
 };
 
 class AndroidAbstractFileEngine: public QAbstractFileEngine
 {
 public:
-    explicit AndroidAbstractFileEngine(AAsset *asset, const QString &fileName)
-    {
-        m_assetFile = asset;
-        m_fileName = fileName;
-    }
-
-    explicit AndroidAbstractFileEngine(QSharedPointer<AndroidAssetDir> asset, const QString &fileName)
+    explicit AndroidAbstractFileEngine(AAssetManager *assetManager, const QString &fileName)
+        : m_assetManager(assetManager)
     {
-        m_assetFile = 0;
-        m_assetDir = asset;
-        m_fileName =  fileName;
-        if (!m_fileName.endsWith(QLatin1Char('/')))
-            m_fileName += QLatin1Char('/');
+        setFileName(fileName);
     }
 
     ~AndroidAbstractFileEngine()
@@ -139,7 +243,11 @@ public:
 
     bool open(QIODevice::OpenMode openMode) override
     {
-        return m_assetFile != 0 && (openMode & QIODevice::WriteOnly) == 0;
+        if (m_isFolder || (openMode & QIODevice::WriteOnly))
+            return false;
+        close();
+        m_assetFile = AAssetManager_open(m_assetManager, m_fileName.toUtf8(), AASSET_MODE_BUFFER);
+        return m_assetFile;
     }
 
     bool close() override
@@ -200,7 +308,7 @@ public:
         FileFlags flags(ReadOwnerPerm|ReadUserPerm|ReadGroupPerm|ReadOtherPerm|ExistsFlag);
         if (m_assetFile)
             flags |= FileType;
-        if (!m_assetDir.isNull())
+        else if (m_isFolder)
             flags |= DirectoryType;
 
         return type & flags;
@@ -213,19 +321,19 @@ public:
         case DefaultName:
         case AbsoluteName:
         case CanonicalName:
-                return m_fileName;
+                return prefixedPath(m_fileName);
         case BaseName:
             if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
-                return m_fileName.mid(pos);
+                return prefixedPath(m_fileName.mid(pos));
             else
-                return m_fileName;
+                return prefixedPath(m_fileName);
         case PathName:
         case AbsolutePathName:
         case CanonicalPathName:
             if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
-                return m_fileName.left(pos);
+                return prefixedPath(m_fileName.left(pos));
             else
-                return m_fileName;
+                return prefixedPath(m_fileName);
         default:
             return QString();
         }
@@ -233,164 +341,46 @@ public:
 
     void setFileName(const QString &file) override
     {
-        if (file == m_fileName)
-            return;
-
-        m_fileName = file;
-        if (!m_fileName.endsWith(QLatin1Char('/')))
-            m_fileName += QLatin1Char('/');
-
         close();
+        m_fileName = cleanedAssetPath(file);
+        m_isFolder = !open(QIODevice::ReadOnly) && !FolderIterator::fromCache(m_fileName)->empty();
     }
 
     Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames) override
     {
-        if (!m_assetDir.isNull())
-            return new AndroidAbstractFileEngineIterator(filters, filterNames, m_assetDir, m_fileName);
-        return 0;
+        if (m_isFolder)
+            return new AndroidAbstractFileEngineIterator(filters, filterNames, m_fileName);
+        return nullptr;
     }
 
 private:
-    AAsset *m_assetFile;
-    QSharedPointer<AndroidAssetDir> m_assetDir;
+    AAsset *m_assetFile = nullptr;
+    AAssetManager *m_assetManager;
     QString m_fileName;
+    bool m_isFolder;
 };
 
 
 AndroidAssetsFileEngineHandler::AndroidAssetsFileEngineHandler()
-    : m_assetsCache(std::max(5, qEnvironmentVariableIntValue("QT_ANDROID_MAX_ASSETS_CACHE_SIZE")))
-    , m_hasPrepopulatedCache(false)
-    , m_hasTriedPrepopulatingCache(false)
 {
     m_assetManager = QtAndroid::assetManager();
 }
 
-AndroidAssetsFileEngineHandler::~AndroidAssetsFileEngineHandler()
-{
-}
-
-void AndroidAssetsFileEngineHandler::prepopulateCache() const
-{
-    Q_ASSERT(!m_hasTriedPrepopulatingCache);
-    m_hasTriedPrepopulatingCache = true;
-
-    Q_ASSERT(m_assetsCache.isEmpty());
-
-    // Failsafe: Don't read cache files that are larger than 1MB
-    static qint64 maxPrepopulatedCacheSize = qMax(1024LL * 1024LL,
-                                                  qgetenv("QT_ANDROID_MAX_PREPOPULATED_ASSETS_CACHE_SIZE").toLongLong());
-
-    const char *fileName = "--Added-by-androiddeployqt--/qt_cache_pregenerated_file_list";
-    AAsset *asset = AAssetManager_open(m_assetManager, fileName, AASSET_MODE_BUFFER);
-    if (asset) {
-        m_hasPrepopulatedCache = true;
-        AndroidAbstractFileEngine fileEngine(asset, QString::fromLatin1(fileName));
-        if (fileEngine.open(QIODevice::ReadOnly)) {
-            qint64 size = fileEngine.size();
-
-            if (size <= maxPrepopulatedCacheSize) {
-                QByteArray bytes(size, Qt::Uninitialized);
-                qint64 read = fileEngine.read(bytes.data(), size);
-                if (read != size) {
-                    qWarning("Failed to read prepopulated cache");
-                    return;
-                }
-
-                QDataStream stream(&bytes, QIODevice::ReadOnly);
-                stream.setVersion(QDataStream::Qt_5_3);
-                if (stream.status() != QDataStream::Ok) {
-                    qWarning("Failed to read prepopulated cache");
-                    return;
-                }
-
-                while (!stream.atEnd()) {
-                    QString directoryName;
-                    stream >> directoryName;
-
-                    int fileCount;
-                    stream >> fileCount;
-
-                    QVector<QString> fileList;
-                    fileList.reserve(fileCount);
-                    while (fileCount--) {
-                        QString fileName;
-                        stream >> fileName;
-                        fileList.append(fileName);
-                    }
-
-                    QSharedPointer<AndroidAssetDir> *aad = new QSharedPointer<AndroidAssetDir>(new AndroidAssetDir(0));
-                    (*aad)->m_items = fileList;
-
-                    // Cost = 0, because we should always cache everything if there's a prepopulated cache
-                    QByteArray key = directoryName != QLatin1String("/")
-                            ? QByteArray("assets:/") + directoryName.toUtf8()
-                            : QByteArray("assets:");
-
-                    bool ok = m_assetsCache.insert(key, aad, 0);
-                    if (!ok)
-                        qWarning("Failed to insert in cache: %s", qPrintable(directoryName));
-                }
-            } else {
-                qWarning("Prepopulated cache is too large to read.\n"
-                         "Use environment variable QT_ANDROID_MAX_PREPOPULATED_ASSETS_CACHE_SIZE to adjust size.");
-            }
-        }
-    }
-}
-
 QAbstractFileEngine * AndroidAssetsFileEngineHandler::create(const QString &fileName) const
 {
     if (fileName.isEmpty())
-        return 0;
+        return nullptr;
 
-    static QLatin1String assetsPrefix("assets:");
     if (!fileName.startsWith(assetsPrefix))
-        return 0;
-
-    static int prefixSize = assetsPrefix.size() + 1;
-
-    QByteArray path;
-    if (!fileName.endsWith(QLatin1Char('/'))) {
-        path = fileName.toUtf8();
-        if (path.size() > prefixSize) {
-            AAsset *asset = AAssetManager_open(m_assetManager,
-                                               path.constData() + prefixSize,
-                                               AASSET_MODE_BUFFER);
-            if (asset)
-                return new AndroidAbstractFileEngine(asset, fileName);
-        }
-    }
-
-    if (!path.size())
-         path = fileName.left(fileName.length() - 1).toUtf8();
-
-
-    m_assetsCacheMutext.lock();
-    if (!m_hasTriedPrepopulatingCache)
-        prepopulateCache();
-
-    QSharedPointer<AndroidAssetDir> *aad = m_assetsCache.object(path);
-    m_assetsCacheMutext.unlock();
-    if (!aad) {
-        if (!m_hasPrepopulatedCache && path.size() > prefixSize) {
-            AAssetDir *assetDir = AAssetManager_openDir(m_assetManager, path.constData() + prefixSize);
-            if (assetDir) {
-                if (AAssetDir_getNextFileName(assetDir)) {
-                    AAssetDir_rewind(assetDir);
-                    aad = new QSharedPointer<AndroidAssetDir>(new AndroidAssetDir(assetDir));
-                    m_assetsCacheMutext.lock();
-                    m_assetsCache.insert(path, aad);
-                    m_assetsCacheMutext.unlock();
-                    return new AndroidAbstractFileEngine(*aad, fileName);
-                } else {
-                    AAssetDir_close(assetDir);
-                }
-            }
-        }
-    } else {
-        return new AndroidAbstractFileEngine(*aad, fileName);
-    }
-    return 0;
+        return nullptr;
+
+    QString path = fileName.mid(prefixSize);
+    path.replace(QLatin1String("//"), QLatin1String("/"));
+    if (path.startsWith(QLatin1Char('/')))
+        path.remove(0, 1);
+    if (path.endsWith(QLatin1Char('/')))
+        path.chop(1);
+    return new AndroidAbstractFileEngine(m_assetManager, path);
 }
 
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/android/qandroidassetsfileenginehandler.h b/src/plugins/platforms/android/qandroidassetsfileenginehandler.h
index f99dc9a11a..51cc5b07a8 100644
--- a/src/plugins/platforms/android/qandroidassetsfileenginehandler.h
+++ b/src/plugins/platforms/android/qandroidassetsfileenginehandler.h
@@ -49,22 +49,14 @@
 
 QT_BEGIN_NAMESPACE
 
-struct AndroidAssetDir;
 class AndroidAssetsFileEngineHandler: public QAbstractFileEngineHandler
 {
 public:
     AndroidAssetsFileEngineHandler();
-    virtual ~AndroidAssetsFileEngineHandler();
     QAbstractFileEngine *create(const QString &fileName) const override;
 
 private:
-    void prepopulateCache() const;
-
     AAssetManager *m_assetManager;
-    mutable QCache<QByteArray, QSharedPointer<AndroidAssetDir>> m_assetsCache;
-    mutable QMutex m_assetsCacheMutext;
-    mutable bool m_hasPrepopulatedCache;
-    mutable bool m_hasTriedPrepopulatingCache;
 };
 
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/cocoa/qcocoaaccessibility.h b/src/plugins/platforms/cocoa/qcocoaaccessibility.h
index 457c158ddc..539d876094 100644
--- a/src/plugins/platforms/cocoa/qcocoaaccessibility.h
+++ b/src/plugins/platforms/cocoa/qcocoaaccessibility.h
@@ -44,9 +44,9 @@
 #include <QtGui>
 #include <qpa/qplatformaccessibility.h>
 
-#ifndef QT_NO_ACCESSIBILITY
+#include "qcocoaaccessibilityelement.h"
 
-@class QT_MANGLE_NAMESPACE(QMacAccessibilityElement);
+#ifndef QT_NO_ACCESSIBILITY
 
 QT_BEGIN_NAMESPACE
 
@@ -84,7 +84,7 @@ namespace QCocoaAccessible {
 NSString *macRole(QAccessibleInterface *interface);
 NSString *macSubrole(QAccessibleInterface *interface);
 bool shouldBeIgnored(QAccessibleInterface *interface);
-NSArray<QT_MANGLE_NAMESPACE(QMacAccessibilityElement) *> *unignoredChildren(QAccessibleInterface *interface);
+NSArray<QMacAccessibilityElement *> *unignoredChildren(QAccessibleInterface *interface);
 NSString *getTranslatedAction(const QString &qtAction);
 QString translateAction(NSString *nsAction, QAccessibleInterface *interface);
 bool hasValueAttribute(QAccessibleInterface *interface);
diff --git a/src/plugins/platforms/cocoa/qcocoaaccessibilityelement.h b/src/plugins/platforms/cocoa/qcocoaaccessibilityelement.h
index 7fbe729381..141ce6bf1a 100644
--- a/src/plugins/platforms/cocoa/qcocoaaccessibilityelement.h
+++ b/src/plugins/platforms/cocoa/qcocoaaccessibilityelement.h
@@ -50,8 +50,6 @@
 
 #import <qaccessible.h>
 
-@class QT_MANGLE_NAMESPACE(QMacAccessibilityElement);
-
 @interface QT_MANGLE_NAMESPACE(QMacAccessibilityElement) : NSObject <NSAccessibilityElement>
 
 - (instancetype)initWithId:(QAccessible::Id)anId;
diff --git a/src/plugins/platforms/cocoa/qcocoaapplication.mm b/src/plugins/platforms/cocoa/qcocoaapplication.mm
index 340191622a..c6029bcf03 100644
--- a/src/plugins/platforms/cocoa/qcocoaapplication.mm
+++ b/src/plugins/platforms/cocoa/qcocoaapplication.mm
@@ -144,7 +144,7 @@ static void qt_maybeSendKeyEquivalentUpEvent(NSEvent *event)
     }
 }
 
-@implementation QT_MANGLE_NAMESPACE(QNSApplication)
+@implementation QNSApplication
 
 - (void)QT_MANGLE_NAMESPACE(qt_sendEvent_original):(NSEvent *)event
 {
@@ -188,7 +188,7 @@ void qt_redirectNSApplicationSendEvent()
         // can be unloaded.
         return;
 
-    if ([NSApp isMemberOfClass:[QT_MANGLE_NAMESPACE(QNSApplication) class]]) {
+    if ([NSApp isMemberOfClass:[QNSApplication class]]) {
         // No need to change implementation since Qt
         // already controls a subclass of NSApplication
         return;
@@ -201,7 +201,7 @@ void qt_redirectNSApplicationSendEvent()
     qt_cocoa_change_implementation(
             [NSApplication class],
             @selector(sendEvent:),
-            [QT_MANGLE_NAMESPACE(QNSApplication) class],
+            [QNSApplication class],
             @selector(QT_MANGLE_NAMESPACE(qt_sendEvent_replacement):),
             @selector(QT_MANGLE_NAMESPACE(qt_sendEvent_original):));
  }
diff --git a/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.h b/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.h
index 0816730c54..8ec9d6fbe0 100644
--- a/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.h
+++ b/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.h
@@ -89,8 +89,7 @@
 
 #include <qglobal.h>
 #include <private/qcore_mac_p.h>
-
-Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(QCocoaNSMenuItem));
+#include "qcocoansmenu.h"
 
 @interface QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate) : NSObject <NSApplicationDelegate>
 @property (nonatomic, retain) NSMenu *dockMenu;
@@ -100,8 +99,9 @@ Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(QCocoaNSMenuItem));
 - (bool)inLaunch;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate) (MenuAPI)
-- (void)qt_itemFired:(QT_MANGLE_NAMESPACE(QCocoaNSMenuItem) *)item;
+QT_NAMESPACE_ALIAS_OBJC_CLASS(QCocoaApplicationDelegate);
+
+@interface QCocoaApplicationDelegate (MenuAPI)
+- (void)qt_itemFired:(QCocoaNSMenuItem *)item;
 @end
 
-QT_NAMESPACE_ALIAS_OBJC_CLASS(QCocoaApplicationDelegate);
diff --git a/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm b/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
index 2cf6672da9..9b0a6b1b86 100644
--- a/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
+++ b/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
@@ -88,10 +88,13 @@
 #include <qpa/qwindowsysteminterface.h>
 #include <qwindowdefs.h>
 
+QT_BEGIN_NAMESPACE
+Q_LOGGING_CATEGORY(lcQpaApplication, "qt.qpa.application");
+QT_END_NAMESPACE
+
 QT_USE_NAMESPACE
 
 @implementation QCocoaApplicationDelegate {
-    bool startedQuit;
     NSObject <NSApplicationDelegate> *reflectionDelegate;
     bool inLaunch;
 }
@@ -140,71 +143,30 @@ QT_USE_NAMESPACE
     return [[self.dockMenu retain] autorelease];
 }
 
-- (BOOL)canQuit
-{
-    [[NSApp mainMenu] cancelTracking];
-
-    bool handle_quit = true;
-    NSMenuItem *quitMenuItem = [[QT_MANGLE_NAMESPACE(QCocoaMenuLoader) sharedMenuLoader] quitMenuItem];
-    if (!QGuiApplicationPrivate::instance()->modalWindowList.isEmpty()
-        && [quitMenuItem isEnabled]) {
-        int visible = 0;
-        const QWindowList tlws = QGuiApplication::topLevelWindows();
-        for (int i = 0; i < tlws.size(); ++i) {
-            if (tlws.at(i)->isVisible())
-                ++visible;
-        }
-        handle_quit = (visible <= 1);
-    }
-
-    if (handle_quit) {
-        QCloseEvent ev;
-        QGuiApplication::sendEvent(qGuiApp, &ev);
-        if (ev.isAccepted()) {
-            return YES;
-        }
-    }
-
-    return NO;
-}
-
 // This function will only be called when NSApp is actually running.
 - (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
 {
-    // The reflection delegate gets precedence
-    if (reflectionDelegate) {
-        if ([reflectionDelegate respondsToSelector:@selector(applicationShouldTerminate:)])
-            return [reflectionDelegate applicationShouldTerminate:sender];
-        return NSTerminateNow;
-    }
-
-    if ([self canQuit]) {
-        if (!startedQuit) {
-            startedQuit = true;
-            // Close open windows. This is done in order to deliver de-expose
-            // events while the event loop is still running.
-            const QWindowList topLevels = QGuiApplication::topLevelWindows();
-            for (int i = 0; i < topLevels.size(); ++i) {
-                QWindow *topLevelWindow = topLevels.at(i);
-                // Already closed windows will not have a platform window, skip those
-                if (topLevelWindow->handle())
-                    QWindowSystemInterface::handleCloseEvent(topLevelWindow);
-            }
-            QWindowSystemInterface::flushWindowSystemEvents();
-
-            QGuiApplication::exit(0);
-            startedQuit = false;
-        }
-    }
+    if ([reflectionDelegate respondsToSelector:_cmd])
+        return [reflectionDelegate applicationShouldTerminate:sender];
 
     if (QGuiApplicationPrivate::instance()->threadData->eventLoops.isEmpty()) {
-        // INVARIANT: No event loop is executing. This probably
-        // means that Qt is used as a plugin, or as a part of a native
-        // Cocoa application. In any case it should be fine to
-        // terminate now:
+        // No event loop is executing. This probably means that Qt is used as a plugin,
+        // or as a part of a native Cocoa application. In any case it should be fine to
+        // terminate now.
+        qCDebug(lcQpaApplication) << "No running event loops, terminating now";
         return NSTerminateNow;
     }
 
+    if (!QWindowSystemInterface::handleApplicationTermination<QWindowSystemInterface::SynchronousDelivery>()) {
+        qCDebug(lcQpaApplication) << "Application termination canceled";
+        return NSTerminateCancel;
+    }
+
+    // Even if the application termination was accepted by the application we can't
+    // return NSTerminateNow, as that would trigger AppKit to ultimately call exit().
+    // We need to ensure that the runloop continues spinning so that we can return
+    // from our own event loop back to main(), and exit from there.
+    qCDebug(lcQpaApplication) << "Termination accepted, but returning to runloop for exit through main()";
     return NSTerminateCancel;
 }
 
@@ -227,10 +189,6 @@ QT_USE_NAMESPACE
         application depends on.
      */
     NSAppleEventManager *eventManager = [NSAppleEventManager sharedAppleEventManager];
-    [eventManager setEventHandler:self
-                      andSelector:@selector(appleEventQuit:withReplyEvent:)
-                    forEventClass:kCoreEventClass
-                       andEventID:kAEQuitApplication];
     [eventManager setEventHandler:self
                       andSelector:@selector(getUrl:withReplyEvent:)
                     forEventClass:kInternetEventClass
@@ -241,7 +199,6 @@ QT_USE_NAMESPACE
 - (void)removeAppleEventHandlers
 {
     NSAppleEventManager *eventManager = [NSAppleEventManager sharedAppleEventManager];
-    [eventManager removeEventHandlerForEventClass:kCoreEventClass andEventID:kAEQuitApplication];
     [eventManager removeEventHandlerForEventClass:kInternetEventClass andEventID:kAEGetURL];
 }
 
@@ -282,26 +239,22 @@ QT_USE_NAMESPACE
         QWindowSystemInterface::handleFileOpenEvent(qtFileName);
     }
 
-    if (reflectionDelegate &&
-        [reflectionDelegate respondsToSelector:@selector(application:openFiles:)])
+    if ([reflectionDelegate respondsToSelector:_cmd])
         [reflectionDelegate application:sender openFiles:filenames];
 
 }
 
 - (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender
 {
-    // If we have a reflection delegate, that will get to call the shots.
-    if (reflectionDelegate
-        && [reflectionDelegate respondsToSelector:
-                            @selector(applicationShouldTerminateAfterLastWindowClosed:)])
+    if ([reflectionDelegate respondsToSelector:_cmd])
         return [reflectionDelegate applicationShouldTerminateAfterLastWindowClosed:sender];
+
     return NO; // Someday qApp->quitOnLastWindowClosed(); when QApp and NSApp work closer together.
 }
 
 - (void)applicationDidBecomeActive:(NSNotification *)notification
 {
-    if (reflectionDelegate
-        && [reflectionDelegate respondsToSelector:@selector(applicationDidBecomeActive:)])
+    if ([reflectionDelegate respondsToSelector:_cmd])
         [reflectionDelegate applicationDidBecomeActive:notification];
 
     QWindowSystemInterface::handleApplicationStateChanged(Qt::ApplicationActive);
@@ -309,8 +262,7 @@ QT_USE_NAMESPACE
 
 - (void)applicationDidResignActive:(NSNotification *)notification
 {
-    if (reflectionDelegate
-        && [reflectionDelegate respondsToSelector:@selector(applicationDidResignActive:)])
+    if ([reflectionDelegate respondsToSelector:_cmd])
         [reflectionDelegate applicationDidResignActive:notification];
 
     QWindowSystemInterface::handleApplicationStateChanged(Qt::ApplicationInactive);
@@ -318,10 +270,7 @@ QT_USE_NAMESPACE
 
 - (BOOL)applicationShouldHandleReopen:(NSApplication *)theApplication hasVisibleWindows:(BOOL)flag
 {
-    Q_UNUSED(theApplication);
-    Q_UNUSED(flag);
-    if (reflectionDelegate
-        && [reflectionDelegate respondsToSelector:@selector(applicationShouldHandleReopen:hasVisibleWindows:)])
+    if ([reflectionDelegate respondsToSelector:_cmd])
         return [reflectionDelegate applicationShouldHandleReopen:theApplication hasVisibleWindows:flag];
 
     /*
@@ -354,16 +303,13 @@ QT_USE_NAMESPACE
 
 - (BOOL)respondsToSelector:(SEL)aSelector
 {
-    BOOL result = [super respondsToSelector:aSelector];
-    if (!result && reflectionDelegate)
-        result = [reflectionDelegate respondsToSelector:aSelector];
-    return result;
+    return [super respondsToSelector:aSelector] || [reflectionDelegate respondsToSelector:aSelector];
 }
 
 - (void)forwardInvocation:(NSInvocation *)invocation
 {
     SEL invocationSelector = [invocation selector];
-    if (reflectionDelegate && [reflectionDelegate respondsToSelector:invocationSelector])
+    if ([reflectionDelegate respondsToSelector:invocationSelector])
         [invocation invokeWithTarget:reflectionDelegate];
     else
         [self doesNotRecognizeSelector:invocationSelector];
@@ -375,14 +321,6 @@ QT_USE_NAMESPACE
     NSString *urlString = [[event paramDescriptorForKeyword:keyDirectObject] stringValue];
     QWindowSystemInterface::handleFileOpenEvent(QUrl(QString::fromNSString(urlString)));
 }
-
-- (void)appleEventQuit:(NSAppleEventDescriptor *)event withReplyEvent:(NSAppleEventDescriptor *)replyEvent
-{
-    Q_UNUSED(event);
-    Q_UNUSED(replyEvent);
-    [NSApp terminate:self];
-}
-
 @end
 
 @implementation QCocoaApplicationDelegate (Menus)
diff --git a/src/plugins/platforms/cocoa/qcocoabackingstore.mm b/src/plugins/platforms/cocoa/qcocoabackingstore.mm
index eb316c53a8..b17302a640 100644
--- a/src/plugins/platforms/cocoa/qcocoabackingstore.mm
+++ b/src/plugins/platforms/cocoa/qcocoabackingstore.mm
@@ -560,17 +560,26 @@ void QCALayerBackingStore::flush(QWindow *flushedWindow, const QRegion &region,
         flushedView.layer.contents = nil;
     }
 
-    qCInfo(lcQpaBackingStore) << "Flushing" << backBufferSurface
-         << "to" << flushedView.layer << "of" << flushedView;
-
-    flushedView.layer.contents = backBufferSurface;
+    if (flushedView == backingStoreView) {
+        qCInfo(lcQpaBackingStore) << "Flushing" << backBufferSurface
+            << "to" << flushedView.layer << "of" << flushedView;
+        flushedView.layer.contents = backBufferSurface;
+    } else {
+        auto subviewRect = [flushedView convertRect:flushedView.bounds toView:backingStoreView];
+        auto scale = flushedView.layer.contentsScale;
+        subviewRect = CGRectApplyAffineTransform(subviewRect, CGAffineTransformMakeScale(scale, scale));
+
+        // We make a copy of the image data up front, which means we don't
+        // need to mark the IOSurface as being in use. FIXME: Investigate
+        // if there's a cheaper way to get sub-image data to a layer.
+        m_buffers.back()->lock(QPlatformGraphicsBuffer::SWReadAccess);
+        QImage subImage = m_buffers.back()->asImage()->copy(QRectF::fromCGRect(subviewRect).toRect());
+        m_buffers.back()->unlock();
 
-    if (flushedView != backingStoreView) {
-        const CGSize backingStoreSize = backingStoreView.bounds.size;
-        flushedView.layer.contentsRect = CGRectApplyAffineTransform(
-            [flushedView convertRect:flushedView.bounds toView:backingStoreView],
-            // The contentsRect is in unit coordinate system
-            CGAffineTransformMakeScale(1.0 / backingStoreSize.width, 1.0 / backingStoreSize.height));
+        qCInfo(lcQpaBackingStore) << "Flushing" << subImage
+            << "to" << flushedView.layer << "of subview" << flushedView;
+        QCFType<CGImageRef> cgImage = subImage.toCGImage();
+        flushedView.layer.contents = (__bridge id)static_cast<CGImageRef>(cgImage);
     }
 
     // Since we may receive multiple flushes before a new frame is started, we do not
diff --git a/src/plugins/platforms/cocoa/qcocoacolordialoghelper.mm b/src/plugins/platforms/cocoa/qcocoacolordialoghelper.mm
index d7850b1481..c9fa035d87 100644
--- a/src/plugins/platforms/cocoa/qcocoacolordialoghelper.mm
+++ b/src/plugins/platforms/cocoa/qcocoacolordialoghelper.mm
@@ -293,7 +293,7 @@ class QCocoaColorPanel
 public:
     QCocoaColorPanel()
     {
-        mDelegate = [[QT_MANGLE_NAMESPACE(QNSColorPanelDelegate) alloc] init];
+        mDelegate = [[QNSColorPanelDelegate alloc] init];
     }
 
     ~QCocoaColorPanel()
@@ -366,7 +366,7 @@ public:
     }
 
 private:
-    QT_MANGLE_NAMESPACE(QNSColorPanelDelegate) *mDelegate;
+    QNSColorPanelDelegate *mDelegate;
 };
 
 Q_GLOBAL_STATIC(QCocoaColorPanel, sharedColorPanel)
diff --git a/src/plugins/platforms/cocoa/qcocoafiledialoghelper.h b/src/plugins/platforms/cocoa/qcocoafiledialoghelper.h
index 2ddda14289..dd0afbefe6 100644
--- a/src/plugins/platforms/cocoa/qcocoafiledialoghelper.h
+++ b/src/plugins/platforms/cocoa/qcocoafiledialoghelper.h
@@ -43,10 +43,16 @@
 #include <QObject>
 #include <QtWidgets/qtwidgetsglobal.h>
 #include <qpa/qplatformdialoghelper.h>
+#include <QtCore/private/qcore_mac_p.h>
+
+#import <AppKit/NSSavePanel.h>
 
 QT_REQUIRE_CONFIG(filedialog);
 
-Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate));
+@interface QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) : NSObject<NSOpenSavePanelDelegate>
+@end
+
+QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSOpenSavePanelDelegate);
 
 QT_BEGIN_NAMESPACE
 
@@ -84,7 +90,7 @@ public:
     void QNSOpenSavePanelDelegate_filterSelected(int menuIndex);
 
 private:
-    QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate) *mDelegate;
+    QNSOpenSavePanelDelegate *mDelegate;
     QUrl mDir;
 };
 
diff --git a/src/plugins/platforms/cocoa/qcocoafiledialoghelper.mm b/src/plugins/platforms/cocoa/qcocoafiledialoghelper.mm
index 5f32400af0..6aa21d78d1 100644
--- a/src/plugins/platforms/cocoa/qcocoafiledialoghelper.mm
+++ b/src/plugins/platforms/cocoa/qcocoafiledialoghelper.mm
@@ -76,27 +76,6 @@ QT_USE_NAMESPACE
 
 typedef QSharedPointer<QFileDialogOptions> SharedPointerFileDialogOptions;
 
-@interface QT_MANGLE_NAMESPACE(QNSOpenSavePanelDelegate)
-    : NSObject<NSOpenSavePanelDelegate>
-
-- (NSString *)strip:(const QString &)label;
-- (BOOL)panel:(id)sender shouldEnableURL:(NSURL *)url;
-- (void)filterChanged:(id)sender;
-- (void)showModelessPanel;
-- (BOOL)runApplicationModalPanel;
-- (void)showWindowModalSheet:(QWindow *)docWidget;
-- (void)updateProperties;
-- (QStringList)acceptableExtensionsForSave;
-- (QString)removeExtensions:(const QString &)filter;
-- (void)createTextField;
-- (void)createPopUpButton:(const QString &)selectedFilter hideDetails:(BOOL)hideDetails;
-- (QStringList)findStrippedFilterWithVisualFilterName:(QString)name;
-- (void)createAccessory;
-
-@end
-
-QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSOpenSavePanelDelegate);
-
 @implementation QNSOpenSavePanelDelegate {
     @public
     NSOpenPanel *mOpenPanel;
@@ -214,7 +193,7 @@ static QString strippedText(QString s)
         NSString *filepath = info.filePath().toNSString();
         NSURL *url = [NSURL fileURLWithPath:filepath isDirectory:info.isDir()];
         bool selectable = (mOptions->acceptMode() == QFileDialogOptions::AcceptSave)
-            || [self panel:nil shouldEnableURL:url];
+            || [self panel:mOpenPanel shouldEnableURL:url];
 
         [self updateProperties];
         [mSavePanel setNameFieldStringValue:selectable ? info.fileName().toNSString() : @""];
@@ -233,7 +212,7 @@ static QString strippedText(QString s)
     NSString *filepath = info.filePath().toNSString();
     NSURL *url = [NSURL fileURLWithPath:filepath isDirectory:info.isDir()];
     bool selectable = (mOptions->acceptMode() == QFileDialogOptions::AcceptSave)
-        || [self panel:nil shouldEnableURL:url];
+        || [self panel:mSavePanel shouldEnableURL:url];
 
     [mSavePanel setDirectoryURL: [NSURL fileURLWithPath:mCurrentDir]];
     [mSavePanel setNameFieldStringValue:selectable ? info.fileName().toNSString() : @""];
@@ -263,7 +242,7 @@ static QString strippedText(QString s)
     NSString *filepath = info.filePath().toNSString();
     NSURL *url = [NSURL fileURLWithPath:filepath isDirectory:info.isDir()];
     bool selectable = (mOptions->acceptMode() == QFileDialogOptions::AcceptSave)
-        || [self panel:nil shouldEnableURL:url];
+        || [self panel:mSavePanel shouldEnableURL:url];
 
     [self updateProperties];
     [mSavePanel setDirectoryURL: [NSURL fileURLWithPath:mCurrentDir]];
diff --git a/src/plugins/platforms/cocoa/qcocoafontdialoghelper.mm b/src/plugins/platforms/cocoa/qcocoafontdialoghelper.mm
index 8c0af97a68..7748c304e3 100644
--- a/src/plugins/platforms/cocoa/qcocoafontdialoghelper.mm
+++ b/src/plugins/platforms/cocoa/qcocoafontdialoghelper.mm
@@ -283,7 +283,7 @@ class QCocoaFontPanel
 public:
     QCocoaFontPanel()
     {
-        mDelegate = [[QT_MANGLE_NAMESPACE(QNSFontPanelDelegate) alloc] init];
+        mDelegate = [[QNSFontPanelDelegate alloc] init];
     }
 
     ~QCocoaFontPanel()
@@ -356,7 +356,7 @@ public:
     }
 
 private:
-    QT_MANGLE_NAMESPACE(QNSFontPanelDelegate) *mDelegate;
+    QNSFontPanelDelegate *mDelegate;
 };
 
 Q_GLOBAL_STATIC(QCocoaFontPanel, sharedFontPanel)
diff --git a/src/plugins/platforms/cocoa/qcocoamenu.h b/src/plugins/platforms/cocoa/qcocoamenu.h
index a957710a88..1dccf0621c 100644
--- a/src/plugins/platforms/cocoa/qcocoamenu.h
+++ b/src/plugins/platforms/cocoa/qcocoamenu.h
@@ -44,8 +44,7 @@
 #include <QtCore/QList>
 #include <qpa/qplatformmenu.h>
 #include "qcocoamenuitem.h"
-
-Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(QCocoaNSMenu));
+#include "qcocoansmenu.h"
 
 QT_BEGIN_NAMESPACE
 
@@ -107,7 +106,7 @@ private:
     void scheduleUpdate();
 
     QList<QCocoaMenuItem *> m_menuItems;
-    QT_MANGLE_NAMESPACE(QCocoaNSMenu) *m_nativeMenu;
+    QCocoaNSMenu *m_nativeMenu;
     NSMenuItem *m_attachedItem;
     int m_updateTimer;
     bool m_enabled:1;
diff --git a/src/plugins/platforms/cocoa/qcocoamenubar.mm b/src/plugins/platforms/cocoa/qcocoamenubar.mm
index 30bff78a36..363defdd28 100644
--- a/src/plugins/platforms/cocoa/qcocoamenubar.mm
+++ b/src/plugins/platforms/cocoa/qcocoamenubar.mm
@@ -278,12 +278,11 @@ void QCocoaMenuBar::updateMenuBarImmediately()
         // we still have to update the menubar.
         if ((win->flags() & Qt::WindowType_Mask) != Qt::Tool)
             return;
-        typedef QT_MANGLE_NAMESPACE(QCocoaApplicationDelegate) AppDelegate;
         NSApplication *app = [NSApplication sharedApplication];
-        if (![app.delegate isKindOfClass:[AppDelegate class]])
+        if (![app.delegate isKindOfClass:[QCocoaApplicationDelegate class]])
             return;
         // We apply this logic _only_ during the startup.
-        AppDelegate *appDelegate = app.delegate;
+        QCocoaApplicationDelegate *appDelegate = app.delegate;
         if (!appDelegate.inLaunch)
             return;
     }
@@ -403,3 +402,4 @@ QCocoaWindow *QCocoaMenuBar::cocoaWindow() const
 
 QT_END_NAMESPACE
 
+#include "moc_qcocoamenubar.cpp"
diff --git a/src/plugins/platforms/cocoa/qcocoansmenu.h b/src/plugins/platforms/cocoa/qcocoansmenu.h
index 6cbb6e4a01..0c77e2f1aa 100644
--- a/src/plugins/platforms/cocoa/qcocoansmenu.h
+++ b/src/plugins/platforms/cocoa/qcocoansmenu.h
@@ -59,31 +59,20 @@ QT_FORWARD_DECLARE_CLASS(QCocoaMenu);
 QT_FORWARD_DECLARE_CLASS(QCocoaMenuItem);
 
 @interface QT_MANGLE_NAMESPACE(QCocoaNSMenuDelegate) : NSObject <NSMenuDelegate>
-
 + (instancetype)sharedMenuDelegate;
-
-- (NSMenuItem *)findItemInMenu:(NSMenu *)menu
-                        forKey:(NSString *)key
-                     modifiers:(NSUInteger)modifiers;
-
+- (NSMenuItem *)findItemInMenu:(NSMenu *)menu forKey:(NSString *)key modifiers:(NSUInteger)modifiers;
 @end
 
 @interface QT_MANGLE_NAMESPACE(QCocoaNSMenu) : NSMenu
-
 @property (readonly, nonatomic) QCocoaMenu *platformMenu;
-
 - (instancetype)initWithPlatformMenu:(QCocoaMenu *)menu;
-
 @end
 
 @interface QT_MANGLE_NAMESPACE(QCocoaNSMenuItem) : NSMenuItem
-
 @property (nonatomic) QCocoaMenuItem *platformMenuItem;
-
 + (instancetype)separatorItemWithPlatformMenuItem:(QCocoaMenuItem *)menuItem;
 - (instancetype)initWithPlatformMenuItem:(QCocoaMenuItem *)menuItem;
 - (instancetype)init;
-
 @end
 
 QT_NAMESPACE_ALIAS_OBJC_CLASS(QCocoaNSMenu);
diff --git a/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
index db64702b8d..a5b42ac4e3 100644
--- a/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
+++ b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
@@ -80,6 +80,8 @@
 #include <qimagewriter.h>
 #include <qdebug.h>
 
+#include <QtCore/private/qcore_mac_p.h>
+
 #include "qcocoamenu.h"
 
 #include "qt_mac_p.h"
@@ -92,8 +94,6 @@
 
 QT_USE_NAMESPACE
 
-@class QT_MANGLE_NAMESPACE(QNSImageView);
-
 @interface QT_MANGLE_NAMESPACE(QNSStatusItem) : NSObject <NSUserNotificationCenterDelegate>
 @property (nonatomic, assign) QCocoaMenu *menu;
 @property (nonatomic, assign) QIcon icon;
@@ -104,12 +104,13 @@ QT_USE_NAMESPACE
 - (void)doubleClickSelector:(id)sender;
 @end
 
+QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSStatusItem);
+
 @interface QT_MANGLE_NAMESPACE(QNSImageView) : NSImageView
 @property (nonatomic, assign) BOOL down;
-@property (nonatomic, assign) QT_MANGLE_NAMESPACE(QNSStatusItem) *parent;
+@property (nonatomic, assign) QNSStatusItem *parent;
 @end
 
-QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSStatusItem);
 QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSImageView);
 
 QT_BEGIN_NAMESPACE
@@ -360,7 +361,7 @@ QT_END_NAMESPACE
 @implementation QNSStatusItem {
     QCocoaSystemTrayIcon *systray;
     NSStatusItem *item;
-    QT_MANGLE_NAMESPACE(QNSImageView) *imageCell;
+    QNSImageView *imageCell;
 }
 
 @synthesize menu = menu;
diff --git a/src/plugins/platforms/cocoa/qcocoatheme.h b/src/plugins/platforms/cocoa/qcocoatheme.h
index 788b616e78..a00cbdfea3 100644
--- a/src/plugins/platforms/cocoa/qcocoatheme.h
+++ b/src/plugins/platforms/cocoa/qcocoatheme.h
@@ -43,8 +43,6 @@
 #include <QtCore/QHash>
 #include <qpa/qplatformtheme.h>
 
-Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(QCocoaThemeAppAppearanceObserver));
-
 #include <QtCore/private/qcore_mac_p.h>
 
 QT_BEGIN_NAMESPACE
diff --git a/src/plugins/platforms/cocoa/qcocoawindow.mm b/src/plugins/platforms/cocoa/qcocoawindow.mm
index 35b7162346..a744a86695 100644
--- a/src/plugins/platforms/cocoa/qcocoawindow.mm
+++ b/src/plugins/platforms/cocoa/qcocoawindow.mm
@@ -1275,14 +1275,11 @@ void QCocoaWindow::windowWillClose()
 bool QCocoaWindow::windowShouldClose()
 {
     qCDebug(lcQpaWindow) << "QCocoaWindow::windowShouldClose" << window();
-   // This callback should technically only determine if the window
-   // should (be allowed to) close, but since our QPA API to determine
-   // that also involves actually closing the window we do both at the
-   // same time, instead of doing the latter in windowWillClose.
-    bool accepted = false;
-    QWindowSystemInterface::handleCloseEvent(window(), &accepted);
-    QWindowSystemInterface::flushWindowSystemEvents();
-    return accepted;
+    // This callback should technically only determine if the window
+    // should (be allowed to) close, but since our QPA API to determine
+    // that also involves actually closing the window we do both at the
+    // same time, instead of doing the latter in windowWillClose.
+    return QWindowSystemInterface::handleCloseEvent<QWindowSystemInterface::SynchronousDelivery>(window());
 }
 
 // ----------------------------- QPA forwarding -----------------------------
diff --git a/src/plugins/platforms/cocoa/qnsview.h b/src/plugins/platforms/cocoa/qnsview.h
index b40dfe0d14..74d0735b4c 100644
--- a/src/plugins/platforms/cocoa/qnsview.h
+++ b/src/plugins/platforms/cocoa/qnsview.h
@@ -51,37 +51,30 @@ class QCocoaGLContext;
 class QPointF;
 QT_END_NAMESPACE
 
-Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(QNSViewMouseMoveHelper));
-Q_FORWARD_DECLARE_OBJC_CLASS(QT_MANGLE_NAMESPACE(QCocoaNSMenuItem));
-
 @interface QT_MANGLE_NAMESPACE(QNSView) : NSView
-
 @property (nonatomic, retain) NSCursor *cursor;
-
 - (instancetype)initWithCocoaWindow:(QCocoaWindow *)platformWindow;
-
 - (void)convertFromScreen:(NSPoint)mouseLocation toWindowPoint:(QPointF *)qtWindowPoint andScreenPoint:(QPointF *)qtScreenPoint;
-
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (MouseAPI)
+QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSView);
+
+@interface QNSView (MouseAPI)
 - (void)handleFrameStrutMouseEvent:(NSEvent *)theEvent;
 - (void)resetMouseButtons;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (KeysAPI)
+@interface QNSView (KeysAPI)
 + (Qt::KeyboardModifiers)convertKeyModifiers:(ulong)modifierFlags;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (ComplexTextAPI)
+@interface QNSView (ComplexTextAPI)
 - (void)unmarkText;
 - (void)cancelComposingText;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (QtExtras)
+@interface QNSView (QtExtras)
 @property (nonatomic, readonly) QCocoaWindow *platformWindow;
 @end
 
-QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSView);
-
 #endif //QNSVIEW_H
diff --git a/src/plugins/platforms/cocoa/qnsview.mm b/src/plugins/platforms/cocoa/qnsview.mm
index 5309449dce..a6e5ca5f7b 100644
--- a/src/plugins/platforms/cocoa/qnsview.mm
+++ b/src/plugins/platforms/cocoa/qnsview.mm
@@ -66,13 +66,13 @@
 #include "qcocoaintegration.h"
 
 // Private interface
-@interface QT_MANGLE_NAMESPACE(QNSView) ()
+@interface QNSView ()
 - (BOOL)isTransparentForUserInput;
 @property (assign) NSView* previousSuperview;
 @property (assign) NSWindow* previousWindow;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Drawing) <CALayerDelegate>
+@interface QNSView (Drawing) <CALayerDelegate>
 - (void)initDrawing;
 @end
 
@@ -84,7 +84,9 @@
 - (void)cursorUpdate:(NSEvent *)theEvent;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Mouse)
+QT_NAMESPACE_ALIAS_OBJC_CLASS(QNSViewMouseMoveHelper);
+
+@interface QNSView (Mouse)
 - (void)initMouse;
 - (NSPoint)screenMousePoint:(NSEvent *)theEvent;
 - (void)mouseMovedImpl:(NSEvent *)theEvent;
@@ -92,28 +94,28 @@
 - (void)mouseExitedImpl:(NSEvent *)theEvent;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Touch)
+@interface QNSView (Touch)
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Tablet)
+@interface QNSView (Tablet)
 - (bool)handleTabletEvent:(NSEvent *)theEvent;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Gestures)
+@interface QNSView (Gestures)
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Dragging)
+@interface QNSView (Dragging)
 -(void)registerDragTypes;
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Keys)
+@interface QNSView (Keys)
 @end
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (ComplexText) <NSTextInputClient>
+@interface QNSView (ComplexText) <NSTextInputClient>
 - (void)textInputContextKeyboardSelectionDidChangeNotification:(NSNotification *)textInputContextKeyboardSelectionDidChangeNotification;
 @end
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) {
+@implementation QNSView {
     QPointer<QCocoaWindow> m_platformWindow;
     Qt::MouseButtons m_buttons;
     Qt::MouseButtons m_acceptedMouseDowns;
@@ -125,7 +127,7 @@
     bool m_sendUpAsRightButton;
     Qt::KeyboardModifiers m_currentWheelModifiers;
     NSString *m_inputSource;
-    QT_MANGLE_NAMESPACE(QNSViewMouseMoveHelper) *m_mouseMoveHelper;
+    QNSViewMouseMoveHelper *m_mouseMoveHelper;
     bool m_resendKeyEvent;
     bool m_scrolling;
     bool m_updatingDrag;
@@ -379,7 +381,7 @@
 
 // -----------------------------------------------------
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (QtExtras)
+@implementation QNSView (QtExtras)
 
 - (QCocoaWindow*)platformWindow
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_accessibility.mm b/src/plugins/platforms/cocoa/qnsview_accessibility.mm
index 32ec0b74d4..7041e14da7 100644
--- a/src/plugins/platforms/cocoa/qnsview_accessibility.mm
+++ b/src/plugins/platforms/cocoa/qnsview_accessibility.mm
@@ -47,7 +47,7 @@
 
 #import <AppKit/NSAccessibility.h>
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Accessibility)
+@implementation QNSView (Accessibility)
 
 - (id)childAccessibleElement
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_complextext.mm b/src/plugins/platforms/cocoa/qnsview_complextext.mm
index 6ff9b26ca4..5926840cf3 100644
--- a/src/plugins/platforms/cocoa/qnsview_complextext.mm
+++ b/src/plugins/platforms/cocoa/qnsview_complextext.mm
@@ -39,7 +39,7 @@
 
 // This file is included from qnsview.mm, and only used to organize the code
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (ComplexTextAPI)
+@implementation QNSView (ComplexTextAPI)
 
 - (void)cancelComposingText
 {
@@ -80,7 +80,7 @@
 
 @end
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (ComplexText)
+@implementation QNSView (ComplexText)
 
 - (void)insertNewline:(id)sender
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_dragging.mm b/src/plugins/platforms/cocoa/qnsview_dragging.mm
index 41b96b2df6..650612e7ff 100644
--- a/src/plugins/platforms/cocoa/qnsview_dragging.mm
+++ b/src/plugins/platforms/cocoa/qnsview_dragging.mm
@@ -39,7 +39,7 @@
 
 // This file is included from qnsview.mm, and only used to organize the code
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Dragging)
+@implementation QNSView (Dragging)
 
 -(void)registerDragTypes
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_drawing.mm b/src/plugins/platforms/cocoa/qnsview_drawing.mm
index ce5488ead0..eb9286519d 100644
--- a/src/plugins/platforms/cocoa/qnsview_drawing.mm
+++ b/src/plugins/platforms/cocoa/qnsview_drawing.mm
@@ -39,7 +39,7 @@
 
 // This file is included from qnsview.mm, and only used to organize the code
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Drawing)
+@implementation QNSView (Drawing)
 
 - (void)initDrawing
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_gestures.mm b/src/plugins/platforms/cocoa/qnsview_gestures.mm
index f6cd3af4da..a80261fd6a 100644
--- a/src/plugins/platforms/cocoa/qnsview_gestures.mm
+++ b/src/plugins/platforms/cocoa/qnsview_gestures.mm
@@ -43,7 +43,7 @@
 
 Q_LOGGING_CATEGORY(lcQpaGestures, "qt.qpa.input.gestures")
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Gestures)
+@implementation QNSView (Gestures)
 
 - (bool)handleGestureAsBeginEnd:(NSEvent *)event
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_keys.mm b/src/plugins/platforms/cocoa/qnsview_keys.mm
index ad751279bb..847adca207 100644
--- a/src/plugins/platforms/cocoa/qnsview_keys.mm
+++ b/src/plugins/platforms/cocoa/qnsview_keys.mm
@@ -39,7 +39,7 @@
 
 // This file is included from qnsview.mm, and only used to organize the code
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (KeysAPI)
+@implementation QNSView (KeysAPI)
 
 + (Qt::KeyboardModifiers)convertKeyModifiers:(ulong)modifierFlags
 {
@@ -60,7 +60,7 @@
 
 @end
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Keys)
+@implementation QNSView (Keys)
 
 - (int)convertKeyCode:(QChar)keyChar
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_menus.mm b/src/plugins/platforms/cocoa/qnsview_menus.mm
index f0489552aa..a55fd97eb7 100644
--- a/src/plugins/platforms/cocoa/qnsview_menus.mm
+++ b/src/plugins/platforms/cocoa/qnsview_menus.mm
@@ -53,11 +53,11 @@ static bool selectorIsCutCopyPaste(SEL selector)
             || selector == @selector(selectAll:));
 }
 
-@interface QT_MANGLE_NAMESPACE(QNSView) (Menus)
+@interface QNSView (Menus)
 - (void)qt_itemFired:(QCocoaNSMenuItem *)item;
 @end
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Menus)
+@implementation QNSView (Menus)
 
 - (BOOL)validateMenuItem:(NSMenuItem*)item
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_mouse.mm b/src/plugins/platforms/cocoa/qnsview_mouse.mm
index 30613eca32..9e2761f850 100644
--- a/src/plugins/platforms/cocoa/qnsview_mouse.mm
+++ b/src/plugins/platforms/cocoa/qnsview_mouse.mm
@@ -55,7 +55,7 @@
     interact with the responder chain by e.g. calling super if Qt does not
     accept the mouse event
 */
-@implementation QT_MANGLE_NAMESPACE(QNSViewMouseMoveHelper) {
+@implementation QNSViewMouseMoveHelper {
     QNSView *view;
 }
 
@@ -89,7 +89,7 @@
 
 @end
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (MouseAPI)
+@implementation QNSView (MouseAPI)
 
 - (void)resetMouseButtons
 {
@@ -178,7 +178,7 @@
 }
 @end
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Mouse)
+@implementation QNSView (Mouse)
 
 - (void)initMouse
 {
@@ -193,7 +193,7 @@
     m_dontOverrideCtrlLMB = qt_mac_resolveOption(false, m_platformWindow->window(),
             "_q_platform_MacDontOverrideCtrlLMB", "QT_MAC_DONT_OVERRIDE_CTRL_LMB");
 
-    m_mouseMoveHelper = [[QT_MANGLE_NAMESPACE(QNSViewMouseMoveHelper) alloc] initWithView:self];
+    m_mouseMoveHelper = [[QNSViewMouseMoveHelper alloc] initWithView:self];
 
     NSUInteger trackingOptions = NSTrackingActiveInActiveApp
         | NSTrackingMouseEnteredAndExited | NSTrackingCursorUpdate;
diff --git a/src/plugins/platforms/cocoa/qnsview_tablet.mm b/src/plugins/platforms/cocoa/qnsview_tablet.mm
index 43b0aa0960..ba1fa55892 100644
--- a/src/plugins/platforms/cocoa/qnsview_tablet.mm
+++ b/src/plugins/platforms/cocoa/qnsview_tablet.mm
@@ -54,7 +54,7 @@ struct QCocoaTabletDeviceData
 typedef QHash<uint, QCocoaTabletDeviceData> QCocoaTabletDeviceDataHash;
 Q_GLOBAL_STATIC(QCocoaTabletDeviceDataHash, tabletDeviceDataHash)
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Tablet)
+@implementation QNSView (Tablet)
 
 - (bool)handleTabletEvent:(NSEvent *)theEvent
 {
diff --git a/src/plugins/platforms/cocoa/qnsview_touch.mm b/src/plugins/platforms/cocoa/qnsview_touch.mm
index 9330844aec..8dfae27c63 100644
--- a/src/plugins/platforms/cocoa/qnsview_touch.mm
+++ b/src/plugins/platforms/cocoa/qnsview_touch.mm
@@ -41,7 +41,7 @@
 
 Q_LOGGING_CATEGORY(lcQpaTouch, "qt.qpa.input.touch")
 
-@implementation QT_MANGLE_NAMESPACE(QNSView) (Touch)
+@implementation QNSView (Touch)
 
 - (bool)shouldSendSingleTouch
 {
diff --git a/src/plugins/platforms/cocoa/qprintengine_mac_p.h b/src/plugins/platforms/cocoa/qprintengine_mac_p.h
index 3d94227ae4..6a1ed2e263 100644
--- a/src/plugins/platforms/cocoa/qprintengine_mac_p.h
+++ b/src/plugins/platforms/cocoa/qprintengine_mac_p.h
@@ -64,11 +64,7 @@
 
 #include "qpaintengine_mac_p.h"
 
-#ifdef __OBJC__
-@class NSPrintInfo;
-#else
-typedef void NSPrintInfo;
-#endif
+Q_FORWARD_DECLARE_OBJC_CLASS(NSPrintInfo);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp b/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp
index d7aba66b2f..03be44e095 100644
--- a/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp
+++ b/src/plugins/platforms/direct2d/qwindowsdirect2dpaintengine.cpp
@@ -941,6 +941,8 @@ public:
     {
         Q_Q(QWindowsDirect2DPaintEngine);
 
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
         // Default path (no optimization)
         if (!(path.shape() == QVectorPath::LinesHint || path.shape() == QVectorPath::PolygonHint)
                 || !pen.dashBrush
@@ -948,6 +950,7 @@ public:
                 || q->state()->renderHints.testFlag(QPainter::HighQualityAntialiasing)
 #endif
                 || q->state()->renderHints.testFlag(QPainter::Antialiasing)) {
+QT_WARNING_POP
             ComPtr<ID2D1Geometry> geometry = vectorPathToID2D1PathGeometry(path);
             if (!geometry) {
                 qWarning("%s: Could not convert path to d2d geometry", __FUNCTION__);
diff --git a/src/plugins/platforms/haiku/qhaikuapplication.cpp b/src/plugins/platforms/haiku/qhaikuapplication.cpp
index b75810c453..de4acdfd4a 100644
--- a/src/plugins/platforms/haiku/qhaikuapplication.cpp
+++ b/src/plugins/platforms/haiku/qhaikuapplication.cpp
@@ -42,6 +42,8 @@
 #include <QCoreApplication>
 #include <QFileOpenEvent>
 
+#include <qpa/qwindowsysteminterface.h>
+
 #include <Entry.h>
 #include <Path.h>
 
@@ -52,8 +54,7 @@ QHaikuApplication::QHaikuApplication(const char *signature)
 
 bool QHaikuApplication::QuitRequested()
 {
-    QEvent quitEvent(QEvent::Quit);
-    QCoreApplication::sendEvent(QCoreApplication::instance(), &quitEvent);
+    QWindowSystemInterface::handleApplicationTermination<QWindowSystemInterface::SynchronousDelivery>();
     return true;
 }
 
diff --git a/src/plugins/platforms/ios/qioseventdispatcher.mm b/src/plugins/platforms/ios/qioseventdispatcher.mm
index 776343c5aa..c5856051de 100644
--- a/src/plugins/platforms/ios/qioseventdispatcher.mm
+++ b/src/plugins/platforms/ios/qioseventdispatcher.mm
@@ -211,6 +211,8 @@ namespace
     } logActivity;
 }
 
+using namespace QT_PREPEND_NAMESPACE(QtPrivate);
+
 extern "C" int qt_main_wrapper(int argc, char *argv[])
 {
     @autoreleasepool {
diff --git a/src/plugins/platforms/windows/openglblacklists/default.json b/src/plugins/platforms/windows/openglblacklists/default.json
index 3cfa7e3856..e37351f9e0 100644
--- a/src/plugins/platforms/windows/openglblacklists/default.json
+++ b/src/plugins/platforms/windows/openglblacklists/default.json
@@ -152,6 +152,18 @@
            "features": [
                "disable_program_cache"
            ]
-        }
+        },
+        {
+           "id": 13,
+           "description": "Disable DesktopGL on Windows with Mobile Intel(R) 4 Series Express Chipset Family graphics card (QTBUG-58772)",
+           "vendor_id": "0x8086",
+           "device_id": [ "0x2A42" ],
+           "os": {
+               "type": "win"
+           },
+           "features": [
+               "disable_desktopgl"
+           ]
+       }
     ]
 }
diff --git a/src/plugins/platforms/windows/qwindowsclipboard.cpp b/src/plugins/platforms/windows/qwindowsclipboard.cpp
index b87e43f3f7..4e6d3306e1 100644
--- a/src/plugins/platforms/windows/qwindowsclipboard.cpp
+++ b/src/plugins/platforms/windows/qwindowsclipboard.cpp
@@ -115,12 +115,21 @@ static QDebug operator<<(QDebug d, const QMimeData *mimeData)
 
 IDataObject *QWindowsClipboardRetrievalMimeData::retrieveDataObject() const
 {
+    enum : int { attempts = 3 };
     IDataObject * pDataObj = nullptr;
-    if (OleGetClipboard(&pDataObj) == S_OK) {
-        if (QWindowsContext::verbose > 1)
-            qCDebug(lcQpaMime) << __FUNCTION__ << pDataObj;
-        return pDataObj;
+    // QTBUG-53979, retry in case the other application has clipboard locked
+    for (int i = 1; i <= attempts; ++i) {
+        if (SUCCEEDED(OleGetClipboard(&pDataObj))) {
+            if (QWindowsContext::verbose > 1)
+                qCDebug(lcQpaMime) << __FUNCTION__ << pDataObj;
+            return pDataObj;
+        }
+        qCWarning(lcQpaMime, i == attempts
+                  ? "Unable to obtain clipboard."
+                  : "Retrying to obtain clipboard.");
+        QThread::msleep(50);
     }
+
     return nullptr;
 }
 
diff --git a/src/plugins/platforms/windows/qwindowscontext.cpp b/src/plugins/platforms/windows/qwindowscontext.cpp
index bb349f08a7..f7d04b667d 100644
--- a/src/plugins/platforms/windows/qwindowscontext.cpp
+++ b/src/plugins/platforms/windows/qwindowscontext.cpp
@@ -79,6 +79,7 @@
 #include <QtCore/qscopedpointer.h>
 #include <QtCore/quuid.h>
 #include <QtCore/private/qsystemlibrary_p.h>
+#include <QtCore/private/qwinregistry_p.h>
 
 #include <QtEventDispatcherSupport/private/qwindowsguieventdispatcher_p.h>
 
@@ -1518,28 +1519,13 @@ QTouchDevice *QWindowsContext::touchDevice() const
         d->m_pointerHandler.touchDevice() : d->m_mouseHandler.touchDevice();
 }
 
-static DWORD readDwordRegistrySetting(const wchar_t *regKey, const wchar_t *subKey, DWORD defaultValue)
-{
-    DWORD result = defaultValue;
-    HKEY handle;
-    if (RegOpenKeyEx(HKEY_CURRENT_USER, regKey, 0, KEY_READ, &handle) == ERROR_SUCCESS) {
-        DWORD type;
-        if (RegQueryValueEx(handle, subKey, nullptr, &type, nullptr, nullptr) == ERROR_SUCCESS
-            && type == REG_DWORD) {
-            DWORD value;
-            DWORD size = sizeof(result);
-            if (RegQueryValueEx(handle, subKey, nullptr, nullptr, reinterpret_cast<unsigned char *>(&value), &size) == ERROR_SUCCESS)
-                result = value;
-        }
-        RegCloseKey(handle);
-    }
-    return result;
-}
-
 DWORD QWindowsContext::readAdvancedExplorerSettings(const wchar_t *subKey, DWORD defaultValue)
 {
-    return readDwordRegistrySetting(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced",
-                                    subKey, defaultValue);
+    const auto value =
+        QWinRegistryKey(HKEY_CURRENT_USER,
+                        LR"(Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced)")
+                       .dwordValue(subKey);
+    return value.second ? value.first : defaultValue;
 }
 
 static inline bool isEmptyRect(const RECT &rect)
diff --git a/src/plugins/platforms/windows/qwindowsservices.cpp b/src/plugins/platforms/windows/qwindowsservices.cpp
index b2b1dee232..83b052bb49 100644
--- a/src/plugins/platforms/windows/qwindowsservices.cpp
+++ b/src/plugins/platforms/windows/qwindowsservices.cpp
@@ -45,6 +45,8 @@
 #include <QtCore/qdebug.h>
 #include <QtCore/qdir.h>
 
+#include <QtCore/private/qwinregistry_p.h>
+
 #include <shlobj.h>
 #include <intshcut.h>
 
@@ -78,35 +80,24 @@ static inline QString mailCommand()
 
     const wchar_t mailUserKey[] = L"Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\mailto\\UserChoice";
 
-    wchar_t command[MAX_PATH] = {0};
     // Check if user has set preference, otherwise use default.
-    HKEY handle;
-    QString keyName;
-    if (!RegOpenKeyEx(HKEY_CURRENT_USER, mailUserKey, 0, KEY_READ, &handle)) {
-        DWORD bufferSize = BufferSize;
-        if (!RegQueryValueEx(handle, L"Progid", nullptr, nullptr, reinterpret_cast<unsigned char*>(command), &bufferSize))
-            keyName = QString::fromWCharArray(command);
-        RegCloseKey(handle);
-    }
+    QString keyName = QWinRegistryKey(HKEY_CURRENT_USER, mailUserKey)
+                      .stringValue( L"Progid");
     const QLatin1String mailto = keyName.isEmpty() ? QLatin1String("mailto") : QLatin1String();
     keyName += mailto + QLatin1String("\\Shell\\Open\\Command");
     if (debug)
         qDebug() << __FUNCTION__ << "keyName=" << keyName;
-    command[0] = 0;
-    if (!RegOpenKeyExW(HKEY_CLASSES_ROOT, reinterpret_cast<const wchar_t*>(keyName.utf16()), 0, KEY_READ, &handle)) {
-        DWORD bufferSize = BufferSize;
-        RegQueryValueEx(handle, L"", nullptr, nullptr, reinterpret_cast<unsigned char*>(command), &bufferSize);
-        RegCloseKey(handle);
-    }
+    const QString command = QWinRegistryKey(HKEY_CLASSES_ROOT, keyName).stringValue(L"");
     // QTBUG-57816: As of Windows 10, if there is no mail client installed, an entry like
     // "rundll32.exe .. url.dll,MailToProtocolHandler %l" is returned. Launching it
     // silently fails or brings up a broken dialog after a long time, so exclude it and
     // fall back to ShellExecute() which brings up the URL assocation dialog.
-    if (!command[0] || wcsstr(command, L",MailToProtocolHandler") != nullptr)
+    if (command.isEmpty() || command.contains(QLatin1String(",MailToProtocolHandler")))
         return QString();
     wchar_t expandedCommand[MAX_PATH] = {0};
-    return ExpandEnvironmentStrings(command, expandedCommand, MAX_PATH) ?
-           QString::fromWCharArray(expandedCommand) : QString::fromWCharArray(command);
+    return ExpandEnvironmentStrings(reinterpret_cast<const wchar_t *>(command.utf16()),
+                                    expandedCommand, MAX_PATH)
+        ? QString::fromWCharArray(expandedCommand) : command;
 }
 
 static inline bool launchMail(const QUrl &url)
diff --git a/src/plugins/platforms/xcb/qxcbscreen.cpp b/src/plugins/platforms/xcb/qxcbscreen.cpp
index 0fe22bd318..8da299d491 100644
--- a/src/plugins/platforms/xcb/qxcbscreen.cpp
+++ b/src/plugins/platforms/xcb/qxcbscreen.cpp
@@ -773,7 +773,7 @@ void QXcbScreen::updateRefreshRate(xcb_randr_mode_t mode)
             xcb_randr_mode_info_t *modeInfo = modesIter.data;
             if (modeInfo->id == mode) {
                 const uint32_t dotCount = modeInfo->htotal * modeInfo->vtotal;
-                m_refreshRate = (dotCount != 0) ? modeInfo->dot_clock / dotCount : 0;
+                m_refreshRate = (dotCount != 0) ? modeInfo->dot_clock / qreal(dotCount) : 0;
                 m_mode = mode;
                 break;
             }
diff --git a/src/plugins/platforms/xcb/qxcbscreen.h b/src/plugins/platforms/xcb/qxcbscreen.h
index 62931d2500..79698b4ef3 100644
--- a/src/plugins/platforms/xcb/qxcbscreen.h
+++ b/src/plugins/platforms/xcb/qxcbscreen.h
@@ -226,7 +226,7 @@ private:
     QRect m_availableGeometry;
     Qt::ScreenOrientation m_orientation = Qt::PrimaryOrientation;
     QXcbCursor *m_cursor;
-    int m_refreshRate = 60;
+    qreal m_refreshRate = 60.0;
     QEdidParser m_edid;
 };
 
diff --git a/src/plugins/platforms/xcb/qxcbsessionmanager.cpp b/src/plugins/platforms/xcb/qxcbsessionmanager.cpp
index 2303ccf806..f880d4d722 100644
--- a/src/plugins/platforms/xcb/qxcbsessionmanager.cpp
+++ b/src/plugins/platforms/xcb/qxcbsessionmanager.cpp
@@ -42,6 +42,8 @@
 
 #ifndef QT_NO_SESSIONMANAGER
 
+#include <qpa/qwindowsysteminterface.h>
+
 #include <qguiapplication.h>
 #include <qdatetime.h>
 #include <qfileinfo.h>
@@ -289,8 +291,7 @@ static void sm_dieCallback(SmcConn smcConn, SmPointer /* clientData */)
     if (smcConn != smcConnection)
         return;
     resetSmState();
-    QEvent quitEvent(QEvent::Quit);
-    QGuiApplication::sendEvent(qApp, &quitEvent);
+    QWindowSystemInterface::handleApplicationTermination<QWindowSystemInterface::SynchronousDelivery>();
 }
 
 static void sm_shutdownCancelledCallback(SmcConn smcConn, SmPointer clientData)
diff --git a/src/plugins/sqldrivers/ibase/qsql_ibase.cpp b/src/plugins/sqldrivers/ibase/qsql_ibase.cpp
index ead08dbce8..0f39f6aa0d 100644
--- a/src/plugins/sqldrivers/ibase/qsql_ibase.cpp
+++ b/src/plugins/sqldrivers/ibase/qsql_ibase.cpp
@@ -40,6 +40,7 @@
 #include "qsql_ibase_p.h"
 #include <qcoreapplication.h>
 #include <qdatetime.h>
+#include <qdeadlinetimer.h>
 #include <qvariant.h>
 #include <qsqlerror.h>
 #include <qsqlfield.h>
@@ -1570,10 +1571,9 @@ void QIBaseDriver::close()
             d->eventBuffers.clear();
 
 #if defined(FB_API_VER)
-            // Workaround for Firebird crash
-            QTime timer;
-            timer.start();
-            while (timer.elapsed() < 500)
+            // TODO check whether this workaround for Firebird crash is still needed
+            QDeadlineTimer timer(500);
+            while (!timer.hasExpired())
                 QCoreApplication::processEvents();
 #endif
         }
diff --git a/src/plugins/sqldrivers/psql/qsql_psql.cpp b/src/plugins/sqldrivers/psql/qsql_psql.cpp
index 28be7bdc38..760685f64b 100644
--- a/src/plugins/sqldrivers/psql/qsql_psql.cpp
+++ b/src/plugins/sqldrivers/psql/qsql_psql.cpp
@@ -812,8 +812,8 @@ QSqlRecord QPSQLResult::record() const
         return info;
 
     int count = PQnfields(d->result);
+    QSqlField f;
     for (int i = 0; i < count; ++i) {
-        QSqlField f;
         if (d->drv_d_func()->isUtf8)
             f.setName(QString::fromUtf8(PQfname(d->result, i)));
         else
@@ -833,6 +833,8 @@ QSqlRecord QPSQLResult::record() const
                 }
             }
             f.setTableName(tableName);
+        } else {
+            f.setTableName(QString());
         }
         int ptype = PQftype(d->result, i);
         f.setType(qDecodePSQLType(ptype));
@@ -1076,8 +1078,10 @@ static QPSQLDriver::Protocol qMakePSQLVersion(int vMaj, int vMin)
         return QPSQLDriver::Version10;
     case 11:
         return QPSQLDriver::Version11;
+    case 12:
+        return QPSQLDriver::Version12;
     default:
-        if (vMaj > 11)
+        if (vMaj > 12)
             return QPSQLDriver::UnknownLaterVersion;
         break;
     }
@@ -1437,26 +1441,29 @@ QSqlRecord QPSQLDriver::record(const QString &tablename) const
     schema = stripDelimiters(schema, QSqlDriver::TableName);
     tbl = stripDelimiters(tbl, QSqlDriver::TableName);
 
-    QString stmt = QStringLiteral("SELECT pg_attribute.attname, pg_attribute.atttypid::int, "
-                                  "pg_attribute.attnotnull, pg_attribute.attlen, pg_attribute.atttypmod, "
-                                  "pg_attrdef.adsrc "
-                                  "FROM pg_class, pg_attribute "
-                                  "LEFT JOIN pg_attrdef ON (pg_attrdef.adrelid = "
-                                  "pg_attribute.attrelid AND pg_attrdef.adnum = pg_attribute.attnum) "
-                                  "WHERE %1 "
-                                  "AND pg_class.relname = '%2' "
-                                  "AND pg_attribute.attnum > 0 "
-                                  "AND pg_attribute.attrelid = pg_class.oid "
-                                  "AND pg_attribute.attisdropped = false "
-                                  "ORDER BY pg_attribute.attnum");
-    if (schema.isEmpty())
-        stmt = stmt.arg(QStringLiteral("pg_table_is_visible(pg_class.oid)"));
-    else
-        stmt = stmt.arg(QStringLiteral("pg_class.relnamespace = (SELECT oid FROM "
-                                            "pg_namespace WHERE pg_namespace.nspname = '%1')").arg(schema));
+    const QString adsrc = protocol() < Version8
+        ? QStringLiteral("pg_attrdef.adsrc")
+        : QStringLiteral("pg_get_expr(pg_attrdef.adbin, pg_attrdef.adrelid)");
+    const QString nspname = schema.isEmpty()
+        ? QStringLiteral("pg_table_is_visible(pg_class.oid)")
+        : QStringLiteral("pg_class.relnamespace = (SELECT oid FROM "
+                         "pg_namespace WHERE pg_namespace.nspname = '%1')").arg(schema);
+    const QString stmt =
+        QStringLiteral("SELECT pg_attribute.attname, pg_attribute.atttypid::int, "
+                       "pg_attribute.attnotnull, pg_attribute.attlen, pg_attribute.atttypmod, "
+                       "%1 "
+                       "FROM pg_class, pg_attribute "
+                       "LEFT JOIN pg_attrdef ON (pg_attrdef.adrelid = "
+                       "pg_attribute.attrelid AND pg_attrdef.adnum = pg_attribute.attnum) "
+                       "WHERE %2 "
+                       "AND pg_class.relname = '%3' "
+                       "AND pg_attribute.attnum > 0 "
+                       "AND pg_attribute.attrelid = pg_class.oid "
+                       "AND pg_attribute.attisdropped = false "
+                       "ORDER BY pg_attribute.attnum").arg(adsrc, nspname, tbl);
 
     QSqlQuery query(createResult());
-    query.exec(stmt.arg(tbl));
+    query.exec(stmt);
     while (query.next()) {
         int len = query.value(3).toInt();
         int precision = query.value(4).toInt();
diff --git a/src/plugins/sqldrivers/psql/qsql_psql_p.h b/src/plugins/sqldrivers/psql/qsql_psql_p.h
index 99e0b5f60f..9ac1fb50d7 100644
--- a/src/plugins/sqldrivers/psql/qsql_psql_p.h
+++ b/src/plugins/sqldrivers/psql/qsql_psql_p.h
@@ -93,6 +93,7 @@ public:
         Version9_6 = 22,
         Version10 = 23,
         Version11 = 24,
+        Version12 = 25,
         UnknownLaterVersion = 100000
     };
 
diff --git a/src/plugins/styles/mac/qmacstyle_mac.mm b/src/plugins/styles/mac/qmacstyle_mac.mm
index b2bcdb3e5b..63dc49fd18 100644
--- a/src/plugins/styles/mac/qmacstyle_mac.mm
+++ b/src/plugins/styles/mac/qmacstyle_mac.mm
@@ -328,6 +328,20 @@ static const int closeButtonSize = 14;
 static const qreal closeButtonCornerRadius = 2.0;
 #endif // QT_CONFIG(tabbar)
 
+#ifndef QT_NO_ACCESSIBILITY // This ifdef to avoid "unused function" warning.
+QBrush brushForToolButton(bool isOnKeyWindow)
+{
+    // When a toolbutton in a toolbar is in the 'ON' state, we draw a
+    // partially transparent background. The colors must be different
+    // for 'Aqua' and 'DarkAqua' appearances though.
+    if (isDarkMode())
+        return isOnKeyWindow ? QColor(73, 73, 73, 100) : QColor(56, 56, 56, 100);
+
+    return isOnKeyWindow ? QColor(0, 0, 0, 28) : QColor(0, 0, 0, 21);
+}
+#endif // QT_NO_ACCESSIBILITY
+
+
 static const int headerSectionArrowHeight = 6;
 static const int headerSectionSeparatorInset = 2;
 
@@ -3462,6 +3476,7 @@ void QMacStyle::drawControl(ControlElement ce, const QStyleOption *opt, QPainter
 {
     Q_D(const QMacStyle);
     const AppearanceSync sync;
+    const QMacAutoReleasePool pool;
     QMacCGContext cg(p);
     QWindow *window = w && w->window() ? w->window()->windowHandle() : nullptr;
     d->resolveCurrentNSView(window);
@@ -4326,7 +4341,6 @@ void QMacStyle::drawControl(ControlElement ce, const QStyleOption *opt, QPainter
         break;
     case CE_ProgressBarContents:
         if (const QStyleOptionProgressBar *pb = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
-            QMacAutoReleasePool pool;
             const bool isIndeterminate = (pb->minimum == 0 && pb->maximum == 0);
             const bool vertical = pb->orientation == Qt::Vertical;
             const bool inverted = pb->invertedAppearance;
@@ -5603,8 +5617,7 @@ void QMacStyle::drawComplexControl(ComplexControl cc, const QStyleOptionComplex
                     if (view)
                         isKey = [view.window isKeyWindow];
 
-                    QBrush brush(isKey ? QColor(0, 0, 0, 28)
-                                       : QColor(0, 0, 0, 21));
+                    QBrush brush(brushForToolButton(isKey));
                     QPainterPath path;
                     path.addRoundedRect(QRectF(tb->rect.x(), tb->rect.y(), tb->rect.width(), tb->rect.height() + 4), 4, 4);
                     p->setRenderHint(QPainter::Antialiasing);
diff --git a/src/src.pro b/src/src.pro
index 832a3b6d82..8ff3ec4c1f 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -70,7 +70,7 @@ src_winmain.depends = sub-corelib  # just for the module .pri file
 
 src_corelib.subdir = $$PWD/corelib
 src_corelib.target = sub-corelib
-src_corelib.depends = src_tools_moc src_tools_rcc
+src_corelib.depends = src_tools_moc src_tools_rcc src_tools_tracegen
 
 src_xml.subdir = $$PWD/xml
 src_xml.target = sub-xml
@@ -157,17 +157,12 @@ src_android.subdir = $$PWD/android
         src_3rdparty_freetype.depends += src_corelib
     }
 }
-SUBDIRS += src_tools_bootstrap src_tools_moc src_tools_rcc
+SUBDIRS += src_tools_bootstrap src_tools_moc src_tools_rcc src_tools_tracegen
 qtConfig(regularexpression):pcre2 {
     SUBDIRS += src_3rdparty_pcre2
     src_corelib.depends += src_3rdparty_pcre2
 }
-TOOLS = src_tools_moc src_tools_rcc src_tools_qlalr
-!force_bootstrap:if(qtConfig(lttng)|qtConfig(etw)) {
-    SUBDIRS += src_tools_tracegen
-    src_corelib.depends += src_tools_tracegen
-    TOOLS += src_tools_tracegen
-}
+TOOLS = src_tools_moc src_tools_rcc src_tools_tracegen src_tools_qlalr
 SUBDIRS += src_corelib src_tools_qlalr
 win32:SUBDIRS += src_winmain
 qtConfig(network) {
diff --git a/src/tools/androiddeployqt/main.cpp b/src/tools/androiddeployqt/main.cpp
index 6a32a659e6..7101a2bf3c 100644
--- a/src/tools/androiddeployqt/main.cpp
+++ b/src/tools/androiddeployqt/main.cpp
@@ -116,7 +116,6 @@ struct Options
         : helpRequested(false)
         , verbose(false)
         , timing(false)
-        , generateAssetsFileList(true)
         , build(true)
         , auxMode(false)
         , deploymentMechanism(Bundled)
@@ -146,7 +145,6 @@ struct Options
     bool helpRequested;
     bool verbose;
     bool timing;
-    bool generateAssetsFileList;
     bool build;
     bool auxMode;
     ActionTimer timer;
@@ -521,8 +519,6 @@ Options parseOptions()
             options.protectedAuthenticationPath = true;
         } else if (argument.compare(QLatin1String("--jarsigner"), Qt::CaseInsensitive) == 0) {
             options.jarSigner = true;
-        } else if (argument.compare(QLatin1String("--no-generated-assets-cache"), Qt::CaseInsensitive) == 0) {
-            options.generateAssetsFileList = false;
         } else if (argument.compare(QLatin1String("--aux-mode"), Qt::CaseInsensitive) == 0) {
             options.auxMode = true;
         }
@@ -1242,8 +1238,6 @@ bool updateLibsXml(Options *options)
     }
 
     QString qtLibs;
-    QString bundledInLibs;
-    QString bundledInAssets;
     QString allLocalLibs;
     QString extraLibs;
 
@@ -1256,33 +1250,6 @@ bool updateLibsXml(Options *options)
                 QString s = bundledFile.second.mid(sizeof("lib/lib") - 1);
                 s.chop(sizeof(".so") - 1);
                 qtLibs += QLatin1String("        <item>%1;%2</item>\n").arg(it.key(), s);
-            } else if (bundledFile.first.startsWith(libsPath)) {
-                QString s = bundledFile.first.mid(libsPath.length());
-                bundledInLibs += QString::fromLatin1("        <item>%1;%2:%3</item>\n")
-                        .arg(it.key(), s, bundledFile.second);
-            } else if (bundledFile.first.startsWith(QLatin1String("assets/"))) {
-                QString s = bundledFile.first.mid(sizeof("assets/") - 1);
-                bundledInAssets += QString::fromLatin1("        <item>%1:%2</item>\n")
-                        .arg(s, bundledFile.second);
-            }
-        }
-
-        if (!options->archExtraPlugins[it.key()].isEmpty()) {
-            for (const QString &extraRes : options->archExtraPlugins[it.key()]) {
-                QDir resourceDir(extraRes);
-                const QStringList files = allFilesInside(resourceDir, resourceDir);
-                for (const QString &file : files) {
-                    QString destinationPath = resourceDir.dirName() + QLatin1Char('/') + file;
-                    if (!file.endsWith(QLatin1String(".so"))) {
-                        bundledInAssets += QLatin1String("        <item>%1:%1</item>\n")
-                            .arg(destinationPath);
-                    } else {
-                        bundledInLibs += QLatin1String("        <item>%1;lib%2:%3</item>\n")
-                                .arg(it.key(),
-                                     QString(destinationPath).replace(QLatin1Char('/'), QLatin1Char('_')),
-                                     destinationPath);
-                    }
-                }
             }
         }
 
@@ -1342,11 +1309,6 @@ bool updateLibsXml(Options *options)
     replacements[QStringLiteral("<!-- %%INSERT_LOCAL_LIBS%% -->")] = allLocalLibs.trimmed();
     replacements[QStringLiteral("<!-- %%INSERT_EXTRA_LIBS%% -->")] = extraLibs.trimmed();
 
-    if (options->deploymentMechanism == Options::Bundled) {
-        replacements[QStringLiteral("<!-- %%INSERT_BUNDLED_IN_LIB%% -->")] += bundledInLibs.trimmed();
-        replacements[QStringLiteral("<!-- %%INSERT_BUNDLED_IN_ASSETS%% -->")] += bundledInAssets.trimmed();
-    }
-
     if (!updateFile(fileName, replacements))
         return false;
 
@@ -1871,6 +1833,70 @@ bool scanImports(Options *options, QSet<QString> *usedDependencies)
     return true;
 }
 
+bool runCommand(const Options &options, const QString &command)
+{
+    if (options.verbose)
+        fprintf(stdout, "Running command '%s'\n", qPrintable(command));
+
+    FILE *runCommand = openProcess(command);
+    if (runCommand == nullptr) {
+        fprintf(stderr, "Cannot run command '%s'\n", qPrintable(command));
+        return false;
+    }
+    char buffer[4096];
+    while (fgets(buffer, sizeof(buffer), runCommand) != nullptr) {
+        if (options.verbose)
+            fprintf(stdout, "%s", buffer);
+    }
+    pclose(runCommand);
+    fflush(stdout);
+    fflush(stderr);
+    return true;
+}
+
+bool createRcc(const Options &options)
+{
+    auto assetsDir = QLatin1String("%1/assets").arg(options.outputDirectory);
+    if (!QDir{QLatin1String("%1/android_rcc_bundle").arg(assetsDir)}.exists()) {
+        fprintf(stdout, "Skipping createRCC\n");
+        return true;
+    }
+
+    if (options.verbose)
+        fprintf(stdout, "Create rcc bundle.\n");
+
+    QString rcc = options.qtInstallDirectory + QLatin1String("/bin/rcc");
+#if defined(Q_OS_WIN32)
+    rcc += QLatin1String(".exe");
+#endif
+
+    if (!QFile::exists(rcc)) {
+        fprintf(stderr, "rcc not found: %s\n", qPrintable(rcc));
+        return false;
+    }
+    auto currentDir = QDir::currentPath();
+    if (!QDir::setCurrent(QLatin1String("%1/android_rcc_bundle").arg(assetsDir))) {
+        fprintf(stderr, "Cannot set current dir to: %s\n", qPrintable(QLatin1String("%1/android_rcc_bundle").arg(assetsDir)));
+        return false;
+    }
+
+    bool res = runCommand(options, QLatin1String("%1 --project -o %2").arg(rcc, shellQuote(QLatin1String("%1/android_rcc_bundle.qrc").arg(assetsDir))));
+    if (!res)
+        return false;
+
+    QFile::rename(QLatin1String("%1/android_rcc_bundle.qrc").arg(assetsDir), QLatin1String("%1/android_rcc_bundle/android_rcc_bundle.qrc").arg(assetsDir));
+
+    res = runCommand(options, QLatin1String("%1 %2 --binary -o %3 android_rcc_bundle.qrc").arg(rcc, shellQuote(QLatin1String("--root=/android_rcc_bundle/")),
+                                                                                               shellQuote(QLatin1String("%1/android_rcc_bundle.rcc").arg(assetsDir))));
+    if (!QDir::setCurrent(currentDir)) {
+        fprintf(stderr, "Cannot set current dir to: %s\n", qPrintable(currentDir));
+        return false;
+    }
+    QFile::remove(QLatin1String("%1/android_rcc_bundle.qrc").arg(assetsDir));
+    QDir{QLatin1String("%1/android_rcc_bundle").arg(assetsDir)}.removeRecursively();
+    return res;
+}
+
 bool readDependencies(Options *options)
 {
     if (options->verbose)
@@ -2025,7 +2051,7 @@ bool copyQtFiles(Options *options)
     QString libsDirectory = QLatin1String("libs/");
 
     // Copy other Qt dependencies
-    auto assetsDestinationDirectory = QLatin1String("assets/--Added-by-androiddeployqt--/");
+    auto assetsDestinationDirectory = QLatin1String("assets/android_rcc_bundle/");
     for (const QtDependency &qtDependency : qAsConst(options->qtDependencies[options->currentArchitecture])) {
         QString sourceFileName = qtDependency.absolutePath;
         QString destinationFileName;
@@ -2681,57 +2707,6 @@ bool signPackage(const Options &options)
     return apkSignerRunner() && QFile::remove(packagePath(options, UnsignedAPK));
 }
 
-bool generateAssetsFileList(const Options &options)
-{
-    if (options.verbose)
-        fprintf(stdout, "Pregenerating entry list for assets file engine.\n");
-
-    QString assetsPath = options.outputDirectory + QLatin1String("/assets/");
-    QString addedByAndroidDeployQtPath = assetsPath + QLatin1String("--Added-by-androiddeployqt--/");
-    if (!QDir().mkpath(addedByAndroidDeployQtPath)) {
-        fprintf(stderr, "Failed to create directory '%s'", qPrintable(addedByAndroidDeployQtPath));
-        return false;
-    }
-
-    QFile file(addedByAndroidDeployQtPath + QLatin1String("/qt_cache_pregenerated_file_list"));
-    if (file.open(QIODevice::WriteOnly)) {
-        QDirIterator dirIterator(assetsPath,
-                                 QDir::Dirs | QDir::Files | QDir::NoDotAndDotDot,
-                                 QDirIterator::Subdirectories);
-
-        QHash<QString, QStringList> directoryContents;
-        while (dirIterator.hasNext()) {
-            const QString name = dirIterator.next().mid(assetsPath.length());
-
-            int slashIndex = name.lastIndexOf(QLatin1Char('/'));
-            QString pathName = slashIndex >= 0 ? name.left(slashIndex) : QStringLiteral("/");
-            QString fileName = slashIndex >= 0 ? name.mid(pathName.length() + 1) : name;
-
-            if (!fileName.isEmpty() && dirIterator.fileInfo().isDir() && !fileName.endsWith(QLatin1Char('/')))
-                fileName += QLatin1Char('/');
-
-            if (fileName.isEmpty() && !directoryContents.contains(pathName))
-                directoryContents[pathName] = QStringList();
-            else if (!fileName.isEmpty())
-                directoryContents[pathName].append(fileName);
-        }
-
-        QDataStream stream(&file);
-        stream.setVersion(QDataStream::Qt_5_3);
-        for (auto it = directoryContents.cbegin(), end = directoryContents.cend(); it != end; ++it) {
-            const QStringList &entryList = it.value();
-            stream << it.key() << entryList.size();
-            for (const QString &entry : entryList)
-                stream << entry;
-        }
-    } else {
-        fprintf(stderr, "Pregenerating entry list for assets file engine failed!\n");
-        return false;
-    }
-
-    return true;
-}
-
 enum ErrorCode
 {
     Success,
@@ -2749,9 +2724,9 @@ enum ErrorCode
     CannotBuildAndroidProject = 14,
     CannotSignPackage = 15,
     CannotInstallApk = 16,
-    CannotGenerateAssetsFileList = 18,
     CannotCopyAndroidExtraResources = 19,
-    CannotCopyApk = 20
+    CannotCopyApk = 20,
+    CannotCreateRcc = 21
 };
 
 int main(int argc, char *argv[])
@@ -2848,14 +2823,16 @@ int main(int argc, char *argv[])
         }
     }
 
+    if (!createRcc(options))
+        return CannotCreateRcc;
+
     if (options.auxMode) {
         if (!updateAndroidFiles(options))
             return CannotUpdateAndroidFiles;
-        if (options.generateAssetsFileList && !generateAssetsFileList(options))
-            return CannotGenerateAssetsFileList;
         return 0;
     }
 
+
     if (options.build) {
         if (!copyAndroidSources(options))
             return CannotCopyAndroidSources;
@@ -2866,9 +2843,6 @@ int main(int argc, char *argv[])
         if (!updateAndroidFiles(options))
             return CannotUpdateAndroidFiles;
 
-        if (options.generateAssetsFileList && !generateAssetsFileList(options))
-            return CannotGenerateAssetsFileList;
-
         if (Q_UNLIKELY(options.timing))
             fprintf(stdout, "[TIMING] %d ms: Updated files\n", options.timer.elapsed());
 
diff --git a/src/tools/bootstrap/bootstrap.pro b/src/tools/bootstrap/bootstrap.pro
index f9ffd1bbea..9863ff5e69 100644
--- a/src/tools/bootstrap/bootstrap.pro
+++ b/src/tools/bootstrap/bootstrap.pro
@@ -75,6 +75,7 @@ SOURCES += \
            ../../corelib/serialization/qxmlutils.cpp \
            ../../corelib/serialization/qxmlstream.cpp \
            ../../corelib/text/qbytearray.cpp \
+           ../../corelib/text/qbytearraylist.cpp \
            ../../corelib/text/qbytearraymatcher.cpp \
            ../../corelib/text/qlocale.cpp \
            ../../corelib/text/qlocale_tools.cpp \
@@ -125,6 +126,7 @@ win32:SOURCES += ../../corelib/global/qoperatingsystemversion_win.cpp \
                  ../../corelib/kernel/qsharedmemory_win.cpp \
                  ../../corelib/kernel/qsystemsemaphore_win.cpp \
                  ../../corelib/plugin/qsystemlibrary.cpp \
+                 ../../corelib/kernel/qwinregistry.cpp \
 
 mac {
     SOURCES += \
diff --git a/src/tools/tracegen/provider.h b/src/tools/tracegen/provider.h
index 9be0c33d89..a4baf56815 100644
--- a/src/tools/tracegen/provider.h
+++ b/src/tools/tracegen/provider.h
@@ -42,6 +42,7 @@
 
 #include <qvector.h>
 #include <qstring.h>
+#include <qstringlist.h>
 #include <qtypeinfo.h>
 
 struct Tracepoint
diff --git a/src/tools/uic/cpp/cppwriteinitialization.cpp b/src/tools/uic/cpp/cppwriteinitialization.cpp
index fd5f8c9017..717bff4a51 100644
--- a/src/tools/uic/cpp/cppwriteinitialization.cpp
+++ b/src/tools/uic/cpp/cppwriteinitialization.cpp
@@ -1680,7 +1680,7 @@ static void writeResourceIcon(QTextStream &output,
                          "Selected", "Off");
     }
     if (i->hasElementSelectedOn()) {
-        writeIconAddFile(output, indent, iconName, i->elementSelectedOff()->text(),
+        writeIconAddFile(output, indent, iconName, i->elementSelectedOn()->text(),
                          "Selected", "On");
     }
 }
diff --git a/src/widgets/doc/src/widgets-and-layouts/stylesheet.qdoc b/src/widgets/doc/src/widgets-and-layouts/stylesheet.qdoc
index 00323eace6..84233e4b62 100644
--- a/src/widgets/doc/src/widgets-and-layouts/stylesheet.qdoc
+++ b/src/widgets/doc/src/widgets-and-layouts/stylesheet.qdoc
@@ -549,6 +549,10 @@
     If the property references an enum declared with Q_ENUMS, you should
     reference its constants by name, i.e., not their numeric value.
 
+    \note Use the qproperty syntax with care, as it modifies the
+    widget that is being painted. Also, the qproperty syntax is evaluated only
+    once, which is when the widget is polished by the style. This means that any
+    attempt to use them in pseudo-states such as QPushButton:hover, will not work.
 */
 
 /*!
diff --git a/src/widgets/itemviews/qabstractitemview.cpp b/src/widgets/itemviews/qabstractitemview.cpp
index 089f398e71..c2afed775c 100644
--- a/src/widgets/itemviews/qabstractitemview.cpp
+++ b/src/widgets/itemviews/qabstractitemview.cpp
@@ -1776,8 +1776,8 @@ void QAbstractItemView::mousePressEvent(QMouseEvent *event)
     QItemSelectionModel::SelectionFlags command = selectionCommand(index, event);
     d->noSelectionOnMousePress = command == QItemSelectionModel::NoUpdate || !index.isValid();
     QPoint offset = d->offset();
+    d->pressedPosition = pos + offset;
     if ((command & QItemSelectionModel::Current) == 0) {
-        d->pressedPosition = pos + offset;
         d->currentSelectionStartIndex = index;
     }
     else if (!d->currentSelectionStartIndex.isValid())
diff --git a/src/widgets/itemviews/qtreewidget.cpp b/src/widgets/itemviews/qtreewidget.cpp
index d285ad6d28..a2d6e7798d 100644
--- a/src/widgets/itemviews/qtreewidget.cpp
+++ b/src/widgets/itemviews/qtreewidget.cpp
@@ -748,11 +748,14 @@ QMimeData *QTreeModel::internalMimeData()  const
 
 QMimeData *QTreeModel::mimeData(const QModelIndexList &indexes) const
 {
-    QList<QTreeWidgetItem*> items;
-    for (const auto &index : indexes) {
-        if (index.column() == 0) // only one item per row
-            items << item(index);
-    }
+    QList<QTreeWidgetItem *> items;
+    std::transform(indexes.begin(), indexes.end(), std::back_inserter(items),
+                   [this](const QModelIndex &idx) -> QTreeWidgetItem * { return item(idx); });
+
+    // Ensure we only have one item as an item may have more than
+    // one index selected if there is more than one column
+    std::sort(items.begin(), items.end());
+    items.erase(std::unique(items.begin(), items.end()), items.end());
 
     // cachedIndexes is a little hack to avoid copying from QModelIndexList to
     // QList<QTreeWidgetItem*> and back again in the view
diff --git a/src/widgets/kernel/qapplication.cpp b/src/widgets/kernel/qapplication.cpp
index 629c696544..dfa1bc23b1 100644
--- a/src/widgets/kernel/qapplication.cpp
+++ b/src/widgets/kernel/qapplication.cpp
@@ -1866,22 +1866,19 @@ void QApplication::aboutQt()
 bool QApplication::event(QEvent *e)
 {
     Q_D(QApplication);
-    if(e->type() == QEvent::Close) {
-        QCloseEvent *ce = static_cast<QCloseEvent*>(e);
-        ce->accept();
+    if (e->type() == QEvent::Quit) {
         closeAllWindows();
-
-        const QWidgetList list = topLevelWidgets();
-        for (auto *w : list) {
+        for (auto *w : topLevelWidgets()) {
             if (w->isVisible() && !(w->windowType() == Qt::Desktop) && !(w->windowType() == Qt::Popup) &&
                  (!(w->windowType() == Qt::Dialog) || !w->parentWidget())) {
-                ce->ignore();
-                break;
+                e->ignore();
+                return true;
             }
         }
-        if (ce->isAccepted()) {
-            return true;
-        }
+        // Explicitly call QCoreApplication instead of QGuiApplication so that
+        // we don't let QGuiApplication close any windows we skipped earlier in
+        // closeAllWindows(). FIXME: Unify all this close magic through closeAllWindows.
+        return QCoreApplication::event(e);
 #ifndef Q_OS_WIN
     } else if (e->type() == QEvent::LocaleChange) {
         // on Windows the event propagation is taken care by the
@@ -3224,8 +3221,11 @@ bool QApplication::notify(QObject *receiver, QEvent *e)
                     QApplicationPrivate::giveFocusAccordingToFocusPolicy(w, e, relpos);
 
 #if QT_DEPRECATED_SINCE(5, 14)
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
                 QWheelEvent we(relpos, wheel->globalPos(), wheel->pixelDelta(), wheel->angleDelta(), wheel->delta(), wheel->orientation(), wheel->buttons(),
                                wheel->modifiers(), phase, wheel->source(), wheel->inverted());
+QT_WARNING_POP
 #else
                 QWheelEvent we(relpos, wheel->globalPosition(), wheel->pixelDelta(), wheel->angleDelta(), wheel->buttons(),
                                wheel->modifiers(), phase, wheel->inverted(), wheel->source());
@@ -3266,8 +3266,11 @@ bool QApplication::notify(QObject *receiver, QEvent *e)
                 // the end of the natural scrolling sequence.
                 const QPoint &relpos = QApplicationPrivate::wheel_widget->mapFromGlobal(wheel->globalPosition().toPoint());
 #if QT_DEPRECATED_SINCE(5, 0)
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
                 QWheelEvent we(relpos, wheel->globalPos(), wheel->pixelDelta(), wheel->angleDelta(), wheel->delta(), wheel->orientation(), wheel->buttons(),
                                wheel->modifiers(), wheel->phase(), wheel->source());
+QT_WARNING_POP
 #else
                 QWheelEvent we(relpos, wheel->globalPosition(), wheel->pixelDelta(), wheel->angleDelta(), wheel->buttons(),
                                wheel->modifiers(), wheel->phase(), wheel->inverted(), wheel->source());
diff --git a/src/widgets/kernel/qdesktopwidget.cpp b/src/widgets/kernel/qdesktopwidget.cpp
index 4fbe6bba3f..9e90adec46 100644
--- a/src/widgets/kernel/qdesktopwidget.cpp
+++ b/src/widgets/kernel/qdesktopwidget.cpp
@@ -211,7 +211,9 @@ QDesktopWidget::QDesktopWidget()
     setObjectName(QLatin1String("desktop"));
     d->_q_updateScreens();
     connect(qApp, SIGNAL(screenAdded(QScreen*)), this, SLOT(_q_updateScreens()));
+#if QT_DEPRECATED_SINCE(5, 11)
     connect(qApp, SIGNAL(primaryScreenChanged(QScreen*)), this, SIGNAL(primaryScreenChanged()));
+#endif
 }
 
 QDesktopWidget::~QDesktopWidget()
diff --git a/src/widgets/kernel/qgesturemanager.cpp b/src/widgets/kernel/qgesturemanager.cpp
index d9d071a31a..d0c6b882b5 100644
--- a/src/widgets/kernel/qgesturemanager.cpp
+++ b/src/widgets/kernel/qgesturemanager.cpp
@@ -133,6 +133,7 @@ Qt::GestureType QGestureManager::registerGestureRecognizer(QGestureRecognizer *r
 void QGestureManager::unregisterGestureRecognizer(Qt::GestureType type)
 {
     QList<QGestureRecognizer *> list = m_recognizers.values(type);
+    m_recognizers.remove(type);
     foreach (QGesture *g, m_gestureToRecognizer.keys()) {
         QGestureRecognizer *recognizer = m_gestureToRecognizer.value(g);
         if (list.contains(recognizer)) {
diff --git a/src/widgets/kernel/qopenglwidget.cpp b/src/widgets/kernel/qopenglwidget.cpp
index 451b18d8d3..bc5ca21b97 100644
--- a/src/widgets/kernel/qopenglwidget.cpp
+++ b/src/widgets/kernel/qopenglwidget.cpp
@@ -788,10 +788,12 @@ void QOpenGLWidgetPrivate::initialize()
     if (initialized)
         return;
 
-    // Get our toplevel's context with which we will share in order to make the
-    // texture usable by the underlying window's backingstore.
+    // If no global shared context get our toplevel's context with which we
+    // will share in order to make the texture usable by the underlying window's backingstore.
     QWidget *tlw = q->window();
-    QOpenGLContext *shareContext = get(tlw)->shareContext();
+    QOpenGLContext *shareContext = qt_gl_global_share_context();
+    if (!shareContext)
+        shareContext = get(tlw)->shareContext();
     // If shareContext is null, showing content on-screen will not work.
     // However, offscreen rendering and grabFramebuffer() will stay fully functional.
 
diff --git a/src/widgets/kernel/qwidget.cpp b/src/widgets/kernel/qwidget.cpp
index 6889c2e9e5..74aebd1223 100644
--- a/src/widgets/kernel/qwidget.cpp
+++ b/src/widgets/kernel/qwidget.cpp
@@ -2914,6 +2914,8 @@ void QWidget::setWindowState(Qt::WindowStates newstate)
 {
     Q_D(QWidget);
     Qt::WindowStates oldstate = windowState();
+    if (newstate.testFlag(Qt::WindowMinimized)) // QTBUG-46763
+       newstate.setFlag(Qt::WindowActive, false);
     if (oldstate == newstate)
         return;
     if (isWindow() && !testAttribute(Qt::WA_WState_Created))
@@ -7669,7 +7671,7 @@ void QWidget::show()
     else if (defaultState == Qt::WindowMaximized)
         showMaximized();
     else
-        setVisible(true); // FIXME: Why not showNormal(), like QWindow::show()?
+        setVisible(true); // Don't call showNormal() as not to clobber Qt::Window(Max/Min)imized
 }
 
 /*! \internal
@@ -9218,9 +9220,11 @@ void QWidget::mouseReleaseEvent(QMouseEvent *event)
     The default implementation calls mousePressEvent().
 
     \note The widget will also receive mouse press and mouse release
-    events in addition to the double click event. It is up to the
-    developer to ensure that the application interprets these events
-    correctly.
+    events in addition to the double click event. And if another widget
+    that overlaps this widget disappears in response to press or
+    release events, then this widget will only receive the double click
+    event. It is up to the developer to ensure that the application
+    interprets these events correctly.
 
     \sa mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(),
     event(), QMouseEvent
diff --git a/src/widgets/styles/qfusionstyle.cpp b/src/widgets/styles/qfusionstyle.cpp
index ba2b6b0ed9..b58dc1660a 100644
--- a/src/widgets/styles/qfusionstyle.cpp
+++ b/src/widgets/styles/qfusionstyle.cpp
@@ -88,6 +88,7 @@
 #include <private/qstylehelper_p.h>
 #include <private/qdrawhelper_p.h>
 #include <private/qapplication_p.h>
+#include <private/qwidget_p.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -364,6 +365,11 @@ static void qt_fusion_draw_mdibutton(QPainter *painter, const QStyleOptionTitleB
     painter->drawPoint(tmp.right() , tmp.bottom() - 1);
 }
 
+static QWindow *qt_getWindow(const QWidget *widget)
+{
+    return widget ? QWidgetPrivate::get(widget)->windowHandle(QWidgetPrivate::WindowHandleMode::Closest) : nullptr;
+}
+
 /*
     \internal
 */
@@ -995,7 +1001,7 @@ void QFusionStyle::drawPrimitive(PrimitiveElement elem,
             d->tabBarcloseButtonIcon = proxy()->standardIcon(SP_DialogCloseButton, option, widget);
         if ((option->state & State_Enabled) && (option->state & State_MouseOver))
             proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
-        QPixmap pixmap = d->tabBarcloseButtonIcon.pixmap(QSize(16, 16), QIcon::Normal, QIcon::On);
+        QPixmap pixmap = d->tabBarcloseButtonIcon.pixmap(qt_getWindow(widget), QSize(16, 16), QIcon::Normal, QIcon::On);
         proxy()->drawItemPixmap(painter, option->rect, Qt::AlignCenter, pixmap);
     }
         break;
@@ -1035,7 +1041,7 @@ void QFusionStyle::drawControl(ControlElement element, const QStyleOption *optio
             if (!cb->currentIcon.isNull()) {
                 QIcon::Mode mode = cb->state & State_Enabled ? QIcon::Normal
                                                              : QIcon::Disabled;
-                QPixmap pixmap = cb->currentIcon.pixmap(cb->iconSize, mode);
+                QPixmap pixmap = cb->currentIcon.pixmap(qt_getWindow(widget), cb->iconSize, mode);
                 QRect iconRect(editRect);
                 iconRect.setWidth(cb->iconSize.width() + 4);
                 iconRect = alignedRect(cb->direction,
@@ -1647,9 +1653,9 @@ void QFusionStyle::drawControl(ControlElement element, const QStyleOption *optio
                     iconSize = combo->iconSize();
 #endif
                 if (checked)
-                    pixmap = menuItem->icon.pixmap(iconSize, mode, QIcon::On);
+                    pixmap = menuItem->icon.pixmap(qt_getWindow(widget), iconSize, mode, QIcon::On);
                 else
-                    pixmap = menuItem->icon.pixmap(iconSize, mode);
+                    pixmap = menuItem->icon.pixmap(qt_getWindow(widget), iconSize, mode);
 
                 const int pixw = pixmap.width() / pixmap.devicePixelRatio();
                 const int pixh = pixmap.height() / pixmap.devicePixelRatio();
@@ -1783,7 +1789,7 @@ void QFusionStyle::drawControl(ControlElement element, const QStyleOption *optio
                 if (button->state & State_On)
                     state = QIcon::On;
 
-                QPixmap pixmap = button->icon.pixmap(button->iconSize, mode, state);
+                QPixmap pixmap = button->icon.pixmap(qt_getWindow(widget), button->iconSize, mode, state);
                 int w = pixmap.width() / pixmap.devicePixelRatio();
                 int h = pixmap.height() / pixmap.devicePixelRatio();
 
diff --git a/src/widgets/styles/qstylesheetstyle.cpp b/src/widgets/styles/qstylesheetstyle.cpp
index 88c6c288e8..3f57992311 100644
--- a/src/widgets/styles/qstylesheetstyle.cpp
+++ b/src/widgets/styles/qstylesheetstyle.cpp
@@ -5035,6 +5035,14 @@ QSize QStyleSheetStyle::sizeFromContents(ContentsType ct, const QStyleOption *op
                 QRenderRule subRule = renderRule(w, opt, PseudoElement_HeaderViewSection);
                 if (subRule.hasGeometry() || subRule.hasBox() || !subRule.hasNativeBorder() || subRule.hasFont) {
                     sz = subRule.adjustSize(csz);
+                    if (!sz.isValid()) {
+                        // Try to set the missing values based on the base style.
+                        const auto baseSize = baseStyle()->sizeFromContents(ct, opt, sz, w);
+                        if (sz.width() < 0)
+                            sz.setWidth(baseSize.width());
+                        if (sz.height() < 0)
+                            sz.setHeight(baseSize.height());
+                    }
                     if (!subRule.hasGeometry()) {
                         QSize nativeContentsSize;
                         bool nullIcon = hdr->icon.isNull();
diff --git a/src/widgets/util/qscroller.cpp b/src/widgets/util/qscroller.cpp
index 1e84237253..df05bbf71c 100644
--- a/src/widgets/util/qscroller.cpp
+++ b/src/widgets/util/qscroller.cpp
@@ -1031,7 +1031,8 @@ void QScrollerPrivate::setDpi(const QPointF &dpi)
 */
 void QScrollerPrivate::setDpiFromWidget(QWidget *widget)
 {
-    const QScreen *screen = QGuiApplication::screens().at(QApplication::desktop()->screenNumber(widget));
+    const QScreen *screen = widget ? widget->screen() : QGuiApplication::primaryScreen();
+    Q_ASSERT(screen);
     setDpi(QPointF(screen->physicalDotsPerInchX(), screen->physicalDotsPerInchY()));
 }
 
diff --git a/src/widgets/widgets/qabstractscrollarea.cpp b/src/widgets/widgets/qabstractscrollarea.cpp
index b295e66574..d2372a7be9 100644
--- a/src/widgets/widgets/qabstractscrollarea.cpp
+++ b/src/widgets/widgets/qabstractscrollarea.cpp
@@ -1144,11 +1144,14 @@ void QAbstractScrollArea::paintEvent(QPaintEvent*)
     mouse press events for the viewport() widget. The event is passed
     in \a e.
 
+    The default implementation calls QWidget::mousePressEvent() for
+    default popup handling.
+
     \sa QWidget::mousePressEvent()
 */
 void QAbstractScrollArea::mousePressEvent(QMouseEvent *e)
 {
-    e->ignore();
+    QWidget::mousePressEvent(e);
 }
 
 /*!
diff --git a/src/widgets/widgets/qeffects.cpp b/src/widgets/widgets/qeffects.cpp
index 9463641369..7069ef0368 100644
--- a/src/widgets/widgets/qeffects.cpp
+++ b/src/widgets/widgets/qeffects.cpp
@@ -99,7 +99,7 @@ static QAlphaWidget* q_blend = 0;
   Constructs a QAlphaWidget.
 */
 QT_WARNING_PUSH
-QT_WARNING_DISABLE_DEPRECATED // QDesktopWidget::screen()
+QT_WARNING_DISABLE_DEPRECATED // ### Qt 6: Find a replacement for QDesktopWidget::screen()
 QAlphaWidget::QAlphaWidget(QWidget* w, Qt::WindowFlags f)
     : QWidget(QApplication::desktop()->screen(QDesktopWidgetPrivate::screenNumber(w)), f)
 {
diff --git a/src/widgets/widgets/qgroupbox.cpp b/src/widgets/widgets/qgroupbox.cpp
index 69eac1ebf7..eec794562a 100644
--- a/src/widgets/widgets/qgroupbox.cpp
+++ b/src/widgets/widgets/qgroupbox.cpp
@@ -389,9 +389,13 @@ bool QGroupBox::event(QEvent *e)
 void QGroupBox::childEvent(QChildEvent *c)
 {
     Q_D(QGroupBox);
-    if (c->type() != QEvent::ChildAdded || !c->child()->isWidgetType())
+    /*
+        Children might have been enabled after being added to the group box, in which case
+        the childEvent handler ran too early, and we need to disabled children again.
+    */
+    if (!(c->added() || c->polished()) || !c->child()->isWidgetType())
         return;
-    QWidget *w = (QWidget*)c->child();
+    QWidget *w = static_cast<QWidget*>(c->child());
     if (w->isWindow())
         return;
     if (d->checkable) {
diff --git a/src/widgets/widgets/qlineedit.cpp b/src/widgets/widgets/qlineedit.cpp
index 7f482a6a4e..fb67936768 100644
--- a/src/widgets/widgets/qlineedit.cpp
+++ b/src/widgets/widgets/qlineedit.cpp
@@ -2226,6 +2226,7 @@ QMenu *QLineEdit::createStandardContextMenu()
 
     action = popup->addAction(QLineEdit::tr("Select All") + ACCEL_KEY(QKeySequence::SelectAll));
     action->setEnabled(!d->control->text().isEmpty() && !d->control->allSelected());
+    setActionIcon(action, QStringLiteral("edit-select-all"));
     d->selectAllAction = action;
     connect(action, SIGNAL(triggered()), SLOT(selectAll()));
 
diff --git a/src/widgets/widgets/qtextedit.cpp b/src/widgets/widgets/qtextedit.cpp
index 0ccbad7eaa..dd2ea3f18f 100644
--- a/src/widgets/widgets/qtextedit.cpp
+++ b/src/widgets/widgets/qtextedit.cpp
@@ -237,7 +237,7 @@ void QTextEditPrivate::_q_hoveredBlockWithMarkerChanged(const QTextBlock &block)
     Qt::CursorShape cursor = cursorToRestoreAfterHover;
     if (block.isValid() && !q->isReadOnly()) {
         QTextBlockFormat::MarkerType marker = block.blockFormat().marker();
-        if (marker != QTextBlockFormat::NoMarker) {
+        if (marker != QTextBlockFormat::MarkerType::NoMarker) {
             if (viewport->cursor().shape() != Qt::PointingHandCursor)
                 cursorToRestoreAfterHover = viewport->cursor().shape();
             cursor = Qt::PointingHandCursor;
@@ -772,6 +772,7 @@ void QTextEdit::setAlignment(Qt::Alignment a)
     QTextCursor cursor = d->control->textCursor();
     cursor.mergeBlockFormat(fmt);
     d->control->setTextCursor(cursor);
+    d->relayoutDocument();
 }
 
 /*!
diff --git a/src/widgets/widgets/qwidgettextcontrol.cpp b/src/widgets/widgets/qwidgettextcontrol.cpp
index fdbaf29dd8..dce18f9100 100644
--- a/src/widgets/widgets/qwidgettextcontrol.cpp
+++ b/src/widgets/widgets/qwidgettextcontrol.cpp
@@ -1810,11 +1810,11 @@ void QWidgetTextControlPrivate::mouseReleaseEvent(QEvent *e, Qt::MouseButton but
         if (markerBlock == blockWithMarkerUnderMouse) {
             auto fmt = blockWithMarkerUnderMouse.blockFormat();
             switch (fmt.marker()) {
-            case QTextBlockFormat::Unchecked :
-                fmt.setMarker(QTextBlockFormat::Checked);
+            case QTextBlockFormat::MarkerType::Unchecked :
+                fmt.setMarker(QTextBlockFormat::MarkerType::Checked);
                 break;
-            case QTextBlockFormat::Checked:
-                fmt.setMarker(QTextBlockFormat::Unchecked);
+            case QTextBlockFormat::MarkerType::Checked:
+                fmt.setMarker(QTextBlockFormat::MarkerType::Unchecked);
                 break;
             default:
                 break;
@@ -2362,6 +2362,7 @@ QMenu *QWidgetTextControl::createStandardContextMenu(const QPointF &pos, QWidget
         a = menu->addAction(tr("Select All") + ACCEL_KEY(QKeySequence::SelectAll), this, SLOT(selectAll()));
         a->setEnabled(!d->doc->isEmpty());
         a->setObjectName(QStringLiteral("select-all"));
+        setActionIcon(a, QStringLiteral("edit-select-all"));
     }
 
     if ((d->interactionFlags & Qt::TextEditable) && QGuiApplication::styleHints()->useRtlExtensions()) {
diff --git a/tests/auto/corelib/global/global.pro b/tests/auto/corelib/global/global.pro
index 139e073644..0f77d191ee 100644
--- a/tests/auto/corelib/global/global.pro
+++ b/tests/auto/corelib/global/global.pro
@@ -12,3 +12,6 @@ SUBDIRS=\
     qtendian \
     qglobalstatic \
     qhooks
+
+win32:!winrt: SUBDIRS += \
+    qwinregistry
diff --git a/tests/auto/corelib/global/qfloat16/tst_qfloat16.cpp b/tests/auto/corelib/global/qfloat16/tst_qfloat16.cpp
index 5c7737085e..94f0afa5ed 100644
--- a/tests/auto/corelib/global/qfloat16/tst_qfloat16.cpp
+++ b/tests/auto/corelib/global/qfloat16/tst_qfloat16.cpp
@@ -41,7 +41,8 @@ private slots:
     void fuzzyCompare();
     void ltgt_data();
     void ltgt();
-    void qNan();
+    void qNaN();
+    void infinity();
     void float_cast();
     void float_cast_data();
     void promotionTests();
@@ -49,6 +50,9 @@ private slots:
     void arithOps();
     void floatToFloat16();
     void floatFromFloat16();
+    void finite_data();
+    void finite();
+    void properties();
     void limits();
 };
 
@@ -103,6 +107,7 @@ void tst_qfloat16::ltgt_data()
     QTest::addColumn<float>("val2");
 
     QTest::newRow("zero")  << 0.0f << 0.0f;
+    QTest::newRow("-zero") << -0.0f << 0.0f;
     QTest::newRow("ten")   << 10.0f << 10.0f;
     QTest::newRow("large") << 100000.0f << 100000.0f;
     QTest::newRow("small") << 0.0000001f << 0.0000001f;
@@ -154,38 +159,66 @@ void tst_qfloat16::ltgt()
 #  pragma GCC optimize "no-fast-math"
 #endif
 
-void tst_qfloat16::qNan()
+void tst_qfloat16::qNaN()
 {
 #if defined __FAST_MATH__ && (__GNUC__ * 100 + __GNUC_MINOR__ < 404)
     QSKIP("Non-conformant fast math mode is enabled, cannot run test");
 #endif
-    qfloat16 nan = qQNaN();
-    QVERIFY(!(0. > nan));
-    QVERIFY(!(0. < nan));
+    using Bounds = std::numeric_limits<qfloat16>;
+    const qfloat16 nan = Bounds::quiet_NaN();
+    const qfloat16 zero(0), one(1);
+    QVERIFY(!(zero > nan));
+    QVERIFY(!(zero < nan));
+    QVERIFY(!(zero == nan));
     QVERIFY(!qIsInf(nan));
     QVERIFY(qIsNaN(nan));
-    QVERIFY(qIsNaN(nan + 1.f));
+    QVERIFY(qIsNaN(nan + one));
     QVERIFY(qIsNaN(-nan));
-    qfloat16 inf = qInf();
-    QVERIFY(inf > qfloat16(0));
-    QVERIFY(-inf < qfloat16(0));
-    QVERIFY(!qIsNaN(inf));
-    QVERIFY(qIsInf(inf));
-    QVERIFY(qIsInf(-inf));
-    QVERIFY(qIsInf(2.f*inf));
-    QVERIFY(qIsInf(inf*2.f));
-    // QTBUG-75812: QEMU/arm64 compiler over-optimizes, so flakily fails 1/inf == 0 :-(
-    if (qfloat16(9.785e-4f) == qfloat16(9.794e-4f))
-        QCOMPARE(qfloat16(1.f) / inf, qfloat16(0.f));
 #ifdef Q_CC_INTEL
     QEXPECT_FAIL("", "ICC optimizes zero * anything to zero", Continue);
 #endif
-    QVERIFY(qIsNaN(nan*0.f));
+    QVERIFY(qIsNaN(nan * zero));
 #ifdef Q_CC_INTEL
     QEXPECT_FAIL("", "ICC optimizes zero * anything to zero", Continue);
 #endif
-    QVERIFY(qIsNaN(inf*0.f));
-    QVERIFY(qFuzzyCompare(qfloat16(1.f/inf), qfloat16(0.0)));
+    QVERIFY(qIsNaN(Bounds::infinity() * zero));
+
+    QVERIFY(!nan.isNormal());
+    QVERIFY(!qIsFinite(nan));
+    QVERIFY(!(nan == nan));
+    QCOMPARE(nan, nan); // Despite the preceding
+    QCOMPARE(qFpClassify(nan), FP_NAN);
+}
+
+void tst_qfloat16::infinity()
+{
+    const qfloat16 huge = std::numeric_limits<qfloat16>::infinity();
+    const qfloat16 zero(0), one(1), two(2);
+    QVERIFY(huge > -huge);
+    QVERIFY(huge > zero);
+    QVERIFY(-huge < zero);
+    QCOMPARE(huge, huge);
+    QCOMPARE(-huge, -huge);
+
+    // QTBUG-75812 - see overOptimized in the limits() test.
+    if (qfloat16(9.785e-4f) == qfloat16(9.794e-4f)) {
+        QCOMPARE(one / huge, zero);
+        QVERIFY(qFuzzyCompare(one / huge, zero)); // (same thing)
+    }
+
+    QVERIFY(qIsInf(huge));
+    QVERIFY(qIsInf(-huge));
+    QVERIFY(qIsInf(two * huge));
+    QVERIFY(qIsInf(huge * two));
+
+    QVERIFY(!huge.isNormal());
+    QVERIFY(!(-huge).isNormal());
+    QVERIFY(!qIsNaN(huge));
+    QVERIFY(!qIsNaN(-huge));
+    QVERIFY(!qIsFinite(huge));
+    QVERIFY(!qIsFinite(-huge));
+    QCOMPARE(qFpClassify(huge), FP_INFINITE);
+    QCOMPARE(qFpClassify(-huge), FP_INFINITE);
 }
 
 void tst_qfloat16::float_cast_data()
@@ -366,10 +399,41 @@ static qfloat16 powf16(qfloat16 base, int raise)
     return answer;
 }
 
-void tst_qfloat16::limits()
+void tst_qfloat16::finite_data()
+{
+    using Bounds = std::numeric_limits<qfloat16>;
+    QTest::addColumn<qfloat16>("value");
+    QTest::addColumn<int>("mode");
+
+    QTest::newRow("zero") << qfloat16(0) << FP_ZERO;
+    QTest::newRow("-zero") << -qfloat16(0) << FP_ZERO;
+    QTest::newRow("one") << qfloat16(1) << FP_NORMAL;
+    QTest::newRow("-one") << qfloat16(-1) << FP_NORMAL;
+    QTest::newRow("ten") << qfloat16(10) << FP_NORMAL;
+    QTest::newRow("-ten") << qfloat16(-10) << FP_NORMAL;
+    QTest::newRow("max") << Bounds::max() << FP_NORMAL;
+    QTest::newRow("lowest") << Bounds::lowest() << FP_NORMAL;
+    QTest::newRow("min") << Bounds::min() << FP_NORMAL;
+    QTest::newRow("-min") << -Bounds::min() << FP_NORMAL;
+    QTest::newRow("denorm_min") << Bounds::denorm_min() << FP_SUBNORMAL;
+    QTest::newRow("-denorm_min") << -Bounds::denorm_min() << FP_SUBNORMAL;
+}
+
+void tst_qfloat16::finite()
+{
+    QFETCH(qfloat16, value);
+    QFETCH(int, mode);
+    QCOMPARE(value.isNormal(), mode != FP_SUBNORMAL);
+    QCOMPARE(value, value); // Fuzzy
+    QVERIFY(value == value); // Exact
+    QVERIFY(qIsFinite(value));
+    QVERIFY(!qIsInf(value));
+    QVERIFY(!qIsNaN(value));
+    QCOMPARE(qFpClassify(value), mode);
+}
+
+void tst_qfloat16::properties()
 {
-    // *NOT* using QCOMPARE() on finite qfloat16 values, since that uses fuzzy
-    // comparison, and we need exact here.
     using Bounds = std::numeric_limits<qfloat16>;
     QVERIFY(Bounds::is_specialized);
     QVERIFY(Bounds::is_signed);
@@ -386,21 +450,22 @@ void tst_qfloat16::limits()
     QCOMPARE(Bounds::round_style, std::round_to_nearest);
     QCOMPARE(Bounds::radix, 2);
     // Untested: has_denorm_loss
+}
 
-    // A few common values:
+void tst_qfloat16::limits() // See also: qNaN() and infinity()
+{
+    // *NOT* using QCOMPARE() on finite qfloat16 values, since that uses fuzzy
+    // comparison, and we need exact here.
+    using Bounds = std::numeric_limits<qfloat16>;
+
+    // A few useful values:
     const qfloat16 zero(0), one(1), ten(10);
-    QVERIFY(qIsFinite(zero));
-    QVERIFY(!qIsInf(zero));
-    QVERIFY(!qIsNaN(zero));
-    QCOMPARE(qFpClassify(zero), FP_ZERO);
-    QVERIFY(qIsFinite(one));
-    QVERIFY(!qIsInf(one));
-    QCOMPARE(qFpClassify(one), FP_NORMAL);
-    QVERIFY(!qIsNaN(one));
-    QVERIFY(qIsFinite(ten));
-    QVERIFY(!qIsInf(ten));
-    QVERIFY(!qIsNaN(ten));
-    QCOMPARE(qFpClassify(ten), FP_NORMAL);
+
+    // The specifics of minus zero:
+    // (IEEE 754 seems to want -zero < zero, but -0. == 0. and -0.f == 0.f in C++.)
+    QVERIFY(-zero <= zero);
+    QVERIFY(-zero == zero);
+    QVERIFY(!(-zero > zero));
 
     // digits in the mantissa, including the implicit 1 before the binary dot at its left:
     QVERIFY(qfloat16(1 << (Bounds::digits - 1)) + one > qfloat16(1 << (Bounds::digits - 1)));
@@ -436,12 +501,12 @@ void tst_qfloat16::limits()
     // How many digits are significant ?  (Casts avoid linker errors ...)
     QCOMPARE(int(Bounds::digits10), 3); // 9.79e-4 has enough sigificant digits:
     qfloat16 below(9.785e-4f), above(9.794e-4f);
-#if 0 // Sadly, the QEMU x-compile for arm64 "optimises" comparisons:
-    const bool overOptimised = false;
+#if 0 // Sadly, the QEMU x-compile for arm64 "optimizes" comparisons:
+    const bool overOptimized = false;
 #else
-    const bool overOptimised = (below != above);
-    if (overOptimised)
-        QEXPECT_FAIL("", "Over-optimised on QEMU", Continue);
+    const bool overOptimized = (below != above);
+    if (overOptimized)
+        QEXPECT_FAIL("", "Over-optimized on ARM", Continue);
 #endif // (but it did, so should, pass everywhere else, confirming digits10 is indeed 3).
     QVERIFY(below == above);
     QCOMPARE(int(Bounds::max_digits10), 5); // we need 5 to distinguish these two:
@@ -450,62 +515,26 @@ void tst_qfloat16::limits()
     // Actual limiting values of the type:
     const qfloat16 rose(one + Bounds::epsilon());
     QVERIFY(rose > one);
-    if (overOptimised)
-        QEXPECT_FAIL("", "Over-optimised on QEMU", Continue);
+    if (overOptimized)
+        QEXPECT_FAIL("", "Over-optimized on ARM", Continue);
     QVERIFY(one + Bounds::epsilon() / rose == one);
-    QVERIFY(qIsInf(Bounds::infinity()));
-    QVERIFY(!qIsNaN(Bounds::infinity()));
-    QVERIFY(!qIsFinite(Bounds::infinity()));
-    QCOMPARE(Bounds::infinity(), Bounds::infinity());
-    QCOMPARE(qFpClassify(Bounds::infinity()), FP_INFINITE);
-
-    QVERIFY(Bounds::infinity() > -Bounds::infinity());
-    QVERIFY(Bounds::infinity() > zero);
-    QVERIFY(qIsInf(-Bounds::infinity()));
-    QVERIFY(!qIsNaN(-Bounds::infinity()));
-    QVERIFY(!qIsFinite(-Bounds::infinity()));
-    QCOMPARE(-Bounds::infinity(), -Bounds::infinity());
-    QCOMPARE(qFpClassify(-Bounds::infinity()), FP_INFINITE);
-
-    QVERIFY(-Bounds::infinity() < zero);
-    QVERIFY(qIsNaN(Bounds::quiet_NaN()));
-    QVERIFY(!qIsInf(Bounds::quiet_NaN()));
-    QVERIFY(!qIsFinite(Bounds::quiet_NaN()));
-    QVERIFY(!(Bounds::quiet_NaN() == Bounds::quiet_NaN()));
-    QCOMPARE(Bounds::quiet_NaN(), Bounds::quiet_NaN());
-    QCOMPARE(qFpClassify(Bounds::quiet_NaN()), FP_NAN);
 
     QVERIFY(Bounds::max() > zero);
-    QVERIFY(qIsFinite(Bounds::max()));
-    QVERIFY(!qIsInf(Bounds::max()));
-    QVERIFY(!qIsNaN(Bounds::max()));
     QVERIFY(qIsInf(Bounds::max() * rose));
-    QCOMPARE(qFpClassify(Bounds::max()), FP_NORMAL);
 
     QVERIFY(Bounds::lowest() < zero);
-    QVERIFY(qIsFinite(Bounds::lowest()));
-    QVERIFY(!qIsInf(Bounds::lowest()));
-    QVERIFY(!qIsNaN(Bounds::lowest()));
     QVERIFY(qIsInf(Bounds::lowest() * rose));
-    QCOMPARE(qFpClassify(Bounds::lowest()), FP_NORMAL);
 
     QVERIFY(Bounds::min() > zero);
-    QVERIFY(Bounds::min().isNormal());
     QVERIFY(!(Bounds::min() / rose).isNormal());
-    QVERIFY(qIsFinite(Bounds::min()));
-    QVERIFY(!qIsInf(Bounds::min()));
-    QVERIFY(!qIsNaN(Bounds::min()));
-    QCOMPARE(qFpClassify(Bounds::min()), FP_NORMAL);
 
     QVERIFY(Bounds::denorm_min() > zero);
-    QVERIFY(!Bounds::denorm_min().isNormal());
-    QVERIFY(qIsFinite(Bounds::denorm_min()));
-    QVERIFY(!qIsInf(Bounds::denorm_min()));
-    QVERIFY(!qIsNaN(Bounds::denorm_min()));
-    if (overOptimised)
-        QEXPECT_FAIL("", "Over-optimised on QEMU", Continue);
-    QCOMPARE(Bounds::denorm_min() / rose, zero);
-    QCOMPARE(qFpClassify(Bounds::denorm_min()), FP_SUBNORMAL);
+    if (overOptimized)
+        QEXPECT_FAIL("", "Over-optimized on ARM", Continue);
+    QVERIFY(Bounds::denorm_min() / rose == zero);
+    if (overOptimized)
+        QEXPECT_FAIL("", "Over-optimized on ARM", Continue);
+    QVERIFY(-Bounds::denorm_min() / rose == -zero);
 }
 
 QTEST_APPLESS_MAIN(tst_qfloat16)
diff --git a/tests/auto/corelib/global/qwinregistry/qwinregistry.pro b/tests/auto/corelib/global/qwinregistry/qwinregistry.pro
new file mode 100644
index 0000000000..eab5df9dc3
--- /dev/null
+++ b/tests/auto/corelib/global/qwinregistry/qwinregistry.pro
@@ -0,0 +1,8 @@
+CONFIG   += testcase
+QT       += testlib core-private
+QT       -= gui
+
+TARGET = tst_qwinregistry
+CONFIG   += console
+
+SOURCES += tst_qwinregistry.cpp
diff --git a/tests/auto/corelib/global/qwinregistry/tst_qwinregistry.cpp b/tests/auto/corelib/global/qwinregistry/tst_qwinregistry.cpp
new file mode 100644
index 0000000000..ac811de2a1
--- /dev/null
+++ b/tests/auto/corelib/global/qwinregistry/tst_qwinregistry.cpp
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtTest/QtTest>
+
+#include <QtCore/qoperatingsystemversion.h>
+
+#include <QtCore/private/qwinregistry_p.h>
+
+class tst_QWinRegistry : public QObject
+{
+    Q_OBJECT
+
+public Q_SLOTS:
+    void initTestCase();
+
+private Q_SLOTS:
+    void values();
+};
+
+void tst_QWinRegistry::initTestCase()
+{
+    if (QOperatingSystemVersion::current() < QOperatingSystemVersion::Windows10)
+        QSKIP("This test requires registry values present in Windows 10");
+}
+
+void tst_QWinRegistry::values()
+{
+    QWinRegistryKey key(HKEY_LOCAL_MACHINE, LR"(SOFTWARE\Microsoft\Windows NT\CurrentVersion)");
+    QVERIFY(key.isValid());
+    QVERIFY(!key.stringValue(L"ProductName").isEmpty());
+    QVERIFY(key.stringValue(L"NonExistingKey").isEmpty());
+    auto majorVersion = key.dwordValue(L"CurrentMajorVersionNumber");
+    QVERIFY(majorVersion.second);
+    QVERIFY(majorVersion.first > 0);
+    auto nonExistingValue = key.dwordValue(L"NonExistingKey");
+    QVERIFY(!nonExistingValue.second);
+    QCOMPARE(nonExistingValue.first, 0u);
+}
+
+QTEST_APPLESS_MAIN(tst_QWinRegistry);
+
+#include "tst_qwinregistry.moc"
diff --git a/tests/auto/corelib/io/qdir/Info.plist b/tests/auto/corelib/io/qdir/Info.plist
index 7dc5622bde..e1f6fbe24a 100644
--- a/tests/auto/corelib/io/qdir/Info.plist
+++ b/tests/auto/corelib/io/qdir/Info.plist
@@ -6,8 +6,6 @@
 	<string>${PRODUCT_NAME}</string>
 	<key>CFBundleExecutable</key>
 	<string>${EXECUTABLE_NAME}</string>
-	<key>CFBundleGetInfoString</key>
-	<string>Created by Qt/QMake</string>
 	<key>CFBundleIconFile</key>
 	<string>${ASSETCATALOG_COMPILER_APPICON_NAME}</string>
 	<key>CFBundleIdentifier</key>
diff --git a/tests/auto/corelib/io/qfileinfo/tst_qfileinfo.cpp b/tests/auto/corelib/io/qfileinfo/tst_qfileinfo.cpp
index 16fcafa248..0597a7d521 100644
--- a/tests/auto/corelib/io/qfileinfo/tst_qfileinfo.cpp
+++ b/tests/auto/corelib/io/qfileinfo/tst_qfileinfo.cpp
@@ -49,6 +49,7 @@
 #ifdef Q_OS_WIN
 #include <qt_windows.h>
 #if !defined(Q_OS_WINRT)
+#include <private/qwinregistry_p.h>
 #include <lm.h>
 #endif
 #endif
@@ -1243,17 +1244,12 @@ void tst_QFileInfo::fileTimes()
     //In Vista the last-access timestamp is not updated when the file is accessed/touched (by default).
     //To enable this the HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisableLastAccessUpdate
     //is set to 0, in the test machine.
-    HKEY key;
-    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\FileSystem",
-        0, KEY_READ, &key)) {
-            DWORD disabledAccessTimes = 0;
-            DWORD size = sizeof(DWORD);
-            LONG error = RegQueryValueEx(key, L"NtfsDisableLastAccessUpdate"
-                , NULL, NULL, (LPBYTE)&disabledAccessTimes, &size);
-            if (ERROR_SUCCESS == error && disabledAccessTimes)
-                noAccessTime = true;
-            RegCloseKey(key);
-    }
+    const auto disabledAccessTimes =
+        QWinRegistryKey(HKEY_LOCAL_MACHINE,
+                        LR"(SYSTEM\CurrentControlSet\Control\FileSystem)")
+        .dwordValue(L"NtfsDisableLastAccessUpdate");
+    if (disabledAccessTimes.second && disabledAccessTimes.first != 0)
+        noAccessTime = true;
 #endif
 
     if (noAccessTime)
diff --git a/tests/auto/corelib/io/qsettings/tst_qsettings.cpp b/tests/auto/corelib/io/qsettings/tst_qsettings.cpp
index 289590a233..0f07ba4bb2 100644
--- a/tests/auto/corelib/io/qsettings/tst_qsettings.cpp
+++ b/tests/auto/corelib/io/qsettings/tst_qsettings.cpp
@@ -54,6 +54,9 @@
 
 #if defined(Q_OS_WIN)
 #include <QtCore/qt_windows.h>
+#ifndef Q_OS_WINRT
+#  include <private/qwinregistry_p.h>
+#endif
 #else
 #include <unistd.h>
 #endif
@@ -3623,16 +3626,13 @@ void tst_QSettings::recursionBug()
 
 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
 
-static DWORD readKeyType(HKEY handle, const QString &rSubKey)
+static DWORD readKeyType(HKEY handle, QStringView rSubKey)
 {
     DWORD dataType;
     DWORD dataSize;
-    LONG res = RegQueryValueEx(handle, reinterpret_cast<const wchar_t *>(rSubKey.utf16()), 0, &dataType, 0, &dataSize);
-
-    if (res == ERROR_SUCCESS)
-        return dataType;
-
-    return 0;
+    LONG res = RegQueryValueEx(handle, reinterpret_cast<const wchar_t *>(rSubKey.utf16()),
+                               nullptr, &dataType, nullptr, &dataSize);
+    return res == ERROR_SUCCESS ? dataType : 0;
 }
 
 // This is a regression test for QTBUG-13249, where QSettings was storing
@@ -3652,29 +3652,12 @@ void tst_QSettings::consistentRegistryStorage()
     QCOMPARE(settings1.value("quint64_value").toULongLong(), (quint64)1024);
     settings1.sync();
 
-    HKEY handle;
-    LONG res;
-    QString keyName = "Software\\software.org\\KillerAPP";
-    res = RegOpenKeyEx(HKEY_CURRENT_USER, reinterpret_cast<const wchar_t *>(keyName.utf16()), 0, KEY_READ, &handle);
-    if (res == ERROR_SUCCESS)
-    {
-        DWORD dataType;
-        dataType = readKeyType(handle, QString("qint32_value"));
-        if (dataType != 0) {
-            QCOMPARE((int)REG_DWORD, (int)dataType);
-        }
-        dataType = readKeyType(handle, QString("quint32_value"));
-        if (dataType != 0) {
-            QCOMPARE((int)REG_DWORD, (int)dataType);
-        }
-        dataType = readKeyType(handle, QString("qint64_value"));
-        if (dataType != 0) {
-            QCOMPARE((int)REG_QWORD, (int)dataType);
-        }
-        dataType = readKeyType(handle, QString("quint64_value"));
-        if (dataType != 0) {
-            QCOMPARE((int)REG_QWORD, (int)dataType);
-        }
+    QWinRegistryKey handle(HKEY_CURRENT_USER, LR"(Software\software.org\KillerAPP)");
+    if (handle.isValid()) {
+        QCOMPARE(readKeyType(handle, L"qint32_value"), DWORD(REG_DWORD));
+        QCOMPARE(readKeyType(handle, L"quint32_value"), DWORD(REG_DWORD));
+        QCOMPARE(readKeyType(handle, L"qint64_value"), DWORD(REG_QWORD));
+        QCOMPARE(readKeyType(handle, L"quint64_value"), DWORD(REG_QWORD));
         RegCloseKey(handle);
     }
 }
diff --git a/tests/auto/corelib/text/qstring/tst_qstring.cpp b/tests/auto/corelib/text/qstring/tst_qstring.cpp
index cce3e601cd..c96210f53d 100644
--- a/tests/auto/corelib/text/qstring/tst_qstring.cpp
+++ b/tests/auto/corelib/text/qstring/tst_qstring.cpp
@@ -4593,6 +4593,8 @@ void tst_QString::fromLatin1()
 }
 
 #if QT_DEPRECATED_SINCE(5, 0)
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
 void tst_QString::fromAscii()
 {
     QString a;
@@ -4613,6 +4615,7 @@ void tst_QString::fromAscii()
     a = QString::fromAscii("\0abcd", 5);
     QVERIFY(a.size() == 5);
 }
+QT_WARNING_POP
 #endif
 
 void tst_QString::fromUcs4()
diff --git a/tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp b/tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp
index 99176dc68d..216ae1f79e 100644
--- a/tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp
+++ b/tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp
@@ -360,6 +360,7 @@ void tst_QDateTime::ctor()
 
 void tst_QDateTime::operator_eq()
 {
+    QVERIFY(QDateTime() != QDateTime(QDate(1970, 1, 1), QTime(0, 0))); // QTBUG-79006
     QDateTime dt1(QDate(2004, 3, 24), QTime(23, 45, 57), Qt::UTC);
     QDateTime dt2(QDate(2005, 3, 11), QTime(), Qt::UTC);
     dt2 = dt1;
@@ -1675,29 +1676,30 @@ void tst_QDateTime::currentDateTimeUtc2()
 void tst_QDateTime::toSecsSinceEpoch_data()
 {
     QTest::addColumn<QString>("dateTimeStr");
-    QTest::addColumn<bool>("res");
+    QTest::addColumn<bool>("valid");
 
-    QTest::newRow( "data1" ) << str( 1800, 1, 1, 12, 0, 0 ) << false;
-    QTest::newRow( "data2" ) << str( 1969, 1, 1, 12, 0, 0 ) << false;
+    QTest::newRow( "data1" ) << str( 1800, 1, 1, 12, 0, 0 ) << true;
+    QTest::newRow( "data2" ) << str( 1969, 1, 1, 12, 0, 0 ) << true;
     QTest::newRow( "data3" ) << str( 2002, 1, 1, 12, 0, 0 ) << true;
     QTest::newRow( "data4" ) << str( 2002, 6, 1, 12, 0, 0 ) << true;
     QTest::newRow( "data5" ) << QString("INVALID") << false;
     QTest::newRow( "data6" ) << str( 2038, 1, 1, 12, 0, 0 ) << true;
     QTest::newRow( "data7" ) << str( 2063, 4, 5, 12, 0, 0 ) << true; // the day of First Contact
-    QTest::newRow( "data8" ) << str( 2107, 1, 1, 12, 0, 0 )
-                          << bool( sizeof(uint) > 32 && sizeof(time_t) > 32 );
+    QTest::newRow( "data8" ) << str( 2107, 1, 1, 12, 0, 0 ) << true;
 }
 
 void tst_QDateTime::toSecsSinceEpoch()
 {
-    QFETCH( QString, dateTimeStr );
-    QDateTime datetime = dt( dateTimeStr );
-
-    qint64 asSecsSinceEpoch = datetime.toSecsSinceEpoch();
-    QCOMPARE(asSecsSinceEpoch, datetime.toMSecsSinceEpoch() / 1000);
+    QFETCH(const QString, dateTimeStr);
+    const QDateTime datetime = dt(dateTimeStr);
+    QFETCH(const bool, valid);
+    QCOMPARE(datetime.isValid(), valid);
 
-    QDateTime datetime2 = QDateTime::fromSecsSinceEpoch(asSecsSinceEpoch);
-    QCOMPARE(datetime, datetime2);
+    if (valid) {
+        const qint64 asSecsSinceEpoch = datetime.toSecsSinceEpoch();
+        QCOMPARE(asSecsSinceEpoch, datetime.toMSecsSinceEpoch() / 1000);
+        QCOMPARE(QDateTime::fromSecsSinceEpoch(asSecsSinceEpoch), datetime);
+    }
 }
 
 #if QT_DEPRECATED_SINCE(5, 8)
@@ -1725,14 +1727,10 @@ void tst_QDateTime::toTime_t()
     uint asTime_t = datetime.toTime_t();
     QFETCH( bool, res );
     if (res) {
-        QVERIFY( asTime_t != (uint)-1 );
+        QVERIFY(asTime_t != uint(-1));
+        QCOMPARE(QDateTime::fromTime_t(asTime_t), datetime);
     } else {
-        QVERIFY( asTime_t == (uint)-1 );
-    }
-
-    if ( asTime_t != (uint) -1 ) {
-        QDateTime datetime2 = QDateTime::fromTime_t( asTime_t );
-        QCOMPARE(datetime, datetime2);
+        QCOMPARE(asTime_t, uint(-1));
     }
 }
 #endif
@@ -1929,8 +1927,8 @@ void tst_QDateTime::operator_eqeq_data()
 
     QDateTime dateTime1(QDate(2012, 6, 20), QTime(14, 33, 2, 500));
     QDateTime dateTime1a = dateTime1.addMSecs(1);
-    QDateTime dateTime2(QDate(2012, 20, 6), QTime(14, 33, 2, 500));
-    QDateTime dateTime2a = dateTime2.addMSecs(-1);
+    QDateTime dateTime2(QDate(2012, 20, 6), QTime(14, 33, 2, 500)); // Invalid
+    QDateTime dateTime2a = dateTime2.addMSecs(-1); // Still invalid
     QDateTime dateTime3(QDate(1970, 1, 1), QTime(0, 0, 0, 0), Qt::UTC); // UTC epoch
     QDateTime dateTime3a = dateTime3.addDays(1);
     QDateTime dateTime3b = dateTime3.addDays(-1);
@@ -1946,7 +1944,7 @@ void tst_QDateTime::operator_eqeq_data()
     QTest::newRow("data2") << dateTime1a << dateTime1a << true << false;
     QTest::newRow("data3") << dateTime1 << dateTime2 << false << false;
     QTest::newRow("data4") << dateTime1 << dateTime1a << false << false;
-    QTest::newRow("data5") << dateTime2 << dateTime2a << false << false;
+    QTest::newRow("data5") << dateTime2 << dateTime2a << true << false;
     QTest::newRow("data6") << dateTime2 << dateTime3 << false << false;
     QTest::newRow("data7") << dateTime3 << dateTime3a << false << false;
     QTest::newRow("data8") << dateTime3 << dateTime3b << false << false;
diff --git a/tests/auto/corelib/tools/qeasingcurve/tst_qeasingcurve.cpp b/tests/auto/corelib/tools/qeasingcurve/tst_qeasingcurve.cpp
index 3af6132695..2a9c1e1e41 100644
--- a/tests/auto/corelib/tools/qeasingcurve/tst_qeasingcurve.cpp
+++ b/tests/auto/corelib/tools/qeasingcurve/tst_qeasingcurve.cpp
@@ -404,6 +404,11 @@ void tst_QEasingCurve::valueForProgress()
         const qreal error = qAbs(ex - curve.valueForProgress(at.at(i)/qreal(100)));
         QVERIFY(error <= errorBound);
     }
+
+    if (type != QEasingCurve::SineCurve && type != QEasingCurve::CosineCurve) {
+        QVERIFY( !(curve.valueForProgress(0) > 0) );
+        QVERIFY( !(curve.valueForProgress(1) < 1) );
+    }
 #endif
 }
 
@@ -632,6 +637,9 @@ void tst_QEasingCurve::bezierSpline()
             QCOMPARE(value, ex);
         QVERIFY(error <= errorBound);
     }
+
+    QVERIFY( !(bezierEasingCurve.valueForProgress(0) > 0) );
+    QVERIFY( !(bezierEasingCurve.valueForProgress(1) < 1) );
 }
 
 void tst_QEasingCurve::tcbSpline_data()
@@ -691,6 +699,9 @@ void tst_QEasingCurve::tcbSpline()
             QCOMPARE(value, ex);
         QVERIFY(error <= errorBound);
     }
+
+    QVERIFY( !(tcbEasingCurve.valueForProgress(0) > 0) );
+    QVERIFY( !(tcbEasingCurve.valueForProgress(1) < 1) );
 }
 
 /*This is single precision code for a cubic root used inside the spline easing curve.
diff --git a/tests/auto/gui/image/qmovie/tst_qmovie.cpp b/tests/auto/gui/image/qmovie/tst_qmovie.cpp
index 4e9e9b8115..c8217b2cec 100644
--- a/tests/auto/gui/image/qmovie/tst_qmovie.cpp
+++ b/tests/auto/gui/image/qmovie/tst_qmovie.cpp
@@ -62,6 +62,7 @@ private slots:
 #ifndef QT_NO_WIDGETS
     void infiniteLoop();
 #endif
+    void emptyMovie();
 };
 
 // Testing get/set functions
@@ -220,5 +221,13 @@ void tst_QMovie::infiniteLoop()
 }
 #endif
 
+void tst_QMovie::emptyMovie()
+{
+    QMovie movie;
+    movie.setCacheMode(QMovie::CacheAll);
+    movie.jumpToFrame(100);
+    QCOMPARE(movie.currentFrameNumber(), -1);
+}
+
 QTEST_MAIN(tst_QMovie)
 #include "tst_qmovie.moc"
diff --git a/tests/auto/gui/kernel/qtouchevent/tst_qtouchevent.cpp b/tests/auto/gui/kernel/qtouchevent/tst_qtouchevent.cpp
index 13dc924f93..54bb8fe0bd 100644
--- a/tests/auto/gui/kernel/qtouchevent/tst_qtouchevent.cpp
+++ b/tests/auto/gui/kernel/qtouchevent/tst_qtouchevent.cpp
@@ -26,7 +26,7 @@
 **
 ****************************************************************************/
 
-#include <QtWidgets/QDesktopWidget>
+#include <QtGui/QScreen>
 #include <QtWidgets/QGraphicsItem>
 #include <QtWidgets/QGraphicsScene>
 #include <QtWidgets/QGraphicsView>
@@ -617,7 +617,7 @@ void tst_QTouchEvent::basicRawEventTranslation()
     QPointF pos = touchWidget.rect().center();
     QPointF screenPos = touchWidget.mapToGlobal(pos.toPoint());
     QPointF delta(10, 10);
-    QRectF screenGeometry = QApplication::desktop()->screenGeometry(&touchWidget);
+    QRectF screenGeometry = touchWidget.screen()->geometry();
 
     QTouchEvent::TouchPoint rawTouchPoint;
     rawTouchPoint.setId(0);
@@ -753,7 +753,7 @@ void tst_QTouchEvent::multiPointRawEventTranslationOnTouchScreen()
     QPointF leftScreenPos = leftWidget.mapToGlobal(leftPos.toPoint());
     QPointF rightScreenPos = rightWidget.mapToGlobal(rightPos.toPoint());
     QPointF centerScreenPos = touchWidget.mapToGlobal(centerPos.toPoint());
-    QRectF screenGeometry = QApplication::desktop()->screenGeometry(&touchWidget);
+    QRectF screenGeometry = touchWidget.screen()->geometry();
 
     QList<QTouchEvent::TouchPoint> rawTouchPoints;
     rawTouchPoints.append(QTouchEvent::TouchPoint(0));
@@ -968,7 +968,7 @@ void tst_QTouchEvent::touchOnMultipleTouchscreens()
     QPointF pos = touchWidget.rect().center();
     QPointF screenPos = touchWidget.mapToGlobal(pos.toPoint());
     QPointF delta(10, 10);
-    QRectF screenGeometry = QApplication::desktop()->screenGeometry(&touchWidget);
+    QRectF screenGeometry = touchWidget.screen()->geometry();
 
     QVector<QTouchEvent::TouchPoint> rawTouchPoints(3);
     rawTouchPoints[0].setId(0);
@@ -1131,7 +1131,7 @@ void tst_QTouchEvent::multiPointRawEventTranslationOnTouchPad()
     QPointF leftScreenPos = leftWidget.mapToGlobal(leftPos.toPoint());
     QPointF rightScreenPos = rightWidget.mapToGlobal(rightPos.toPoint());
     QPointF centerScreenPos = touchWidget.mapToGlobal(centerPos.toPoint());
-    QRectF screenGeometry = QApplication::desktop()->screenGeometry(&touchWidget);
+    QRectF screenGeometry = touchWidget.screen()->geometry();
 
     QList<QTouchEvent::TouchPoint> rawTouchPoints;
     rawTouchPoints.append(QTouchEvent::TouchPoint(0));
@@ -1348,7 +1348,7 @@ void tst_QTouchEvent::basicRawEventTranslationOfIds()
         screenPos << touchWidget.mapToGlobal(pos[i].toPoint());
     }
     QPointF delta(10, 10);
-    QRectF screenGeometry = QApplication::desktop()->screenGeometry(&touchWidget);
+    QRectF screenGeometry = touchWidget.screen()->geometry();
 
     QVector<QPointF> rawPosList;
     rawPosList << QPointF(12, 34) << QPointF(56, 78);
@@ -1629,7 +1629,7 @@ void tst_QTouchEvent::deleteInRawEventTranslation()
     QPointF leftScreenPos = leftWidget->mapToGlobal(leftPos.toPoint());
     QPointF centerScreenPos = centerWidget->mapToGlobal(centerPos.toPoint());
     QPointF rightScreenPos = rightWidget->mapToGlobal(rightPos.toPoint());
-    QRectF screenGeometry = QApplication::desktop()->screenGeometry(&touchWidget);
+    QRectF screenGeometry = touchWidget.screen()->geometry();
 
     QList<QTouchEvent::TouchPoint> rawTouchPoints;
     rawTouchPoints.append(QTouchEvent::TouchPoint(0));
diff --git a/tests/auto/gui/kernel/qwindow/tst_qwindow.cpp b/tests/auto/gui/kernel/qwindow/tst_qwindow.cpp
index 4f26950192..60f89fcb4e 100644
--- a/tests/auto/gui/kernel/qwindow/tst_qwindow.cpp
+++ b/tests/auto/gui/kernel/qwindow/tst_qwindow.cpp
@@ -893,7 +893,13 @@ void tst_QWindow::isActive()
     QTRY_COMPARE(QGuiApplication::focusWindow(), &window);
     QCoreApplication::processEvents();
     QTRY_COMPARE(dialog.received(QEvent::FocusOut), 1);
-    QTRY_COMPARE(window.received(QEvent::FocusIn), 3);
+    // We should be checking for exactly three, but since this is a try-compare _loop_, we might
+    // loose and regain focus multiple times in the event of a system popup. This has been observed
+    // to fail on Windows, see QTBUG-77769.
+    QTRY_VERIFY2(window.received(QEvent::FocusIn) >= 3,
+                 qPrintable(
+                 QStringLiteral("Expected more than three focus in events, received: %1")
+                 .arg(window.received(QEvent::FocusIn))));
 
     QVERIFY(window.isActive());
 
diff --git a/tests/auto/gui/painting/qpainter/tst_qpainter.cpp b/tests/auto/gui/painting/qpainter/tst_qpainter.cpp
index d2a4dfc3e9..6e48439944 100644
--- a/tests/auto/gui/painting/qpainter/tst_qpainter.cpp
+++ b/tests/auto/gui/painting/qpainter/tst_qpainter.cpp
@@ -157,10 +157,10 @@ private slots:
     void clippedLines();
     void clippedPolygon_data();
     void clippedPolygon();
-
     void clippedText();
 
     void clipBoundingRect();
+    void transformedClip();
 
     void setOpacity_data();
     void setOpacity();
@@ -4589,6 +4589,53 @@ void tst_QPainter::clipBoundingRect()
 
 }
 
+void tst_QPainter::transformedClip()
+{
+    QImage img(8, 4, QImage::Format_ARGB32_Premultiplied);
+    QImage img2(img.size(), img.format());
+    QRect clip(0, 0, 2, 1);
+    QTransform xf;
+    xf.translate(0.2, 0);
+    xf.scale(2.2, 1);
+    // setClipRect(QRectF)
+    {
+        img.fill(Qt::green);
+        QPainter p(&img);
+        p.setTransform(xf);
+        p.setClipRect(QRectF(clip));
+        p.fillRect(img.rect(), Qt::white);
+    }
+    // setClipRect(QRect)
+    {
+        img2.fill(Qt::green);
+        QPainter p(&img2);
+        p.setTransform(xf);
+        p.setClipRect(clip);
+        p.fillRect(img2.rect(), Qt::white);
+        QCOMPARE(img, img2);
+    }
+    // setClipRegion
+    {
+        img2.fill(Qt::green);
+        QPainter p(&img2);
+        p.setTransform(xf);
+        p.setClipRegion(QRegion(clip) + QRect(0, 3, 1, 1));  // dummy extra rect to avoid single-rect codepath
+        p.fillRect(img2.rect(), Qt::white);
+        QCOMPARE(img.copy(0, 0, 8, 2), img2.copy(0, 0, 8, 2));
+    }
+    // setClipPath
+    {
+        img2.fill(Qt::green);
+        QPainter p(&img2);
+        p.setTransform(xf);
+        QPainterPath path;
+        path.addRect(clip);
+        p.setClipPath(path);
+        p.fillRect(img2.rect(), Qt::white);
+        QCOMPARE(img, img2);
+    }
+}
+
 #if defined(Q_OS_MAC)
 // Only Mac supports sub pixel positions in raster engine currently
 void tst_QPainter::drawText_subPixelPositionsInRaster_qtbug5053()
diff --git a/tests/auto/gui/rhi/qrhi/data/compile.bat b/tests/auto/gui/rhi/qrhi/data/compile.bat
new file mode 100644
index 0000000000..5b8a77b833
--- /dev/null
+++ b/tests/auto/gui/rhi/qrhi/data/compile.bat
@@ -0,0 +1,48 @@
+:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+::
+:: Copyright (C) 2019 The Qt Company Ltd.
+:: Contact: https://www.qt.io/licensing/
+::
+:: This file is part of the QtQuick module of the Qt Toolkit.
+::
+:: $QT_BEGIN_LICENSE:LGPL$
+:: Commercial License Usage
+:: Licensees holding valid commercial Qt licenses may use this file in
+:: accordance with the commercial license agreement provided with the
+:: Software or, alternatively, in accordance with the terms contained in
+:: a written agreement between you and The Qt Company. For licensing terms
+:: and conditions see https://www.qt.io/terms-conditions. For further
+:: information use the contact form at https://www.qt.io/contact-us.
+::
+:: GNU Lesser General Public License Usage
+:: Alternatively, this file may be used under the terms of the GNU Lesser
+:: General Public License version 3 as published by the Free Software
+:: Foundation and appearing in the file LICENSE.LGPL3 included in the
+:: packaging of this file. Please review the following information to
+:: ensure the GNU Lesser General Public License version 3 requirements
+:: will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+::
+:: GNU General Public License Usage
+:: Alternatively, this file may be used under the terms of the GNU
+:: General Public License version 2.0 or (at your option) the GNU General
+:: Public license version 3 or any later version approved by the KDE Free
+:: Qt Foundation. The licenses are as published by the Free Software
+:: Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+:: included in the packaging of this file. Please review the following
+:: information to ensure the GNU General Public License requirements will
+:: be met: https://www.gnu.org/licenses/gpl-2.0.html and
+:: https://www.gnu.org/licenses/gpl-3.0.html.
+::
+:: $QT_END_LICENSE$
+::
+:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+
+:: Note the -c argument: we do not want runtime HLSL compilation since that is
+:: not an option on UWP (WinRT). This means that running qsb must happen on Windows.
+
+qsb --glsl "150,120,100 es" --hlsl 50 -c --msl 12 -o simple.vert.qsb simple.vert
+qsb --glsl "150,120,100 es" --hlsl 50 -c --msl 12 -o simple.frag.qsb simple.frag
+qsb --glsl "150,120,100 es" --hlsl 50 -c --msl 12 -o simpletextured.vert.qsb simpletextured.vert
+qsb --glsl "150,120,100 es" --hlsl 50 -c --msl 12 -o simpletextured.frag.qsb simpletextured.frag
+qsb --glsl "150,120,100 es" --hlsl 50 -c --msl 12 -o textured.vert.qsb textured.vert
+qsb --glsl "150,120,100 es" --hlsl 50 -c --msl 12 -o textured.frag.qsb textured.frag
diff --git a/tests/auto/gui/rhi/qrhi/data/qt256.png b/tests/auto/gui/rhi/qrhi/data/qt256.png
new file mode 100644
index 0000000000..30c621c9c6
Binary files /dev/null and b/tests/auto/gui/rhi/qrhi/data/qt256.png differ
diff --git a/tests/auto/gui/rhi/qrhi/data/simple.frag b/tests/auto/gui/rhi/qrhi/data/simple.frag
new file mode 100644
index 0000000000..2aa500e09a
--- /dev/null
+++ b/tests/auto/gui/rhi/qrhi/data/simple.frag
@@ -0,0 +1,8 @@
+#version 440
+
+layout(location = 0) out vec4 fragColor;
+
+void main()
+{
+    fragColor = vec4(1.0, 0.0, 0.0, 1.0);
+}
diff --git a/tests/auto/gui/rhi/qrhi/data/simple.frag.qsb b/tests/auto/gui/rhi/qrhi/data/simple.frag.qsb
new file mode 100644
index 0000000000..264b71ec0f
Binary files /dev/null and b/tests/auto/gui/rhi/qrhi/data/simple.frag.qsb differ
diff --git a/tests/auto/gui/rhi/qrhi/data/simple.vert b/tests/auto/gui/rhi/qrhi/data/simple.vert
new file mode 100644
index 0000000000..16ee61beca
--- /dev/null
+++ b/tests/auto/gui/rhi/qrhi/data/simple.vert
@@ -0,0 +1,10 @@
+#version 440
+
+layout(location = 0) in vec4 position;
+
+out gl_PerVertex { vec4 gl_Position; };
+
+void main()
+{
+    gl_Position = position;
+}
diff --git a/tests/auto/gui/rhi/qrhi/data/simple.vert.qsb b/tests/auto/gui/rhi/qrhi/data/simple.vert.qsb
new file mode 100644
index 0000000000..59080b60c6
Binary files /dev/null and b/tests/auto/gui/rhi/qrhi/data/simple.vert.qsb differ
diff --git a/tests/auto/gui/rhi/qrhi/data/simpletextured.frag b/tests/auto/gui/rhi/qrhi/data/simpletextured.frag
new file mode 100644
index 0000000000..630df7b807
--- /dev/null
+++ b/tests/auto/gui/rhi/qrhi/data/simpletextured.frag
@@ -0,0 +1,13 @@
+#version 440
+
+layout(location = 0) in vec2 uv;
+layout(location = 0) out vec4 fragColor;
+
+layout(binding = 0) uniform sampler2D tex;
+
+void main()
+{
+    vec4 c = texture(tex, uv);
+    c.rgb *= c.a;
+    fragColor = c;
+}
diff --git a/tests/auto/gui/rhi/qrhi/data/simpletextured.frag.qsb b/tests/auto/gui/rhi/qrhi/data/simpletextured.frag.qsb
new file mode 100644
index 0000000000..f302702aa9
Binary files /dev/null and b/tests/auto/gui/rhi/qrhi/data/simpletextured.frag.qsb differ
diff --git a/tests/auto/gui/rhi/qrhi/data/simpletextured.vert b/tests/auto/gui/rhi/qrhi/data/simpletextured.vert
new file mode 100644
index 0000000000..1dd204f84d
--- /dev/null
+++ b/tests/auto/gui/rhi/qrhi/data/simpletextured.vert
@@ -0,0 +1,14 @@
+#version 440
+
+layout(location = 0) in vec4 position;
+layout(location = 1) in vec2 texcoord;
+
+layout(location = 0) out vec2 uv;
+
+out gl_PerVertex { vec4 gl_Position; };
+
+void main()
+{
+    uv = texcoord;
+    gl_Position = position;
+}
diff --git a/tests/auto/gui/rhi/qrhi/data/simpletextured.vert.qsb b/tests/auto/gui/rhi/qrhi/data/simpletextured.vert.qsb
new file mode 100644
index 0000000000..e4f12bfb9e
Binary files /dev/null and b/tests/auto/gui/rhi/qrhi/data/simpletextured.vert.qsb differ
diff --git a/tests/auto/gui/rhi/qrhi/data/texture.frag b/tests/auto/gui/rhi/qrhi/data/texture.frag
deleted file mode 100644
index e6021fe905..0000000000
--- a/tests/auto/gui/rhi/qrhi/data/texture.frag
+++ /dev/null
@@ -1,12 +0,0 @@
-#version 440
-
-layout(location = 0) in vec2 v_texcoord;
-
-layout(location = 0) out vec4 fragColor;
-
-layout(binding = 1) uniform sampler2D tex;
-
-void main()
-{
-    fragColor = texture(tex, v_texcoord);
-}
diff --git a/tests/auto/gui/rhi/qrhi/data/textured.frag b/tests/auto/gui/rhi/qrhi/data/textured.frag
new file mode 100644
index 0000000000..605410b028
--- /dev/null
+++ b/tests/auto/gui/rhi/qrhi/data/textured.frag
@@ -0,0 +1,19 @@
+#version 440
+
+layout(location = 0) in vec2 uv;
+layout(location = 0) out vec4 fragColor;
+
+layout(std140, binding = 0) uniform buf {
+    mat4 matrix;
+    float opacity;
+} ubuf;
+
+layout(binding = 1) uniform sampler2D tex;
+
+void main()
+{
+    vec4 c = texture(tex, uv);
+    c.a *= ubuf.opacity;
+    c.rgb *= c.a;
+    fragColor = c;
+}
diff --git a/tests/auto/gui/rhi/qrhi/data/textured.frag.qsb b/tests/auto/gui/rhi/qrhi/data/textured.frag.qsb
new file mode 100644
index 0000000000..0a039137ec
Binary files /dev/null and b/tests/auto/gui/rhi/qrhi/data/textured.frag.qsb differ
diff --git a/tests/auto/gui/rhi/qrhi/data/texture.vert b/tests/auto/gui/rhi/qrhi/data/textured.vert
similarity index 60%
rename from tests/auto/gui/rhi/qrhi/data/texture.vert
rename to tests/auto/gui/rhi/qrhi/data/textured.vert
index de486cb772..f1ccf2ee50 100644
--- a/tests/auto/gui/rhi/qrhi/data/texture.vert
+++ b/tests/auto/gui/rhi/qrhi/data/textured.vert
@@ -3,16 +3,17 @@
 layout(location = 0) in vec4 position;
 layout(location = 1) in vec2 texcoord;
 
-layout(location = 0) out vec2 v_texcoord;
+layout(location = 0) out vec2 uv;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 mvp;
+    mat4 matrix;
+    float opacity;
 } ubuf;
 
 out gl_PerVertex { vec4 gl_Position; };
 
 void main()
 {
-    v_texcoord = texcoord;
-    gl_Position = ubuf.mvp * position;
+    uv = texcoord;
+    gl_Position = ubuf.matrix * position;
 }
diff --git a/tests/auto/gui/rhi/qrhi/data/textured.vert.qsb b/tests/auto/gui/rhi/qrhi/data/textured.vert.qsb
new file mode 100644
index 0000000000..7853f77943
Binary files /dev/null and b/tests/auto/gui/rhi/qrhi/data/textured.vert.qsb differ
diff --git a/tests/auto/gui/rhi/qrhi/tst_qrhi.cpp b/tests/auto/gui/rhi/qrhi/tst_qrhi.cpp
index 897613d525..768b227ecd 100644
--- a/tests/auto/gui/rhi/qrhi/tst_qrhi.cpp
+++ b/tests/auto/gui/rhi/qrhi/tst_qrhi.cpp
@@ -30,10 +30,13 @@
 #include <QThread>
 #include <QFile>
 #include <QOffscreenSurface>
+#include <QPainter>
+
 #include <QtGui/private/qrhi_p.h>
 #include <QtGui/private/qrhinull_p.h>
 
 #if QT_CONFIG(opengl)
+# include <QOpenGLContext>
 # include <QtGui/private/qrhigles2_p.h>
 # define TST_GL
 #endif
@@ -65,8 +68,29 @@ private slots:
     void initTestCase();
     void cleanupTestCase();
 
+    void rhiTestData();
     void create_data();
     void create();
+    void nativeHandles_data();
+    void nativeHandles();
+    void resourceUpdateBatchBuffer_data();
+    void resourceUpdateBatchBuffer();
+    void resourceUpdateBatchRGBATextureUpload_data();
+    void resourceUpdateBatchRGBATextureUpload();
+    void resourceUpdateBatchRGBATextureCopy_data();
+    void resourceUpdateBatchRGBATextureCopy();
+    void resourceUpdateBatchRGBATextureMip_data();
+    void resourceUpdateBatchRGBATextureMip();
+    void invalidPipeline_data();
+    void invalidPipeline();
+    void renderToTextureSimple_data();
+    void renderToTextureSimple();
+    void renderToTextureTexturedQuad_data();
+    void renderToTextureTexturedQuad();
+    void renderToTextureTexturedQuadAndUniformBuffer_data();
+    void renderToTextureTexturedQuadAndUniformBuffer();
+    void renderToWindowSimple_data();
+    void renderToWindowSimple();
 
 private:
     struct {
@@ -99,9 +123,26 @@ void tst_QRhi::initTestCase()
 #endif
 
 #ifdef TST_VK
+#ifndef Q_OS_ANDROID
+    vulkanInstance.setLayers({ QByteArrayLiteral("VK_LAYER_LUNARG_standard_validation") });
+#else
+    vulkanInstance.setLayers({ QByteArrayLiteral("VK_LAYER_GOOGLE_threading"),
+                               QByteArrayLiteral("VK_LAYER_LUNARG_parameter_validation"),
+                               QByteArrayLiteral("VK_LAYER_LUNARG_object_tracker"),
+                               QByteArrayLiteral("VK_LAYER_LUNARG_core_validation"),
+                               QByteArrayLiteral("VK_LAYER_LUNARG_image"),
+                               QByteArrayLiteral("VK_LAYER_LUNARG_swapchain"),
+                               QByteArrayLiteral("VK_LAYER_GOOGLE_unique_objects") });
+#endif
+    vulkanInstance.setExtensions(QByteArrayList()
+                                 << "VK_KHR_get_physical_device_properties2");
     vulkanInstance.create();
     initParams.vk.inst = &vulkanInstance;
 #endif
+
+#ifdef TST_D3D11
+    initParams.d3d.enableDebugLayer = true;
+#endif
 }
 
 void tst_QRhi::cleanupTestCase()
@@ -113,7 +154,7 @@ void tst_QRhi::cleanupTestCase()
     delete fallbackSurface;
 }
 
-void tst_QRhi::create_data()
+void tst_QRhi::rhiTestData()
 {
     QTest::addColumn<QRhi::Implementation>("impl");
     QTest::addColumn<QRhiInitParams *>("initParams");
@@ -134,6 +175,11 @@ void tst_QRhi::create_data()
 #endif
 }
 
+void tst_QRhi::create_data()
+{
+    rhiTestData();
+}
+
 static int aligned(int v, int a)
 {
     return (v + a - 1) & ~(a - 1);
@@ -154,6 +200,8 @@ void tst_QRhi::create()
         QCOMPARE(rhi->backend(), impl);
         QCOMPARE(rhi->thread(), QThread::currentThread());
 
+        // do a basic smoke test for the apis that do not directly render anything
+
         int cleanupOk = 0;
         QRhi *rhiPtr = rhi.data();
         auto cleanupFunc = [rhiPtr, &cleanupOk](QRhi *dyingRhi) {
@@ -211,9 +259,11 @@ void tst_QRhi::create()
         const int texMin = rhi->resourceLimit(QRhi::TextureSizeMin);
         const int texMax = rhi->resourceLimit(QRhi::TextureSizeMax);
         const int maxAtt = rhi->resourceLimit(QRhi::MaxColorAttachments);
+        const int framesInFlight = rhi->resourceLimit(QRhi::FramesInFlight);
         QVERIFY(texMin >= 1);
         QVERIFY(texMax >= texMin);
         QVERIFY(maxAtt >= 1);
+        QVERIFY(framesInFlight >= 1);
 
         QVERIFY(rhi->nativeHandles());
         QVERIFY(rhi->profiler());
@@ -230,17 +280,1450 @@ void tst_QRhi::create()
             QRhi::NonFourAlignedEffectiveIndexBufferOffset,
             QRhi::NPOTTextureRepeat,
             QRhi::RedOrAlpha8IsRed,
-            QRhi::ElementIndexUint
+            QRhi::ElementIndexUint,
+            QRhi::Compute,
+            QRhi::WideLines,
+            QRhi::VertexShaderPointSize,
+            QRhi::BaseVertex,
+            QRhi::BaseInstance,
+            QRhi::TriangleFanTopology,
+            QRhi::ReadBackNonUniformBuffer,
+            QRhi::ReadBackNonBaseMipLevel
         };
         for (size_t i = 0; i <sizeof(features) / sizeof(QRhi::Feature); ++i)
             rhi->isFeatureSupported(features[i]);
 
         QVERIFY(rhi->isTextureFormatSupported(QRhiTexture::RGBA8));
 
+        rhi->releaseCachedResources();
+
+        QVERIFY(!rhi->isDeviceLost());
+
         rhi.reset();
         QCOMPARE(cleanupOk, 1);
     }
 }
 
+void tst_QRhi::nativeHandles_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::nativeHandles()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing native handles");
+
+    // QRhi::nativeHandles()
+    {
+        const QRhiNativeHandles *rhiHandles = rhi->nativeHandles();
+        Q_ASSERT(rhiHandles);
+
+        switch (impl) {
+        case QRhi::Null:
+            break;
+#ifdef TST_VK
+        case QRhi::Vulkan:
+        {
+            const QRhiVulkanNativeHandles *vkHandles = static_cast<const QRhiVulkanNativeHandles *>(rhiHandles);
+            QVERIFY(vkHandles->physDev);
+            QVERIFY(vkHandles->dev);
+            QVERIFY(vkHandles->gfxQueueFamilyIdx >= 0);
+            QVERIFY(vkHandles->gfxQueue);
+            QVERIFY(vkHandles->cmdPool);
+            QVERIFY(vkHandles->vmemAllocator);
+        }
+            break;
+#endif
+#ifdef TST_GL
+        case QRhi::OpenGLES2:
+        {
+            const QRhiGles2NativeHandles *glHandles = static_cast<const QRhiGles2NativeHandles *>(rhiHandles);
+            QVERIFY(glHandles->context);
+            QVERIFY(glHandles->context->isValid());
+            glHandles->context->doneCurrent();
+            QVERIFY(!QOpenGLContext::currentContext());
+            rhi->makeThreadLocalNativeContextCurrent();
+            QVERIFY(QOpenGLContext::currentContext() == glHandles->context);
+        }
+            break;
+#endif
+#ifdef TST_D3D11
+        case QRhi::D3D11:
+        {
+            const QRhiD3D11NativeHandles *d3dHandles = static_cast<const QRhiD3D11NativeHandles *>(rhiHandles);
+            QVERIFY(d3dHandles->dev);
+            QVERIFY(d3dHandles->context);
+        }
+            break;
+#endif
+#ifdef TST_MTL
+        case QRhi::Metal:
+        {
+            const QRhiMetalNativeHandles *mtlHandles = static_cast<const QRhiMetalNativeHandles *>(rhiHandles);
+            QVERIFY(mtlHandles->dev);
+            QVERIFY(mtlHandles->cmdQueue);
+        }
+            break;
+#endif
+        default:
+            Q_ASSERT(false);
+        }
+    }
+
+    // QRhiTexture::nativeHandles()
+    {
+        QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 256)));
+        QVERIFY(tex->build());
+
+        const QRhiNativeHandles *texHandles = tex->nativeHandles();
+        QVERIFY(texHandles);
+
+        switch (impl) {
+        case QRhi::Null:
+            break;
+#ifdef TST_VK
+        case QRhi::Vulkan:
+        {
+            const QRhiVulkanTextureNativeHandles *vkHandles = static_cast<const QRhiVulkanTextureNativeHandles *>(texHandles);
+            QVERIFY(vkHandles->image);
+            QVERIFY(vkHandles->layout >= 1); // VK_IMAGE_LAYOUT_GENERAL
+            QVERIFY(vkHandles->layout <= 8); // VK_IMAGE_LAYOUT_PREINITIALIZED
+        }
+            break;
+#endif
+#ifdef TST_GL
+        case QRhi::OpenGLES2:
+        {
+            const QRhiGles2TextureNativeHandles *glHandles = static_cast<const QRhiGles2TextureNativeHandles *>(texHandles);
+            QVERIFY(glHandles->texture);
+        }
+            break;
+#endif
+#ifdef TST_D3D11
+        case QRhi::D3D11:
+        {
+            const QRhiD3D11TextureNativeHandles *d3dHandles = static_cast<const QRhiD3D11TextureNativeHandles *>(texHandles);
+            QVERIFY(d3dHandles->texture);
+        }
+            break;
+#endif
+#ifdef TST_MTL
+        case QRhi::Metal:
+        {
+            const QRhiMetalTextureNativeHandles *mtlHandles = static_cast<const QRhiMetalTextureNativeHandles *>(texHandles);
+            QVERIFY(mtlHandles->texture);
+        }
+            break;
+#endif
+        default:
+            Q_ASSERT(false);
+        }
+    }
+
+    // QRhiCommandBuffer::nativeHandles()
+    {
+        QRhiCommandBuffer *cb = nullptr;
+        QRhi::FrameOpResult result = rhi->beginOffscreenFrame(&cb);
+        QVERIFY(result == QRhi::FrameOpSuccess);
+        QVERIFY(cb);
+
+        const QRhiNativeHandles *cbHandles = cb->nativeHandles();
+        // no null check here, backends where not applicable will return null
+
+        switch (impl) {
+        case QRhi::Null:
+            break;
+#ifdef TST_VK
+        case QRhi::Vulkan:
+        {
+            const QRhiVulkanCommandBufferNativeHandles *vkHandles = static_cast<const QRhiVulkanCommandBufferNativeHandles *>(cbHandles);
+            QVERIFY(vkHandles);
+            QVERIFY(vkHandles->commandBuffer);
+        }
+            break;
+#endif
+#ifdef TST_GL
+        case QRhi::OpenGLES2:
+            break;
+#endif
+#ifdef TST_D3D11
+        case QRhi::D3D11:
+            break;
+#endif
+#ifdef TST_MTL
+        case QRhi::Metal:
+        {
+            const QRhiMetalCommandBufferNativeHandles *mtlHandles = static_cast<const QRhiMetalCommandBufferNativeHandles *>(cbHandles);
+            QVERIFY(mtlHandles);
+            QVERIFY(mtlHandles->commandBuffer);
+            QVERIFY(!mtlHandles->encoder);
+
+            QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
+            QVERIFY(tex->build());
+            QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ tex.data() }));
+            QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
+            QVERIFY(rpDesc);
+            rt->setRenderPassDescriptor(rpDesc.data());
+            QVERIFY(rt->build());
+            cb->beginPass(rt.data(), Qt::red, { 1.0f, 0 });
+            QVERIFY(static_cast<const QRhiMetalCommandBufferNativeHandles *>(cb->nativeHandles())->encoder);
+            cb->endPass();
+        }
+            break;
+#endif
+        default:
+            Q_ASSERT(false);
+        }
+
+        rhi->endOffscreenFrame();
+    }
+
+    // QRhiRenderPassDescriptor::nativeHandles()
+    {
+        QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
+        QVERIFY(tex->build());
+        QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ tex.data() }));
+        QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
+        QVERIFY(rpDesc);
+        rt->setRenderPassDescriptor(rpDesc.data());
+        QVERIFY(rt->build());
+
+        const QRhiNativeHandles *rpHandles = rpDesc->nativeHandles();
+        switch (impl) {
+        case QRhi::Null:
+            break;
+#ifdef TST_VK
+        case QRhi::Vulkan:
+        {
+            const QRhiVulkanRenderPassNativeHandles *vkHandles = static_cast<const QRhiVulkanRenderPassNativeHandles *>(rpHandles);
+            QVERIFY(vkHandles);
+            QVERIFY(vkHandles->renderPass);
+        }
+            break;
+#endif
+#ifdef TST_GL
+        case QRhi::OpenGLES2:
+            break;
+#endif
+#ifdef TST_D3D11
+        case QRhi::D3D11:
+            break;
+#endif
+#ifdef TST_MTL
+        case QRhi::Metal:
+            break;
+#endif
+        default:
+            Q_ASSERT(false);
+        }
+    }
+}
+
+static bool submitResourceUpdates(QRhi *rhi, QRhiResourceUpdateBatch *batch)
+{
+    QRhiCommandBuffer *cb = nullptr;
+    QRhi::FrameOpResult result = rhi->beginOffscreenFrame(&cb);
+    if (result != QRhi::FrameOpSuccess) {
+        qWarning("beginOffscreenFrame returned %d", result);
+        return false;
+    }
+    if (!cb) {
+        qWarning("No command buffer from beginOffscreenFrame");
+        return false;
+    }
+    cb->resourceUpdate(batch);
+    rhi->endOffscreenFrame();
+    return true;
+}
+
+void tst_QRhi::resourceUpdateBatchBuffer_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::resourceUpdateBatchBuffer()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing buffer resource updates");
+
+    const int bufferSize = 23;
+    const QByteArray a(bufferSize, 'A');
+    const QByteArray b(bufferSize, 'B');
+
+    // dynamic buffer, updates, readback
+    {
+        QScopedPointer<QRhiBuffer> dynamicBuffer(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, bufferSize));
+        QVERIFY(dynamicBuffer->build());
+
+        QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+        QVERIFY(batch);
+
+        batch->updateDynamicBuffer(dynamicBuffer.data(), 10, bufferSize - 10, a.constData());
+        batch->updateDynamicBuffer(dynamicBuffer.data(), 0, 12, b.constData());
+
+        QRhiBufferReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackBuffer(dynamicBuffer.data(), 5, 10, &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+
+        // Offscreen frames are synchronous, so the readback must have
+        // completed at this point. With swapchain frames this would not be the
+        // case.
+        QVERIFY(readCompleted);
+        QVERIFY(readResult.data.size() == 10);
+        QCOMPARE(readResult.data.left(7), QByteArrayLiteral("BBBBBBB"));
+        QCOMPARE(readResult.data.mid(7), QByteArrayLiteral("AAA"));
+    }
+
+    // static buffer, updates, readback
+    {
+        QScopedPointer<QRhiBuffer> dynamicBuffer(rhi->newBuffer(QRhiBuffer::Static, QRhiBuffer::VertexBuffer, bufferSize));
+        QVERIFY(dynamicBuffer->build());
+
+        QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+        QVERIFY(batch);
+
+        batch->uploadStaticBuffer(dynamicBuffer.data(), 10, bufferSize - 10, a.constData());
+        batch->uploadStaticBuffer(dynamicBuffer.data(), 0, 12, b.constData());
+
+        QRhiBufferReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+
+        if (rhi->isFeatureSupported(QRhi::ReadBackNonUniformBuffer))
+            batch->readBackBuffer(dynamicBuffer.data(), 5, 10, &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+
+        if (rhi->isFeatureSupported(QRhi::ReadBackNonUniformBuffer)) {
+            QVERIFY(readCompleted);
+            QVERIFY(readResult.data.size() == 10);
+            QCOMPARE(readResult.data.left(7), QByteArrayLiteral("BBBBBBB"));
+            QCOMPARE(readResult.data.mid(7), QByteArrayLiteral("AAA"));
+        } else {
+            qDebug("Skipping verifying buffer contents because readback is not supported");
+        }
+    }
+}
+
+inline bool imageRGBAEquals(const QImage &a, const QImage &b)
+{
+    const int maxFuzz = 1;
+
+    if (a.size() != b.size())
+        return false;
+
+    const QImage image0 = a.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
+    const QImage image1 = b.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
+
+    const int width = image0.width();
+    const int height = image0.height();
+    for (int y = 0; y < height; ++y) {
+        const quint32 *p0 = reinterpret_cast<const quint32 *>(image0.constScanLine(y));
+        const quint32 *p1 = reinterpret_cast<const quint32 *>(image1.constScanLine(y));
+        int x = width - 1;
+        while (x-- >= 0) {
+            const QRgb c0(*p0++);
+            const QRgb c1(*p1++);
+            const int red = qAbs(qRed(c0) - qRed(c1));
+            const int green = qAbs(qGreen(c0) - qGreen(c1));
+            const int blue = qAbs(qBlue(c0) - qBlue(c1));
+            const int alpha = qAbs(qAlpha(c0) - qAlpha(c1));
+            if (red > maxFuzz || green > maxFuzz || blue > maxFuzz || alpha > maxFuzz)
+                return false;
+        }
+    }
+
+    return true;
+}
+
+void tst_QRhi::resourceUpdateBatchRGBATextureUpload_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::resourceUpdateBatchRGBATextureUpload()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing texture resource updates");
+
+    QImage image(234, 123, QImage::Format_RGBA8888_Premultiplied);
+    image.fill(Qt::red);
+    QPainter painter;
+    const QPoint greenRectPos(35, 50);
+    const QSize greenRectSize(100, 50);
+    painter.begin(&image);
+    painter.fillRect(QRect(greenRectPos, greenRectSize), Qt::green);
+    painter.end();
+
+    // simple image upload; uploading and reading back RGBA8 is supported by the Null backend even
+    {
+        QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, image.size(),
+                                                            1, QRhiTexture::UsedAsTransferSource));
+        QVERIFY(texture->build());
+
+        QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+        batch->uploadTexture(texture.data(), image);
+
+        QRhiReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackTexture(texture.data(), &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        // like with buffers, the readback is now complete due to endOffscreenFrame()
+        QVERIFY(readCompleted);
+        QCOMPARE(readResult.format, QRhiTexture::RGBA8);
+        QCOMPARE(readResult.pixelSize, image.size());
+
+        QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                            readResult.pixelSize.width(), readResult.pixelSize.height(),
+                            image.format());
+
+        QVERIFY(imageRGBAEquals(image, wrapperImage));
+    }
+
+    // the same with raw data
+    {
+        QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, image.size(),
+                                                            1, QRhiTexture::UsedAsTransferSource));
+        QVERIFY(texture->build());
+
+        QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+
+        QRhiTextureUploadEntry upload(0, 0, { image.constBits(), int(image.sizeInBytes()) });
+        QRhiTextureUploadDescription uploadDesc(upload);
+        batch->uploadTexture(texture.data(), uploadDesc);
+
+        QRhiReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackTexture(texture.data(), &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+        QCOMPARE(readResult.format, QRhiTexture::RGBA8);
+        QCOMPARE(readResult.pixelSize, image.size());
+
+        QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                            readResult.pixelSize.width(), readResult.pixelSize.height(),
+                            image.format());
+
+        QVERIFY(imageRGBAEquals(image, wrapperImage));
+    }
+
+    // partial image upload at a non-zero destination position
+    {
+        const QSize copySize(30, 40);
+        const int gap = 10;
+        const QSize fullSize(copySize.width() + gap, copySize.height() + gap);
+        QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, fullSize,
+                                                            1, QRhiTexture::UsedAsTransferSource));
+        QVERIFY(texture->build());
+
+        QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+
+        QImage clearImage(fullSize, image.format());
+        clearImage.fill(Qt::black);
+        batch->uploadTexture(texture.data(), clearImage);
+
+        // copy green pixels of copySize to (gap, gap), leaving a black bar of
+        // gap pixels on the left and top
+        QRhiTextureSubresourceUploadDescription desc;
+        desc.setImage(image);
+        desc.setSourceSize(copySize);
+        desc.setDestinationTopLeft(QPoint(gap, gap));
+        desc.setSourceTopLeft(greenRectPos);
+
+        batch->uploadTexture(texture.data(), QRhiTextureUploadDescription({ 0, 0, desc }));
+
+        QRhiReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackTexture(texture.data(), &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+        QCOMPARE(readResult.format, QRhiTexture::RGBA8);
+        QCOMPARE(readResult.pixelSize, clearImage.size());
+
+        QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                            readResult.pixelSize.width(), readResult.pixelSize.height(),
+                            image.format());
+
+        QVERIFY(!imageRGBAEquals(clearImage, wrapperImage));
+
+        QImage expectedImage = clearImage;
+        QPainter painter(&expectedImage);
+        painter.fillRect(QRect(QPoint(gap, gap), QSize(copySize)), Qt::green);
+        painter.end();
+
+        QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
+    }
+
+    // the same (partial upload) with raw data as source
+    {
+        const QSize copySize(30, 40);
+        const int gap = 10;
+        const QSize fullSize(copySize.width() + gap, copySize.height() + gap);
+        QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, fullSize,
+                                                            1, QRhiTexture::UsedAsTransferSource));
+        QVERIFY(texture->build());
+
+        QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+
+        QImage clearImage(fullSize, image.format());
+        clearImage.fill(Qt::black);
+        batch->uploadTexture(texture.data(), clearImage);
+
+        // SourceTopLeft is not supported for non-QImage-based uploads.
+        const QImage im = image.copy(QRect(greenRectPos, copySize));
+        QRhiTextureSubresourceUploadDescription desc;
+        desc.setData(QByteArray::fromRawData(reinterpret_cast<const char *>(im.constBits()),
+                                             int(im.sizeInBytes())));
+        desc.setSourceSize(copySize);
+        desc.setDestinationTopLeft(QPoint(gap, gap));
+
+        batch->uploadTexture(texture.data(), QRhiTextureUploadDescription({ 0, 0, desc }));
+
+        QRhiReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackTexture(texture.data(), &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+        QCOMPARE(readResult.format, QRhiTexture::RGBA8);
+        QCOMPARE(readResult.pixelSize, clearImage.size());
+
+        QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                            readResult.pixelSize.width(), readResult.pixelSize.height(),
+                            image.format());
+
+        QVERIFY(!imageRGBAEquals(clearImage, wrapperImage));
+
+        QImage expectedImage = clearImage;
+        QPainter painter(&expectedImage);
+        painter.fillRect(QRect(QPoint(gap, gap), QSize(copySize)), Qt::green);
+        painter.end();
+
+        QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
+    }
+
+    // now a QImage from an actual file
+    {
+        QImage inputImage;
+        inputImage.load(QLatin1String(":/data/qt256.png"));
+        QVERIFY(!inputImage.isNull());
+        inputImage = std::move(inputImage).convertToFormat(image.format());
+
+        QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(),
+                                                            1, QRhiTexture::UsedAsTransferSource));
+        QVERIFY(texture->build());
+
+        QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+        batch->uploadTexture(texture.data(), inputImage);
+
+        QRhiReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackTexture(texture.data(), &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+        QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                            readResult.pixelSize.width(), readResult.pixelSize.height(),
+                            inputImage.format());
+
+        QVERIFY(imageRGBAEquals(inputImage, wrapperImage));
+    }
+}
+
+void tst_QRhi::resourceUpdateBatchRGBATextureCopy_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::resourceUpdateBatchRGBATextureCopy()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing texture resource updates");
+
+    QImage red(256, 256, QImage::Format_RGBA8888_Premultiplied);
+    red.fill(Qt::red);
+
+    QImage green(35, 73, red.format());
+    green.fill(Qt::green);
+
+    QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+
+    QScopedPointer<QRhiTexture> redTexture(rhi->newTexture(QRhiTexture::RGBA8, red.size(),
+                                                           1, QRhiTexture::UsedAsTransferSource));
+    QVERIFY(redTexture->build());
+    batch->uploadTexture(redTexture.data(), red);
+
+    QScopedPointer<QRhiTexture> greenTexture(rhi->newTexture(QRhiTexture::RGBA8, green.size(),
+                                                             1, QRhiTexture::UsedAsTransferSource));
+    QVERIFY(greenTexture->build());
+    batch->uploadTexture(greenTexture.data(), green);
+
+    // 1. simple copy red -> texture; 2. subimage copy green -> texture; 3. partial subimage copy green -> texture
+    {
+        QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, red.size(),
+                                                            1, QRhiTexture::UsedAsTransferSource));
+        QVERIFY(texture->build());
+
+        // 1.
+        batch->copyTexture(texture.data(), redTexture.data());
+
+        QRhiReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackTexture(texture.data(), &readResult);
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+        QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                            readResult.pixelSize.width(), readResult.pixelSize.height(),
+                            red.format());
+        QVERIFY(imageRGBAEquals(red, wrapperImage));
+
+        batch = rhi->nextResourceUpdateBatch();
+        readCompleted = false;
+
+        // 2.
+        QRhiTextureCopyDescription copyDesc;
+        copyDesc.setDestinationTopLeft(QPoint(15, 23));
+        batch->copyTexture(texture.data(), greenTexture.data(), copyDesc);
+
+        batch->readBackTexture(texture.data(), &readResult);
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+        wrapperImage = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                              readResult.pixelSize.width(), readResult.pixelSize.height(),
+                              red.format());
+
+        QImage expectedImage = red;
+        QPainter painter(&expectedImage);
+        painter.drawImage(copyDesc.destinationTopLeft(), green);
+        painter.end();
+
+        QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
+
+        batch = rhi->nextResourceUpdateBatch();
+        readCompleted = false;
+
+        // 3.
+        copyDesc.setDestinationTopLeft(QPoint(125, 89));
+        copyDesc.setSourceTopLeft(QPoint(5, 5));
+        copyDesc.setPixelSize(QSize(26, 45));
+        batch->copyTexture(texture.data(), greenTexture.data(), copyDesc);
+
+        batch->readBackTexture(texture.data(), &readResult);
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+        wrapperImage = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                              readResult.pixelSize.width(), readResult.pixelSize.height(),
+                              red.format());
+
+        painter.begin(&expectedImage);
+        painter.drawImage(copyDesc.destinationTopLeft(), green,
+                          QRect(copyDesc.sourceTopLeft(), copyDesc.pixelSize()));
+        painter.end();
+
+        QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
+    }
+}
+
+void tst_QRhi::resourceUpdateBatchRGBATextureMip_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::resourceUpdateBatchRGBATextureMip()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing texture resource updates");
+
+
+    QImage red(512, 512, QImage::Format_RGBA8888_Premultiplied);
+    red.fill(Qt::red);
+
+    const QRhiTexture::Flags textureFlags =
+            QRhiTexture::UsedAsTransferSource
+            | QRhiTexture::MipMapped
+            | QRhiTexture::UsedWithGenerateMips;
+    QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, red.size(), 1, textureFlags));
+    QVERIFY(texture->build());
+
+    QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
+    batch->uploadTexture(texture.data(), red);
+    batch->generateMips(texture.data());
+    QVERIFY(submitResourceUpdates(rhi.data(), batch));
+
+    const int levelCount = rhi->mipLevelsForSize(red.size());
+    QCOMPARE(levelCount, 10);
+    for (int level = 0; level < levelCount; ++level) {
+        batch = rhi->nextResourceUpdateBatch();
+
+        QRhiReadbackDescription readDesc(texture.data());
+        readDesc.setLevel(level);
+        QRhiReadbackResult readResult;
+        bool readCompleted = false;
+        readResult.completed = [&readCompleted] { readCompleted = true; };
+        batch->readBackTexture(readDesc, &readResult);
+
+        QVERIFY(submitResourceUpdates(rhi.data(), batch));
+        QVERIFY(readCompleted);
+
+        const QSize expectedSize = rhi->sizeForMipLevel(level, texture->pixelSize());
+        QCOMPARE(readResult.pixelSize, expectedSize);
+
+        QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                            readResult.pixelSize.width(), readResult.pixelSize.height(),
+                            red.format());
+        QImage expectedImage;
+        if (level == 0 || rhi->isFeatureSupported(QRhi::ReadBackNonBaseMipLevel)) {
+            // Compare to a scaled version; we can do this safely only because we
+            // only have plain red pixels in the source image.
+            expectedImage = red.scaled(expectedSize);
+        } else {
+            qDebug("Expecting all-zero image for level %d because reading back a level other than 0 is not supported", level);
+            expectedImage = QImage(readResult.pixelSize, red.format());
+            expectedImage.fill(0);
+        }
+        QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
+    }
+}
+
+static QShader loadShader(const char *name)
+{
+    QFile f(QString::fromUtf8(name));
+    if (f.open(QIODevice::ReadOnly)) {
+        const QByteArray contents = f.readAll();
+        return QShader::fromSerialized(contents);
+    }
+    return QShader();
+}
+
+void tst_QRhi::invalidPipeline_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::invalidPipeline()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing empty shader");
+
+    QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(256, 256), 1, QRhiTexture::RenderTarget));
+    QVERIFY(texture->build());
+    QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
+    QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
+    rt->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(rt->build());
+
+    QRhiCommandBuffer *cb = nullptr;
+    QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
+    QVERIFY(cb);
+
+    QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
+    QVERIFY(srb->build());
+
+    QRhiVertexInputLayout inputLayout;
+    inputLayout.setBindings({ { 2 * sizeof(float) } });
+    inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
+
+    // no stages
+    QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb.data());
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(!pipeline->build());
+
+    QShader vs;
+    QShader fs;
+
+    // no shaders in the stages
+    pipeline.reset(rhi->newGraphicsPipeline());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb.data());
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(!pipeline->build());
+
+    vs = loadShader(":/data/simple.vert.qsb");
+    QVERIFY(vs.isValid());
+    fs = loadShader(":/data/simple.frag.qsb");
+    QVERIFY(fs.isValid());
+
+    // no vertex stage
+    pipeline.reset(rhi->newGraphicsPipeline());
+    pipeline->setShaderStages({ { QRhiShaderStage::Fragment, fs } });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb.data());
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(!pipeline->build());
+
+    // no vertex inputs
+    pipeline.reset(rhi->newGraphicsPipeline());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+    pipeline->setShaderResourceBindings(srb.data());
+    QVERIFY(!pipeline->build());
+
+    // no renderpass descriptor
+    pipeline.reset(rhi->newGraphicsPipeline());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb.data());
+    QVERIFY(!pipeline->build());
+
+    // no shader resource bindings
+    pipeline.reset(rhi->newGraphicsPipeline());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(!pipeline->build());
+
+    // correct
+    pipeline.reset(rhi->newGraphicsPipeline());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+    pipeline->setShaderResourceBindings(srb.data());
+    QVERIFY(pipeline->build());
+}
+
+void tst_QRhi::renderToTextureSimple_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::renderToTextureSimple()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing rendering");
+
+    const QSize outputSize(1920, 1080);
+    QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, outputSize, 1,
+                                                        QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
+    QVERIFY(texture->build());
+
+    QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
+    QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
+    rt->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(rt->build());
+
+    QRhiCommandBuffer *cb = nullptr;
+    QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
+    QVERIFY(cb);
+
+    QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
+
+    static const float vertices[] = {
+        -1.0f, -1.0f,
+        1.0f, -1.0f,
+        0.0f, 1.0f
+    };
+    QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
+    QVERIFY(vbuf->build());
+    updates->uploadStaticBuffer(vbuf.data(), vertices);
+
+    QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
+    QVERIFY(srb->build());
+
+    QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
+    QShader vs = loadShader(":/data/simple.vert.qsb");
+    QVERIFY(vs.isValid());
+    QShader fs = loadShader(":/data/simple.frag.qsb");
+    QVERIFY(fs.isValid());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    QRhiVertexInputLayout inputLayout;
+    inputLayout.setBindings({ { 2 * sizeof(float) } });
+    inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb.data());
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+
+    QVERIFY(pipeline->build());
+
+    cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, updates);
+    cb->setGraphicsPipeline(pipeline.data());
+    cb->setViewport({ 0, 0, float(outputSize.width()), float(outputSize.height()) });
+    QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
+    cb->setVertexInput(0, 1, &vbindings);
+    cb->draw(3);
+
+    QRhiReadbackResult readResult;
+    QImage result;
+    readResult.completed = [&readResult, &result] {
+        result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                        readResult.pixelSize.width(), readResult.pixelSize.height(),
+                        QImage::Format_RGBA8888_Premultiplied); // non-owning, no copy needed because readResult outlives result
+    };
+    QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
+    readbackBatch->readBackTexture({ texture.data() }, &readResult);
+    cb->endPass(readbackBatch);
+
+    rhi->endOffscreenFrame();
+    // Offscreen frames are synchronous, so the readback is guaranteed to
+    // complete at this point. This would not be the case with swapchain-based
+    // frames.
+    QCOMPARE(result.size(), texture->pixelSize());
+
+    if (impl == QRhi::Null)
+        return;
+
+    // Now we have a red rectangle on blue background.
+    const int y = 100;
+    const quint32 *p = reinterpret_cast<const quint32 *>(result.constScanLine(y));
+    int x = result.width() - 1;
+    int redCount = 0;
+    int blueCount = 0;
+    const int maxFuzz = 1;
+    while (x-- >= 0) {
+        const QRgb c(*p++);
+        if (qRed(c) >= (255 - maxFuzz) && qGreen(c) == 0 && qBlue(c) == 0)
+            ++redCount;
+        else if (qRed(c) == 0 && qGreen(c) == 0 && qBlue(c) >= (255 - maxFuzz))
+            ++blueCount;
+        else
+            QFAIL("Encountered a pixel that is neither red or blue");
+    }
+
+    QCOMPARE(redCount + blueCount, texture->pixelSize().width());
+
+    // The triangle is "pointing up" in the resulting image with OpenGL
+    // (because Y is up both in normalized device coordinates and in images)
+    // and Vulkan (because Y is down in both and the vertex data was specified
+    // with Y up in mind), but "pointing down" with D3D (because Y is up in NDC
+    // but down in images).
+    if (rhi->isYUpInFramebuffer() == rhi->isYUpInNDC())
+        QVERIFY(redCount < blueCount);
+    else
+        QVERIFY(redCount > blueCount);
+}
+
+void tst_QRhi::renderToTextureTexturedQuad_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::renderToTextureTexturedQuad()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing rendering");
+
+    QImage inputImage;
+    inputImage.load(QLatin1String(":/data/qt256.png"));
+    QVERIFY(!inputImage.isNull());
+
+    QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
+                                                        QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
+    QVERIFY(texture->build());
+
+    QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
+    QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
+    rt->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(rt->build());
+
+    QRhiCommandBuffer *cb = nullptr;
+    QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
+    QVERIFY(cb);
+
+    QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
+
+    static const float verticesUvs[] = {
+        -1.0f, -1.0f,   0.0f, 0.0f,
+        1.0f, -1.0f,    1.0f, 0.0f,
+        -1.0f, 1.0f,    0.0f, 1.0f,
+        1.0f, 1.0f,     1.0f, 1.0f
+    };
+    QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(verticesUvs)));
+    QVERIFY(vbuf->build());
+    updates->uploadStaticBuffer(vbuf.data(), verticesUvs);
+
+    QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
+    QVERIFY(inputTexture->build());
+    updates->uploadTexture(inputTexture.data(), inputImage);
+
+    QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
+                                                        QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
+    QVERIFY(sampler->build());
+
+    QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
+    srb->setBindings({
+                         QRhiShaderResourceBinding::sampledTexture(0, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
+                     });
+    QVERIFY(srb->build());
+
+    QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
+    pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
+    QShader vs = loadShader(":/data/simpletextured.vert.qsb");
+    QVERIFY(vs.isValid());
+    QShader fs = loadShader(":/data/simpletextured.frag.qsb");
+    QVERIFY(fs.isValid());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    QRhiVertexInputLayout inputLayout;
+    inputLayout.setBindings({ { 4 * sizeof(float) } });
+    inputLayout.setAttributes({
+                                  { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
+                                  { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
+                              });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb.data());
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+
+    QVERIFY(pipeline->build());
+
+    cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
+    cb->setGraphicsPipeline(pipeline.data());
+    cb->setShaderResources();
+    cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
+    QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
+    cb->setVertexInput(0, 1, &vbindings);
+    cb->draw(4);
+
+    QRhiReadbackResult readResult;
+    QImage result;
+    readResult.completed = [&readResult, &result] {
+        result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                        readResult.pixelSize.width(), readResult.pixelSize.height(),
+                        QImage::Format_RGBA8888_Premultiplied);
+    };
+    QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
+    readbackBatch->readBackTexture({ texture.data() }, &readResult);
+    cb->endPass(readbackBatch);
+
+    rhi->endOffscreenFrame();
+
+    QVERIFY(!result.isNull());
+
+    if (impl == QRhi::Null)
+        return;
+
+    // Flip with D3D and Metal because these have Y down in images. Vulkan does
+    // not need this because there Y is down both in images and in NDC, which
+    // just happens to give correct results with our OpenGL-targeted vertex and
+    // UV data.
+    if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC())
+        result = std::move(result).mirrored();
+
+    // check a few points that are expected to match regardless of the implementation
+    QRgb white = qRgba(255, 255, 255, 255);
+    QCOMPARE(result.pixel(79, 77), white);
+    QCOMPARE(result.pixel(124, 81), white);
+    QCOMPARE(result.pixel(128, 149), white);
+    QCOMPARE(result.pixel(120, 189), white);
+    QCOMPARE(result.pixel(116, 185), white);
+
+    QRgb empty = qRgba(0, 0, 0, 0);
+    QCOMPARE(result.pixel(11, 45), empty);
+    QCOMPARE(result.pixel(246, 202), empty);
+    QCOMPARE(result.pixel(130, 18), empty);
+    QCOMPARE(result.pixel(4, 227), empty);
+
+    QVERIFY(qGreen(result.pixel(32, 52)) > 2 * qRed(result.pixel(32, 52)));
+    QVERIFY(qGreen(result.pixel(32, 52)) > 2 * qBlue(result.pixel(32, 52)));
+    QVERIFY(qGreen(result.pixel(214, 191)) > 2 * qRed(result.pixel(214, 191)));
+    QVERIFY(qGreen(result.pixel(214, 191)) > 2 * qBlue(result.pixel(214, 191)));
+}
+
+void tst_QRhi::renderToTextureTexturedQuadAndUniformBuffer_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::renderToTextureTexturedQuadAndUniformBuffer()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing rendering");
+
+    QImage inputImage;
+    inputImage.load(QLatin1String(":/data/qt256.png"));
+    QVERIFY(!inputImage.isNull());
+
+    QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
+                                                        QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
+    QVERIFY(texture->build());
+
+    QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
+    QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
+    rt->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(rt->build());
+
+    QRhiCommandBuffer *cb = nullptr;
+    QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
+    QVERIFY(cb);
+
+    QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
+
+    static const float verticesUvs[] = {
+        -1.0f, -1.0f,   0.0f, 0.0f,
+        1.0f, -1.0f,    1.0f, 0.0f,
+        -1.0f, 1.0f,    0.0f, 1.0f,
+        1.0f, 1.0f,     1.0f, 1.0f
+    };
+    QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(verticesUvs)));
+    QVERIFY(vbuf->build());
+    updates->uploadStaticBuffer(vbuf.data(), verticesUvs);
+
+    // There will be two renderpasses. One renders with no transformation and
+    // an opacity of 0.5, the second has a rotation. Bake the uniform data for
+    // both into a single buffer.
+
+    const int UNIFORM_BLOCK_SIZE = 64 + 4; // matrix + opacity
+    const int secondUbufOffset = rhi->ubufAligned(UNIFORM_BLOCK_SIZE);
+    const int UBUF_SIZE = secondUbufOffset + UNIFORM_BLOCK_SIZE;
+
+    QScopedPointer<QRhiBuffer> ubuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, UBUF_SIZE));
+    QVERIFY(ubuf->build());
+
+    QMatrix4x4 matrix;
+    updates->updateDynamicBuffer(ubuf.data(), 0, 64, matrix.constData());
+    float opacity = 0.5f;
+    updates->updateDynamicBuffer(ubuf.data(), 64, 4, &opacity);
+
+    // rotation by 45 degrees around the Z axis
+    matrix.rotate(45, 0, 0, 1);
+    updates->updateDynamicBuffer(ubuf.data(), secondUbufOffset, 64, matrix.constData());
+    updates->updateDynamicBuffer(ubuf.data(), secondUbufOffset + 64, 4, &opacity);
+
+    QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
+    QVERIFY(inputTexture->build());
+    updates->uploadTexture(inputTexture.data(), inputImage);
+
+    QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
+                                                        QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
+    QVERIFY(sampler->build());
+
+    const QRhiShaderResourceBinding::StageFlags commonVisibility = QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage;
+    QScopedPointer<QRhiShaderResourceBindings> srb0(rhi->newShaderResourceBindings());
+    srb0->setBindings({
+                         QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data(), 0, UNIFORM_BLOCK_SIZE),
+                         QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
+                     });
+    QVERIFY(srb0->build());
+
+    QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
+    srb1->setBindings({
+                         QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data(), secondUbufOffset, UNIFORM_BLOCK_SIZE),
+                         QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
+                     });
+    QVERIFY(srb1->build());
+    QVERIFY(srb1->isLayoutCompatible(srb0.data())); // hence no need for a second pipeline
+
+    QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
+    pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
+    QShader vs = loadShader(":/data/textured.vert.qsb");
+    QVERIFY(vs.isValid());
+    QShaderDescription shaderDesc = vs.description();
+    QVERIFY(!shaderDesc.uniformBlocks().isEmpty());
+    QCOMPARE(shaderDesc.uniformBlocks().first().size, UNIFORM_BLOCK_SIZE);
+
+    QShader fs = loadShader(":/data/textured.frag.qsb");
+    QVERIFY(fs.isValid());
+    shaderDesc = fs.description();
+    QVERIFY(!shaderDesc.uniformBlocks().isEmpty());
+    QCOMPARE(shaderDesc.uniformBlocks().first().size, UNIFORM_BLOCK_SIZE);
+
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    QRhiVertexInputLayout inputLayout;
+    inputLayout.setBindings({ { 4 * sizeof(float) } });
+    inputLayout.setAttributes({
+                                  { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
+                                  { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
+                              });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb0.data());
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+
+    QVERIFY(pipeline->build());
+
+    cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
+    cb->setGraphicsPipeline(pipeline.data());
+    cb->setShaderResources();
+    cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
+    QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
+    cb->setVertexInput(0, 1, &vbindings);
+    cb->draw(4);
+
+    QRhiReadbackResult readResult0;
+    QImage result0;
+    readResult0.completed = [&readResult0, &result0] {
+        result0 = QImage(reinterpret_cast<const uchar *>(readResult0.data.constData()),
+                        readResult0.pixelSize.width(), readResult0.pixelSize.height(),
+                        QImage::Format_RGBA8888_Premultiplied);
+    };
+    QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
+    readbackBatch->readBackTexture({ texture.data() }, &readResult0);
+    cb->endPass(readbackBatch);
+
+    // second pass (rotated)
+    cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 });
+    cb->setGraphicsPipeline(pipeline.data());
+    cb->setShaderResources(srb1.data()); // sources data from a different offset in ubuf
+    cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
+    cb->setVertexInput(0, 1, &vbindings);
+    cb->draw(4);
+
+    QRhiReadbackResult readResult1;
+    QImage result1;
+    readResult1.completed = [&readResult1, &result1] {
+        result1 = QImage(reinterpret_cast<const uchar *>(readResult1.data.constData()),
+                        readResult1.pixelSize.width(), readResult1.pixelSize.height(),
+                        QImage::Format_RGBA8888_Premultiplied);
+    };
+    readbackBatch = rhi->nextResourceUpdateBatch();
+    readbackBatch->readBackTexture({ texture.data() }, &readResult1);
+    cb->endPass(readbackBatch);
+
+    rhi->endOffscreenFrame();
+
+    QVERIFY(!result0.isNull());
+    QVERIFY(!result1.isNull());
+
+    if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC()) {
+        result0 = std::move(result0).mirrored();
+        result1 = std::move(result1).mirrored();
+    }
+
+    if (impl == QRhi::Null)
+        return;
+
+    // opacity 0.5 (premultiplied)
+    static const auto checkSemiWhite = [](const QRgb &c) {
+        QRgb semiWhite127 = qPremultiply(qRgba(255, 255, 255, 127));
+        QRgb semiWhite128 = qPremultiply(qRgba(255, 255, 255, 128));
+        return c == semiWhite127 || c == semiWhite128;
+    };
+    QVERIFY(checkSemiWhite(result0.pixel(79, 77)));
+    QVERIFY(checkSemiWhite(result0.pixel(124, 81)));
+    QVERIFY(checkSemiWhite(result0.pixel(128, 149)));
+    QVERIFY(checkSemiWhite(result0.pixel(120, 189)));
+    QVERIFY(checkSemiWhite(result0.pixel(116, 185)));
+    QVERIFY(checkSemiWhite(result0.pixel(191, 172)));
+
+    QRgb empty = qRgba(0, 0, 0, 0);
+    QCOMPARE(result0.pixel(11, 45), empty);
+    QCOMPARE(result0.pixel(246, 202), empty);
+    QCOMPARE(result0.pixel(130, 18), empty);
+    QCOMPARE(result0.pixel(4, 227), empty);
+
+    // also rotated 45 degrees around Z
+    QRgb black = qRgba(0, 0, 0, 255);
+    QCOMPARE(result1.pixel(20, 23), black);
+    QCOMPARE(result1.pixel(47, 5), black);
+    QCOMPARE(result1.pixel(238, 22), black);
+    QCOMPARE(result1.pixel(250, 203), black);
+    QCOMPARE(result1.pixel(224, 237), black);
+    QCOMPARE(result1.pixel(12, 221), black);
+
+    QVERIFY(checkSemiWhite(result1.pixel(142, 67)));
+    QVERIFY(checkSemiWhite(result1.pixel(81, 79)));
+    QVERIFY(checkSemiWhite(result1.pixel(79, 168)));
+    QVERIFY(checkSemiWhite(result1.pixel(146, 204)));
+    QVERIFY(checkSemiWhite(result1.pixel(186, 156)));
+
+    QCOMPARE(result1.pixel(204, 45), empty);
+    QCOMPARE(result1.pixel(28, 178), empty);
+}
+
+void tst_QRhi::renderToWindowSimple_data()
+{
+    rhiTestData();
+}
+
+void tst_QRhi::renderToWindowSimple()
+{
+    QFETCH(QRhi::Implementation, impl);
+    QFETCH(QRhiInitParams *, initParams);
+
+#ifdef Q_OS_WINRT
+    if (impl == QRhi::D3D11)
+        QSKIP("Skipping window-based QRhi rendering on WinRT as the platform and the D3D11 backend are not prepared for this yet");
+#endif
+
+    QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
+    if (!rhi)
+        QSKIP("QRhi could not be created, skipping testing rendering");
+
+    QScopedPointer<QWindow> window(new QWindow);
+    switch (impl) {
+    case QRhi::OpenGLES2:
+        Q_FALLTHROUGH();
+    case QRhi::D3D11:
+        window->setSurfaceType(QSurface::OpenGLSurface);
+        break;
+    case QRhi::Metal:
+        window->setSurfaceType(QSurface::MetalSurface);
+        break;
+    case QRhi::Vulkan:
+        window->setSurfaceType(QSurface::VulkanSurface);
+#if QT_CONFIG(vulkan)
+        window->setVulkanInstance(&vulkanInstance);
+#endif
+        break;
+    default:
+        break;
+    }
+
+    window->setGeometry(0, 0, 640, 480);
+    window->show();
+    QVERIFY(QTest::qWaitForWindowExposed(window.data()));
+
+    QScopedPointer<QRhiSwapChain> swapChain(rhi->newSwapChain());
+    swapChain->setWindow(window.data());
+    swapChain->setFlags(QRhiSwapChain::UsedAsTransferSource);
+    QScopedPointer<QRhiRenderPassDescriptor> rpDesc(swapChain->newCompatibleRenderPassDescriptor());
+    swapChain->setRenderPassDescriptor(rpDesc.data());
+    QVERIFY(swapChain->buildOrResize());
+
+    QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
+
+    static const float vertices[] = {
+        -1.0f, -1.0f,
+        1.0f, -1.0f,
+        0.0f, 1.0f
+    };
+    QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
+    QVERIFY(vbuf->build());
+    updates->uploadStaticBuffer(vbuf.data(), vertices);
+
+    QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
+    QVERIFY(srb->build());
+
+    QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
+    QShader vs = loadShader(":/data/simple.vert.qsb");
+    QVERIFY(vs.isValid());
+    QShader fs = loadShader(":/data/simple.frag.qsb");
+    QVERIFY(fs.isValid());
+    pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
+    QRhiVertexInputLayout inputLayout;
+    inputLayout.setBindings({ { 2 * sizeof(float) } });
+    inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
+    pipeline->setVertexInputLayout(inputLayout);
+    pipeline->setShaderResourceBindings(srb.data());
+    pipeline->setRenderPassDescriptor(rpDesc.data());
+
+    QVERIFY(pipeline->build());
+
+    const int framesInFlight = rhi->resourceLimit(QRhi::FramesInFlight);
+    QVERIFY(framesInFlight >= 1);
+    const int FRAME_COUNT = framesInFlight + 1;
+    bool readCompleted = false;
+    QRhiReadbackResult readResult;
+    QImage result;
+    int readbackWidth = 0;
+
+    for (int frameNo = 0; frameNo < FRAME_COUNT; ++frameNo) {
+        QVERIFY(rhi->beginFrame(swapChain.data()) == QRhi::FrameOpSuccess);
+        QRhiCommandBuffer *cb = swapChain->currentFrameCommandBuffer();
+        QRhiRenderTarget *rt = swapChain->currentFrameRenderTarget();
+        const QSize outputSize = swapChain->currentPixelSize();
+        QCOMPARE(rt->pixelSize(), outputSize);
+        QRhiViewport viewport(0, 0, float(outputSize.width()), float(outputSize.height()));
+
+        cb->beginPass(rt, Qt::blue, { 1.0f, 0 }, updates);
+        updates = nullptr;
+        cb->setGraphicsPipeline(pipeline.data());
+        cb->setViewport(viewport);
+        QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
+        cb->setVertexInput(0, 1, &vbindings);
+        cb->draw(3);
+
+        if (frameNo == 0) {
+            readResult.completed = [&readCompleted, &readResult, &result, &rhi] {
+                readCompleted = true;
+                QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
+                                    readResult.pixelSize.width(), readResult.pixelSize.height(),
+                                    QImage::Format_ARGB32_Premultiplied);
+                if (readResult.format == QRhiTexture::RGBA8)
+                    wrapperImage = wrapperImage.rgbSwapped();
+                if (rhi->isYUpInFramebuffer() == rhi->isYUpInNDC())
+                    result = wrapperImage.mirrored();
+                else
+                    result = wrapperImage.copy();
+            };
+            QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
+            readbackBatch->readBackTexture({}, &readResult); // read back the current backbuffer
+            readbackWidth = outputSize.width();
+            cb->endPass(readbackBatch);
+        } else {
+            cb->endPass();
+        }
+
+        rhi->endFrame(swapChain.data());
+    }
+
+    // The readback is asynchronous here. However it is guaranteed that it
+    // finished at latest after rendering QRhi::FramesInFlight frames after the
+    // one that enqueues the readback.
+    QVERIFY(readCompleted);
+    QVERIFY(readbackWidth > 0);
+
+    if (impl == QRhi::Null)
+        return;
+
+    // Now we have a red rectangle on blue background.
+    const int y = 50;
+    const quint32 *p = reinterpret_cast<const quint32 *>(result.constScanLine(y));
+    int x = result.width() - 1;
+    int redCount = 0;
+    int blueCount = 0;
+    const int maxFuzz = 1;
+    while (x-- >= 0) {
+        const QRgb c(*p++);
+        if (qRed(c) >= (255 - maxFuzz) && qGreen(c) == 0 && qBlue(c) == 0)
+            ++redCount;
+        else if (qRed(c) == 0 && qGreen(c) == 0 && qBlue(c) >= (255 - maxFuzz))
+            ++blueCount;
+        else
+            QFAIL("Encountered a pixel that is neither red or blue");
+    }
+
+    QCOMPARE(redCount + blueCount, readbackWidth);
+    QVERIFY(redCount < blueCount);
+}
+
 #include <tst_qrhi.moc>
 QTEST_MAIN(tst_QRhi)
diff --git a/tests/auto/gui/text/qtextlayout/tst_qtextlayout.cpp b/tests/auto/gui/text/qtextlayout/tst_qtextlayout.cpp
index a474acd790..2dcca0209e 100644
--- a/tests/auto/gui/text/qtextlayout/tst_qtextlayout.cpp
+++ b/tests/auto/gui/text/qtextlayout/tst_qtextlayout.cpp
@@ -2068,7 +2068,12 @@ void tst_QTextLayout::cursorInLigatureWithMultipleLines()
 
 void tst_QTextLayout::xToCursorForLigatures()
 {
+#if defined(Q_OS_WIN32)
+    QTextLayout layout("fi", QFont("Calibri", 20));
+#else
     QTextLayout layout("fi", QFont("Times", 20));
+#endif
+
     layout.setCacheEnabled(true);
     layout.beginLayout();
     QTextLine line = layout.createLine();
diff --git a/tests/auto/gui/text/qtextmarkdownwriter/tst_qtextmarkdownwriter.cpp b/tests/auto/gui/text/qtextmarkdownwriter/tst_qtextmarkdownwriter.cpp
index 8d38cbb18a..1e6c354f17 100644
--- a/tests/auto/gui/text/qtextmarkdownwriter/tst_qtextmarkdownwriter.cpp
+++ b/tests/auto/gui/text/qtextmarkdownwriter/tst_qtextmarkdownwriter.cpp
@@ -159,7 +159,7 @@ void tst_QTextMarkdownWriter::testWriteNestedBulletLists()
     QTextCursor cursor(document);
     QTextBlockFormat blockFmt = cursor.blockFormat();
     if (checkbox) {
-        blockFmt.setMarker(checked ? QTextBlockFormat::Checked : QTextBlockFormat::Unchecked);
+        blockFmt.setMarker(checked ? QTextBlockFormat::MarkerType::Checked : QTextBlockFormat::MarkerType::Unchecked);
         cursor.setBlockFormat(blockFmt);
     }
 
diff --git a/tests/auto/other/lancelot/paintcommands.cpp b/tests/auto/other/lancelot/paintcommands.cpp
index fbf906b55d..215a4c2a29 100644
--- a/tests/auto/other/lancelot/paintcommands.cpp
+++ b/tests/auto/other/lancelot/paintcommands.cpp
@@ -365,6 +365,7 @@ void PaintCommands::staticInit()
                       "^gradient_setCoordinateMode\\s+(\\w*)$",
                       "gradient_setCoordinateMode <coordinate method enum>",
                       "gradient_setCoordinateMode ObjectBoundingMode");
+
     DECL_PAINTCOMMANDSECTION("drawing ops");
     DECL_PAINTCOMMAND("drawPoint", command_drawPoint,
                       "^drawPoint\\s+(-?[\\w.]*)\\s+(-?[\\w.]*)$",
@@ -454,6 +455,14 @@ void PaintCommands::staticInit()
                       "\n  - where t means tile"
                       "\n  - and s is an offset in the tile",
                       "drawTiledPixmap :/images/alpha.png ");
+    DECL_PAINTCOMMAND("fillRect", command_fillRect,
+                      "^fillRect\\s+(-?\\w*)\\s+(-?\\w*)\\s+(-?\\w*)\\s+(-?\\w*)\\s*(\\w*)?$",
+                      "fillRect <x> <y> <w> <h> [color]\n - Uses current brush if no color given",
+                      "fillRect 10 10 20 20 blue");
+    DECL_PAINTCOMMAND("fillRectF", command_fillRectF,
+                      "^fillRectF\\s+(-?[.\\w]*)\\s+(-?[.\\w]*)\\s+(-?[.\\w]*)\\s+(-?[.\\w]*)\\s*(\\w*)?$",
+                      "fillRectF <x> <y> <w> <h> [color]\n - Uses current brush if no color given",
+                      "fillRectF 10.5 10.5 20.2 20.2 blue");
 
     DECL_PAINTCOMMANDSECTION("painterPaths");
     DECL_PAINTCOMMAND("path_moveTo", command_path_moveTo,
@@ -1331,6 +1340,46 @@ void PaintCommands::command_drawTextDocument(QRegularExpressionMatch re)
     m_painter->restore();
 }
 
+/***************************************************************************************************/
+void PaintCommands::command_fillRect(QRegularExpressionMatch re)
+{
+    QStringList caps = re.capturedTexts();
+    int x = convertToInt(caps.at(1));
+    int y = convertToInt(caps.at(2));
+    int w = convertToInt(caps.at(3));
+    int h = convertToInt(caps.at(4));
+
+    if (!caps.at(5).isEmpty()) {
+        QColor color = convertToColor(caps.at(5));
+        if (m_verboseMode)
+            printf(" -(lance) fillRect(%d, %d, %d, %d, %s)\n", x, y, w, h, qPrintable(color.name()));
+        m_painter->fillRect(x, y, w, h, color);
+    } else {
+        if (m_verboseMode)
+            printf(" -(lance) fillRect(%d, %d, %d, %d)\n", x, y, w, h);
+        m_painter->fillRect(x, y, w, h, m_painter->brush());
+    }
+}
+
+void PaintCommands::command_fillRectF(QRegularExpressionMatch re)
+{
+    QStringList caps = re.capturedTexts();
+    double x = convertToDouble(caps.at(1));
+    double y = convertToDouble(caps.at(2));
+    double w = convertToDouble(caps.at(3));
+    double h = convertToDouble(caps.at(4));
+
+    if (!caps.at(5).isEmpty()) {
+        QColor color = convertToColor(caps.at(5));
+        if (m_verboseMode)
+            printf(" -(lance) fillRectF(%.2f, %.2f, %.2f, %.2f, %s)\n", x, y, w, h, qPrintable(color.name()));
+        m_painter->fillRect(QRectF(x, y, w, h), color);
+    } else {
+        if (m_verboseMode)
+            printf(" -(lance) fillRectF(%.2f, %.2f, %.2f, %.2f)\n", x, y, w, h);
+        m_painter->fillRect(QRectF(x, y, w, h), m_painter->brush());
+    }
+}
 
 /***************************************************************************************************/
 void PaintCommands::command_noop(QRegularExpressionMatch)
diff --git a/tests/auto/other/lancelot/paintcommands.h b/tests/auto/other/lancelot/paintcommands.h
index 79bdab634a..816ecd6fa2 100644
--- a/tests/auto/other/lancelot/paintcommands.h
+++ b/tests/auto/other/lancelot/paintcommands.h
@@ -200,6 +200,10 @@ private:
     void command_drawStaticText(QRegularExpressionMatch re);
     void command_drawTextDocument(QRegularExpressionMatch re);
     void command_drawTiledPixmap(QRegularExpressionMatch re);
+    void command_fillRect(QRegularExpressionMatch re);
+    void command_fillRectF(QRegularExpressionMatch re);
+
+    // paths
     void command_path_addEllipse(QRegularExpressionMatch re);
     void command_path_addPolygon(QRegularExpressionMatch re);
     void command_path_addRect(QRegularExpressionMatch re);
diff --git a/tests/auto/other/lancelot/scripts/fillrect.qps b/tests/auto/other/lancelot/scripts/fillrect.qps
new file mode 100644
index 0000000000..103ef2646a
--- /dev/null
+++ b/tests/auto/other/lancelot/scripts/fillrect.qps
@@ -0,0 +1,121 @@
+setRenderHint Antialiasing false
+
+# offscreen
+translate 0 -200
+
+begin_block rects
+# int API
+fillRect 10 10 20 20 green
+fillRect 40 10 20 20
+drawRect 70 10 20 20
+
+# float API, int values
+fillRectF 10.0 40.0 20.0 20.0 green
+fillRectF 40.0 40.0 20.0 20.0
+drawRect 70.0 40.0 20.0 20.0
+
+# float API, float values
+fillRectF 10.0 70.0 20.5 20.5 green
+fillRectF 40.0 70.0 20.5 20.5
+drawRect 70.0 70.0 20.5 20.5
+
+# alignment, int api, color
+fillRect 10 100 10 10 green
+fillRect 20 100 10 10 green
+fillRect 10 110 10 10 green
+fillRect 20 110 10 10 green
+
+# alignment, int api, brush
+fillRect 40 100 10 10
+fillRect 50 100 10 10
+fillRect 40 110 10 10
+fillRect 50 110 10 10
+
+# alignment comparison
+drawRect 70 100 10 10
+drawRect 80 100 10 10
+drawRect 70 110 10 10
+drawRect 80 110 10 10
+
+# alignment, float api, color
+fillRectF 10.0 130.0 10.0 10.0 green
+fillRectF 20.0 130.0 10.0 10.0 green
+fillRectF 10.0 140.0 10.0 10.0 green
+fillRectF 20.0 140.0 10.0 10.0 green
+
+# alignment, float api, brush
+fillRectF 40.0 130.0 10.0 10.0
+fillRectF 50.0 130.0 10.0 10.0
+fillRectF 40.0 140.0 10.0 10.0
+fillRectF 50.0 140.0 10.0 10.0
+
+# alignment comparison
+drawRect 70.0 130.0 10.0 10.0
+drawRect 80.0 130.0 10.0 10.0
+drawRect 70.0 140.0 10.0 10.0
+drawRect 80.0 140.0 10.0 10.0
+
+end_block
+
+begin_block row
+
+repeat_block rects
+
+save
+translate 100.2 0.2
+repeat_block rects
+restore
+
+save
+translate 200.5 0.5
+repeat_block rects
+restore
+
+save
+translate 300.7 0.7
+repeat_block rects
+restore
+
+end_block
+
+# end of block defs
+
+resetMatrix
+
+setPen NoPen
+setBrush green
+repeat_block row
+
+save
+translate 500 50
+scale 0.42 0.42
+repeat_block row
+restore
+
+save
+translate 0 160
+scale 1.8 0.8
+repeat_block row
+restore
+
+save
+translate 650 320
+rotate 80
+repeat_block row
+restore
+
+save
+setBrush green Dense2Pattern
+translate 0 400
+repeat_block row
+restore
+
+save
+gradient_clearStops
+gradient_appendStop 0 green
+gradient_appendStop 1 blue
+gradient_setCoordinateMode ObjectBoundingMode
+gradient_setLinear 0.0 0.0 1.0 1.0
+translate 0 600
+repeat_block row
+restore
diff --git a/tests/auto/other/lancelot/scripts/fillrect_aa.qps b/tests/auto/other/lancelot/scripts/fillrect_aa.qps
new file mode 100644
index 0000000000..3232899661
--- /dev/null
+++ b/tests/auto/other/lancelot/scripts/fillrect_aa.qps
@@ -0,0 +1,121 @@
+setRenderHint Antialiasing true
+
+# offscreen
+translate 0 -200
+
+begin_block rects
+# int API
+fillRect 10 10 20 20 green
+fillRect 40 10 20 20
+drawRect 70 10 20 20
+
+# float API, int values
+fillRectF 10.0 40.0 20.0 20.0 green
+fillRectF 40.0 40.0 20.0 20.0
+drawRect 70.0 40.0 20.0 20.0
+
+# float API, float values
+fillRectF 10.0 70.0 20.5 20.5 green
+fillRectF 40.0 70.0 20.5 20.5
+drawRect 70.0 70.0 20.5 20.5
+
+# alignment, int api, color
+fillRect 10 100 10 10 green
+fillRect 20 100 10 10 green
+fillRect 10 110 10 10 green
+fillRect 20 110 10 10 green
+
+# alignment, int api, brush
+fillRect 40 100 10 10
+fillRect 50 100 10 10
+fillRect 40 110 10 10
+fillRect 50 110 10 10
+
+# alignment comparison
+drawRect 70 100 10 10
+drawRect 80 100 10 10
+drawRect 70 110 10 10
+drawRect 80 110 10 10
+
+# alignment, float api, color
+fillRectF 10.0 130.0 10.0 10.0 green
+fillRectF 20.0 130.0 10.0 10.0 green
+fillRectF 10.0 140.0 10.0 10.0 green
+fillRectF 20.0 140.0 10.0 10.0 green
+
+# alignment, float api, brush
+fillRectF 40.0 130.0 10.0 10.0
+fillRectF 50.0 130.0 10.0 10.0
+fillRectF 40.0 140.0 10.0 10.0
+fillRectF 50.0 140.0 10.0 10.0
+
+# alignment comparison
+drawRect 70.0 130.0 10.0 10.0
+drawRect 80.0 130.0 10.0 10.0
+drawRect 70.0 140.0 10.0 10.0
+drawRect 80.0 140.0 10.0 10.0
+
+end_block
+
+begin_block row
+
+repeat_block rects
+
+save
+translate 100.2 0.2
+repeat_block rects
+restore
+
+save
+translate 200.5 0.5
+repeat_block rects
+restore
+
+save
+translate 300.7 0.7
+repeat_block rects
+restore
+
+end_block
+
+# end of block defs
+
+resetMatrix
+
+setPen NoPen
+setBrush green
+repeat_block row
+
+save
+translate 500 50
+scale 0.42 0.42
+repeat_block row
+restore
+
+save
+translate 0 160
+scale 1.8 0.8
+repeat_block row
+restore
+
+save
+translate 650 320
+rotate 80
+repeat_block row
+restore
+
+save
+setBrush green Dense2Pattern
+translate 0 400
+repeat_block row
+restore
+
+save
+gradient_clearStops
+gradient_appendStop 0 green
+gradient_appendStop 1 blue
+gradient_setCoordinateMode ObjectBoundingMode
+gradient_setLinear 0.0 0.0 1.0 1.0
+translate 0 600
+repeat_block row
+restore
diff --git a/tests/auto/other/macplist/tst_macplist.cpp b/tests/auto/other/macplist/tst_macplist.cpp
index 755cc462f5..dec63b1b66 100644
--- a/tests/auto/other/macplist/tst_macplist.cpp
+++ b/tests/auto/other/macplist/tst_macplist.cpp
@@ -59,8 +59,6 @@ void tst_MacPlist::test_plist_data()
 "	<string></string>\n"
 "	<key>CFBundlePackageType</key>\n"
 "	<string>APPL</string>\n"
-"	<key>CFBundleGetInfoString</key>\n"
-"	<string>Created by Qt/QMake</string>\n"
 "	<key>CFBundleExecutable</key>\n"
 "	<string>app</string>\n"
 "	<key>CFBundleIdentifier</key>\n"
@@ -77,8 +75,6 @@ void tst_MacPlist::test_plist_data()
 "	<string></string>\n"
 "	<key>CFBundlePackageType</key>\n"
 "	<string>APPL</string>\n"
-"	<key>CFBundleGetInfoString</key>\n"
-"	<string>Created by Qt/QMake</string>\n"
 "	<key>CFBundleExecutable</key>\n"
 "	<string>app</string>\n"
 "	<key>CFBundleIdentifier</key>\n"
@@ -97,8 +93,6 @@ void tst_MacPlist::test_plist_data()
 "	<string></string>\n"
 "	<key>CFBundlePackageType</key>\n"
 "	<string>APPL</string>\n"
-"	<key>CFBundleGetInfoString</key>\n"
-"	<string>Created by Qt/QMake</string>\n"
 "	<key>CFBundleExecutable</key>\n"
 "	<string>app</string>\n"
 "	<key>CFBundleIdentifier</key>\n"
@@ -117,8 +111,6 @@ void tst_MacPlist::test_plist_data()
 "	<string></string>\n"
 "	<key>CFBundlePackageType</key>\n"
 "	<string>APPL</string>\n"
-"	<key>CFBundleGetInfoString</key>\n"
-"	<string>Created by Qt/QMake</string>\n"
 "	<key>CFBundleExecutable</key>\n"
 "	<string>app</string>\n"
 "	<key>CFBundleIdentifier</key>\n"
@@ -137,8 +129,6 @@ void tst_MacPlist::test_plist_data()
 "	<string></string>\n"
 "	<key>CFBundlePackageType</key>\n"
 "	<string>APPL</string>\n"
-"	<key>CFBundleGetInfoString</key>\n"
-"	<string>Created by Qt/QMake</string>\n"
 "	<key>CFBundleExecutable</key>\n"
 "	<string>app</string>\n"
 "	<key>CFBundleIdentifier</key>\n"
diff --git a/tests/auto/sql/kernel/qsqlquery/tst_qsqlquery.cpp b/tests/auto/sql/kernel/qsqlquery/tst_qsqlquery.cpp
index 784d0a70d7..6c838995eb 100644
--- a/tests/auto/sql/kernel/qsqlquery/tst_qsqlquery.cpp
+++ b/tests/auto/sql/kernel/qsqlquery/tst_qsqlquery.cpp
@@ -185,12 +185,6 @@ private slots:
     void mysql_timeType_data() { generic_data("QMYSQL"); }
     void mysql_timeType();
 
-#ifdef NOT_READY_YET
-    void task_229811();
-    void task_229811_data() { generic_data(); }
-    void task_234422_data() {  generic_data(); }
-    void task_234422();
-#endif
     void task_217003_data() { generic_data(); }
     void task_217003();
 
@@ -3463,90 +3457,6 @@ void tst_QSqlQuery::task_205701()
     QSqlDatabase::removeDatabase("atest");
 }
 
-#ifdef NOT_READY_YET
-// For task: 229811
-void tst_QSqlQuery::task_229811()
-{
-    QFETCH( QString, dbName );
-    QSqlDatabase db = QSqlDatabase::database( dbName );
-    CHECK_DATABASE( db );
-
-    if (!db.driverName().startsWith( "QODBC" )) return;
-
-    QSqlQuery q( db );
-
-    const QString tableName(qTableName("task_229811", __FILE__, db));
-
-    if ( !q.exec( "CREATE TABLE " + tableName + " (Word varchar(20))" ) ) {
-        qDebug() << "Warning" << q.lastError();
-    }
-
-    QVERIFY_SQL( q, exec( "INSERT INTO " + tableName + " values ('Albert')" ) );
-    QVERIFY_SQL( q, exec( "INSERT INTO " + tableName + " values ('Beehive')" ) );
-    QVERIFY_SQL( q, exec( "INSERT INTO " + tableName + " values ('Alimony')" ) );
-    QVERIFY_SQL( q, exec( "INSERT INTO " + tableName + " values ('Bohemian')" ) );
-    QVERIFY_SQL( q, exec( "INSERT INTO " + tableName + " values ('AllStars')" ) );
-
-
-    QString stmt = "SELECT * FROM " + tableName  +  " WHERE Word LIKE :name";
-    QVERIFY_SQL(q,prepare(stmt));
-    q.bindValue(":name", "A%");
-    QVERIFY_SQL(q,exec());
-
-    QVERIFY(q.isActive());
-    QVERIFY(q.isSelect());
-    QVERIFY(q.first());
-
-    QSqlRecord rec = q.record();
-    QCOMPARE(rec.field(0).value().toString(), QString("Albert"));
-    QVERIFY(q.next());
-    rec = q.record();
-    QCOMPARE(rec.field(0).value().toString(), QString("Alimony"));
-    QVERIFY(q.next());
-    rec = q.record();
-    QCOMPARE(rec.field(0).value().toString(),QString("AllStars"));
-
-    q.exec("DROP TABLE " + tableName );
-}
-
-void tst_QSqlQuery::task_234422()
-{
-    QFETCH( QString, dbName );
-    QSqlDatabase db = QSqlDatabase::database( dbName );
-    CHECK_DATABASE( db );
-
-    QSqlQuery query(db);
-    QStringList m_airlines;
-    QStringList m_countries;
-
-    m_airlines << "Lufthansa" << "SAS" << "United" << "KLM" << "Aeroflot";
-    m_countries << "DE" << "SE" << "US" << "NL" << "RU";
-
-    const QString tableName(qTableName("task_234422", __FILE__, db));
-
-    QVERIFY_SQL(query,exec("CREATE TABLE " + tableName + " (id int primary key, "
-                "name varchar(20), homecountry varchar(2))"));
-    for (int i = 0; i < m_airlines.count(); ++i) {
-        QVERIFY(query.exec(QString("INSERT INTO " + tableName + " values(%1, '%2', '%3')")
-                    .arg(i).arg(m_airlines[i], m_countries[i])));
-    }
-
-    QVERIFY_SQL(query, exec("SELECT name FROM " + tableName));
-    QVERIFY(query.isSelect());
-    QVERIFY(query.first());
-    QVERIFY(query.next());
-    QCOMPARE(query.at(), 1);
-
-    QSqlQuery query2(query);
-
-    QVERIFY_SQL(query2,exec());
-    QVERIFY(query2.first());
-    QCOMPARE(query2.at(), 0);
-    QCOMPARE(query.at(), 1);
-}
-
-#endif
-
 void tst_QSqlQuery::task_233829()
 {
     QFETCH( QString, dbName );
diff --git a/tests/auto/tools/qmake/testdata/conflicting_targets/conflicting_targets.pro b/tests/auto/tools/qmake/testdata/conflicting_targets/conflicting_targets.pro
index c3e8034e35..bd0d4d824a 100644
--- a/tests/auto/tools/qmake/testdata/conflicting_targets/conflicting_targets.pro
+++ b/tests/auto/tools/qmake/testdata/conflicting_targets/conflicting_targets.pro
@@ -1,5 +1,5 @@
 TEMPLATE = app
-CONFIG += debug_and_release
+CONFIG += debug_and_release build_all
 TARGET = bah
 DESTDIR = shu
 SOURCES += main.cpp
diff --git a/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp b/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp
index 0b08586f7d..af0dd9b0f0 100644
--- a/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicsitem/tst_qgraphicsitem.cpp
@@ -10977,7 +10977,7 @@ static QList<QTouchEvent::TouchPoint>
     tp.setStartScreenPos(screenPos);
     tp.setLastScreenPos(screenPos);
     tp.setEllipseDiameters(ellipseDiameters);
-    const QSizeF screenSize = QApplication::desktop()->screenGeometry(&view).size();
+    const QSizeF screenSize = view.screen()->geometry().size();
     tp.setNormalizedPos(QPointF(screenPos.x() / screenSize.width(), screenPos.y() / screenSize.height()));
     return QList<QTouchEvent::TouchPoint>() << tp;
 }
diff --git a/tests/auto/widgets/itemviews/qheaderview/tst_qheaderview.cpp b/tests/auto/widgets/itemviews/qheaderview/tst_qheaderview.cpp
index df02815eb2..0b120985ee 100644
--- a/tests/auto/widgets/itemviews/qheaderview/tst_qheaderview.cpp
+++ b/tests/auto/widgets/itemviews/qheaderview/tst_qheaderview.cpp
@@ -216,6 +216,7 @@ private slots:
     void QTBUG14242_hideSectionAutoSize();
     void QTBUG50171_visualRegionForSwappedItems();
     void QTBUG53221_assertShiftHiddenRow();
+    void QTBUG75615_sizeHintWithStylesheet();
     void ensureNoIndexAtLength();
     void offsetConsistent();
 
@@ -2606,6 +2607,26 @@ void tst_QHeaderView::QTBUG53221_assertShiftHiddenRow()
     QCOMPARE(tableView.verticalHeader()->isSectionHidden(2), true);
 }
 
+void tst_QHeaderView::QTBUG75615_sizeHintWithStylesheet()
+{
+    QTableView tableView;
+    QStandardItemModel model(1, 1);
+    tableView.setModel(&model);
+    tableView.show();
+
+    const auto headerView = tableView.horizontalHeader();
+    const auto oldSizeHint = headerView->sizeHint();
+    QVERIFY(oldSizeHint.isValid());
+
+    tableView.setStyleSheet("QTableView QHeaderView::section { height: 100px;}");
+    QCOMPARE(headerView->sizeHint().width(), oldSizeHint.width());
+    QCOMPARE(headerView->sizeHint().height(), 100);
+
+    tableView.setStyleSheet("QTableView QHeaderView::section { width: 100px;}");
+    QCOMPARE(headerView->sizeHint().height(), oldSizeHint.height());
+    QCOMPARE(headerView->sizeHint().width(), 100);
+}
+
 void protected_QHeaderView::testVisualRegionForSelection()
 {
     QRegion r = visualRegionForSelection(QItemSelection(model()->index(1, 0), model()->index(1, 2)));
diff --git a/tests/auto/widgets/kernel/qdesktopwidget/tst_qdesktopwidget.cpp b/tests/auto/widgets/kernel/qdesktopwidget/tst_qdesktopwidget.cpp
index 90776dfcb2..a29e8408a3 100644
--- a/tests/auto/widgets/kernel/qdesktopwidget/tst_qdesktopwidget.cpp
+++ b/tests/auto/widgets/kernel/qdesktopwidget/tst_qdesktopwidget.cpp
@@ -42,10 +42,12 @@ class tst_QDesktopWidget : public QObject
 private slots:
     void cleanup();
 
+#if QT_DEPRECATED_SINCE(5, 11)
     void numScreens();
     void primaryScreen();
-    void screenNumberForQWidget();
     void screenNumberForQPoint();
+#endif
+    void screenNumberForQWidget();
     void availableGeometry();
     void screenGeometry();
     void topLevels();
@@ -56,6 +58,7 @@ void tst_QDesktopWidget::cleanup()
     QVERIFY(QApplication::topLevelWidgets().isEmpty());
 }
 
+#if QT_DEPRECATED_SINCE(5, 11)
 void tst_QDesktopWidget::numScreens()
 {
     QDesktopWidget desktop;
@@ -68,14 +71,17 @@ void tst_QDesktopWidget::primaryScreen()
     QVERIFY(desktop.primaryScreen() >= 0);
     QVERIFY(desktop.primaryScreen() < desktop.numScreens());
 }
+#endif
 
 void tst_QDesktopWidget::availableGeometry()
 {
     QDesktopWidget desktop;
     QTest::ignoreMessage(QtWarningMsg, "QDesktopWidget::availableGeometry(): Attempt "
                                        "to get the available geometry of a null widget");
-    desktop.availableGeometry((QWidget *)0);
+    QRect r = desktop.availableGeometry(nullptr);
+    QVERIFY(r.isNull());
 
+#if QT_DEPRECATED_SINCE(5, 11)
     QRect total;
     QRect available;
 
@@ -90,13 +96,14 @@ void tst_QDesktopWidget::availableGeometry()
     QVERIFY(total.contains(available));
     QCOMPARE(desktop.availableGeometry(desktop.primaryScreen()), available);
     QCOMPARE(desktop.screenGeometry(desktop.primaryScreen()), total);
+#endif
 }
 
 void tst_QDesktopWidget::screenNumberForQWidget()
 {
     QDesktopWidget desktop;
 
-    QCOMPARE(desktop.screenNumber(0), 0);
+    QCOMPARE(desktop.screenNumber(nullptr), 0);
 
     QWidget widget;
     widget.show();
@@ -105,9 +112,10 @@ void tst_QDesktopWidget::screenNumberForQWidget()
 
     int widgetScreen = desktop.screenNumber(&widget);
     QVERIFY(widgetScreen > -1);
-    QVERIFY(widgetScreen < desktop.numScreens());
+    QVERIFY(widgetScreen < QGuiApplication::screens().size());
 }
 
+#if QT_DEPRECATED_SINCE(5, 11)
 void tst_QDesktopWidget::screenNumberForQPoint()
 {
     // make sure QDesktopWidget::screenNumber(QPoint) returns the correct screen
@@ -131,25 +139,28 @@ void tst_QDesktopWidget::screenNumberForQPoint()
     screen = desktopWidget->screenNumber(allScreens.bottomRight() + QPoint(1, 1));
     QVERIFY(screen >= 0 && screen < desktopWidget->numScreens());
 }
+#endif
 
 void tst_QDesktopWidget::screenGeometry()
 {
     QDesktopWidget *desktopWidget = QApplication::desktop();
     QTest::ignoreMessage(QtWarningMsg, "QDesktopWidget::screenGeometry(): Attempt "
                                        "to get the screen geometry of a null widget");
-    QRect r = desktopWidget->screenGeometry((QWidget *)0);
+    QRect r = desktopWidget->screenGeometry(nullptr);
     QVERIFY(r.isNull());
     QWidget widget;
     widget.show();
     QVERIFY(QTest::qWaitForWindowExposed(&widget));
     r = desktopWidget->screenGeometry(&widget);
 
+#if QT_DEPRECATED_SINCE(5, 11)
     QRect total;
     QRect available;
     for (int i = 0; i < desktopWidget->screenCount(); ++i) {
         total = desktopWidget->screenGeometry(i);
         available = desktopWidget->availableGeometry(i);
     }
+#endif
 }
 
 void tst_QDesktopWidget::topLevels()
diff --git a/tests/auto/widgets/kernel/qwidget/tst_qwidget.cpp b/tests/auto/widgets/kernel/qwidget/tst_qwidget.cpp
index 3e372b76f5..40377eb946 100644
--- a/tests/auto/widgets/kernel/qwidget/tst_qwidget.cpp
+++ b/tests/auto/widgets/kernel/qwidget/tst_qwidget.cpp
@@ -5383,7 +5383,7 @@ void tst_QWidget::moveChild()
     parent.setStyle(style.data());
     ColorWidget child(&parent, Qt::Widget, Qt::blue);
 
-    parent.setGeometry(QRect(QPoint(QApplication::desktop()->availableGeometry(&parent).topLeft()) + QPoint(50, 50),
+    parent.setGeometry(QRect(parent.screen()->availableGeometry().topLeft() + QPoint(50, 50),
                              QSize(200, 200)));
     child.setGeometry(25, 25, 50, 50);
 #ifndef QT_NO_CURSOR // Try to make sure the cursor is not in a taskbar area to prevent tooltips or window highlighting
@@ -5430,8 +5430,7 @@ void tst_QWidget::showAndMoveChild()
     const QScopedPointer<QStyle> style(QStyleFactory::create(QLatin1String("Windows")));
     parent.setStyle(style.data());
 
-    QDesktopWidget desktop;
-    QRect desktopDimensions = desktop.availableGeometry(&parent);
+    QRect desktopDimensions = parent.screen()->availableGeometry();
     desktopDimensions = desktopDimensions.adjusted(64, 64, -64, -64);
 
 #ifndef QT_NO_CURSOR // Try to make sure the cursor is not in a taskbar area to prevent tooltips or window highlighting
@@ -7708,7 +7707,7 @@ void tst_QWidget::repaintWhenChildDeleted()
 #endif
     ColorWidget w(nullptr, Qt::FramelessWindowHint, Qt::red);
     w.setWindowTitle(QLatin1String(QTest::currentTestFunction()));
-    QPoint startPoint = QApplication::desktop()->availableGeometry(&w).topLeft();
+    QPoint startPoint = w.screen()->availableGeometry().topLeft();
     startPoint.rx() += 50;
     startPoint.ry() += 50;
     w.setGeometry(QRect(startPoint, QSize(100, 100)));
@@ -7733,7 +7732,7 @@ void tst_QWidget::hideOpaqueChildWhileHidden()
 {
     ColorWidget w(nullptr, Qt::FramelessWindowHint, Qt::red);
     w.setWindowTitle(QLatin1String(QTest::currentTestFunction()));
-    QPoint startPoint = QApplication::desktop()->availableGeometry(&w).topLeft();
+    QPoint startPoint = w.screen()->availableGeometry().topLeft();
     startPoint.rx() += 50;
     startPoint.ry() += 50;
     w.setGeometry(QRect(startPoint, QSize(100, 100)));
@@ -9601,8 +9600,7 @@ void tst_QWidget::rectOutsideCoordinatesLimit_task144779()
     palette.setColor(QPalette::Window, Qt::red);
     main.setPalette(palette);
 
-    QDesktopWidget desktop;
-    QRect desktopDimensions = desktop.availableGeometry(&main);
+    QRect desktopDimensions = main.screen()->availableGeometry();
     QSize mainSize(400, 400);
     mainSize = mainSize.boundedTo(desktopDimensions.size());
     main.resize(mainSize);
diff --git a/tests/auto/widgets/util/qcompleter/tst_qcompleter.cpp b/tests/auto/widgets/util/qcompleter/tst_qcompleter.cpp
index 5a51f15008..27ae41fc4f 100644
--- a/tests/auto/widgets/util/qcompleter/tst_qcompleter.cpp
+++ b/tests/auto/widgets/util/qcompleter/tst_qcompleter.cpp
@@ -1765,7 +1765,7 @@ void tst_QCompleter::QTBUG_52028_tabAutoCompletes()
     auto le = new QLineEdit;
     w.layout()->addWidget(le);
 
-    const auto pos = QApplication::desktop()->availableGeometry(&w).topLeft() + QPoint(200,200);
+    const auto pos = w.screen()->availableGeometry().topLeft() + QPoint(200,200);
     w.move(pos);
     w.show();
     QApplication::setActiveWindow(&w);
@@ -1806,7 +1806,7 @@ void tst_QCompleter::QTBUG_51889_activatedSentTwice()
 
     w.layout()->addWidget(new QLineEdit);
 
-    const auto pos = QApplication::desktop()->availableGeometry(&w).topLeft() + QPoint(200,200);
+    const auto pos = w.screen()->availableGeometry().topLeft() + QPoint(200,200);
     w.move(pos);
     w.show();
     QApplication::setActiveWindow(&w);
diff --git a/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp b/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp
index 4e16edaca8..b7869a0653 100644
--- a/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp
+++ b/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp
@@ -34,7 +34,6 @@
 #include <qpa/qplatformtheme.h>
 
 #include <qfontcombobox.h>
-#include <qdesktopwidget.h>
 #include <qapplication.h>
 #include <qpushbutton.h>
 #include <qdialog.h>
@@ -2212,15 +2211,13 @@ void tst_QComboBox::itemListPosition()
     QFontComboBox combo(&topLevel);
 
     layout->addWidget(&combo);
-    //the code to get the available screen space is copied from QComboBox code
-    const int scrNumber = QApplication::desktop()->screenNumber(&combo);
 
     bool useFullScreenForPopupMenu = false;
     if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
         useFullScreenForPopupMenu = theme->themeHint(QPlatformTheme::UseFullScreenForPopupMenu).toBool();
     const QRect screen = useFullScreenForPopupMenu ?
-                         QApplication::screens().at(scrNumber)->geometry() :
-                         QApplication::screens().at(scrNumber)->availableGeometry();
+                         combo.screen()->geometry() :
+                         combo.screen()->availableGeometry();
 
     topLevel.move(screen.width() - topLevel.sizeHint().width() - 10, 0); //puts the combo to the top-right corner
 
@@ -2440,8 +2437,7 @@ void tst_QComboBox::task248169_popupWithMinimalSize()
 #if defined QT_BUILD_INTERNAL
     QFrame *container = comboBox.findChild<QComboBoxPrivateContainer *>();
     QVERIFY(container);
-    QDesktopWidget desktop;
-    QTRY_VERIFY(desktop.screenGeometry(container).contains(container->geometry()));
+    QTRY_VERIFY(container->screen()->geometry().contains(container->geometry()));
 #endif
 }
 
diff --git a/tests/auto/widgets/widgets/qgroupbox/tst_qgroupbox.cpp b/tests/auto/widgets/widgets/qgroupbox/tst_qgroupbox.cpp
index 420ef56106..1b477fbbd0 100644
--- a/tests/auto/widgets/widgets/qgroupbox/tst_qgroupbox.cpp
+++ b/tests/auto/widgets/widgets/qgroupbox/tst_qgroupbox.cpp
@@ -295,6 +295,12 @@ void tst_QGroupBox::enabledChildPropagation()
     QVERIFY(!childWidget->isEnabled());
     dialog = new QDialog(&testWidget);
     QVERIFY(dialog->isEnabled());
+
+    // children that are enabled after adding should still be disabled before
+    // they are shown
+    childWidget->setEnabled(true);
+    testWidget.show();
+    QVERIFY(!childWidget->isEnabled());
 }
 
 void tst_QGroupBox::sizeHint()
diff --git a/tests/auto/widgets/widgets/qmenubar/tst_qmenubar.cpp b/tests/auto/widgets/widgets/qmenubar/tst_qmenubar.cpp
index d6ba85d61f..417d6e3124 100644
--- a/tests/auto/widgets/widgets/qmenubar/tst_qmenubar.cpp
+++ b/tests/auto/widgets/widgets/qmenubar/tst_qmenubar.cpp
@@ -34,7 +34,6 @@
 #include <qstyle.h>
 #include <qproxystyle.h>
 #include <qstylefactory.h>
-#include <qdesktopwidget.h>
 #include <qaction.h>
 #include <qstyleoption.h>
 #include <QVBoxLayout>
@@ -1149,8 +1148,8 @@ void tst_QMenuBar::check_menuPosition()
 
     Menu menu;
     menu.setTitle("&menu");
-    QRect availRect = QApplication::desktop()->availableGeometry(&w);
-    QRect screenRect = QApplication::desktop()->screenGeometry(&w);
+    QRect availRect = w.screen()->availableGeometry();
+    QRect screenRect = w.screen()->geometry();
 
     while(menu.sizeHint().height() < (screenRect.height()*2/3)) {
         menu.addAction("item");
diff --git a/tests/libfuzzer/corelib/serialization/qxmlstream/qxmlstreamreader/readnext/main.cpp b/tests/libfuzzer/corelib/serialization/qxmlstream/qxmlstreamreader/readnext/main.cpp
index 5a60c78cb5..7b73e6e952 100644
--- a/tests/libfuzzer/corelib/serialization/qxmlstream/qxmlstreamreader/readnext/main.cpp
+++ b/tests/libfuzzer/corelib/serialization/qxmlstream/qxmlstreamreader/readnext/main.cpp
@@ -29,7 +29,7 @@
 #include <QXmlStreamReader>
 
 extern "C" int LLVMFuzzerTestOneInput(const char *Data, size_t Size) {
-    QXmlStreamReader reader(QByteArray(Data, Size));
+    QXmlStreamReader reader(QByteArray::fromRawData(Data, Size));
     while (!reader.atEnd())
         reader.readNext();
     return 0;
diff --git a/tests/libfuzzer/gui/iccparser/main.cpp b/tests/libfuzzer/gui/iccparser/main.cpp
index ba4f70ef3b..1db43d2e25 100644
--- a/tests/libfuzzer/gui/iccparser/main.cpp
+++ b/tests/libfuzzer/gui/iccparser/main.cpp
@@ -32,6 +32,6 @@
 extern "C" int LLVMFuzzerTestOneInput(const char *data, size_t size) {
     static int c = 0;
     static QGuiApplication a(c, nullptr);
-    QColorSpace cs = QColorSpace::fromIccProfile(QByteArray(data, size));
+    QColorSpace cs = QColorSpace::fromIccProfile(QByteArray::fromRawData(data, size));
     return 0;
 }
diff --git a/tests/libfuzzer/gui/text/qtextdocument/setHtml/main.cpp b/tests/libfuzzer/gui/text/qtextdocument/setHtml/main.cpp
index c9b33d0f88..51fa3c9e0f 100644
--- a/tests/libfuzzer/gui/text/qtextdocument/setHtml/main.cpp
+++ b/tests/libfuzzer/gui/text/qtextdocument/setHtml/main.cpp
@@ -32,6 +32,6 @@
 extern "C" int LLVMFuzzerTestOneInput(const char *Data, size_t Size) {
     static int c = 0;
     static QApplication a(c, nullptr);
-    QTextDocument().setHtml(QByteArray(Data, Size));
+    QTextDocument().setHtml(QByteArray::fromRawData(Data, Size));
     return 0;
 }
diff --git a/tests/libfuzzer/gui/text/qtextdocument/setMarkdown/main.cpp b/tests/libfuzzer/gui/text/qtextdocument/setMarkdown/main.cpp
new file mode 100644
index 0000000000..66ddf738f2
--- /dev/null
+++ b/tests/libfuzzer/gui/text/qtextdocument/setMarkdown/main.cpp
@@ -0,0 +1,34 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QTextDocument>
+
+extern "C" int LLVMFuzzerTestOneInput(const char *Data, size_t Size) {
+    QTextDocument().setMarkdown(QByteArray::fromRawData(Data, Size));
+    return 0;
+}
diff --git a/tests/libfuzzer/gui/text/qtextdocument/setMarkdown/setMarkdown.pro b/tests/libfuzzer/gui/text/qtextdocument/setMarkdown/setMarkdown.pro
new file mode 100644
index 0000000000..4a2dfa51b9
--- /dev/null
+++ b/tests/libfuzzer/gui/text/qtextdocument/setMarkdown/setMarkdown.pro
@@ -0,0 +1,4 @@
+CONFIG += console
+CONFIG -= app_bundle
+SOURCES += main.cpp
+LIBS += -fsanitize=fuzzer
diff --git a/tests/libfuzzer/gui/text/qtextlayout/beginLayout/beginLayout.pro b/tests/libfuzzer/gui/text/qtextlayout/beginLayout/beginLayout.pro
new file mode 100644
index 0000000000..c9b14f6caf
--- /dev/null
+++ b/tests/libfuzzer/gui/text/qtextlayout/beginLayout/beginLayout.pro
@@ -0,0 +1,3 @@
+QT += widgets
+SOURCES += main.cpp
+LIBS += -fsanitize=fuzzer
diff --git a/tests/libfuzzer/gui/text/qtextlayout/beginLayout/main.cpp b/tests/libfuzzer/gui/text/qtextlayout/beginLayout/main.cpp
new file mode 100644
index 0000000000..dfb9559241
--- /dev/null
+++ b/tests/libfuzzer/gui/text/qtextlayout/beginLayout/main.cpp
@@ -0,0 +1,36 @@
+/****************************************************************************
+**
+** Copyright (C) 2019 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QTextLayout>
+
+extern "C" int LLVMFuzzerTestOneInput(const char *Data, size_t Size) {
+    QTextLayout tl(QByteArray::fromRawData(Data, Size));
+    tl.beginLayout();
+    tl.endLayout();
+    return 0;
+}
diff --git a/tests/manual/dialogs/printdialogpanel.cpp b/tests/manual/dialogs/printdialogpanel.cpp
index 8d64d2f6a6..b7447e3d64 100644
--- a/tests/manual/dialogs/printdialogpanel.cpp
+++ b/tests/manual/dialogs/printdialogpanel.cpp
@@ -710,8 +710,7 @@ void PrintDialogPanel::showPreviewDialog()
     applySettings(m_printer.data());
     PrintPreviewDialog dialog(m_printer.data(), this);
 #if QT_VERSION >= 0x050000
-    const int screenNumber = QApplication::desktop()->screenNumber(this);
-    const QSize availableSize = QGuiApplication::screens().at(screenNumber)->availableSize();
+    const QSize availableSize = screen()->availableSize();
 #else
     const QSize availableSize = QApplication::desktop()->availableGeometry().size();
 #endif
diff --git a/tests/manual/qcursor/qcursorhighdpi/main.cpp b/tests/manual/qcursor/qcursorhighdpi/main.cpp
index 3b18bff91c..e70be333fd 100644
--- a/tests/manual/qcursor/qcursorhighdpi/main.cpp
+++ b/tests/manual/qcursor/qcursorhighdpi/main.cpp
@@ -218,7 +218,7 @@ protected:
 
 VerticalRuler::VerticalRuler(QWidget *parent) : QWidget(parent)
 {
-    const int screenWidth = QApplication::desktop()->screenGeometry(this).width();
+    const int screenWidth = screen()->geometry().width();
     setFixedWidth(screenWidth / 48); // 1920 pixel monitor ->40
 }
 
@@ -356,15 +356,12 @@ int main(int argc, char *argv[])
     QApplication app(argc, argv);
 
     MainWindowPtrList windows;
-
-    QDesktopWidget *desktopWidget = app.desktop();
-
     const int lastScreen = arguments.contains("-p")
         ? 0  // Primary screen only
-        : desktopWidget->screenCount() - 1; // All screens
+        : QGuiApplication::screens().size() - 1; // All screens
     for (int s = lastScreen; s >= 0; --s) {
-        MainWindowPtr window(new MainWindow(desktopWidget->screen(s)));
-        const QPoint pos = desktopWidget->screenGeometry(s).center() - QPoint(200, 100);
+        MainWindowPtr window(new MainWindow());
+        const QPoint pos = QGuiApplication::screens().at(s)->geometry().center() - QPoint(200, 100);
         window->move(pos);
         windows.append(window);
         window->show();
diff --git a/tests/manual/qdesktopwidget/main.cpp b/tests/manual/qdesktopwidget/main.cpp
index f4c82c5f72..978dc62b0e 100644
--- a/tests/manual/qdesktopwidget/main.cpp
+++ b/tests/manual/qdesktopwidget/main.cpp
@@ -34,6 +34,7 @@
 
 class DesktopView : public QGraphicsView
 {
+#if QT_DEPRECATED_SINCE(5, 11)
     Q_OBJECT
 public:
     DesktopView()
@@ -195,6 +196,7 @@ private:
     QGraphicsScene *scene;
     QGraphicsRectItem *that;
     QPoint thatRoot;
+#endif
 };
 
 #include "main.moc"
diff --git a/tests/manual/qscreen/main.cpp b/tests/manual/qscreen/main.cpp
index 6fba872b12..0728d66bf9 100644
--- a/tests/manual/qscreen/main.cpp
+++ b/tests/manual/qscreen/main.cpp
@@ -61,8 +61,10 @@ public:
                 QLatin1String("Left-click to test QGuiApplication::topLevelAt(click pos)\nRight-click to ungrab\n") :
                 QLatin1String("Left-click to grab mouse\n");
         if (!m_cursorPos.isNull()) {
+            const auto screen = QGuiApplication::screenAt(m_cursorPos);
+            const auto screenNum = screen ? QGuiApplication::screens().indexOf(screen) : 0;
             txt += QString(QLatin1String("Current mouse position: %1, %2 on screen %3\n"))
-                    .arg(m_cursorPos.x()).arg(m_cursorPos.y()).arg(QApplication::desktop()->screenNumber(m_cursorPos));
+                    .arg(m_cursorPos.x()).arg(m_cursorPos.y()).arg(screenNum);
             if (QGuiApplication::mouseButtons() & Qt::LeftButton) {
                 QWindow *win = QGuiApplication::topLevelAt(m_cursorPos);
                 txt += QString(QLatin1String("Top-level window found? %1\n"))
@@ -234,6 +236,7 @@ void screenAdded(QScreen* screen)
     QList<QScreen *> screens = QGuiApplication::screens();
     int screenNumber = screens.indexOf(screen);
     Q_ASSERT(screenNumber >= 0);
+    // ### Qt 6: Find a replacement for QDesktopWidget::screen()
     w->setParent(qApp->desktop()->screen(screenNumber));
 
     w->show();
diff --git a/tests/manual/rhi/compressedtexture_bc1/compressedtexture_bc1.cpp b/tests/manual/rhi/compressedtexture_bc1/compressedtexture_bc1.cpp
index bb3722bec5..af454c2487 100644
--- a/tests/manual/rhi/compressedtexture_bc1/compressedtexture_bc1.cpp
+++ b/tests/manual/rhi/compressedtexture_bc1/compressedtexture_bc1.cpp
@@ -165,11 +165,13 @@ void Window::customRender()
         u->updateDynamicBuffer(d.ubuf, 64, 4, &flip);
     }
     if (!d.compressedData.isEmpty()) {
-        QRhiTextureUploadDescription desc;
+        QVarLengthArray<QRhiTextureUploadEntry, 16> descEntries;
         for (int i = 0; i < d.compressedData.count(); ++i) {
             QRhiTextureSubresourceUploadDescription image(d.compressedData[i].constData(), d.compressedData[i].size());
-            desc.append({ 0, i, image });
+            descEntries.append({ 0, i, image });
         }
+        QRhiTextureUploadDescription desc;
+        desc.setEntries(descEntries.cbegin(), descEntries.cend());
         u->uploadTexture(d.tex, desc);
         d.compressedData.clear();
     }
diff --git a/tests/manual/rhi/mrt/mrt.cpp b/tests/manual/rhi/mrt/mrt.cpp
index dc72c7d194..dfec5bb1d1 100644
--- a/tests/manual/rhi/mrt/mrt.cpp
+++ b/tests/manual/rhi/mrt/mrt.cpp
@@ -143,10 +143,10 @@ void Window::customInit()
     }
 
     QRhiTextureRenderTargetDescription rtDesc;
-    QVector<QRhiColorAttachment> att;
+    QRhiColorAttachment att[ATTCOUNT];
     for (int i = 0; i < ATTCOUNT; ++i)
-        att.append(QRhiColorAttachment(d.colData[i].tex));
-    rtDesc.setColorAttachments(att);
+        att[i] = QRhiColorAttachment(d.colData[i].tex);
+    rtDesc.setColorAttachments(att, att + ATTCOUNT);
     d.rt = m_r->newTextureRenderTarget(rtDesc);
     d.releasePool << d.rt;
     d.rtRp = d.rt->newCompatibleRenderPassDescriptor();
diff --git a/tests/manual/rhi/triquadcube/texturedcuberenderer.cpp b/tests/manual/rhi/triquadcube/texturedcuberenderer.cpp
index 3f15881e2d..8c5845d4fc 100644
--- a/tests/manual/rhi/triquadcube/texturedcuberenderer.cpp
+++ b/tests/manual/rhi/triquadcube/texturedcuberenderer.cpp
@@ -181,16 +181,18 @@ void TexturedCubeRenderer::queueResourceUpdates(QRhiResourceUpdateBatch *resourc
 
     if (!m_image.isNull()) {
         if (MIPMAP) {
-            QRhiTextureUploadDescription desc;
+            QVarLengthArray<QRhiTextureUploadEntry, 16> descEntries;
             if (!AUTOGENMIPMAP) {
                 // the ghetto mipmap generator...
                 for (int i = 0, ie = m_r->mipLevelsForSize(m_image.size()); i != ie; ++i) {
                     QImage image = m_image.scaled(m_r->sizeForMipLevel(i, m_image.size()));
-                    desc.append({ 0, i, image });
+                    descEntries.append({ 0, i, image });
                 }
             } else {
-                desc.append({ 0, 0, m_image });
+                descEntries.append({ 0, 0, m_image });
             }
+            QRhiTextureUploadDescription desc;
+            desc.setEntries(descEntries.cbegin(), descEntries.cend());
             resourceUpdates->uploadTexture(m_tex, desc);
             if (AUTOGENMIPMAP)
                 resourceUpdates->generateMips(m_tex);
